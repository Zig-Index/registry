{
  "name": "InkList",
  "owner": "Joseph-Matteo-Scorsone",
  "repo": "InkList",
  "description": "Actor model implementation in Zig.",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 13,
  "forks": 1,
  "watchers": 0,
  "updated_at": "2025-09-12T21:09:28Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.14.0",
  "readme": "# InkList\r\n\r\nInkList is an actor model written in Zig. It is done in a way to provide a nice blueprint for consistent coding as well as performance.\r\nUsers can make their structs into actors and then send them messages through the engine.\r\n\r\n\r\n- Engine: Manages a collection of actors, message delivery, and a thread pool.\r\n\r\n- Actor: Encapsulates per-actor state, a lock-free message queue, and worker threads.\r\n\r\n- Message: Supports both custom‐string payloads and function‐based payloads (handlers) with deep cloning.\r\n\r\n- PeriodicSender: Sends cloned messages to an actor at fixed intervals.\r\n\r\n- ConcurrentHashMap: A lock‐free, thread‐safe map used internally by the Engine.\r\n\r\n# Features\r\n- Actor Model:\r\n  -   Spawn lightweight actors that process messages asynchronously.\r\n\r\nMessage Payloads:\r\n  -   Custom‐string payloads (makeCustomPayload)\r\n\r\n  -   Function‐call payloads (makeFuncPayload) with clone & cleanup support\r\n\r\nLock‐Free Data Structures:\r\n  -   LockFreeQueue per actor for message buffering\r\n\r\n  -   ConcurrentHashMap in the Engine to store actor handles\r\n\r\nThread Pool:\r\n  -   All message processing is scheduled on a shared thread pool (std.Thread.Pool).\r\n\r\nPeriodic Messaging: \r\n  -   sendEvery allows you to send a cloned message to an actor at a fixed nanosecond interval.\r\n\r\nGraceful Shutdown: \r\n  -   Actors can be stopped, their queues drained, and resources deallocated cleanly.\r\n\r\n### This was made with Zig version 0.14.0\r\n\r\n# Module Overview\r\n\r\n## Engine\r\n\r\n- Holds a ConcurrentHashMap(u64, *ActorHandle) mapping actor_id → ActorHandle.\r\n\r\n- Maintains a shared std.Thread.Pool for dispatching work items (message processing).\r\n\r\n### Provides:\r\n\r\n- spawnActor(TStruct):\r\n\r\n- Enforces that TStruct has init, receive, deinit.\r\n\r\n- Initializes TStruct via TStruct.init(allocator).\r\n\r\n- Wraps it in Actor(TStruct).init(...).\r\n\r\n- Stores an ActorHandle in the map and returns a unique actor_id.\r\n\r\n- sendMessage(actor_id, msg): Looks up the ActorHandle and invokes its send_fn.\r\n\r\n- sendEvery(actor_id, msg, delay_ns): Creates a PeriodicSender to send a cloned msg every delay_ns nanoseconds.\r\n\r\n- waitForActor(actor_id): Invokes the actor’s wait method, blocking until its work is done.\r\n\r\n- getActorState(TStruct, actor_id): Returns a pointer to the inner TStruct.\r\n\r\n- deinit(): Cleans up all actors (calling ActorHandle.deinit_fn), shuts down the thread pool, and deallocates resources.\r\n\r\n## Actor\r\n\r\n- Signature: pub fn Actor(comptime TStruct: type) type { ... }\r\n\r\n- Key Fields:\r\n\r\n- actor_id: u64\r\n\r\n- t_struct: *TStruct\r\n\r\n- message_queue: *LockFreeQueue(*Message)\r\n\r\n- wg: std.Thread.WaitGroup (for pending tasks)\r\n\r\n- stop_flag: AtomicBool (to indicate shutdown)\r\n\r\n- thread_pool: *std.Thread.Pool\r\n\r\n### Core Methods:\r\n\r\n- init(allocator, t_struct, actor_id, thread_pool): Allocates itself and a LockFreeQueue; stores t_struct.\r\n\r\n- receive(msg):\r\n\r\n  - Enqueues msg into message_queue.\r\n\r\n  - Calls wg.start(), then thread_pool.spawn(processMessage, .{self}).\r\n\r\n- processMessage:\r\n\r\n  - Dequeues a single message.\r\n\r\n  - Calls t_struct.receive(allocator, msg).\r\n\r\n  - Calls msg.deinit(allocator).\r\n\r\n  - Calls wg.finish().\r\n\r\n- wait(): Blocks until wg.wait(), meaning all queued messages are processed.\r\n\r\n- stop(): Sets stop_flag = true and drains the queue (deinit each message).\r\n\r\n- deinit(): Calls stop(), then t_struct.deinit(), message_queue.deinit(), and deallocates itself.\r\n\r\n## Message\r\n\r\n- pub const InstructionPayload = union(enum) { custom: []const u8, func: struct { ... } };\r\n\r\n- pub const Message = struct { sender_id: u64, instruction: InstructionPayload, ... }\r\n\r\n### Core Methods:\r\n\r\n- init(allocator, sender_id, instruction): Allocates a Message and stores the payload.\r\n\r\n- makeCustomPayload(allocator, sender_id, custom: []const u8):\r\n\r\n  - Duplicates the provided string.\r\n\r\n  - Returns a newly allocated Message with .instruction = .{ .custom = duped_str }.\r\n\r\n  - makeFuncPayload(allocator, sender_id, call_fn, context, deinit_fn, clone_fn):\r\n\r\n  - Stores a function pointer, a context pointer, and optional deinit_fn & clone_fn.\r\n\r\n- clone(allocator):\r\n\r\n  - Deep‐copies either the custom string or (if func) calls clone_fn(context, allocator) to duplicate the context.\r\n\r\n- deinit(allocator):\r\n\r\n  - If .custom, allocator.free(str).\r\n\r\n  - If .func and deinit_fn != null, call deinit_fn(context, allocator).\r\n\r\n  - Finally call allocator.destroy(self).\r\n\r\n## PeriodicSender\r\nDefined inside engine.zig.\r\n\r\n- Periodically re‐sends a cloned message to a given actor_id.\r\n\r\n- Internally spawns a thread from the Engine’s thread pool that:\r\n\r\n- Sleeps for delay_ns.\r\n\r\n- Clones the original msg (msg.clone(allocator)).\r\n\r\n- Calls engine.sendMessage(actor_id, cloned_msg).\r\n\r\n- Maintains an AtomicBool stop_flag so you can call stop(), which:\r\n\r\n- Sets stop_flag = true\r\n\r\n- Waits for the spawned thread to finish\r\n\r\n- Cleans up the cloned message and itself.\r\n\r\n## ConcurrentHashMap\r\n\r\n#### Type: pub const ConcurrentHashMap(KeyType, ValueType, ContextType) = std.hash_map.HashMap(KeyType, ValueType, ContextType);\r\n\r\n#### Usage:\r\n\r\n- The Engine uses ConcurrentHashMap(u64, *ActorHandle, AutoContext(u64)):\r\n\r\n- Key: actor_id: u64\r\n\r\n- Value: *ActorHandle\r\n\r\n- Context: std.hash_map.AutoContext(u64) to manage internal hashing and bucket logic.\r\n\r\n## LockFreeQueue\r\n\r\n#### Type: pub const LockFreeQueue(ItemType) = /* lock‐free linked queue implementation */;\r\n\r\n#### Usage:\r\n\r\n- Each Actor instantiates a LockFreeQueue(*Message):\r\n\r\n- Allows multiple threads to call enqueue(msg) and dequeue() without blocking.\r\n\r\n- dequeue() returns the next msg or returns an error if the queue is empty.\r\n\r\n# Installation\r\n\r\nClone the repo:\r\n```git clone https://github.com/Joseph-Matteo-Scorsone/InkList.git```\r\n\r\n## Integrate into build.zig\r\n```\r\nconst inklist_lib = b.createModule(.{\r\n        .root_source_file = b.path(\"InkList/src/root.zig\"),\r\n});\r\n\r\nexe_mod.addImport(\"InkList_lib\", inklist_lib);\r\n```\r\n\r\n# Example project\r\n```\r\nconst std = @import(\"std\");\r\nconst InkList_lib = @import(\"InkList_lib\");\r\nconst Engine = InkList_lib.Engine;\r\nconst Message = InkList_lib.Message;\r\n\r\n// Example actor that counts messages:\r\nconst CounterActor = struct {\r\n    allocator: std.mem.Allocator,\r\n    count: std.atomic.Value(u64),\r\n\r\n    pub fn init(allocator: std.mem.Allocator) !*CounterActor {\r\n        const self = try allocator.create(CounterActor);\r\n        self.allocator = allocator;\r\n        self.count = std.atomic.Value(u64).init(0);\r\n        return self;\r\n    }\r\n\r\n    pub fn deinit(self: *CounterActor) void {\r\n        self.allocator.destroy(self);\r\n    }\r\n\r\n    pub fn receive(self: *CounterActor, allocator: std.mem.Allocator, msg: *Message) void {\r\n        _ = allocator;\r\n        // Every time we get a custom payload, increment the counter.\r\n        switch (msg.instruction) {\r\n            .custom => |_| {\r\n                _ = self.count.fetchAdd(1, .seq_cst);\r\n            },\r\n            .func => |f| {\r\n                // For handler payloads, call the handler’s function:\r\n                f.call_fn(f.context, @ptrCast(self));\r\n            },\r\n        }\r\n    }\r\n};\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    defer _ = gpa.deinit();\r\n    const allocator = gpa.allocator();\r\n\r\n    // Initialize an Engine with a 4-thread pool, capacity for 16 actors.\r\n    var engine = try Engine.init(allocator, .{ .allocator = allocator, .n_jobs = 4 }, 16);\r\n    defer engine.deinit();\r\n\r\n    // Spawn a CounterActor\r\n    const actor_id = try engine.spawnActor(CounterActor);\r\n\r\n    // Send 10 custom messages\r\n    for (0..10) |i| {\r\n        const msg = try Message.makeCustomPayload(allocator, @as(u64, @intCast(i)), \"increment\");\r\n        try engine.sendMessage(actor_id, msg);\r\n    }\r\n\r\n    // Wait for all messages to be processed\r\n    try engine.waitForActor(actor_id);\r\n\r\n    // Retrieve actor state and print the final count\r\n    const counter_ptr = try engine.getActorState(CounterActor, actor_id);\r\n    const final_count = counter_ptr.count.load(.seq_cst);\r\n    std.log.info(\"CounterActor final count: {d}\", .{final_count});\r\n}\r\n\r\n```\r\n\r\n# License\r\nThis project is licensed under the MIT License. See the LICENSE file for details.\r\n\r\nPlease don't hesitate to request things, suggest things :)\r\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/91394235?u=a7054fed41f025734e701fdf2fe3fa492c64ca3f&v=4",
  "releases": [],
  "owner_bio": "I'm a Quantitative Engineer following the dopamine.",
  "owner_company": null,
  "owner_location": "NY",
  "owner_blog": null,
  "owner_twitter_username": "ScorEnterprises",
  "owner_followers": 51,
  "owner_following": 16,
  "owner_created_at": "2021-09-25T21:48:59Z",
  "license": "MIT",
  "category": "library"
}