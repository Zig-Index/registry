{
  "name": "InkCept",
  "owner": "Joseph-Matteo-Scorsone",
  "repo": "InkCept",
  "description": "Document analyzer",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 3,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-08-12T12:29:42Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.14.0",
  "readme": "# InkCept - Intelligent Knowledge Engine\n\nInkCept is a concurrent, actor-based knowledge representation and processing system written in Zig. It implements a dynamic knowledge graph where concepts are represented as autonomous actors that can activate, learn, form relationships, and evolve over time.\n\nInkCept models knowledge as a living network of interconnected concepts. Each concept is an independent actor that:\n\n-   **Activates** when accessed or referenced\n-   **Propagates** activation to related concepts\n-   **Learns** by strengthening or weakening relationships over time\n-   **Evolves** through merging, splitting, or natural decay\n-   **Self-manages** its lifecycle based on usage patterns\n\nArchitecture\n----------------\n\n### Actor-Based Design\n\n-   **Concurrent Processing**: Each concept runs as an independent actor, enabling parallel knowledge processing\n-   **Message Passing**: Concepts communicate through asynchronous messages for activation, relation updates, and maintenance\n-   **Thread-Safe**: Built on Zig's atomic operations and concurrent data structures\n\n### Knowledge Representation\n\n-   **Dynamic Concepts**: Concepts have activation levels, energy, stability, and complexity metrics\n-   **Rich Relations**: Support for multiple relationship types (IsA, PartOf, Causes, AssociatedWith, etc.)\n-   **Temporal Awareness**: Tracks access patterns, birth time, and relationship usage\n-   **Adaptive Weights**: Relationship strengths adjust based on usage and co-activation patterns\n\nFeatures\n-----------\n\n### Core Knowledge Operations\n\n-   **Document Processing**: Extract and create concepts from text documents\n-   **Concept Activation**: Trigger concept activation with spreading activation\n-   **Relationship Management**: Create and maintain weighted relationships between concepts\n-   **Query Processing**: Find and activate concepts by term lookup\n\n### Intelligent Maintenance\n\n-   **Automatic Decay**: Unused concepts gradually lose activation and energy\n-   **Lifecycle Management**: Concepts can merge, split, or die based on usage patterns\n-   **Relationship Evolution**: Connection weights adapt based on co-activation patterns\n-   **Periodic Cleanup**: Background maintenance processes optimize the knowledge graph\n\n### Monitoring & Analytics\n\n-   **Real-time Stats**: Track activation, energy, stability, and complexity for each concept\n-   **Relationship Visualization**: Inspect concept relationships and their properties\n-   **Usage Analytics**: Monitor access patterns and concept evolution\n\nProject Structure\n--------------------\n\n```\nInkCept/\n├── src/\n│   ├── knowledge_engine.zig   # Main KnowledgeEngine implementation\n│   ├── documentParser.zig     # Document reader\n│   ├── actor.zig              # Actor implementation\n│   ├── engine.zig             # Actor system engine\n│   ├── message.zig            # Message passing system\n│   └── concurrentHashMap.zig  # Thread-safe hash map\n|   └── lockFreeQueue.zig      # Thread-safe queue\n├── tests/\n│   └── knowledge_tests.zig    # Comprehensive test suite\n|\n├── example.txt                # Sample document for testing\n├── differentExample.txt       # Additional test document\n└── build.zig                  # Zig build configuration\n\n```\n\nBuilding and Testing\n------------------------\n\n### Prerequisites\n\n-   Zig 0.14.0 or later\n\n### Build\n\n```\nzig build\n\n```\n\n### Run Tests\n\n```\nzig build test\n\n```\n\n### Example Test Output\n```\nFile size: 1221 bytes\nFirst 100 chars: Book Title: Fooled by Randomness\nPublication Year: 2001\nSummary: Explores the role of randomness in\nProcessing 1221 bytes of text\nConcept: Key=6, Value=6\nConcept: Key=2, Value=2\nConcept: Key=10, Value=10\nConcept: Key=1, Value=1\nConcept: Key=5, Value=5\nConcept: Key=7, Value=7\nConcept: Key=9, Value=9\nConcept: Key=4, Value=4\nConcept: Key=8, Value=8\nConcept: Key=3, Value=3\nTotal concepts created: 10\nConcept ID 6: activation=0.285, energy=2.000, relations=6\nConcept ID 2: activation=0.442, energy=2.000, relations=6\nConcept ID 10: activation=0.285, energy=2.000, relations=6\nConcepts after first document: 20\nConcepts after second document: 20\nInitial stats: activation=0.285\nFinal stats: activation=0.285\nFound 'book' -> ID: 4\nFound 'title' -> ID: 7\nFound 'randomness' -> ID: 9\nFound 'summary' -> ID: 8\nConcepts before maintenance: 20\nConcepts after maintenance: 20\n\n--- Concept ID: 6 ---\nTerm: 'antifragile'\nActivation: 0.285\nEnergy: 2.000\nStability: 0.500\nComplexity: 0.324\nRelations count: 6\nRelations:\n  1: antifragile -> 'title' (ID: 7) | Weight: 0.378 | Type: AssociatedWith | Last accessed: 0s ago\n  2: antifragile -> 'book' (ID: 4) | Weight: 0.311 | Type: AssociatedWith | Last accessed: 0s ago\n  3: antifragile -> 'swan' (ID: 10) | Weight: 0.244 | Type: AssociatedWith | Last accessed: 0s ago\n  4: antifragile -> 'year' (ID: 5) | Weight: 0.300 | Type: AssociatedWith | Last accessed: 0s ago\n  5: antifragile -> 'summary' (ID: 8) | Weight: 0.244 | Type: AssociatedWith | Last accessed: 0s ago\n  6: antifragile -> 'publication' (ID: 2) | Weight: 0.467 | Type: AssociatedWith | Last accessed: 0s ago\n\n--- Concept ID: 2 ---\nTerm: 'publication'\nActivation: 0.442\nEnergy: 2.000\nStability: 0.500\nComplexity: 0.583\nRelations count: 6\nRelations:\n  1: publication -> 'swan' (ID: 10) | Weight: 0.533 | Type: AssociatedWith | Last accessed: 0s ago\n  2: publication -> 'summary' (ID: 8) | Weight: 0.667 | Type: AssociatedWith | Last accessed: 0s ago\n  3: publication -> 'randomness' (ID: 9) | Weight: 0.378 | Type: AssociatedWith | Last accessed: 0s ago\n  4: publication -> 'antifragile' (ID: 6) | Weight: 0.467 | Type: AssociatedWith | Last accessed: 0s ago\n  5: publication -> 'title' (ID: 7) | Weight: 0.619 | Type: AssociatedWith | Last accessed: 0s ago\n  6: publication -> 'year' (ID: 5) | Weight: 0.833 | Type: AssociatedWith | Last accessed: 0s ago\n\n--- Concept ID: 10 ---\nTerm: 'swan'\nActivation: 0.285\nEnergy: 2.000\nStability: 0.500\nComplexity: 0.426\nRelations count: 6\nRelations:\n  1: swan -> 'book' (ID: 4) | Weight: 0.311 | Type: AssociatedWith | Last accessed: 0s ago\n  2: swan -> 'antifragile' (ID: 6) | Weight: 0.244 | Type: AssociatedWith | Last accessed: 0s ago\n  3: swan -> 'publication' (ID: 2) | Weight: 0.533 | Type: AssociatedWith | Last accessed: 0s ago\n  4: swan -> 'title' (ID: 7) | Weight: 0.400 | Type: AssociatedWith | Last accessed: 0s ago\n  5: swan -> 'randomness' (ID: 9) | Weight: 0.367 | Type: AssociatedWith | Last accessed: 0s ago\n  6: swan -> 'black' (ID: 3) | Weight: 0.700 | Type: AssociatedWith | Last accessed: 0s ago\n\n--- Concept ID: 1 ---\nTerm: 'events'\nActivation: 0.285\nEnergy: 2.000\nStability: 0.500\nComplexity: 0.339\nRelations count: 2\nRelations:\n  1: events -> 'title' (ID: 7) | Weight: 0.311 | Type: AssociatedWith | Last accessed: 0s ago\n  2: events -> 'book' (ID: 4) | Weight: 0.367 | Type: AssociatedWith | Last accessed: 0s ago\n\n--- Concept ID: 5 ---\nTerm: 'year'\nActivation: 0.442\nEnergy: 2.000\nStability: 0.500\nComplexity: 0.586\nRelations count: 4\nRelations:\n  1: year -> 'summary' (ID: 8) | Weight: 0.833 | Type: AssociatedWith | Last accessed: 0s ago\n  2: year -> 'antifragile' (ID: 6) | Weight: 0.300 | Type: AssociatedWith | Last accessed: 0s ago\n  3: year -> 'randomness' (ID: 9) | Weight: 0.378 | Type: AssociatedWith | Last accessed: 0s ago\n  4: year -> 'publication' (ID: 2) | Weight: 0.833 | Type: AssociatedWith | Last accessed: 0s ago\n\nConcept 'book' (ID: 1): 2 relations\n  1: book --[PartOf]--> title (weight: 0.800)\n  2: book --[AssociatedWith]--> randomness (weight: 0.600)\n\nConcept 'title' (ID: 2): 1 relations\n  1: title --[Synonym]--> randomness (weight: 0.400)\n\nConcept 'randomness' (ID: 3): 0 relations\n```\n\n# Example main\n```\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\nconst KnowledgeEngine = @import(\"knowledgeEngine.zig\").KnowledgeEngine;\nconst processDocument = @import(\"documentParser.zig\").processDocument;\nconst fileToText = @import(\"documentParser.zig\").fileToText;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Initialize Knowledge Engine with 4 threads and capacity for 1000 actors\n    var knowledge_engine = try KnowledgeEngine.init(allocator, 4, 1000);\n    defer knowledge_engine.deinit();\n\n    std.log.info(\"=== Autopoietic Knowledge Engine with Document Processing ===\", .{});\n\n    // =============================================================================\n    // Process a sample document\n    // =============================================================================\n\n    const sample_text = try fileToText(allocator, \"example.txt\");\n    defer allocator.free(sample_text);\n\n    std.log.info(\"\\n=== Processing Sample Document ===\", .{});\n    try processDocument(allocator, sample_text, &knowledge_engine);\n\n    // Wait for message propagation\n    try knowledge_engine.waitForAllActors();\n\n    // =============================================================================\n    // Query and explore the created knowledge graph\n    // =============================================================================\n\n    std.log.info(\"\\n=== Exploring Created Knowledge Graph ===\", .{});\n\n    // Query some concepts that should have been created\n    const queries = [_][]const u8{ \"events\", \"publication\", \"antifragile\", \"swan\", \"title\", \"summary\" };\n\n    for (queries) |query| {\n        if (try knowledge_engine.query(query)) |concept_id| {\n            std.log.info(\"Found concept '{s}' with ID: {d}\", .{ query, concept_id });\n\n            if (try knowledge_engine.getConceptStats(concept_id)) |stats| {\n                std.log.info(\"  Stats: activation={d:.3}, energy={d:.3}, stability={d:.3}, complexity={d:.3}, relations={}\", .{ stats.activation, stats.energy, stats.stability, stats.complexity, stats.relations });\n            }\n        } else {\n            std.log.info(\"Concept '{s}' not found in knowledge base\", .{query});\n        }\n    }\n\n    // =============================================================================\n    // Demonstrate knowledge propagation\n    // =============================================================================\n\n    std.log.info(\"\\n=== Testing Knowledge Propagation ===\", .{});\n\n    // Activate \"events\" and see how activation spreads\n    if (try knowledge_engine.query(\"events\")) |id| {\n        std.log.info(\"Activating 'events' concept...\", .{});\n\n        // Give multiple activations to trigger strong propagation\n        for (0..5) |_| {\n            try knowledge_engine.activateConcept(id);\n        }\n\n        // Check related concepts that should have received activation\n        const related_concepts = [_][]const u8{ \"book\", \"decision\", \"disorder\", \"implications\" };\n\n        for (related_concepts) |concept_name| {\n            if (knowledge_engine.findConcept(concept_name)) |concept_id| {\n                if (try knowledge_engine.getConceptStats(concept_id)) |stats| {\n                    std.log.info(\"  '{s}' received activation: {d:.3}\", .{ concept_name, stats.activation });\n                }\n            }\n        }\n    }\n\n    // =============================================================================\n    // Different document reading\n    // =============================================================================\n\n    std.log.info(\"\\n=== Processing Sample Document ===\", .{});\n\n    // Process a different document\n    const different_text = try fileToText(allocator, \"differentExample.txt\");\n    defer allocator.free(different_text);\n\n    try processDocument(allocator, different_text, &knowledge_engine);\n\n    // =============================================================================\n    // Cross-domain knowledge integration\n    // =============================================================================\n\n    std.log.info(\"\\n=== Cross-Domain Knowledge Integration ===\", .{});\n\n    // Now we have concepts from both animal domain and AI domain\n    // Let's see how they might interact\n    const cross_domain_queries = [_][]const u8{ \"unity\", \"seperation\", \"theory\", \"systems\", \"framework\", \"education\" };\n\n    for (cross_domain_queries) |query| {\n        if (try knowledge_engine.query(query)) |concept_id| {\n            if (try knowledge_engine.getConceptStats(concept_id)) |stats| {\n                std.log.info(\"Cross-domain concept '{s}': relations={d}, complexity={d:.3}\", .{ query, stats.relations, stats.complexity });\n            }\n        }\n    }\n\n    // =============================================================================\n    // Simulation with maintenance and evolution\n    // =============================================================================\n\n    std.log.info(\"\\n=== Running Extended Simulation ===\", .{});\n\n    // Run a longer simulation to see concept evolution\n    for (0..20) |cycle| {\n        // Randomly activate concepts from our vocabulary\n        const random_concepts = [_][]const u8{ \"events\", \"publication\", \"antifragile\", \"swan\", \"title\", \"summary\", \"unity\", \"seperation\", \"theory\", \"systems\", \"framework\", \"education\" };\n\n        // Activate 2-3 random concepts each cycle\n        const activations_per_cycle = 2 + (cycle % 2);\n        for (0..activations_per_cycle) |_| {\n            const random_concept = random_concepts[cycle % random_concepts.len];\n            _ = try knowledge_engine.query(random_concept);\n        }\n\n        // Run maintenance every few cycles\n        if (cycle % 3 == 0) {\n            try knowledge_engine.runMaintenance();\n        }\n\n        // Print progress every 5 cycles\n        if (cycle % 5 == 0) {\n            std.log.info(\"Simulation cycle {d} completed\", .{cycle + 1});\n\n            // Show stats for a few key concepts\n            if (knowledge_engine.findConcept(\"learning\")) |concept_id| {\n                if (try knowledge_engine.getConceptStats(concept_id)) |stats| {\n                    std.log.info(\"  'learning' concept: activation={d:.3}, relations={d}\", .{ stats.activation, stats.relations });\n                }\n            }\n        }\n\n        std.time.sleep(150_000_000); // 150ms between cycles\n    }\n\n    // =============================================================================\n    // Final analysis and reporting\n    // =============================================================================\n\n    std.log.info(\"\\n=== Final Knowledge Graph Analysis ===\", .{});\n\n    // Analyze the most connected concepts\n    const analysis_concepts = [_][]const u8{ \"events\", \"publication\", \"antifragile\", \"swan\", \"title\", \"summary\" };\n\n    var most_connected_concept: []const u8 = \"\";\n    var max_relations: usize = 0;\n    var highest_complexity: f64 = 0.0;\n    var most_complex_concept: []const u8 = \"\";\n\n    for (analysis_concepts) |concept_name| {\n        if (knowledge_engine.findConcept(concept_name)) |concept_id| {\n            if (try knowledge_engine.getConceptStats(concept_id)) |stats| {\n                std.log.info(\"Final stats for '{s}': activation={d:.3}, energy={d:.3}, stability={d:.3}, complexity={d:.3}, relations={d}\", .{ concept_name, stats.activation, stats.energy, stats.stability, stats.complexity, stats.relations });\n\n                if (stats.relations > max_relations) {\n                    max_relations = stats.relations;\n                    most_connected_concept = concept_name;\n                }\n\n                if (stats.complexity > highest_complexity) {\n                    highest_complexity = stats.complexity;\n                    most_complex_concept = concept_name;\n                }\n            }\n        }\n    }\n\n    std.log.info(\"\\n=== Knowledge Graph Summary ===\", .{});\n    std.log.info(\"Most connected concept: '{s}' with {d} relations\", .{ most_connected_concept, max_relations });\n    std.log.info(\"Most complex concept: '{s}' with complexity {d:.3}\", .{ most_complex_concept, highest_complexity });\n\n    // =============================================================================\n    // Save knowledge graph state\n    // =============================================================================\n\n    std.log.info(\"\\n=== Saving Knowledge Graph State ===\", .{});\n\n    var concept_count: u32 = 0;\n    var total_relations: u32 = 0;\n    var total_activation: f64 = 0.0;\n\n    for (analysis_concepts) |concept_name| {\n        if (knowledge_engine.findConcept(concept_name)) |concept_id| {\n            if (try knowledge_engine.getConceptStats(concept_id)) |stats| {\n                concept_count += 1;\n                total_relations += @intCast(stats.relations);\n                total_activation += stats.activation;\n            }\n        }\n    }\n\n    if (concept_count > 0) {\n        const avg_relations = @as(f64, @floatFromInt(total_relations)) / @as(f64, @floatFromInt(concept_count));\n        const avg_activation = total_activation / @as(f64, @floatFromInt(concept_count));\n\n        std.log.info(\"Knowledge graph metrics:\", .{});\n        std.log.info(\"  Active concepts: {d}\", .{concept_count});\n        std.log.info(\"  Average relations per concept: {d:.2}\", .{avg_relations});\n        std.log.info(\"  Average activation level: {d:.3}\", .{avg_activation});\n    }\n\n    std.log.info(\"\\n=== End ===\", .{});\n}\n```\n\nTesting\n\nThe project includes comprehensive tests covering:\n\n-   **Initialization**: Engine setup and cleanup\n-   **Concept Creation**: Dynamic concept generation from text\n-   **Activation Patterns**: Spreading activation and propagation\n-   **Relationship Management**: Creating and evolving concept relationships\n-   **Lifecycle Operations**: Maintenance, decay, and concept evolution\n-   **Cross-domain Processing**: Handling multiple document types\n-   **Query Processing**: Finding and activating concepts\n\n### Key Test Categories\n\n1.  **Core Functionality Tests**\n\n    -   Engine initialization and cleanup\n    -   Concept creation and management\n    -   Basic query operations\n2.  **Activation System Tests**\n\n    -   Concept activation and propagation\n    -   Spreading activation networks\n    -   Energy and stability tracking\n3.  **Relationship Tests**\n\n    -   Relation creation and management\n    -   Relationship evolution over time\n    -   Cross-concept connections\n4.  **Maintenance Tests**\n\n    -   Periodic cleanup operations\n    -   Concept lifecycle management\n    -   System optimization\n\nConfiguration\n----------------\n\n### Engine Parameters\n\n-   **Thread Count**: Number of worker threads for actor processing\n-   **Initial Size**: Starting capacity for internal data structures\n-   **Activation Thresholds**: Configurable thresholds for concept behavior\n\n### Concept Behavior\n\n-   **Decay Rate**: How quickly unused concepts lose activation\n-   **Propagation Threshold**: Minimum activation needed for spreading\n-   **Merge/Split Criteria**: Conditions for concept evolution\n\nUse Cases\n------------\n\n### Knowledge Management\n\n-   **Document Analysis**: Extract and organize concepts from text documents\n-   **Semantic Search**: Find related concepts through activation spreading\n-   **Knowledge Discovery**: Identify emerging relationships and patterns\n\n### AI and Machine Learning\n\n-   **Feature Learning**: Discover relevant features in data\n-   **Representation Learning**: Build dynamic knowledge representations\n-   **Associative Memory**: Implement content-addressable memory systems\n\n### Research and Analysis\n\n-   **Concept Evolution**: Study how ideas develop and change over time\n-   **Network Analysis**: Analyze knowledge graph structure and dynamics\n-   **Information Retrieval**: Build intelligent search and recommendation systems\n\nLicense\n----------\n\nThis project is licensed under the MIT License - see the LICENSE file for details.",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/91394235?u=a7054fed41f025734e701fdf2fe3fa492c64ca3f&v=4",
  "releases": [],
  "owner_bio": "I'm a Quantitative Engineer following the dopamine.",
  "owner_company": null,
  "owner_location": "NY",
  "owner_blog": null,
  "owner_twitter_username": "ScorEnterprises",
  "owner_followers": 52,
  "owner_following": 15,
  "owner_created_at": "2021-09-25T21:48:59Z",
  "category": "library"
}