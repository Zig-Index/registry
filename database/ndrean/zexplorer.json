{
  "name": "zexplorer",
  "owner": "ndrean",
  "repo": "zexplorer",
  "description": "Programmable HTML processor engine with JavaScript execution on steroids",
  "type": "package",
  "topics": [
    "lexbor",
    "zig",
    "zig-package",
    "css-parser",
    "css-sanitization",
    "html-parser",
    "javascript-tools",
    "sanitize-html",
    "quickjs-ng"
  ],
  "stars": 5,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-25T23:08:58Z",
  "dependencies": [
    {
      "name": "curl",
      "url": "https://github.com/jiacai2050/zig-curl/archive/refs/tags/v0.3.2.tar.gz",
      "hash": "curl-0.3.2-P4tT4SXPAACuV6f5eyh4jG_1SspjWwMm_vRJfoKrQep5"
    },
    {
      "name": "httpz",
      "url": "git+https://github.com/karlseguin/http.zig?ref=master#ddaf1989f9c5fe1b139fa846ad273efd4368083a",
      "hash": "httpz-0.0.0-PNVzrN40BwD3lGAE8l_pShvVIGSlWglmFOsdhJnMVcXR"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# zexplorer\n\n![Zig support](https://img.shields.io/badge/Zig-0.15.2-color?logo=zig&color=%23f3ab20)\n\n`zexplorer` is a stateless, composable and embeddable engine designed for HTML based document content pipelines: a mini Swiss Army knife that runs fast, delivers, and dies.\n\nIt is a native DOM + JS runtime with some layout rendering capabilities (**Flexbox** layout rendering and raster compositing).\n\nIt is not a general-purpose application runtime nor for rendering arbitrary public websites.\n\nFeed the dev-server with a JavaScript snippet, or pass your HTML documents to the CLI, and get back structured data or a layout as PNG, JPEG, WEBP, or PDF, without a browser.\n\n<p align=\"center\">\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/images/zexplorer.png\" alt=\"logo\" width=\"600\" height=\"600\" />\n</p>\n\n---\n\nYou can use it :\n\n 1) as a library if you need to add native functionalities and are ready to use Zig,\n 2) via the CLI for composing/piping as a one-shot multi-steps process,\n 3) as a service: you pass a JavaScript snippet and POST it to the dev-server.\n\n---\n\n**TL;DR**:\n\n> - Cold start: 2ms\n> - Memory: 10MB\n> - Zero dependencies. Single binary.\n> - Features JavaScript ES2020\n> - can be used as a composable/embeddable tool (think `ffmepg`) or as a dev server serving requests over HTTP.\n> - supports HTML chunks streams (SSE)\n> - suppports HTML or SVG with PNG, JPEG or WEBP input support, and output data with PNG, JPEG, WEBP and PDF support.\n> - No TypeScript nor JSX. It supports \"tagged templates\" with the embedded `htm` library.\n> - A \"good enough\" snapshot rendering engine. Based on `Flexbox` with `grid-1d` emulated.\n\n**Limitations**:\n\nIt is not\n\n- a `Node.js` or `Bun` alternative\n- a headless browser — no layout engine, no visual rendering\n- a full Web API implementation — however, it has \"essential\" coverage, focused on what frameworks actually need\n- a multi-tenant platform — it assumes process-level isolation (microVM/container)\n\nIt cannot:\n\n- scrape arbitrary bot protected public websites,\n- paint complex CSS using grid-2d, position:fixed, CSS functions...\n\n## What can it do?\n\nThink of it as a lightweight `JSDOM`+`DOMPurify`+`node-canvas`+`Satori` engine used with its built-in HTTP server or its composable CLI.\n\nIt can:\n\n- **Scrape** — fetch a URL, hydrate React, render Vue/Svelte/Lit, WebComponents, extract data. No headless browser.\n- **Stream**  - receive HTML chunks and rebuild a real DOM.\n- **Render** — `Flexbox` based and no CSS functions.  HTML+JS+SVG (D3, Chart.js, Leaflet, Canvas API), output PNG/JPEG/WEBP/PDF.\n- **Generate** — design an SVG in Figma, plug in data, batch-produce OG images or PDF reports.\n- **Sanitize** — DOM+CSS-aware HTML sanitization (stylesheets, inline styles, XSS/mXSS). Built-in.\n- **Run JS** — execute ES2020 scripts against a real DOM with fetch, timers, workers, and an event loop.\n\n❗️No TypeScript support. JSX is supported via \"tagged templates\" (using `htm`).\n\n## How is it built?\n\nA native Zig engine that wires together purpose-built C/C++ libraries — no runtime dependencies:\n\n| Layer                    | Library                                                                                         | Role                                   |\n| ------------------------ | ----------------------------------------------------------------------------------------------- | -------------------------------------- |\n| DOM & CSS                | [lexbor](https://lexbor.com/)                                                                   | HTML/CSS parsing, CSSOM, selectors     |\n| JavaScript               | [QuickJS-ng](https://quickjs-ng.github.io/quickjs/)                                             | Full ES6 runtime (bytecode, no JIT)    |\n| Images                   | [stb_image](https://github.com/nothings/stb), [libwebp](https://github.com/webmproject/libwebp) | PNG/JPEG/WEBP decode & encode          |\n| Raster rendering         | [ThorVG](https://github.com/thorvg/thorvg)                                                      | Full SVG rasterization & thorvg-canvas |\n| PDF                      | [libharu](https://github.com/libharu/libharu)                                                   | PDF generation & text layer            |\n| Text                     | [stb_truetype](https://github.com/nothings/stb)                                                 | Font rendering (Roboto preloaded)      |\n| Network                  | [zig-curl](https://github.com/jiacai2050/zig-curl)                                              | HTTP via libcurl multi                 |\n| WebServer                | [httpz-zig](https://github.com/karlseguin/http.zig)                                             | Serve over HTTP                        |\n| Flexbor Layout rendering | [yoga](https://github.com/facebook/yoga)                                                        | Layout computation                     |\n\nCan be compared to [JSDOM](https://github.com/jsdom/jsdom) + [DOMPurify](https://github.com/cure53/DOMPurify) + [node-canvas](https://github.com/Automattic/node-canvas) + [Satori](https://github.com/vercel/satori) — but native speed, 10MB footprint, 2ms cold start.\n\n## Tested against js-framework-benchmark\n\nThe engine runs real framework code from [js-framework-benchmark](https://github.com/krausest/js-framework-benchmark): React 19, Preact, SolidJS, Vue 3, Svelte 5, Lit-html.\n\n| Feature           | zexplorer                 | JSDOM           | Puppeteer       |\n| ----------------- | ------------------------- | --------------- | --------------- |\n| Startup time      | 2ms                       | ~30ms           | ~500ms          |\n| DOM sanitization  | Built-in, DOM & CSS-aware | Needs DOMPurify | Browser context |\n| Memory footprint  | 10MB                      | ~50MB           | ~200MB          |\n| Web API coverage  | (essential)               | ~90%            | 100%            |\n| JavaScript engine | QuickJS (bytecode)        | Node.js V8      | Chrome V8       |\n\n## Security\n\nIf you use your own trusted code, you can skip sanitization entirely. For untrusted content:\n\n> [!WARNING]\n> All layers are _best-effort_ — see [SECURITY.md](https://github.com/ndrean/zexplorer/blob/main/SECURITY.md) for full details.\n>\n> - **Content sanitization** — DOM+CSS-aware: stylesheets, inline styles, iframes, SVG/MathML, DOM clobbering, URI schemas, XSS/mXSS. Tested against [H5SC](https://github.com/cure53/H5SC), [OWASP](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html), [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet), and [DOMPurify](https://github.com/cure53/DOMPurify).\n> - **Filesystem sandbox** — kernel-enforced `openat()` with symlink blocking, traversal rejection, cross-device check.\n> - **Network hardening** — timeouts, redirect/size limits, SSRF pre-flight filtering, HTTPS-only remote imports.\n> - **Resource limits** — worker fan-out caps, busy-loop interrupts, max stack/GC/memory, wall-clock deadlines.\n\n### Sanitization model\n\nThe sanitizer operates on the **live Lexbor DOM and CSS AST** — there is no serialize/re-parse step, so there is no parse-differential surface for mXSS. HTML character references are decoded by Lexbor at parse time, before the sanitizer sees any attribute value.\n\nThe pipeline:\n\n```txt\nRaw HTML / SVG / CSS\n        │\n        ▼\n  Lexbor parse ── entities decoded, DOM + CSSOM built\n        │\n        ├─── DOM node tree ──────────────────────┐\n        │    walk every node                     │\n        │    • remove dangerous elements         │\n        │    • strip unsafe attributes           │    merge sanitized\n        │    • inline style → CSS sanitizer      │    CSS back into DOM\n        │                                        │\n        └─── CSS AST (stylesheets + style=\"\")  ──┘\n             • remove dangerous at-rules\n             • strip unsafe properties\n             • validate URIs structurally\n\n        ▼\n  Sanitized DOM — safe for rendering or serialization\n```\n\n**Policy decisions and known trade-offs:**\n\n| Threat                                                                                         | Policy                                                                                                                     | Rationale                                                                                                                                          | Gap / known trade-off                                                                                                                                 |\n| ---------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `<script>` tags                                                                                | Removed by default; configurable via `remove_scripts: bool`                                                                | Scripts execute in the QuickJS sandbox during `loadPage` — the sandbox is the boundary                                                             | When allowed, no CSP is generated; caller is responsible                                                                                              |\n| `on*` event handlers                                                                           | Always removed                                                                                                             | No legitimate use in sanitized output                                                                                                              | —                                                                                                                                                     |\n| `href=\"javascript:\"`, `vbscript:`, `file:`                                                     | Blocked on all URL attributes (`href`, `src`, `action`, `poster`, `data`, …)                                               | These protocols execute code or access local files                                                                                                 | —                                                                                                                                                     |\n| `data:` URIs — non-image                                                                       | Blocked entirely                                                                                                           | `data:text/html`, `data:text/javascript` are direct XSS vectors                                                                                    | —                                                                                                                                                     |\n| `data:image/svg+xml`                                                                           | Blocked                                                                                                                    | SVG images can contain `<script>` and event handlers                                                                                               | —                                                                                                                                                     |\n| `data:image/*` — other                                                                         | Allowed only with `;base64` encoding **and** matching magic bytes                                                          | Non-base64 binary images are never legitimate; magic byte check (PNG/JPEG/WebP/GIF header) blocks mislabeled or polyglot payloads                  | `image/avif`, `image/bmp`, etc. have no magic checker — pass through on MIME type alone                                                               |\n| External image `src` (`https://…`)                                                             | Allowed                                                                                                                    | External images are legitimate content; blocking would break most pages                                                                            | Tracking pixels are a known consequence — this is a content policy decision, not a sanitizer decision                                                 |\n| `srcset` attribute                                                                             | Allowed without URL validation                                                                                             | `srcset` contains multiple space-separated URLs; browsers do not execute JavaScript from `srcset`                                                  | Known gap: a `javascript:` URL in `srcset` would pass through (browsers ignore it, but the string survives)                                           |\n| `//evil.com` protocol-relative                                                                 | Allowed                                                                                                                    | Protocol-relative URLs are legitimate for same-protocol assets                                                                                     | In HTTP contexts, loads HTTP even on an HTTPS page; caller should enforce CSP                                                                         |\n| `<style>` blocks                                                                               | CSS AST sanitized — dangerous at-rules (`@import`, `@namespace`) removed, unsafe properties stripped                       | Tokenized AST parsing: obfuscated `expression()` and `url(javascript:)` are structurally detected, not regex-matched                               | —                                                                                                                                                     |\n| External stylesheets (`<link>`)                                                                | Fetched, sanitized, inlined as `<style>` in the output                                                                     | The serialized output is self-contained; re-fetching the original URL would bypass sanitization                                                    | Only enforced in sanitize mode; SSRF limits apply to the fetch                                                                                        |\n| Inline `style=\"\"`                                                                              | CSS sanitizer applied per-attribute                                                                                        | `background-image: url(evil.com)` is an exfiltration vector — stripped                                                                             | —                                                                                                                                                     |\n| JS DOM mutation (`innerHTML`, `outerHTML`, `insertAdjacentHTML`, `createElement+setAttribute`) | Sanitized post-mutation via the same CSS sanitizer pipeline                                                                | Mutations happen in the QuickJS sandbox; results are sanitized before the DOM is considered stable                                                 | —                                                                                                                                                     |\n| SVG `<foreignObject>`, `<feImage>`, `<animate>`, `<animateMotion>`, `<set>`, `<switch>`        | Blocked                                                                                                                    | `foreignObject` re-enters HTML parsing context (primary mXSS entry point); `feImage` loads external resources; animate* can trigger event handlers | —                                                                                                                                                     |\n| SVG `href` / `xlink:href`                                                                      | Fragment-only (`#id`) for most elements; `<image>` and `<a>` use standard URI validation                                   | External SVG resources via `<use href=\"external.svg#x\">` load arbitrary SVG                                                                        | —                                                                                                                                                     |\n| MathML                                                                                         | Allowed in correct context with attribute allowlist; `href`, `xlink:href`, `on*` removed                                   | Prevents XSS via invalid MathML nesting or href abuse                                                                                              | —                                                                                                                                                     |\n| DOM clobbering (`id`, `name`)                                                                  | Values that shadow `window`/`document` properties filtered                                                                 | Prevents `id=\"cookie\"` from overriding `document.cookie` etc.                                                                                      | —                                                                                                                                                     |\n| mXSS / obfuscated encoding                                                                     | Entity decoding happens at Lexbor parse time; `containsMxssPattern` run on all attribute values; CSS content AST-sanitized | No serialize/re-parse step means no parse-differential surface                                                                                     | Text nodes inside SVG `<title>`, `<desc>`, `<text>` are not pattern-checked — low risk because `foreignObject` (the main SVG escape hatch) is blocked |\n| `<iframe>`                                                                                     | Allowed only with `sandbox` attribute; `src` and `srcdoc` validated                                                        | Prevents loading of arbitrary external content                                                                                                     | `allow-scripts` in `sandbox` is blocked; other dangerous combinations not exhaustively validated                                                      |\n| Framework attributes (`v-html`, `ng-bind-html`, `x-html`, `:innerHTML`)                        | Removed by default; configurable via `allow_framework_attrs`                                                               | These attributes trigger HTML injection in their respective runtimes                                                                               | When allowed, values are checked against `DANGEROUS_JS_PATTERNS` but not fully sanitized                                                              |\n| CSP generation                                                                                 | Not provided                                                                                                               | CSP is a server/browser responsibility, not a DOM sanitizer responsibility                                                                         | Caller must set appropriate `Content-Security-Policy` headers when serving sanitized output                                                           |\n\n---\n\n## Usage examples\n\n### Render an HTML file\n\nWe want to render this HTML:\n\n<details><summary>HTML with CSS grid-1D and Flexbox</summary>\n\n<https://github.com/ndrean/zexplorer/blob/main/src/examples/render_grid_1d/grid_1d.html>\n\n```html\n<html>\n  <head>\n    <style>\n      body {\n        background: #1e1e2e;\n        padding: 24px;\n        display: flex;\n        flex-direction: column;\n        gap: 20px;\n        width: 760px;\n      }\n\n      h3 {\n        color: #cba6f7;\n        font-size: 13px;\n      }\n\n      /* Test 1: 3 equal columns, wraps to 2 rows */\n      .grid-3col {\n        display: grid;\n        grid-template-columns: repeat(3, 1fr);\n        gap: 12px;\n      }\n      .grid-3col .cell {\n        background: #313244;\n        border: 1px solid #585b70;\n        border-radius: 6px;\n        padding: 16px;\n        color: #a6e3a1;\n        font-size: 14px;\n      }\n\n      /* Test 2: 4 equal columns with gap */\n      .grid-4col {\n        display: grid;\n        grid-template-columns: repeat(4, 1fr);\n        gap: 8px;\n      }\n      .grid-4col .cell {\n        background: #45475a;\n        border: 1px solid #6c7086;\n        border-radius: 4px;\n        padding: 12px;\n        color: #89dceb;\n        font-size: 13px;\n      }\n\n      /* Test 3: grid-auto-flow: column — items flow horizontally */\n      .grid-autoflow {\n        display: grid;\n        grid-auto-flow: column;\n        gap: 10px;\n      }\n      .grid-autoflow .badge {\n        background: #f38ba8;\n        border-radius: 4px;\n        padding: 8px 14px;\n        color: #1e1e2e;\n        font-size: 13px;\n      }\n\n      /* Test 4: place-items: center — single centred item */\n      .grid-center {\n        display: grid;\n        place-items: center;\n        background: #181825;\n        border: 1px solid #cba6f7;\n        border-radius: 8px;\n        height: 100px;\n      }\n      .grid-center .label {\n        background: fuchsia;\n        border-radius: 4px;\n        padding: 10px 24px;\n        color: #1e1e2e;\n        font-size: 14px;\n      }\n    </style>\n  </head>\n  <body>\n    <!-- Test 1: 3-column equal-fr, 6 items → 2 rows -->\n    <div>\n      <h3>repeat(3, 1fr) — 6 items, wraps to 2 rows</h3>\n      <div class=\"grid-3col\">\n        <div class=\"cell\">Column A</div>\n        <div class=\"cell\">Column B</div>\n        <div class=\"cell\">Column C</div>\n        <div class=\"cell\">Row 2 — A</div>\n        <div class=\"cell\">Row 2 — B</div>\n        <div class=\"cell\">Row 2 — C</div>\n      </div>\n    </div>\n\n    <!-- Test 2: 4-column grid with gap, 8 items → 2 rows -->\n    <div>\n      <h3>repeat(4, 1fr) + gap: 8px — 8 items</h3>\n      <div class=\"grid-4col\">\n        <div class=\"cell\">Jan</div>\n        <div class=\"cell\">Feb</div>\n        <div class=\"cell\">Mar</div>\n        <div class=\"cell\">Apr</div>\n        <div class=\"cell\">May</div>\n        <div class=\"cell\">Jun</div>\n        <div class=\"cell\">Jul</div>\n        <div class=\"cell\">Aug</div>\n      </div>\n    </div>\n\n    <!-- Test 3: grid-auto-flow: column → horizontal flex row -->\n    <div>\n      <h3>grid-auto-flow: column — horizontal strip</h3>\n      <div class=\"grid-autoflow\">\n        <div class=\"badge\">Alpha</div>\n        <div class=\"badge\">Beta</div>\n        <div class=\"badge\">Gamma</div>\n        <div class=\"badge\">Delta</div>\n      </div>\n    </div>\n\n    <!-- Test 4: place-items: center → centered item in box -->\n    <div>\n      <h3>place-items: center</h3>\n      <div class=\"grid-center\">\n        <div class=\"label\" style=\"color: yellow\">Centered content</div>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n</details>\n\nWe will use the three methods: use the dev-server and send a POST HTTP request whose payload is JavaScript code, use the CLI with the verb `convert`, and run `Zig` code.\n\n- **dev-server**: the pipeline is described in a JavaScript snippet where we:\n  - read the HTML file using `fetch(url, headers)`,\n  - load (parse, load JS chunks, load and sync CSS) the full HTML with `zxp.loadHTML(html, {sanitize: ?})`\n  - paint the DOM using `zxp.paintDOM(node)` and get an ImageData.\n  - Then we can either print it in the terminal as a PNG using `kitty` and use `zxp.encode(imageData, mimeType)`, or save the image locally, with `zxp.save(path, imageData)`.\n  \nIn the example below, we encode in WEBP and will pipe the output to render an image in the terminal using `kitty`.\n\n```js\nconst file = \"file://src/examples/render_grid_1d/grid_1d.html\";\n\nasync function render() {\n  const file_data = await fetch(file);\n  const html = await file_data.text();\n  zxp.loadHTML(html);\n  const img = zxp.paintDOM(document.body);\n  return zxp.encode(img, \"webp\");\n}\n\nrender();\n```\n\nWe start the dev-server with:\n\n```sh\n./zig-out/bin/zxp server\n```\n\nand send an HTTP request with the content of the JavaScript snippet and pipe to display an image in the terminal:\n\n```sh\ncurl -s -X POST http://localhost:9984/run  \\\n--data-binary @src/examples/render_grid_1d/grid_1d.js \\\n| kitty +kitten icat\n```\n\nand get in your terminal the image:\n\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/src/examples/render_grid_1d/grid_1d.webp\" alt=\"grid_1d.png\" width=\"300\" height=\"200\">\n\n<br>\n\nIf you want to save the image to a say JPEG, you can instead use `zxp.save()` and the file extension will use the proper encoding (amonst PNG, WEBP, JPEG and PDF).\n\n```js\nzxp.save(img, \"src/examples/render_grid_1d/serve_grid_1d.webp\");\n```\n\n- **CLI**: we use the verb `convert` to load and draw the HTML and output it in the desired format (PDF chosen here)\n\n```sh\n./zig-out/bin/zxp convert src/examples/render_grid_1d/grid_1d.html -dpi 72 -o src/examples/render_grid_1d/grid_1d.pdf\n```\n\n- **using the library**:\n\n<details><summary>Zig code using the library</summary>\n\nSource: <https://github.com/zexplorer/blob/main/src/examples/render_grid_1d/grid_1d.zig>\n\n```zig\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst z = @import(\"zexplorer\");\nconst ZxpRuntime = z.ZxpRuntime;\nconst ScriptEngine = z.ScriptEngine;\n\npub fn main() !void {\n    var debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n    const gpa, const is_debug = gpa: {\n        break :gpa switch (builtin.mode) {\n            .Debug, .ReleaseSafe => .{ debug_allocator.allocator(), true },\n            .ReleaseFast, .ReleaseSmall => .{ std.heap.c_allocator, false },\n        };\n    };\n    defer if (is_debug) {\n        _ = .ok == debug_allocator.deinit();\n    };\n\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    var zxp_rt = try z.ZxpRuntime.init(gpa, sandbox_root);\n    defer zxp_rt.deinit();\n\n    var engine = try ScriptEngine.init(gpa, zxp_rt);\n    defer engine.deinit();\n\n    const html = @embedFile(\"grid_1d.html\"); // relative to source file\n    try engine.loadPage(html, .{});\n\n    try z.prettyPrint(gpa, z.bodyNode(engine.dom.doc).?);\n\n    // Paint\n    const script =\n        \\\\ const body = document.querySelector(\"body\");\n        \\\\ zxp.save(zxp.paintDOM(body), \"src/examples/render_grid_1d/grid_1d.jpeg\")\n    ;\n    const val = try engine.eval(script, \"<grid-paint>\", .global);\n    engine.ctx.freeValue(val);\n}\n```\n\n</details>\n\nYou run it with:\n\n```sh\nzig build example -Dname=render_grid_1d/grid_1d\n```\n\n---\n\n### Scrape a Vercel site in less than 1s\n\nScrape <https://demo.vercel.store> and get structured data extracted:\n\n- using the dev-server: you prepare a JavaScript snippet to reach the website and pass the selector of your choice. We mimic `puppeteer`'s API with `await zxp.goto()` ot fetch, execute all the received JS chunks and CSS files and parse and sync the DOM and CSS to be able to `await zxp.waitForSelector()` which extracts the data using _querySelector_ against the DOM.\n\n```js\n//  src/examples/vercel-demo/inline-select.js \nasync function select() {\n  await zxp.goto(\"https://demo.vercel.store\");\n  await zxp.waitForSelector(\"a[href^='/product/']\");\n\n  const links = document.querySelectorAll(\"a[href^='/product/']\");\n  const unique = [\n    ...new Set(Array.from(links).map((el) => el.getAttribute(\"href\"))),\n  ];\n  const items = unique.map((href) => {\n    const el = document.querySelector(`a[href='${href}']`);\n    return el.textContent.trim();\n  });\n  return items;\n}\n\nselect();\n```\n\nYour server is still running:\n\n```sh\n./zig-out/bin/zxp server\n```\n\nYou send a POST request:\n\n```sh\ncurl -s -X POST http://localhost:9984/run  \\\n--data-binary @src/examples/vercel-demo/inline-select.js\n```\n\nYou receive in your terminal:\n\n```txt\n[\"Acme Circles T-Shirt$20.00USD\", \"Acme Drawstring Bag$12.00USD\", \"Acme Cup$15.00USD\",...]\n```\n\n- using the CLI: you rus the verb `run`\n\n```sh\nzxp run src/examples/vercel-demo/inline-select.js --pretty\n```\n\n- using the library:\n\nSource: <https://github.com/zexplorer/blob/main/src/examples/vercel-demo/inline-select.zig>\n\n```sh\nzig build example -Dname=vercel-demo/vercel\n```\n\n---\n\n### Render the Vercel side\n\nIf you want to visualize the website, you can do:\n\n- using the CLI: we use the verb `scrape` and run an additional snippet:\n\n<https://github.com/ndrean/zexplorer/blob/main/src/examples/vercel-demo/inline-images.js>\n\nThe reason is that Next.js uses `srcset` to serve multiple formats, and we transform it into a `src =\"data:image/webp;base64, ...\"` to render using the Liveserver in VSCode.\n\nWe use two custom native methods `zxp.fetchAll([urls], [headers])` and `zxp.arrayBufferToBase64DataUri(buffer, type)`.\n\n```sh\nzxp scrape https://demo.vercel.store src/examples/inline-images.js -o src/examples/vercel-demo/vercel.html\n```\n\n<details><summary>inline-image.js helper</summary>\n\n```js\n// Resolves Next.js srcset URLs; removes srcset after inlining.\nasync function fetchImages() {\n  const base = \"https://demo.vercel.store\";\n  const imgs = Array.from(document.querySelectorAll(\"img\"));\n\n  // Collect one URL per image (first srcset entry preferred over src).\n  const urls = imgs.map((img) => {\n    const srcset = img.getAttribute(\"srcset\");\n    if (srcset) {\n      const first = srcset.split(\",\")[0].trim().split(/\\s+/)[0];\n      if (first) return first.startsWith(\"http\") ? first : base + first;\n    }\n    const src = img.getAttribute(\"src\");\n    if (src && !src.startsWith(\"data:\")) {\n      return src.startsWith(\"http\") ? src : base + src;\n    }\n    return null;\n  });\n\n  // Fetch all in parallel via libcurl multi.\n  const results = fetchAll(\n    urls.filter((u) => u !== null),\n    {\n      Accept: \"image/png,image/jpeg,image/webp,*/*;q=0.5\",\n      Referer: base + \"/\",\n    }\n  );\n\n  // Map results back to images (skip nulls).\n  let ri = 0;\n  for (let i = 0; i < imgs.length; i++) {\n    if (urls[i] === null) continue;\n    const r = results[ri++];\n    if (!r || !r.ok) continue;\n    imgs[i].setAttribute(\"src\", arrayBufferToBase64DataUri(r.data, r.type));\n    imgs[i].removeAttribute(\"srcset\");\n  }\n\n  return document.documentElement.outerHTML;\n}\nfetchImages();\n```\n\n</details>\n\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/images/demo.vercel.store.png\" alt=\"vercel demo\" width=\"600\" height=\"400\">\n\n<br>\n\nWhen using the server, we then use this function along with `zxp.goto()`:\n\n```js\nasync function scrape() {\n  url = \"https://demo.vercel.store\";\n  await zxp.goto(url);\n  return await fetchImages(url); // <-- returns the serailized DOM\n  // return zxp.fs.WriteFileSync(\"src/examples/demo-vercel/vercel.html) <- save disk\n}\nscrape();\n\n```\n\nYou can serve this HTML via the LiveServer to have a snapshot of the Vercel demo website.\n\n<https://github.com/ndrean/zexplorer/blob/main/demo-vercel/vercel.html>\n\n---\n\n### Generate a Leaflet map PDF report\n\nLoad Leaflet, draw a GeoJSON route on OpenStreetMap tiles, composite the map with an SVG template, and output a multi-layered PDF — all in one shot:\n\n<https://github.com/ndrean/zexplorer/blob/main/images/RouteReport.pdf>\n\nSee the [full Leaflet-to-PDF example](#embed-leaflet-geojson-path-map-in-an-svg-and-output-a-pdf) below.\n\n---\n\n\n## Library quick start\n\n### Hello world\n\n**[Dual primitives]** When you use `zexplorer` as a `Zig` library, you have DOM primitives accessible in the Zig code. Since these primitives are ported into the JavaScript runtime, you can access them as well in the runtime.\n\n**[First example]** You have a simple HTML file, _examples/hello_world.html_.\n\n```html\n<div>\n  <p>Hello world</p>\n</div>\n```\n\nWe will parse it with `z.parseHTML()` and print the DOM into the console with `prettyPrint()`. We will build and execute the following _src/ex1.zig_ file where we respect the careful and explicit Zig memory allocation ceremony:\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n  const gpa = debug_allocator.allocator();\n  defer { \n    _= .ok == debug_allocator.deinit();\n  }\n\n  const html = @embedFile(\"examples/hello_world.html\");\n\n  const doc = try z.parseHTML(allocator, html);\n  defer z.destroyDocument(doc);\n\n  try z.prettyPrint(gpa, z.documentRoot(doc).?);\n}\n\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n```\n\nThe executable is named \"zxp\". We build the _main.zig_ file (defined for you in _build.zig_ asa the \"run\" step), and execute it by using its name:\n\n```sh\n$> zig build run\n$> ./zig-out/bin/zxp\n```\n\nIn the terminal, you see:\n\n```txt\n<div>\n  <p>\n    \"Hello world\"\n  </p>\n</div>\n```\n\n---\n\n**[Example of dual primitives]** We create a DOM and query it in pur Zig and then using embedded JavaScript:\n\nIn this example, we first parse the HTML file with `DOMParser.parseFromString()` and then we can query the \"VDOM\" in Zig with `z.querySelector()` and get the content with `textContent_zc()`.\n\n<details><summary>Use parser.parseFromString </summary>\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n  const gpa = debug_allocator.allocator();\n  defer {\n    _ =  .ok == debug_allocator.deinit();\n  }\n\n  // alternative: using DOMParser alternative instead of `parseHTML()`\n  var parser = try z.DOMParser.init(gpa);\n  defer parser.deinit();\n\n  const html = @embedFile(\"examples/hello_world.html\");\n  const doc = try parser.parseFromString(html);\n  defer z.destroyDocument(doc);\n\n  const p_elt = try z.querySelector(gpa, z.bodyNode(doc).?, \"p\");\n  const p_node = z.elementToNode(p_elt.?);\n  const inner_text = z.textContent_zc(p_node); // no allocation\n\n  std.debug.print(\"[Zig] {s}\\n\", .{inner_text});\n}\n\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n```\n\n</details>\n\nThen, we run a JavaScript snippet that knows about the \"vDOM\". Indeed, zexplorer brings in a default `document` to which the JavaScript code accesses via a globalThis `document`. We use the engine `z.ScriptEngine`  and the `loadHTML()` and `evalModule()` methods.\n\n<details><summary>With a JavaScript snippet</summary>\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n  const gpa = debug_allocator.allocator();\n  defer _ = debug_allocator.deinit();\n\n  const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n  defer gpa.free(sandbox_root);\n\n  var engine = try z.ScriptEngine.init(gpa, sandbox_root);\n  defer engine.deinit();\n\n  const js =\n    \\\\const innerText = document.querySelector(\"p\").textContent;\n    \\\\console.log(\"[JS]\", innerText);\n    ;\n  const html = @embedFile(\"examples/hello_world.html\");\n\n  try engine.loadHTML(html);\n  try engine.evalModule(js, \"<script>\");\n}\n\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n```\n\n</details>\n\nYou build and execute the _main.zig_ file via the \"run\" step:\n\n```sh\n$> zig build run\n$> ./zig-out/bin/zxp-ex\n```\n\nand get in the terminal:\n\n```txt\n[Zig] Hello world\n[JS] Hello world\n```\n\n---\n\n**[Run JavaScript]** Let's run a JavaScript snippet that builds the same DOM programmatically and adds a `<script>` to it:\n\n```js\n// src/examples/hello_world.js\nconst div = document.createElement(\"div\");\nconst p = document.createElement(\"p\");\np.textContent = \"Hello zexplorer\";\ndiv.appendChild(p);\ndocument.body.appendChild(div);\n\nconst script = document.createElement(\"script\");\nscript.textContent = \"const hello = document.querySelector('p').textContent; console.log(\"[JS]\", hello);\";\ndocument.head.appendChild(script);\n```\n\nIn the _main.zig_ file, we use the `z.ScriptEngine` to load the JS code `engine.evalModule()` and then execute it with `engine.executeScripts()`. We take care of all the memory allocations:\n\n<details><summary>Using engine.evalModule() and engine.executeScripts()</summary>\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n    const gpa = debug_allocator.allocator();\n    defer _ = debug_allocator.deinit();\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    var engine = try z.ScriptEngine.init(gpa, sandbox_root);\n    defer engine.deinit();\n\n    const script = @embedFile(\"examples/hello_world.js\");\n\n    const val = try engine.evalModule(script, \"<my-script>\");\n    defer engine.ctx.freeValue(val);\n\n    try engine.executeScripts(gpa, \".\");\n\n    // Print the DOM to stdout\n    try z.prettyPrint(gpa, z.documentRoot(engine.dom.doc).?);\n}\n\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n```\n\n</details>\n\nYou build and execute the _main.zig_ file via the \"run\" step:\n\n\n```sh\n$> zig build run\n$> ./zig-out/bin/zxp-ex\n```\n\nThe output in the terminal:\n\n```txt\n[JS] Hello zexplorer  <-- zexplorer executed the script\n\n<html>                <-- zexplorer \"pretty-printed\" the DOM to stdout\n  <head>\n    <script>\n      \"const hello = document.querySelector('p').textContent; console.log('[JS]', hello);\"\n    </script>\n  </head>\n  <body>\n    <div>\n      <p>\n        \"Hello zexplorer\"\n      </p>\n    </div>\n  </body>\n</html>\n```\n\n---\n\n**[HTML with script]** You have an HTML file (_examples/html-script.html_) with a script. We use the `z.ScriptEngine` and use a higher level primitive `loadPage()` that parses the HTML and CSS and syncs it, and reads and evaluates the found `<script>`'s elements.\n\n```html\n<body>\n  <p>Hello Zig</p>\n  <script>\n    const p = document.querySelector(\"p\");\n    console.log(p.textContent);\n  </script>\n</body>\n```\n\nYour _main.zig_  file contains:\n\n<details><summary>Using ScriptEngine.loadPage()</summary>\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n    const gpa = debug_allocator.allocator();\n    defer _ = debug_allocator.deinit();\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    var engine = try z.ScriptEngine.init(gpa, sandbox_root);\n    defer engine.deinit();\n\n    const html = @embedFile(\"html-script.html\");\n    try engine.loadPage(html, .{});\n\n    try z.prettyPrint(gpa, z.documentRoot(engine.dom.doc).?);\n}\n\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n```\n\n</details>\n\nYou build and execute _main.zig_:\n\n```sh\n$> zig build run\n$> ./zig-out/bin/zxp-ex\n```\n\nThe output is as expected:\n\n```txt\n[JS] Hello Zig\n\n<html>\n  <head>\n    ...\n```\n\n### Scrape a Vercel site\n\nWe scrape <https://demo.vercel.store>. It makes 12 HTTP requests and runs 42 scripts in order to hydrate the first SSR rendered page.\n\nYou can scrap the Vercel website with this JavaScript snippet that mimics `Puppeteer`'s API.\n\n```js\n// vercel.js\n\nasync function testVercel() {\n  try {\n    await zexplorer.goto(\"https://demo.vercel.store\");\n\n    await zexplorer.waitForSelector(\"a[href^='/product/']\");\n\n    const links = document.querySelectorAll(\"a[href^='/product/']\");\n    const unique = [...new Set(Array.from(links).map(el => el.getAttribute('href')))];\n    const items = unique.map(href => {\n      const el = document.querySelector(`a[href='${href}']`);\n      return el.textContent.trim();\n    });\n\n    console.log(items);\n    return items; // <-- return to the engine to marshall the array\n  } catch (err) {\n    console.error(err);\n  }\n}\n```\n\nYou pass it to the engine:\n\n<details><summary>Using engine.Eval() and engine.evalAsyncAs()</summary>\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n    const gpa = debug_allocator.allocator();\n    defer _ = debug_allocator.deinit();\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    var engine = try z.ScriptEngine.init(gpa, sandbox_root);\n    defer engine.deinit();\n\n    const script = @embedFile(\"vercel.js\");\n    const val = try engine.eval(script, \"test_vercel.js\", .global);\n    defer engine.ctx.freeValue(val);\n    \n    // output is an Array of strings\n    const items = try engine.evalAsyncAs(\n        allocator,\n        []const []const u8,\n        \"testVercel()\",\n        \"<vercel>\",\n    );\n    defer {\n        for (items) |item| allocator.free(item);\n        allocator.free(items);\n    }\n\n    // output : toOwnedSlice or file\n    var buf: std.ArrayList(u8) = .empty;\n    defer buf.deinit(allocator);\n    for (items) |item| {\n        try buf.appendSlice(allocator, item);\n        try buf.append(allocator, '\\n');\n    }\n\n    try std.fs.cwd().writeFile(\n        .{\n            .sub_path = \"vercel_data.txt\",\n            .data = buf.items,\n        },\n    );\n}\n```\n\n</details>\n\nand you get your data back in 1s:\n\n```txt\n0.17s user 0.14s system 37% cpu 0.835 total\n\n[\n  \"Acme Circles T-Shirt$20.00USD\",\n  \"Acme Drawstring Bag$12.00USD\",\n  \"Acme Cup$15.00USD\",\n  \"Acme Mug$15.00USD\",\n  \"Acme Hoodie$50.00USD\",\n  \"Acme Baby Onesie$10.00USD\",\n  \"Acme Baby Cap$10.00USD\"\n]\n```\n\nTODO\n\n```sh\nTODO\n```\n\n---\n\n### Sanitize HTML & CSS\n\nFour CSS threat vectors are sanitized in a single pass — covering every way untrusted CSS can reach a document:\n\n| #   | Vector                                                                            | Example threat                                        |\n| --- | --------------------------------------------------------------------------------- | ----------------------------------------------------- |\n| 1   | External stylesheet (`<link>`)                                                    | `background-image: url(\"evil.com\")`                   |\n| 2   | `<style>` block                                                                   | `background: url(javascript:alert(\"xss\"))`            |\n| 3   | Inline `style=\"\"` attribute                                                       | `behavior: url(evil.htc)`                             |\n| 4   | JS DOM mutation (`innerHTML`, `outerHTML`, `insertAdjacentHTML`, `createElement`) | `background-image: url(evil.com)` injected at runtime |\n\nVectors 1–3 are static (present in the HTML source). Vector 4 is dynamic — injected by JavaScript after parse.\n\n---\n\n#### Vectors 1–3: static CSS (`<link>`, `<style>`, inline)\n\n<details><summary>src/examples/test_example.css</summary>\n\n```css\n.untrusted {\n  color: red;\n  background-color: #ffe0e0;\n  font-size: 18px;\n  padding: 8px;\n  background-image: url(\"evil.com\");  /* ← threat: exfiltration via image load */\n}\n.trusted {\n  color: darkgreen;\n  background-color: #e0ffe0;\n  font-size: 14px;\n  padding: 6px;\n}\n```\n\n</details>\n\n<details><summary>src/examples/test_example.html</summary>\n\n```html\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"test_example.css\" />  <!-- vector 1 -->\n    <style>\n      body { margin: 10px; padding: 5px;\n             background: url(javascript:alert(\"xss\")); } /* vector 2: threat */\n      .trusted { color: green; }\n    </style>\n    <script src=\"test_example.js\"></script>\n  </head>\n  <body>\n    <div class=\"untrusted\" onclick=\"alert(1)\"           <!-- onclick: threat -->\n         style=\"font-size: 16px\">                       <!-- vector 3 -->\n      red + pink bg from &lt;link&gt; | font-size 16px from inline | onclick removed\n    </div>\n    <p class=\"untrusted\" style=\"font-size: 12px\">\n      red + pink bg from &lt;link&gt; | font-size 12px from inline | bg-image threat stripped\n    </p>\n    <p class=\"trusted\" style=\"padding: 20px\">\n      darkgreen + green bg from &lt;link&gt; | color green from &lt;style&gt; block | padding from inline\n    </p>\n  </body>\n</html>\n```\n\n</details>\n\n**Sanitize and render:**\n\n```sh\nzxp sanitize src/examples/test_example.html > sanitized.html\nzxp convert sanitized.html -o test_example_sanitized.png\n```\n\n<!-- generated image: test_example_sanitized.png -->\n\n<details><summary>sanitized.html — annotated output</summary>\n\n```html\n<html><head>\n    <!-- ✓ vector 1: <link> replaced by inline <style>; background-image stripped -->\n    <style>.untrusted { color: red; background-color: #ffe0e0; font-size: 18px; padding: 8px }\n.trusted { color: darkgreen; background-color: #e0ffe0; font-size: 14px; padding: 6px }\n</style>\n    <!-- ✓ vector 2: background: url(javascript:...) stripped from <style> block -->\n    <style>body { margin: 10px; padding: 5px }\n.trusted { color: green }\n</style>\n    <!-- ✓ <script> removed (default) -->\n  </head>\n  <body>\n    <!-- ✓ onclick removed; vector 3 inline style preserved (font-size is safe) -->\n    <div class=\"untrusted\" style=\"font-size: 16px\">\n      red + pink bg from &lt;link&gt; | font-size 16px from inline | onclick removed\n    </div>\n    <p class=\"untrusted\" style=\"font-size: 12px\">\n      red + pink bg from &lt;link&gt; | font-size 12px from inline | bg-image threat stripped\n    </p>\n    <p class=\"trusted\" style=\"padding: 20px\">\n      darkgreen + green bg from &lt;link&gt; | color green from &lt;style&gt; block | padding from inline\n    </p>\n  </body>\n</html>\n```\n\n</details>\n\n**Programmatic verification** — re-parse the sanitized output cold (no network, no external files) and confirm via `getComputedStyle`:\n\n<details><summary>Zig verification (src/examples/test_example.zig)</summary>\n\n```zig\ntry engine.loadPage(@embedFile(\"test_example.html\"), .{\n    .sanitize = true,\n    .base_dir = \"src/examples\",\n    .execute_scripts = true,\n    .load_stylesheets = true,\n    .sanitizer_options = .{ .remove_scripts = false },\n});\n\nconst doc = engine.dom.doc;\n\n// vector 1 — external stylesheet: safe props survive, threat stripped\nif (z.querySelector(doc, \".untrusted\")) |el| {\n    _ = try z.getComputedStyle(ta, el, \"color\");             // \"red\"      ✓ safe\n    _ = try z.getComputedStyle(ta, el, \"background-color\");  // \"#ffe0e0\"  ✓ safe\n    _ = try z.getComputedStyle(ta, el, \"background-image\");  // null       ✓ stripped\n}\n\n// vector 2 — <style> block: safe props survive, js: url stripped\nif (z.querySelector(doc, \"body\")) |el| {\n    _ = try z.getComputedStyle(ta, el, \"margin\");            // \"10px\"     ✓ safe\n    _ = try z.getComputedStyle(ta, el, \"background\");        // null       ✓ stripped\n}\n\n// vector 3 — inline style: safe font-size survives\nif (z.querySelector(doc, \"div.untrusted\")) |el| {\n    _ = try z.getComputedStyle(ta, el, \"font-size\");         // \"16px\"     ✓ safe\n    // onclick attribute removed:\n    std.debug.assert(z.getAttribute_zc(el, \"onclick\") == null);\n}\n```\n\n</details>\n\n---\n\n#### Vector 4: JS DOM mutation\n\nJavaScript can inject HTML at runtime via `innerHTML`, `outerHTML`, `insertAdjacentHTML`, or `createElement` + `setAttribute`. Each mutation is intercepted and sanitized at the point of injection when `sanitize = true`.\n\n<details><summary>src/examples/test_sanitize_injection.html</summary>\n\n```html\n<html>\n  <body>\n    <div id=\"t1\"></div>\n    <div id=\"t2-placeholder\"></div>\n    <div id=\"t3\"></div>\n    <div id=\"t4-host\"></div>\n    <script>\n      // Each injection carries a safe property (color:red) and a threat (background-image)\n      document.getElementById(\"t1\").innerHTML =\n        '<p id=\"r1\" style=\"color:red; background-image:url(evil.com)\">innerHTML | red from inline | bg-image stripped</p>';\n\n      document.getElementById(\"t2-placeholder\").outerHTML =\n        '<p id=\"r2\" style=\"color:red; background-image:url(evil2.com)\">outerHTML | red from inline | bg-image stripped</p>';\n\n      document.getElementById(\"t3\").insertAdjacentHTML(\"beforeend\",\n        '<p id=\"r3\" style=\"color:red; background-image:url(evil3.com)\">insertAdjacentHTML | red from inline | bg-image stripped</p>');\n\n      const p4 = document.createElement(\"p\");\n      p4.id = \"r4\";\n      p4.setAttribute(\"style\", \"color:red; background-image:url(evil4.com)\");\n      p4.textContent = \"createElement + setAttribute | red from inline | bg-image stripped\";\n      document.getElementById(\"t4-host\").appendChild(p4);\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n**Run (Zig API — sanitize + render):**\n\n```sh\nzig build example -Dname=test_sanitize_injection\n```\n\n<!-- generated image: test_sanitize_injection.png -->\n\n**Programmatic verification** (from `src/examples/test_sanitize_injection.zig`):\n\n```txt\n  [innerHTML]              style=\"color: red\"   color ✓   bg-image (stripped) ✓   PASS\n  [outerHTML]              style=\"color: red\"   color ✓   bg-image (stripped) ✓   PASS\n  [insertAdjacentHTML]     style=\"color: red\"   color ✓   bg-image (stripped) ✓   PASS\n  [createElement+setAttribute]  style=\"color: red\"   color ✓   bg-image (stripped) ✓   PASS\n```\n\nIn all four cases: the safe property (`color: red`) reaches the computed style, the threat (`background-image: url(...)`) is stripped before the DOM is committed. The rendered image shows red text on a white background — no external image loads occurred.\n\n---\n\n### Generate OG images from SVG templates\n\nWe display two examples that show that `zexplorer` overlaps partially [node-canvas](https://github.com/Automattic/node-canvas) and [Vercel/satori](https://github.com/vercel/satori)  (no JSX but `React` can be loaded) but is very lightweight and limited.\n\nGiven this SVG (designed in Figma):\n\n<details><summary>SVG template</summary>\n\n```html\n<svg width=\"1200\" height=\"630\" viewBox=\"0 0 1200 630\" xmlns=\"http://www.w3.org/2000/svg\">\n  <defs>\n    <mask id=\"hole\">\n        <rect width=\"1200\" height=\"630\" fill=\"white\" />\n        <circle cx=\"175\" cy=\"175\" r=\"75\" fill=\"black\" />\n    </mask>\n  </defs>\n  <rect width=\"1200\" height=\"630\" fill=\"#0f172a\" mask=\"url(#hole)\"/>\n        \n  <text x=\"100\" y=\"380\" font-family=\"Arial\" font-size=\"80\" fill=\"#ffffff\" font-weight=\"bold\">\n    {{TITLE}}\n  </text>\n        \n  <text x=\"100\" y=\"480\" font-family=\"Arial\" font-size=\"40\" fill=\"#94a3b8\">\n    Written by {{AUTHOR}}\n  </text>\n </svg>\n```\n\n</details>\n\nThe following \"standard\" JavaScript snippet makes a layered composition of a \"fetched\" image and the interpolated SVG template inside a Canvas.\n\nYou extract the data and return an ArrayBuffer that Zig will marshall.\n\n<details><summary>JS code</summary>\n\n```js\nasync function loadImage(url) {\n  return await new Promise((resolve, reject) => {\n    try {\n      const img = new Image();\n      img.onload = () => resolve(img);\n      img.onerror = (e) => reject(new Error(`Image failed to load: ${url}`));\n      img.src = url;\n    } catch (e) {\n      reject(new Error(`Failed to fetch image: ${e.message}`));\n    }\n  });\n}\n\nasync function generateOGImage({ title, author, avatarUrl }) {\n  console.log(`Generating OG Image for:  ${title}`);\n  const avatarImg = await loadImage(avatarUrl);\n\n  const templ_res = await fetch(\n    \"file://src/examples/test_og_generator_template_v2.svg\",\n  );\n\n  const rawSvgTemplate = await templ_res.text();\n  const finalSvgText = rawSvgTemplate\n    .replace(\"{{TITLE}}\", title)\n    .replace(\"{{AUTHOR}}\", author);\n  const svgBlob = new Blob([finalSvgText], { type: \"image/svg+xml\" });\n  const imgSVG = await createImageBitmap(svgBlob);\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 1200;\n  canvas.height = 630;\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(avatarImg, 100, 100, 150, 150); // in the hole\n  ctx.drawImage(imgSVG, 0, 0);\n\n  const pngBlob = await canvas.toBlob();\n  return await pngBlob.arrayBuffer();\n}\n\nasync function renderTemplate() {\n  try {\n    console.log(\"Called\");\n    const pngBytes = await generateOGImage({\n      title: \"Headless Browser in Zig\",\n      author: \"N. Drean\",\n      avatarUrl: \"https://github.com/torvalds.png\",\n    });\n\n    return pngBytes; // return data to Zig to save in a file\n  } catch (e) {\n    console.error(\"Failed to generate OG image:\", e);\n  }\n}\n```\n\n</details>\n\nThe Zig code to run this is quite simple:\n\n\n<details><summary>Zig runner</summary>\n\n```zig\npub fn main() !void {\n    const allocator = std.testing.allocator;\n\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    try run_test(gpa, sandbox_root);\n}\n\nfn run_test(allocator: std.mem.Allocator, sbx: []const u8) !void {\n    var zxp_rt = z.ZxpRuntime.init(allocator, sbx);\n    defer zxp_rt.deinit();\n    var engine = try z.ScriptEngine.init(allocator, zxp_rt);\n    defer engine.deinit();\n\n    const script = @embedFile(\"test_og_generator.js\");\n\n    const val = try engine.eval(script, \"<script>\", .global);\n    defer engine.ctx.freeValue(val);\n\n    const png_bytes = try engine.evalAsyncAs(allocator, []const u8, \"renderTemplate()\", \"<svg-template>\");\n    defer allocator.free(png_bytes);\n\n    try std.fs.cwd().writeFile(.{.sub_path = \"templated.png\", .data = png_bytes});\n}\n\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\nconst ScriptEngine = z.ScriptEngine;\nconst js_canvas = z.js_canvas;\n```\n\n</details>\n\nThe result is:\n\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/template_generated.png\" alt=\"OG image\" width=\"600\" height=\"300\">\n\n\n2) \n[TODO] CLI...\n\n---\n\n### Embed Leaflet geoJSON path map in an SVG and output a PDF\n\n<details><summary>The HTML file that draws a Leaflet map into an SVG template and renders a PDF</summary>\n\n```html\n<!doctype html>\n<html>\n  <head>\n    <link\n      rel=\"stylesheet\"\n      href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\"\n    />\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n  </head>\n  <body>\n    <div id=\"map\" style=\"width: 800px; height: 600px\"></div>\n\n    <script>\n      async function runDrawGeoJSONRoute(deliveryData) {\n        console.log(\"[Test] Booting Leaflet GeoJSON Engine...\");\n\n        const map = L.map(\"map\", {\n          zoomControl: false,\n          attributionControl: false,\n        }).setView([51.505, -0.09], 13);\n\n        L.tileLayer(\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\").addTo(\n          map,\n        );\n\n        // Draw a path from Hyde Park to the Tower of London!\n        const route = {\n          type: \"LineString\",\n          coordinates: [\n            [-0.15, 51.505],\n            [-0.12, 51.51],\n            [-0.076, 51.508],\n          ],\n        };\n        L.geoJSON(route, {\n          style: { color: \"red\", weight: 6, opacity: 0.8 },\n        }).addTo(map);\n\n        // 1. Extract the Tiles\n        const tiles = Array.from(\n          document.querySelectorAll(\"img.leaflet-tile\"),\n        ).map((img) => ({\n          url: img.src,\n          x: parseInt(img.style.left || 0, 10),\n          y: parseInt(img.style.top || 0, 10),\n        }));\n\n        // 2. Extract the SVG Vector Data!\n        const svgElement = document.querySelector(\".leaflet-overlay-pane svg\");\n        const svgString = svgElement ? svgElement.outerHTML : \"\";\n\n        console.log(`✅ Extracted ${tiles.length} tiles and SVG overlay!`);\n\n        const readyTiles = [];\n        for (const t of tiles) {\n          try {\n            const res = await fetch(t.url);\n            const buffer = await res.arrayBuffer();\n            readyTiles.push({\n              buffer: buffer,\n              x: t.x,\n              y: t.y,\n              w: t.w,\n              h: t.h,\n            });\n            console.log(`  + Fetched tile at (${t.x}, ${t.y})`);\n          } catch (e) {\n            console.log(`  - Failed to fetch ${t.url}`);\n          }\n        }\n\n        // 3. Send to Zig Compositor\n        // CRITICAL: Dimensions must match the CSS width/height of the map div!\n        const mapBuffer = zexplorer.generateRoutePng(\n          readyTiles,\n          svgString,\n          null, // No file output, keep in memory\n          800, // Map DOM width\n          600, // Map DOM height\n        );\n        console.log(\"Composited Map loaded:\", mapBuffer.byteLength, \"bytes\");\n\n        // 4. Load the UI Background Template\n        const templateRes = await fetch(\n          \"file://src/examples/test_route_report_template.svg\",\n        );\n        const svgText = await templateRes.text();\n        const svgBlob = new Blob([svgText], { type: \"image/svg+xml\" });\n        const bgBitmap = await createImageBitmap(svgBlob);\n\n        // 5. Assemble the PDF Layout (Top-to-Bottom)\n        const pdf = new PDFDocument();\n        pdf.addPage(); // Zig backend handles A4 sizing natively\n\n        // Layer 1: Background\n        pdf.drawImage(bgBitmap, 0, 0, 595, 842);\n\n        // Calculate responsive dimensions\n        const margin = 40;\n        const pdfPageWidth = 595;\n        const maxImageWidth = pdfPageWidth - margin * 2;\n        const imgWidth = maxImageWidth;\n        const imgHeight = (600 / 800) * imgWidth; // 4:3 Aspect Ratio scaling\n        const mapStartY = 160;\n\n        // Layer 2: Title Text at the top\n        pdf.fillStyle = \"#0f172a\";\n        pdf.setFont(\"Roboto-Bold\", 24);\n        pdf.fillText(\"Delivery Route Summary\", margin, margin + 20);\n\n        // Layer 3: The Map (Placed below the title)\n        pdf.drawImageFromBuffer(\n          mapBuffer,\n          margin,\n          mapStartY,\n          imgWidth,\n          imgHeight,\n        );\n\n        // Layer 4: Report Data (Placed dynamically below the map)\n        const textStartY = mapStartY + imgHeight + 40; // Properly declared and calculated\n        pdf.setFont(\"Roboto\", 12);\n        pdf.fillStyle = \"#475569\";\n\n        // Left Column\n        pdf.fillText(`Date: ${deliveryData.date}`, margin + 15, textStartY);\n        pdf.fillText(\n          `Driver: ${deliveryData.driverName}`,\n          margin + 15,\n          textStartY + 25,\n        );\n\n        // Right Column\n        const rightColX = pdfPageWidth - margin - 180;\n        pdf.fillText(`Est Time: ${deliveryData.eta}`, rightColX, textStartY);\n        pdf.fillText(\n          `Total Distance: ${deliveryData.distance}`,\n          rightColX,\n          textStartY + 25,\n        );\n\n        // Layer 5: Decorative Border around the text\n        pdf.setLineWidth(2);\n        pdf.setDrawColor(\"#cbd5e1\");\n        pdf.strokeRect(margin, textStartY - 25, maxImageWidth, 65);\n\n        pdf.save(`RouteReport_${deliveryData.id}.pdf`);\n        console.log(\"🟢 Route Report generated\");\n      }\n\n      runDrawGeoJSONRoute({\n        id: \"LDN-8492\",\n        driverName: \"Auto-Pilot\",\n        date: \"Feb 18, 2026\",\n        distance: \"6.4 km\",\n        eta: \"18 mins\",\n      }).catch((e) => console.error(\"Error:\", e.message, e.stack));\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n\n<details><summary>Zig runner</summary>\n\n```zig\nvar debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n\npub fn main() !void {\n    const gpa = debug_allocator.allocator(),\n    defer {\n      _ = .ok == debug_allocator.deinit();\n    };\n\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    var engine = try ScriptEngine.init(allocator, sbx);\n    defer engine.deinit();\n\n    const html = @embedFile(\"test_route_report.html\");\n    try engine.loadPage(html, .{});\n    try engine.run();\n}\n\nconst std = @import(\"std\");\nconst builtin = @import(\"builtin\");\nconst z = @import(\"zexplorer\");\nconst ScriptEngine = z.ScriptEngine;\n```\n\n</details>\n\nThe result is:\n\n<https://github.com/ndrean/zexplorer/blob/main/images/RouteReport.pdf>\n\n---\n\n### Render D3.js to PNG\n\n<details><summary>HTML & JavaScript snippet to render a pie chart</summary>\n\n```html\n<!doctype html>\n<html>\n  <head>\n    <script src=\"https://d3js.org/d3.v7.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"chart\" style=\"width: 800px; height: 600px\"></div>\n\n    <script>\n      async function runDrawD3Chart() {\n        console.log(\"[Test] Booting D3.js Engine...\");\n\n        const width = 800;\n        const height = 600;\n        const margin = 40;\n        const radius = Math.min(width, height) / 2 - margin;\n\n        // Setup the SVG canvas\n        const svg = d3\n          .select(\"#chart\")\n          .append(\"svg\")\n          .attr(\"width\", width)\n          .attr(\"height\", height)\n          // Crucial for ThorVG!\n          .attr(\"xmlns\", \"http://www.w3.org/2000/svg\")\n          .append(\"g\")\n          .attr(\"transform\", `translate(${width / 2},${height / 2})`);\n\n        const data = {\n          \"In Transit\": 45,\n          Delivered: 120,\n          Delayed: 15,\n          Maintenance: 5,\n        };\n\n        // Color scale\n        const color = d3\n          .scaleOrdinal()\n          .domain(Object.keys(data))\n          .range([\"#3b82f6\", \"#22c55e\", \"#ef4444\", \"#f59e0b\"]);\n\n        // the pie slices\n        const pie = d3.pie().value((d) => d[1]);\n        const data_ready = pie(Object.entries(data));\n\n        // Shape generator for the arcs (Donut chart)\n        const arcGenerator = d3\n          .arc()\n          .innerRadius(radius * 0.5) // This makes it a donut!\n          .outerRadius(radius);\n\n        // Build the SVG DOM elements!\n        svg\n          .selectAll(\"path\")\n          .data(data_ready)\n          .join(\"path\")\n          .attr(\"d\", arcGenerator)\n          .attr(\"fill\", (d) => color(d.data[0]))\n          .attr(\"stroke\", \"white\")\n          .style(\"stroke-width\", \"4px\");\n\n        // text labels\n        svg\n          .selectAll(\"text\")\n          .data(data_ready)\n          .join(\"text\")\n          .text((d) => d.data[0])\n          .attr(\"transform\", (d) => `translate(${arcGenerator.centroid(d)})`)\n          .style(\"text-anchor\", \"middle\")\n          .style(\"font-family\", \"sans-serif\")\n          .style(\"font-size\", \"16px\")\n          .style(\"fill\", \"#ffffff\")\n          .style(\"font-weight\", \"bold\");\n\n        // Extract the SVG string\n        const svgElement = document.querySelector(\"#chart svg\");\n        const svgString = svgElement ? svgElement.outerHTML : \"\";\n\n        // Send to Zig Compositor (just the SVG saved as PNG)\n        zexplorer.generateRoutePng(\n          [], // Empty tiles array\n          svgString,\n          \"D3_Chart_report.png\",\n          width,\n          height,\n        );\n\n        console.log(\"🟢 Chart Report generated\");\n      }\n\n      runDrawD3Chart().catch((e) =>\n        console.error(\"Error:\", e.message, e.stack),\n      );\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/images/D3_Chart_report.png\" alt=\"d3 char\" with=\"600\" height=\"400\">\n\n---\n\n### Render Chart.js to PNG\n\nYou can run [Chart.js](https://www.chartjs.org/) server-side and export the result as a PNG file. \n\n❗️ The Chart.js bundle is _pre-built_ with `Bun` and embedded at compile time.\n\n<details><summary>ChartJS example</summary>\n\n```sh\ncd src/examples/zexp-frams && bun run build_chartjs.js\nzig build example -Dname=test_canvas -Doptimize=ReleaseFast\n```\n\nThe HTML file defines the chart configuration and uses the `Chart` constructor:\n\n```html\n<!-- src/examples/test_canvas.html -->\n<html>\n  <body>\n    <script>\n      globalThis.window = globalThis;\n      if (typeof Intl === \"undefined\") {\n        globalThis.Intl = {\n          NumberFormat: function(locale, opts) {\n            return { format: function(n) { return String(n); } };\n          }\n        };\n      }\n      window.devicePixelRatio = 1;\n      window.requestAnimationFrame = (cb) => setTimeout(cb, 0);\n\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = 800;\n      canvas.height = 600;\n      document.body.insertAdjacentElement(\"afterbegin\", canvas);\n\n      async function render() {\n        const config = {\n          type: \"bar\",\n          data: {\n            labels: [\"Zig\", \"Rust\", \"C++\", \"Go\", \"Python\"],\n            datasets: [{\n              label: \"Performance (Imaginary Units)\",\n              data: [150, 145, 140, 120, 80],\n              backgroundColor: [\n                \"rgba(255, 99, 132, 0.8)\", \"rgba(54, 162, 235, 0.8)\",\n                \"rgba(255, 206, 86, 0.8)\", \"rgba(75, 192, 192, 0.8)\",\n                \"rgba(153, 102, 255, 0.8)\",\n              ],\n              borderColor: \"black\",\n              borderWidth: 2,\n            }],\n          },\n          options: {\n            animation: false,  // CRITICAL: disable animation for SSR\n            responsive: false,\n            plugins: {\n              title: { display: true, text: \"Language Speed Test\", font: { size: 30 } },\n            },\n          },\n        };\n\n        new globalThis.Chart(canvas, config);\n\n        // Since animation is false, it renders synchronously!\n        const blob = await canvas.toBlob();\n        return await blob.arrayBuffer();\n      }\n      render();\n    </script>\n  </body>\n</html>\n```\n\nThe Zig runner loads the `Chart.js` bundle, then evaluates the HTML with its inline script:\n\n```zig\nfn chartJS(allocator: std.mem.Allocator, sbx: []const u8) !void {\n    var engine = try ScriptEngine.init(allocator, sbx);\n    defer engine.deinit();\n\n    // Load Chart.js bundle (pre-built IIFE, embedded at compile time)\n\n    const chartjs = @embedFile(\"vendor/chart.js\");\n    const chartjs_val = try engine.eval(chartjs, \"<chartjs>\", .global);\n    engine.ctx.freeValue(chartjs_val);\n\n    // Load the HTML with chart config, extract and run the <script>\n\n    const html = @embedFile(\"test_canvas.html\");\n    try engine.loadHTML(html);\n\n    // access the DOM with Zig\n\n    const body = z.bodyNode(engine.dom.doc);\n    const script_elt = z.getElementByTag(body.?, .script).?;\n    const script = z.textContent_zc(z.elementToNode(script_elt));\n\n    const png_bytes = try engine.evalAsyncAs(allocator, []const u8, script, \"<chart>\");\n    defer allocator.free(png_bytes);\n\n    try std.fs.cwd().writeFile(.{ .sub_path = \"canvas_chartjs.png\", .data = png_bytes });\n}\n```\n\n</details>\n\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/canvas_graphJS_test.png\" alt=\"chartjs example\" width=\"600\" height=\"400\">\n\n---\n\n### Run React bundled code\n\nYou can run bundled JSX code in zexplorer. It is a two-step process.\n\n<details><summary>React code + test</summary>\n\n```js\n\nimport React, { useState, useMemo, useEffect } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nconst Item = ({ value }) => {\n  return <li className=\"item\">Value: <strong>{value}</strong></li>;\n};\n\nconst List = ({ onlyEven }) => {\n  const allNumbers = [1, 2, 3, 4, 5, 6, 7];\n\n  // useMemo ensures we only filter when 'onlyEven' changes\n  const displayedNumbers = useMemo(() => {\n    console.log(`[React] Calculating filter (Even: ${onlyEven})`);\n    if (onlyEven) {\n      return allNumbers.filter(n => n % 2 === 0);\n    }\n    return allNumbers;\n  }, [onlyEven]);\n\n  return (\n    <ul id=\"list-container\">\n      {displayedNumbers.map(n => <Item key={n} value={n} />)}\n    </ul>\n  );\n};\n\nconst App = () => {\n  const [onlyEven, setOnlyEven] = useState(false);\n  const [renderCount, setRenderCount] = useState(1);\n\n  useEffect(() => {\n    console.log(\"[React] 👍 App Mounted\");\n  }, []);\n\n\n  return (\n    <div style={{ padding: 20, fontFamily: 'sans-serif' }}>\n      <h1>Zexplorer Memo Test</h1>\n\n      {/* Control Panel */}\n      <div style={{ marginBottom: 15 }}>\n        <button\n          id=\"btn-toggle\"\n          onClick={() => setOnlyEven(prev => !prev)}\n        >\n          {onlyEven ? \"Show All\" : \"Show Even Only\"}\n        </button>\n\n        <button\n          id=\"btn-force\"\n          onClick={() => setRenderCount(c => c + 1)}\n          style={{ marginLeft: 10 }}\n        >\n          Force Re-render ({renderCount})\n        </button>\n      </div>\n\n      <p>Status: {onlyEven ? \"Filtering Active\" : \"Showing All\"}</p>\n\n      {/* Nested List */}\n      <List onlyEven={onlyEven} />\n    </div>\n  );\n};\n\nconst rootNode = document.getElementById('root');\nif (rootNode) {\n  const root = createRoot(rootNode);\n  root.render(<App />);\n}\n```\n\n```sh\nbun run build_react.js   # produces dist/app.js\nzig build example -Dname=test_react -Doptimize=ReleaseFast\n```\n\nThe test simulates clicks via `dispatchEvent` and verifies that `useMemo` works correctly: filtering triggers a recalculation, but a force re-render does not.\n\n</details>\n\n### Preact with `html` template strings\n\n<details><summary>Preact code + test</summary>\n\n```html\n<html>\n  <body>\n    <h1>Preact Demo - Nested Components Test</h1>\n    <div id=\"root\"></div>\n    <script type=\"module\">\n      import { h, render } from \"preact\";\n      import { useState } from \"preact/hooks\";\n\n      console.log(\"[JS] Preact + Hooks loaded\");\n\n      const root = document.getElementById(\"root\");\n\n      let globalSetCount = null;\n\n      // Nested component: Button with onclick prop\n      const Button = ({ id, children, onClick }) => {\n        console.log(\"[JS] Button component render\");\n        return h(\"button\", { id, onclick: onClick }, children);\n      };\n\n      // Nested component: Counter display\n      const CountDisplay = ({ count }) => {\n        console.log(\"[JS] CountDisplay render, count =\", count);\n        return h(\"p\", { id: \"count-display\" }, `Count: ${count}`);\n      };\n\n      // Parent component with nested children + useState\n      const App = () => {\n        const [count, setCount] = useState(0);\n        globalSetCount = setCount;\n        console.log(\"[JS] App render, count =\", count);\n\n        const handleClick = () => {\n          console.log(\"[JS] onclick prop triggered!\");\n          setCount((c) => c + 1);\n        };\n\n        return h(\n          \"div\",\n          { class: \"app\" },\n          h(\"h1\", null, \"Preact Counter\"),\n          h(CountDisplay, { count }),\n          h(Button, { id: \"increment-btn\", onClick: handleClick }, \"+1\"),\n        );\n      };\n\n      try {\n        render(h(App), root);\n        console.log(\"[JS] Rendered successfully!\");\n        console.log(\"[JS] innerHTML:\", root.innerHTML);\n\n        // Test onclick via dispatchEvent\n        const btn = document.getElementById(\"increment-btn\");\n        if (btn) {\n          console.log(\"[JS] Testing onclick prop...\");\n          for (let i = 0; i < 3; i++) {\n            setTimeout(\n              () => btn.dispatchEvent(new Event(\"click\")),\n              (i + 1) * 100,\n            );\n          }\n          setTimeout(() => {\n            console.log(\n              \"[JS] Final count:\",\n              document.getElementById(\"count-display\")?.textContent,\n            );\n          }, 500);\n        }\n      } catch (e) {\n        console.log(\"[JS] ERROR:\", e.message);\n        console.log(\n          \"[JS] TIP: Run with --release=fast to avoid stack overflow\",\n        );\n      }\n    </script>\n  </body>\n</html>\n\n```\n\n</details>\n\n```sh\n\nzig build example -Dname=test_htm -Doptimize=ReleaseFast\n```\n\n\n### SolidJS templated with `html`\n\n```sh\nzig build example -Dname=test_solidjs --release=fast\n```\n\n<details><summary>SolidJS with createSignal, createEffect, and setInterval</summary>\n\n```html\n<html>\n  <body>\n    <h1>Testing CDN import: SolidJS (Nested Components)</h1>\n    <div id=\"root\"></div>\n    <script type=\"module\">\n      import { createSignal, createEffect, onMount } from \"solid-js\";\n      import { render } from \"solid-js/web\";\n      import html from \"solid-js/html\";\n\n      console.log(\"[JS] SolidJS loaded\");\n      const root = document.getElementById(\"root\");\n\n      // --- Nested Components ---\n      // Note: solid-js/html's dynamicProperty wraps ALL function-valued\n      // component props as reactive getters (calls them on access).\n      // Unlike JSX (where Babel distinguishes signal accessors from\n      // regular functions), html templates treat all functions as\n      // reactive accessors. So we pass event handlers wrapped in an\n      // object to avoid auto-calling.\n\n      const Button = (props) => {\n        const handleClick = () => props.actions.increment();\n        return html`\n          <button type=\"button\" id=\"btn\" onclick=${handleClick}>\n            ${props.children}\n          </button>\n        `;\n      };\n\n      function Counter(props) {\n        createEffect(() => {\n          console.log(\"[JS] Effect: count =\", props.count);\n        });\n\n        return html`\n          <div class=\"counter-app\">\n            <h2>SolidJS Counter (Nested)</h2>\n            <p id=\"count-display\">Count: ${() => props.count}</p>\n            <${Button} actions=${props.actions} children=${\"👍 +1\"} />\n          </div>\n        `;\n      }\n\n      const App = () => {\n        const [localCount, setLocalCount] = createSignal(0);\n        // Wrap handlers in an object so dynamicProperty doesn't\n        // auto-call them (objects are not functions)\n        const actions = { increment: () => setLocalCount((c) => c + 1) };\n\n        onMount(() => {\n          console.log(\"[JS] App mounted\");\n          console.log(\"[JS] initial innerHTML:\", root.innerHTML);\n        });\n\n        return html`<${Counter} count=${localCount} actions=${actions} />`;\n      };\n\n      try {\n        render(() => html`<${App} />`, root);\n        console.log(\"[JS] First render:\", root.innerHTML);\n\n        // Simulate periodic clicks\n        let iterations = 0;\n        const interval = setInterval(() => {\n          iterations++;\n          const btn = document.getElementById(\"btn\");\n          if (btn) {\n            console.log(\"[JS] dispatching click\", iterations);\n            btn.dispatchEvent(new Event(\"click\", { bubbles: true }));\n          }\n          if (iterations >= 3) {\n            clearInterval(interval);\n            console.log(\"[JS] Auto-increment stopped after 3 iterations\");\n            console.log(\n              \"[JS] Final:\",\n              document.getElementById(\"count-display\")?.textContent,\n            );\n          }\n        }, 100);\n      } catch (e) {\n        console.log(\"[JS] SolidJS Error:\", e.message);\n        if (e.stack)\n          console.log(\n            \"[JS] Stack:\",\n            e.stack.split(\"\\n\").slice(0, 5).join(\"\\n\"),\n          );\n      }\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n### Vue with template strings\n\n```sh\nzig build example -Dname=test_vue --release=fast\n```\n\n<details><summary>Vue 3 with ref, template compiler, and dispatchEvent</summary>\n\n```html\n<html>\n  <body>\n    <h1>Testing CDN import: Vue 3 (Template Compiler)</h1>\n    <div id=\"root\"></div>\n    <script type=\"module\">\n      // Vue checks for browser globals during mount\n      if (typeof SVGElement === \"undefined\") {\n        globalThis.SVGElement = class SVGElement {};\n      }\n      if (typeof Element === \"undefined\") {\n        globalThis.Element = class Element {};\n      }\n\n      // import Vue from \"vue\";\n\n      // const { createApp, ref, compile } = Vue;\n      import { createApp, ref, compile } from \"vue\";\n\n      console.log(\"[JS] Vue 3 loaded (template compiler path)\");\n      console.log(\"[JS] createApp:\", typeof createApp);\n      console.log(\"[JS] ref:\", typeof ref);\n\n      // const root = document.getElementById(\"root\");\n\n      const Counter = {\n        setup() {\n          const count = ref(0);\n          const increment = () => {\n            console.log(\"[JS] Button clicked!\");\n            count.value++;\n          };\n          return { count, increment };\n        },\n        template: `\n          <div class=\"counter-app\">\n            <h2>Vue Counter (Template)</h2>\n            <p id=\"count-display\">Count: {{ count }}</p>\n            <button id=\"increment-btn\" @click=\"increment\">+1</button>\n          </div>\n        `,\n      };\n\n      try {\n        // First, manually compile the template to see what the compiler outputs\n        // if (typeof compile === \"function\") {\n        //   const result = compile(Counter.template);\n        //   console.log(\"[JS] Compiled render code:\", result.toString());\n        // } else {\n        //   console.log(\"[JS] compile function not available\");\n        // }\n\n        const app = createApp(Counter);\n        const root = document.getElementById(\"root\");\n\n        app.mount(\"#root\");\n        console.log(\"[JS] First render:\", root.innerHTML);\n        // __flush();\n\n        // simulate periodic clicks\n        let iterations = 0;\n        const interval = setInterval(() => {\n          iterations++;\n          const btn = document.getElementById(\"increment-btn\");\n          if (btn) {\n            btn.dispatchEvent(new Event(\"click\", { bubbles: true }));\n            // __flush();\n          }\n          if (iterations >= 3) {\n            clearInterval(interval);\n            console.log(\"[JS] Auto-increment stopped after 3 iterations\");\n            console.log(\n              \"[JS] Final:\",\n              document.getElementById(\"count-display\")?.textContent,\n            );\n          }\n        }, 100);\n      } catch (e) {\n        console.log(\"[JS] Vue Error:\", e.message);\n        if (e.stack)\n          console.log(\n            \"[JS] Stack:\",\n            e.stack.split(\"\\n\").slice(0, 5).join(\"\\n\"),\n          );\n      }\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n---\n\n## Tests & performance\n\n| Operation            | zexplorer | JSDOM+DOMPurify |\n| -------------------- | --------- | --------------- |\n| Cold start           | 1.5ms     | 30ms            |\n| Sanitize 36kB HTML   | 2.1ms     | 11ms            |\n| Create 10k DOM nodes | 26ms      | 191ms           |\n\n### zexplorer running js-framework-benchmark code\n\nTo ensure the Web primitives are correctly implemented in `zexplorer`, we run code from the [js-vanilla-bench-framework tests](https://github.com/krausest/js-framework-benchmark).\n\nThe examples can be built and run with the commands:\n\n```sh\ncd src/examples\nzig build example -Dname=js-bench-* -Doptimize=ReleaseFast\n```\n\nSource:\n\n- [Vanilla-1-keyed](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/non-keyed/vanillajs-1/src/Main.js)\n- [Vanilla-2-non-keyd](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/non-keyed/vanillajs-3/src/Main.js)\n- [Vanilla-3-k](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/keyed/vanillajs-3/src/Main.js)\n- [bau](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/non-keyed/bau/main.js)\n\n\nRef: browser Vanilla\n\n| Test             | Ref  | [V1-keyd] | [V2-nonKeyd] | [V3-keyd] |     | [bau] |\n| ---------------- | ---- | --------- | ------------ | --------- | --- | ----- |\n| Create 1k        | 22.0 | 3.08      | 1.65         | 1.67      |     | 1.97  |\n| Replace 1k       | 24.4 | 3.03      | 2.46         | 2.73      |     | 1.94  |\n| Partial Up (10k) | 9.5  | 2.82      | 8.86         | 7.92      |     | 5.40  |\n| Select Row       | 2.2  | 0.02      | 0.02         | 0.01      |     | 0.01  |\n| Swap Rows        | 11.7 | 0.05      | 0.09         | 0.11      |     | 0.01  |\n| Remove Row       | 9.2  | 0.01      | 0.05         | 0.05      |     | 0.00  |\n| Create 10k       | 229  | 28.71     | 16.06        | 16.15     |     | 19.03 |\n| Append 1k        | 25.6 | 3.48      | 4.28         | 4.10      |     | 2.06  |\n| Clear            | 9.0  | 4.21      | 6.08         | 5.66      |     | 0.01  |\n| --               | --   | --        | --           | --        | --  | --    |\n| Total Engine     | --   | 78        | 84           | 82        |     | 57    |\n\n**[Lit-html](https://github.com/krausest/js-framework-benchmark/tree/master/frameworks/non-keyed/lit-html)**\n\n| Test                 | Lit-html |\n| -------------------- | -------- |\n| Create 1k            | 16.7 ms  |\n| Replace 1k           | 4.4 ms   |\n| Partial Update (10k) | 28.6 ms  |\n| Select Row           | 25.9 ms  |\n| Swap Rows            | 2.8 ms   |\n| Remove Row           | 3.9 ms   |\n| Create 10k           | 164.6 ms |\n| Append 1k            | 54.1 ms  |\n| Clear                | 13.2 ms  |\n| Total engine (c)     | 597ms    |\n\n(c) CDN import\n\n- [Comp(*) Solid](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/keyed/solid/src/main.jsx)\n- [Temp(**) Solid](https://github.com/ndrean/zexplorer/src/examples/js-bench-solid.js)\n- [Svelte5](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/keyed/svelte/src/App.svelte) (compiled with `svelte/compiler`, bundled with Bun)\n- [Vue3](https://github.com/ndrean/zexplorer/src/examples/js-bench-vue3.js)\n- \n\n| Test             | Ref  | Solid (*) | Solid (**) | Svelte5  | Vue3 (***) |\n| ---------------- | ---- | --------- | ---------- | -------- | ---------- |\n|                  |      | compiled  | templated  | compiled | templated  |\n| ---------------- | ---- | --------  | ---------  | -------- | ---------- |\n| Create 1k        | 22.0 | 18.5      | 16.7       | 26.0     | 54.7       |\n| Replace 1k       | 24.4 | 17.0      | 17.6       | 26.9     | 55.2       |\n| Partial Up (10k) | 9.5  | 7.0       | 138.4      | 8.7      | 205.2      |\n| Select Row       | 2.2  | 3.7       | 127.9      | 3.0      | 199.2      |\n| Swap Rows        | 11.7 | 1.2       | 10.3       | 1.1      | 21.7       |\n| Remove Row       | 9.2  | 0.5       | 10.8       | 0.7      | 20.5       |\n| Create 10k       | 229  | 143.5     | 142.0      | 422.1    | 473.2      |\n| Append 1k        | 25.6 | 16.5      | 173.7      | 22.8     | 245.8      |\n| Clear            | 9.0  | 32.8      | 23.7       | 9.1      | 37.8       |\n| -----            | ---  | --        | --         | --       | --         |\n| Total Engine     | --   | 486       | 1087       | 954      | 2086 (***) |\n\n(*) compiled JSX->JS with `bun`\n\n(**) templated with `html` and using `map` instead of `For`\n\n(***) CDN + templated\n\n**[React familly - vDOM]**\n\n- [React19](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/keyed/react-hooks/src/main.jsx)\n- [Preact](https://github.com/krausest/js-framework-benchmark/blob/master/frameworks/keyed/react-hooks/src/main.jsx) (same source, built with preact/compat)\n\n| Test             | React19^ | Preact^^ |\n| ---------------- | -------- | -------- |\n| Create 1k        | 105.0    | 157.8    |\n| Replace 1k       | 106.2    | 159.1    |\n| Partial Up (10k) | 128.6    | 166.0    |\n| Select Row       | 47.2     | 5.9      |\n| Swap Rows        | 37.1     | 4.9      |\n| Remove Row       | 5.1      | 4.9      |\n| Create 10k       | 3601.9   | 5670.4   |\n| Append 1k        | 154.9    | 121.4    |\n| Clear            | 92.7     | 10.3     |\n| --               | --       | --       |\n| Total Engine     | 8715     | 8255     |\n\n(^) React production build (`process.env.NODE_ENV = \"production\"`)\n\n(^^) Preact/compat production build (same JSX source as React, aliased via build plugin)\n\nSvelte 5's compiled approach generates direct imperative DOM operations (no VDOM), making it the fastest compiled framework on QuickJS — on par with Compiled Solid for 1k operations and significantly faster than React/Preact/Vue. Preact is lighter than React (3KB vs 45KB) but its microtask-scheduled rendering creates more GC pressure at scale. React's fiber architecture pays off for partial updates where its diffing skips unchanged subtrees more efficiently.\n\n### zexplorer vs jsdom\n\nWhile JSDOM emulates more of the many web standards, zexplorer can run Vanilla code, Preact/React code (no JSX, via templating or compiled), Vue (via templating), SolidJS (via templating or compiled), or Svelte 5 (compiled). Check the examples below.\n\nWe present a comparison in performance between `JSDOM` and `zexplorer` on a Vanilla example where build a simple DOM and run querySelectors and populate elements.\n\n<details><summary>JSDOM script</summary>\n\n```js\nconst { JSDOM } = require(\"jsdom\");\nconst { performance } = require(\"perf_hooks\");\n\nconst values = [100, 1000, 10_000, 20_000, 50_000];\n\nconsole.log(\"\\n=== JSDOM Benchmark --------------------------------\\n\");\n\nfor (const nb of values) {\n  const globalStart = performance.now();\n\n  // We enable runScripts so we can execute the test logic inside the context\n  const dom = new JSDOM(`<!DOCTYPE html><body></body>`, {\n    runScripts: \"dangerously\",\n    resources: \"usable\",\n  });\n\n  const { window } = dom;\n\n  window.NB = nb;\n\n  // Benchmark Script\n\n  const scriptContent = `\n    let start = performance.now();\n    const NB = window.NB; // Access injected global\n    console.log(\\`[Internal] Starting DOM creation test with \\${NB} elements\\`);\n    \n    const btn = document.createElement(\"button\");\n    const form = document.createElement(\"form\");\n    form.appendChild(btn);\n    document.body.appendChild(form);\n\n    const mylist = document.createElement(\"ul\");\n\n    for (let i = 1; i <= NB; i++) {\n      const item = document.createElement(\"li\");\n      item.textContent = \"Item \" + i * 10;\n      item.setAttribute(\"id\", i.toString());\n      mylist.appendChild(item);\n    }\n    document.body.appendChild(mylist);\n\n    const lis = document.querySelectorAll(\"li\");\n    \n    let clickCount = 0;\n        \n    btn.addEventListener(\"click\", () => {\n      clickCount++;\n      btn.textContent = \\`Clicked \\${clickCount}\\`;\n    });\n\n    const clickEvent = new window.Event(\"click\");\n    for (let i = 0; i < NB; i++) {\n      btn.dispatchEvent(clickEvent);\n    }\n\n    let time = performance.now() - start;\n\n    console.log(\n      JSON.stringify({\n        time: time.toFixed(2),\n        elementCount: lis.length,\n        last_li_id: lis[lis.length - 1].getAttribute(\"id\"),\n        last_li_text: lis[lis.length - 1].textContent,\n        success: clickCount === NB,\n      })\n    );\n  `;\n\n  console.log(`[Node] Running with NB=${nb}`);\n  window.eval(scriptContent);\n\n  const globalEnd = performance.now();\n  const totalMs = (globalEnd - globalStart).toFixed(2);\n\n  console.log(`⚡️ JSDOM Total Time: ${totalMs}ms\\n`);\n\n  window.close();\n}\n```\n\n</details>\n\n<details><summary>Zexplorer script:</summary>\n\n```zig\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\nconst ScriptEngine = z.ScriptEngine;\n\npub fn main() !void {\n    var debug_allocator: std.heap.DebugAllocator(.{}) = .init;\n    const gpa, const is_debug = gpa: {\n        break :gpa switch (builtin.mode) {\n            .Debug, .ReleaseSafe => .{ debug_allocator.allocator(), true },\n            .ReleaseFast, .ReleaseSmall => .{ std.heap.c_allocator, false },\n        };\n    };\n    defer if (is_debug) {\n        _ = debug_allocator.deinit();\n    };\n\n    const sandbox_root = try std.fs.cwd().realpathAlloc(gpa, \".\");\n    defer gpa.free(sandbox_root);\n\n    try bench(gpa, sandbox_root);\n}\n\nfn bench(allocator: std.mem.Allocator, sbx: []const u8) !void {\n    z.print(\"\\n=== JS-simple-bench --------------------------------\\n\\n\", .{});\n\n    const values = [_]u32{ 100, 1000, 10000, 20000, 50000 };\n\n    for (values) |v| {\n        z.print(\"[Zig]-> Running with NB={d}\\n\", .{v});\n        const start = std.time.nanoTimestamp();\n        var engine = try ScriptEngine.init(allocator, sbx);\n\n        const js =\n            \\\\ let start = performance.now();\n            \\\\ console.log(`Starting DOM creation test with {d} elements`);\n            \\\\ const btn = document.createElement(\"button\");\n            \\\\ const form = document.createElement(\"form\");\n            \\\\ form.appendChild(btn);\n            \\\\ document.body.appendChild(form);\n            \\\\ const mylist = document.createElement(\"ul\");\n            \\\\ for (let i = 1; i <= parseInt({d}); i++) {{\n            \\\\   const item = document.createElement(\"li\");\n            \\\\   item.textContent = \"Item \" + i * 10;\n            \\\\   item.setAttribute(\"id\", i.toString());\n            \\\\   mylist.appendChild(item);\n            \\\\ }}\n            \\\\ document.body.appendChild(mylist);\n            \\\\\n            // \\\\ let time = performance.now() - start;\n            \\\\\n            \\\\ const lis = document.querySelectorAll(\"li\");\n            \\\\ console.log(lis.length);\n            \\\\\n            // \\\\ start = performance.now();\n            \\\\ let clickCount = 0;\n            \\\\ btn.addEventListener(\"click\", () => {{\n            \\\\  clickCount++;\n            \\\\  btn.textContent = `Clicked ${{clickCount}}`;\n            \\\\ }});\n            \\\\\n            \\\\ // Simulate clicks\n            \\\\ for (let i = 0; i < parseInt({d}); i++) {{\n            \\\\   btn.dispatchEvent(\"click\");\n            \\\\ }}\n            \\\\\n            \\\\ const time = performance.now() - start;\n            \\\\\n            \\\\ console.log(\n            \\\\   JSON.stringify({{\n            \\\\     time: time.toFixed(2),\n            \\\\     elementCount: lis.length,\n            \\\\     last_li_id: lis[lis.length - 1].getAttribute(\"id\"),\n            \\\\     last_li_text: lis[lis.length - 1].textContent,\n            \\\\     success: clickCount === parseInt({d}),\n            \\\\   }}),\n            \\\\ );\n        ;\n\n        const script = try std.fmt.allocPrint(allocator, js, .{ v, v, v, v });\n        defer allocator.free(script);\n        const body = try std.fmt.allocPrint(allocator, \"<body><script>{s}</script></body>\", .{script});\n        // z.print(\"{s}\\n\", .{body});\n        defer allocator.free(body);\n        try engine.loadHTML(body);\n\n        try engine.executeScripts(allocator, \".\");\n\n        const end = std.time.nanoTimestamp();\n        const ms = @as(f64, @floatFromInt(end - start)) / 1_000_000.0;\n        std.debug.print(\"\\n⚡️ Zexplorer Engine Total Time: {d:.2}ms\\n\\n\", .{ms});\n\n        engine.deinit();\n    }\n}\n```\n\n</details>\n\n**Results**\n\nThe start time of the engine is approx 1.5ms (difference between the engine setup & loop execution and the JavaScript execution, as measured by `performance()` ).\n\n| #rows  | JS/Zexplorer | Total/Zexplorer | JS/JSDom | Total/JSDom |\n| ------ | ------------ | --------------- | -------- | ----------- |\n| 100    | 0.29 ms      | 1.86 ms         | 9.81 ms  | 36.72 ms    |\n| 1_000  | 2.42 ms      | 3.77 ms         | 27.9 ms  | 32.90 ms    |\n| 10_000 | 24.83 ms     | 26.24 ms        | 191.1 ms | 197.9 ms    |\n| 20_000 | 49.11 ms     | 50.50 ms        | 315.4 ms | 318.9 ms    |\n| 50_000 | 125.28 ms    | 126.58 ms       | 741.4 ms | 745.5 ms    |\n\nThe DOM operations are externalized from the JavaScript runtime and these results demonstrate this clearly.\n\n---\n\n### Tests Zaniter module\n\nThe goal is to be as performant as [DOMPurify](https://github.com/cure53/DOMPurify) in terms of sanitization. It's a DOM-level sanitizer, not a string filter. It performs the sanitization in context, meaning  DOM and CSS aware, so retains the structure. It can allow framework attributes.\n\nThis is a two phase process. We firstly parse the input into a real DocumentFragment. It walks the tree DOM and attributes, URIs and CSS (parsed & sanitized). It applies whitelist and [html_specs rules](https://github.com/ndrean/zexplorer/blob/main/src/modules/html_specs.zig) marks the node or attributes for removal or update (sanitized attributes) and processes templates separately. It then applies the collected changes once the walk completes.\n\nThere are settings for the sanitizer (remove comments, remove/keep `<script>`, `<style>`, custom elements, allow framework attributes, embedded media with attributes in context...). Preset built-in modes are proposed but can be customized per run \n\n**TODO**: CL-args to run sanitization only with args\n\n#### Quality test\n\nIt is tested against collected tests from:\n\n- DOMPurify test suite: <https://github.com/cure53/DOMPurify/tree/main/test>\n- OWASP XSS Filter Evasion Cheat Sheet: <https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html>\n- PortSwigger XSS cheat sheet: <https://portswigger.net/web-security/cross-site-scripting/cheat-sheet>\n- DOMPurify CVEs: Especially CVE-2024-47875 (mXSS via nesting) <https://github.com/cure53/DOMPurify>\n\nTests:\n\n- 139 real-world XSS attack vectors from [html5sec.org](https://html5sec.org/) with output in <https://github.com/ndrean/zexplorer/blob/main/src/examples/h5sc-test_output.html>\n- sanitization of the \"dirty\" HTML:  <https://cure53.de/purify> in <https://github.com/ndrean/zexplorer/blob/main/src/examples/dom_purify.zig>\n- tests in [Zanitizer module](https://github.com/ndrean/zexplorer/blob/main/src/modules/sanitizer.zig) and [Zanitizer-css module](https://github.com/ndrean/zexplorer/blob/main/src/modules/sanitizer_css.zig)\n\n```sh\nzig build test\nzig build example -Dname=h5sc-test -Doptimize=ReleaseFast\nzig build example -Dname=dom_purify -Doptimize=ReleaseFast\n```\n\n#### Speed test against JSDOM\n\n```sh\nzig build example -Dname=dom_purify -Doptimize=ReleaseFast\n```\n\n```txt\n=== DOMPurify Benchmark -------\n\nInput size: 36526 bytes\nOutput size: 16501 bytes\nTotal Engine time: 1.052 ms\n\nDOMPurify reference: ~11 ms\n(without JSDom overhead)\n```\n\n---\n\n## Features by example\n\n**TODO**: link each to a src/example/*.\n\nList of implemented server and Web API and examples\n\n- async Timers: `setTimeout`, `setInterval`\n- EventLoop.\n- `Event`: with bubbling\n- `Worker` (OS thread). With `onmessage` (`data`) , `postMessage`, `terminate`,  \n- `URL`, `URLPattern`, `URLSearchParams`. With `url.createObjectURL(blob)` and `url.revokeObjectURL`. TODO: check what is missing. `\n- `Blob`: `arrayBuffer`, `text`. With `size` and `type`. TODO `slice`, `bytes` (promise -> Unit8Array)\n- `HTMLCanvasElement`  with `width`, `height`, `canvas`, `fillStyle` and `font`. Drawing methods `drawImage`, `beginPath`, `closePath`, `moveTo`, `stroke`, `strokeStyle`, `lineWidth`, `fillText`, `fillRect`, `scale`, `translate`, `measureText`, `save`, `restore`, `arc`. Methods `getContext`, `getPngData`, `getJpegData`, `toDataURL()`, `toBlob()` (promise based but support for callback based), support image PNG/JPEG via `stb_image_write`.\n- `HTMLImageElement` : via `createImageBitmap`, to add property `src` to be able to do : `image.src = URL.createObjectURL(blob)`\n- `File`, inherits from `Blob`,with `size`, `path`, `lastModified`, `name`; `fromPath()`.\n- `FileList` with `length` and `item()`.\n- `FormData` with `append`, `serializeFormData` for Fetch/multi-part. TODO (?) `delete`, `entries`,\n- `fetch` API (async `CurlMulti`), with `Headers` and `body` (-> `ReadableStream` via OS thread), `status`, `url`. `Response` methods `text()`, `json()`, `arrayBuffer()`, `blob()`. TODO ? `Request`.\n- `fs`: sandboxed file system with: `readFile`, `readFileBuffer`, `writeFile`, `appendFile`, `stat`, `exists`, `readDir`, `mkdir`, `rm`, `copyFile`, `rename`, `fileFromPath`, `createReadStream`, `createWriteStream`.\n- `ReadableStream` (via `fs` and Worker thread, not event I/O): `read`, `releaseLock`, `cancel`.\n- `WritableStream` (via `fs` and Worker thread, not event I/O): \n- async `FileReader` (Worker based): `readAsText`, `readAsArrayBuffer`, `'readAsDataURL`\n- `FileReaderSync`: `readAsArrayBuffer`,  `readAsText`,  `readAsDataURL`,\n- `DocumentFragment` and `Template`.\n- `CSSStyleDeclaration`, with `style`, `window.getComputedStyle`, `setProperty`, `getPropertyValue`\n- `Classlist` and `DomTokenList` with `add`, `remove`, `contains`, `toggle`, `replace`, `item`, `toString`.\n- `Dataset` and `DOMStringMap`.\n- `console`\n- `Range` with `setStartBefore`, `setEndAfter`, `deleteContents`. **TODO**  `window.getSelection()`, `selection.addRange()`\n- `DOMParser` with `parseFromString()`.\n- `Canvas` and `Image`\n- `addEventListener`, `dispatchEventListener`, `removeEventListener`, `reportResult` (helper->Zig)\n- `querySelector(All)`, `matches`, `getElementById`, `getElementByTagName`, `childNodes`, `children`, `append`, `prepend`, `before`, `after`, `insertAdjacentHTML`, `insertAdjacentElement`, `replaceWith`, `replaceChildren`,\n- `TreeWalker`,\n- DOM: `document` with createElement|comment|header|TextNode, `parseHTML`, siblings, etc\n- `Sanitizer`. (`setHTML` or parseHTMLUnsafe to be aliased?)\n- log and printing helpers: `prettyPrint`, `printDoc`, `printDocStruct`, `saveDOM` (to file).\n\n- `crypto.getRandomValues` via Zig `std.crypto.random`\n- `localStorage` (`getItem`, `setItem`, `removeItem`, `clear`) backed by a Zig HashMap\n- TODO: `alert`, `prompt`, `confirm` : implement dumb versions\n\n\n\n> [!IMPORTANT] \n > Use `ReleaseFast` as debug mode causes Maximum call stack size exceeded\n\n### Other examples\n\n#### Canvas layering\n\n1) We use a canvas compositor process: we load a static base image (PNG/JPEG/WEBP/SVG) into a Canvas, and programmatically draw text over using `fillText()`, `measureText()`... functions powered by `stb_truetype`. It comes with the `Arial` font preloaded. The ouput is printed into a file.\nThe use this [SVG source](https://github.com/ndrean/zexplorer/blob/main/test_opengraph_me.svg).\n\n<details><summary>JS script and Zig runner</summary>\n\n```js\n// src/examples/test_svg_read_render.js\n\nasync function renderTemplate(svgText, data) {\n  const blob = new Blob([svgText], { type: \"image/svg+xml\" });\n  const img = await createImageBitmap(blob);\n\n  const w = data.width || 1200;\n  const h = data.height || 630;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = w;\n  canvas.height = h;\n  const ctx = canvas.getContext(\"2d\");\n\n  // White background fallback\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(0, 0, w, h);\n\n  // Draw the SVG template as background (scaled to fill)\n  ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, w, h);\n\n  // -- Overlay dynamic text --\n\n  // Title (large, prominent)\n  if (data.title) {\n    ctx.fillStyle = data.titleColor || \"blue\";\n    ctx.font = data.titleFont || \"bold 48px\";\n    ctx.fillText(data.title, 60, 60);\n  }\n\n  // Footer (bottom-left)\n  if (data.footer) {\n    ctx.fillStyle = data.footerColor || \"#f11c75\";\n    ctx.font = data.footerFont || \"18px\";\n    ctx.fillText(data.footer, 60, h - 40);\n  }\n\n  // -- return data to Zig --\n\n  const result = await canvas.toBlob();\n  return await result.arrayBuffer();\n}\n```\n\n```zig\n// src/examples/test_svg_raster.zig\n\nfn testSvgTemplateFromJS(allocator: std.mem.Allocator, sbr: []const u8) !void {\n    var engine = try ScriptEngine.init(allocator, sbr);\n    defer engine.deinit();\n\n    const js = @embedFile(\"test_svg_template_render.js\");\n\n    const val = try engine.eval(js, \"<template-init>\", .global);\n    defer engine.ctx.freeValue(val);\n\n    const scope = z.wrapper.Context.GlobalScope.init(engine.ctx);\n    defer scope.deinit();\n\n    try scope.setString(\"TEMPLATE_SVG\", opengraph_svg);\n\n    // Build and inject the data object\n    const data = scope.newObject();\n    try engine.ctx.setPropertyStr(data, \"title\", scope.newString(\"Built by Zexplorer\"));\n\n    try engine.ctx.setPropertyStr(data, \"footer\", scope.newString(\"Built with Zig, nanosvg, stb_truetype & QuickJS\"));\n    try scope.set(\"TEMPLATE_DATA\", data);\n\n    const png_bytes = try engine.evalAsyncAs(\n        allocator,\n        []const u8,\n        \"renderTemplate(TEMPLATE_SVG, TEMPLATE_DATA)\",\n        \"<svg-template>\",\n    );\n    defer allocator.free(png_bytes);\n\n    try js_canvas.verifyPngStructure(png_bytes);\n    try std.fs.cwd().writeFile(\n        .{\n            .sub_path = \"svg_template_opengraph.png\",\n            .data = png_bytes,\n        },\n    );\n    std.debug.print(\"  [8] Saved 'svg_template_opengraph.png' ({d} bytes) — SVG template + dynamic text\\n\", .{png_bytes.len});\n}\n```\n\n</details>\n\nThe result is:\n\n<img src=\"https://github.com/ndrean/zexplorer/blob/main/svg_template_opengraph.png\" alt=\"SVG via Blob + createImageBitmap\" width=\"600\" height=\"300\">\n\n---\n\n\n<details><summary>Upload a file: POST a Blob</summary>\n\nCreate a filetext blob and append it to a formData object and upload to the test endpoint `httpbin` (it returns the data it received).\n\n```js\nconst formData = new FormData();\nconst blob = new Blob([\"Hello form data!\"], { type: \"text/plain\" });\nformData.append(\"file\", blob, \"hello.txt\");\n\nconsole.log(\"Sending POST...\");\n\nfetch('https://httpbin.org/post', {\n    method: 'POST',\n   body: formData\n})\n.then(res => res.json())\n.then(data => {\n    console.log(\"🟢 Server received:\", data);\n})\n.catch(err => console.log(\"🔴 Error:\", err));\n```\n\n```zig\nfn uploadFile(allocator: std.mem.Allocator, sbx: []const u8) !void {\n    var engine = try ScriptEngine.init(allocator, sbx);\n    defer engine.deinit();\n\n    const script = readFile(\"js/test_send_post.js\");\n    defer allocator.free(script);\n\n    const res = try engine.eval(script, \"<fetch>\", .module);\n    engine.ctx.freeValue(res);\n    try engine.run();\n}\n```\n\nThe output in the terminal is:\n\n```txt\n🟢 Server received: {\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"file\": \"Hello form data!\"\n  },\n  \"form\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Content-Length\": \"205\",\n    \"Content-Type\": \"multipart/form-data; boundary=----ZigQuickJSBoundary1769609637330069000\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"zig-curl/0.3.2\",\n    \"X-Amzn-Trace-Id\": \"Root=1-697a19a5-3c4d5687799f935028ffcfeb\"\n  },\n  \"json\": null,\n  \"origin\": \"90.93.234.63\",\n  \"url\": \"https://httpbin.org/post\"\n}\n```\n\n</details>\n\n---\n\n<details><summary>CSS in JS using source files</summary>\n\nFile: _/js/js-and-css/style.css_\n\n```css\n\n#pid {\n  color: green;\n  font-size: 20px;\n}\n```\n\nFile: _/js/js-and-css/main.js_\n\n```js\nconst changeText = () =>{\n  const p = document.getElementById(\"pid\");\n  p.textContent = \"New text\";\n}\n\nconst btn = document.querySelector(\"button\");\nbtn.addEventListener(\"click\", () => {\n  changeText();\n  const p = document.getElementById(\"pid\");\n  const p_color = p.style.getProperyValue(\"color\");\n  const p_font_size = window.getComputedStyle(p).getPropertyValue(\"font-size\");\n  console.log(\"[JS] 'p' properties: \", p_color, p_font_size);\n  console.log(\"[JS] 'p' textContent: \", p.textContent);\n});\n\nbtn.dispatchEvent(new Event(\"click\")  );\n```\n\nFile: _/js/js-and-css/index.html_\n\n```html\n<!-- js/js-and-css/index.html -->\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n  </head>\n <body>\n  <p id=\"pid\">Some text</p>\n  <form>\n    <button type=\"button\">Change text</button>\n  </form>\n  <script type=\"module\" src=\"main.js\"></script>\n</body>\n</html>\n```\n\nThe following `Zig` code runs successfully:\n\n```zig\nfn css_js_external_file(allocator: std.mem.Allocator, sandbox_root: []const u8) !void {\n  const engine = try ScriptEngine.init(allocator, sandbox_root);\n  defer engine.deinit();\n\n  try engine.loadHTML(html);\n  try engine.loadExternalStylesheets(\"js/js-and-css/\");\n  try engine.executeScripts(allocator, \"js/js-and-css\");\n  try engine.run();\n\n  const p_el = z.getElementById(bridge.doc, \"pid\").?;\n  const computed_color = try z.getComputedStyle(allocator, p_el, \"color\");\n  const computed_font_size = try z.getComputedStyle(allocator, p_el, \"font-size\");\n  defer if (computed_color) |c| allocator.free(c);\n  defer if (computed_font_size) |c| allocator.free(c);\n\n\n  z.print(\"[Zig] p_color: {s}, p_font_size: {s}\\n\", .{ computed_color.?, computed_font_size.? });\n\n  try z.printDoc(allocator, engine.dom.doc, \"link-stylesheet and Script with 'external' file\");\n}\n```\n\nIn the terminal:\n\n```txt\n[JS] 'p' properties: green, 20px\n[JS] 'p' textContent: New text\n[Zig] p_color: green, p_font_size: 20px\n\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <title>\n      \"link-stylesheet and Script with 'external' file\"\n    </title>\n  </head>\n  <body>\n    <p id=\"pid\">\n      \"New text\"\n    </p>\n    <form>\n      <button type=\"button\">\n        \"Change text\"\n      </button>\n    </form>\n    <script type=\"module\" src=\"main.js\">\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n---\n\n## Zig to JS intercomm and native function injection in JS\n\nTODO\n\nYou can send p from Zig to JS and receive typed data from JS to Zig.\n\nYou can use native Zig functions in JS\n\n## State of the DOM API integration\n  \n- **Event Loop**. Native Zig thread-safe loop handling Timers (microtasks) and  Promises (macrotasks).\n- **Worker pool**: OS-threaded with message passing and library import support for CPU-intensive tasks (eg CSV parsing); inject Zig functions into JS code.\n- **EventListeners** (add, remove, dispatch) and _bubbling_ supported.\n- **ES6 Module System**: Load external, third-party libraries (es-toolkit) from disk, resolving paths, handling extensions, and executing them natively.\n- **CSSOM**: _inline_ CSS-inJS and _StyleSheet_ support. [WIP] The 500+ CSS properties (`Object.keys(document.body.style).filter(k => !k.startsWith('webkit'))`). Currently,  functional accessors: `Element.getPropertyValue()` and `Element.setProperty()` and `getComputedStyles()`.\n- Templating support.\n- **DOM Sanitizer**. Handles templates. To become closer to `DOMPurify`, [TODO] Missing full support of SVG sanitization and only basic CSS sanitization.\n- `fetch` API (via libCurl Multi).\n- Binary Interop: Zero-copy passing of ArrayBuffers and efficient Tuples.\n- **Security: RCE**. Sandboxing.\n\n**Expectations**:\n\n- instant start, low footprint\n- No JIT Compilation: QuickJS compiles JS to bytecode. Very performant for one-shot, short-lived scripts, cold starts.\n- For long-lived scripts, CPU intensive, loop heavy ➡ Move hot paths to `Zig`: embed native Zig functions for this! (data processing, CSV parsing, batch and send to Zig...)\n\n## Limitations\n\nNo AsyncIO, no WebSocket, no planned WASM support.\n  \n## A few JS examples\n\n<details><summary>Import CSS</summary>\n\n```zig\nfn additional_stylesheet_style_tag(allocator: std.mem.Allocator) !void {\n    const html =\n        \\\\<html>\n        \\\\  <head>\n        \\\\    <style>\n        \\\\      #pid {  color: green;  font-size: 20px; }\n        \\\\    </style>\n        \\\\  </head>\n        \\\\  <body>\n        \\\\      <p id=\"pid\">Some text</p>\n        \\\\      <form>\n        \\\\          <button type=\"button\">Change text</button>\n        \\\\      </form>\n        \\\\  </body>\n        \\\\</html>\n    ;\n\n    const css =\n        \\\\#pid {\n        \\\\  color: red;\n        \\\\  font-size: 30px;\n        \\\\}\n    ;\n\n    const js =\n        \\\\function changeText() {\n        \\\\  const p = document.getElementById(\"pid\")\n        \\\\  p.textContent = \"New text\"\n        \\\\}\n        \\\\const btn = document.querySelector(\"button\");\n        \\\\btn.addEventListener(\"click\", () => {\n        \\\\  changeText();\n        \\\\});\n        \\\\\n        \\\\ btn.dispatchEvent(new Event('click'), (e) => {\n        \\\\  console.log(\"Button clicked\");\n        \\\\});\n    ;\n\n    const engine = try ScriptEngine.init(allocator);\n    defer engine.deinit();\n\n    const bridge = engine.dom;\n\n    try engine.loadHTML(html);\n    try z.parseStylesheet(bridge.stylesheet, bridge.css_style_parser, css);\n    try z.attachStylesheet(bridge.doc, bridge.stylesheet);\n\n    const val = try engine.eval(js, \"style_test.js\");\n    defer engine.ctx.freeValue(val);\n\n    const p_el = z.getElementById(bridge.doc, \"pid\").?;\n\n    const computed_color = try z.getComputedStyle(allocator, p_el, \"color\");\n    const computed_font_size = try z.getComputedStyle(allocator, p_el, \"font-size\");\n    defer if (computed_color) |c| allocator.free(c);\n    defer if (computed_font_size) |c| allocator.free(c);\n\n    try std.testing.expectEqualStrings(\"red\", computed_color.?);\n    try std.testing.expectEqualStrings(\"30px\", computed_font_size.?);\n    try std.testing.expectEqualStrings(\"New text\", z.textContent_zc(z.elementToNode(p_el)));\n\n    try z.prettyPrint(allocator, z.bodyNode(engine.dom.doc).?);\n}\n```\n\n</details>\n\n---\n\n<details><summary>Use Reactive DOM primitives in async JavaScript code executed by Zig</summary>\n\n```js\nconst btn = document.createElement(\"button\");\nconst form = document.createElement(\"form\");\nform.appendChild(btn);\ndocument.body.appendChild(form);\n\nconst mylist = document.createElement(\"ul\");\nfor (let i = 1; i < 3; i++) {\n  const item = document.createElement(\"li\");\n  item.setContentAsText(\"Item \" + i * 10);\n  item.setAttribute(\"id\", i);\n  mylist.appendChild(item);\n}\ndocument.body.appendChild(mylist);\nconsole.log(\"[JS] Initial document\", document.body.innerHTML);\n\n// DOM Event Listener with Delayed action with Timer\n\nform.addEventListener(\"submit\", (e) => {\n  e.preventDefault(); // Prevent actual form submission\n  console.log(\"[JS] ⌛️ 📝 Form Submitted! Event Type:\", e.type);\n});\n\nconsole.log(\"[JS] Submit the form! ⏳\");\nsetTimeout(() => {\n  form.dispatchEvent(\"submit\");\n  console.log(\"[JS] Final HTML: \", document.body.innerHTML);\n}, 1000);\n\n// Simple reactive object\n\nfunction createReactiveObject(target, callback) {\n  return new Proxy(target, {\n    set(obj, prop, value) {\n      const oldValue = obj[prop];\n      obj[prop] = value;\n\n      // Trigger callback on change\n      if (oldValue !== value) {\n        const prop_id = prop === \"name\" ? \"#1\" : prop === \"age\" ? \"#2\" : null;\n        document.querySelector(prop_id).setContentAsText(value); // Normal DOM update\n        callback(prop, oldValue, value);\n      }\n\n      return true;\n    },\n\n    get(obj, prop) {\n      return obj[prop];\n    },\n  });\n}\n\n// Instantiate the data and update the DOM\nconst data = { name: \"John\", age: 30 };\ndocument.querySelector(\"#1\").setContentAsText(data.name);\ndocument.querySelector(\"#2\").setContentAsText(data.age);\nconsole.log(\"[JS] Direct DOM update: \", document.body.innerHTML);\n\n// Reactive function\nconst reactiveData = createReactiveObject(data, (prop, oldVal, newVal) => {\n  console.log(\"[JS] reaction:\", document.body.innerHTML);\n});\n\n// 1. First reaction via property change\nreactiveData.name = \"Jane\";\n\n// Second reaction trigger via Event Listener to change age\nbtn.addEventListener(\"click\", (e) => {\n  console.log(\"[JS] ⚡️ Button Clicked! Event Type:\", e.type);\n  reactiveData.age *= 2;\n});\n\nconsole.log(\"[JS] Click the button! ✅\");\nbtn.dispatchEvent(\"click\");\n```\n\nThe output:\n\n```txt\n[JS] Initial document <form><button></button></form><ul><li id=\"1\">Item 10</li><li id=\"2\">Item 20</li></ul>\n\n[JS] Direct DOM injection:  <form><button></button></form><ul><li id=\"1\">John</li><li id=\"2\">30</li></ul>\n\n[JS] Reaction: change 'name' <form><button></button></form><ul><li id=\"1\">Jane</li><li id=\"2\">30</li></ul>\n\n[JS] Click the button! ✅\n[JS] ⚡️ Button Clicked! Event Type: click\n[JS] Reaction: change 'age' <form><button></button></form><ul><li id=\"1\">Jane</li><li id=\"2\">60</li></ul>\n\n[JS] Submit the form! ⏳\n[JS] ⌛️ 📝 Form Submitted! Event Type: submit\n[JS] Final HTML:  <form><button></button></form><ul><li id=\"1\">Jane</li><li id=\"2\">60</li></ul>\n\n[Zig-serialized-DOM-string]\n<html>\n  <head>\n  </head>\n  <body>\n    <form>\n      <button>\n      </button>\n    </form>\n    <ul>\n      <li id=\"1\">\n        \"Jane\"\n      </li>\n      <li id=\"2\">\n        \"60\"\n      </li>\n    </ul>\n  </body>\n</html>\n```\n\nAnd the Zig code to run this snippet:\n\n```zig\n    const engine = try ScriptEngine.init(allocator);\n    defer engine.deinit();\n\n    const source = try std.fs.cwd().readFileAlloc(allocator, \"js/dom_event_listener.js\", 1024);\n    defer allocator.free(source);\n\n    const c_source = try allocator.dupeZ(u8, source);\n    defer allocator.free(c_source);\n\n    const val = try engine.evalModule(c_source, \"dom_event_listener.js\");\n\n    engine.ctx.freeValue(val);\n\n    // Run Main Loop (Handles Events)\n    try engine.run();\n\n    const body_node = z.documentRoot(engine.dom.doc);\n    try z.prettyPrint(allocator, body_node.?);\n```\n\n</details>\n\n<details><summary>Import JavaScript libraries: es-toolkit</summary>\n\nDownload the `es-toolkit` library:\n\n```sh\n curl -L https://cdn.jsdelivr.net/npm/es-toolkit@1.43.0/+esm  -o es-toolkit.min.js\n```\n\nThe JavaScript module _js/import_test.js_:\n\n```js\nimport * as Module from \"js/vendor/es-toolkit.min.js\";\n\nconsole.log(\"\\n[JS] 🚀 Testing external library: es-toolkit\\n\");\nconsole.log(\n  \"\\nimport ESM module: https://cdn.jsdelivr.net/npm/es-toolkit@1.43.0/+esm \\n\"\n);\nconsole.log(Object.keys(Module).join(\", \"));\nconsole.log(\"\\n\");\n\n// 1. Test 'mean' function\nconst numbers = [10, 50, 5, 100, 2];\nconst m = Module.mean(numbers);\nconsole.log(`[JS] ✅ Mean value is: ${m}\\n`);\n\n// 2. Test 'chunk' function\nconst list = [1, 2, 3, 4, 5, 6];\nconst chunks = Module.chunk(list, 2);\nconsole.log(`[JS] ✅ Chunked array: ${JSON.stringify(chunks)}`);\n// Should be [[1,2], [3,4], [5,6]]\n```\n\nThe output is:\n\n```txt\n[JS] 🚀 Testing external library: es-toolkit\n\n\nimport ESM module: https://cdn.jsdelivr.net/npm/es-toolkit@1.43.0/+esm\n\nAbortError, Mutex, Semaphore, TimeoutError, after, ary, ... zip, zipObject, zipWith\n\n\n[JS] ✅ Mean value is: 33.4\n\n[JS] ✅ Chunked array: [[1,2],[3,4],[5,6]]\n-----------------------------------------\n```\n\nThe Zig code to run this:\n\n```zig\nfn importModule(allocator: std.mem.Allocator) !void {\n    const engine = try ScriptEngine.init(allocator);\n    defer engine.deinit();\n\n    const source = std.fs.cwd().readFileAlloc(\n        allocator,\n        \"js/import_test.js\",\n        1024 * 1024,\n    ) catch |err| {\n        z.print(\"Error: Could not  find 'js/import_test.js'\\n\", .{});\n        return err;\n    };\n\n    defer allocator.free(source);\n\n    const c_source = try allocator.dupeZ(u8, source);\n    defer allocator.free(c_source);\n\n    // 2. Evaluate as Module\n    // Our loader will see 'import ... from \"js/vendor/es-toolkit.min.js\"'\n    // and automatically load that file too.\n    const val = try engine.evalModule(c_source, \"import_test.js\");\n    defer engine.ctx.freeValue(val);\n\n    // Imports are resolved asynchronously\n    try engine.run();\n}\n```\n\n</details>\n\n<details><summary>Worker</summary>\n\n```mermaid\nsequenceDiagram\n    participant MainJS as Main JS\n    participant MainZig as Zig (Main)\n    participant WorkerZig as Zig (Worker)\n    participant WorkerJS as Worker JS\n\n    Note over MainJS, WorkerJS: 1. Main sends message (Action)\n    MainJS->>MainZig: worker.postMessage(\"hello\")\n    Note right of MainJS: Calls C function js_Worker_postMessage\n    MainZig->>WorkerZig: Mailbox Send\n\n    Note over MainJS, WorkerJS: 2. Worker receives message (Reaction)\n    WorkerZig->>WorkerZig: Loop detects message\n    WorkerZig->>WorkerJS: CALLS global.onmessage(\"hello\")\n    Note right of WorkerZig: Looks up property \"onmessage\"\n```\n\n</details>\n\n\n### Examples using Zig\n\n<details><summary>Example: Create document and parse</summary>\n\nYou have a few methods available.\n\n1. You  create a document with `createDocument()` and populate it with `insertHTML(doc, html)`\n2. The `parseHTML(allocator, \"\")` creates a `<head>` and a `<body>` element and replaces BODY innerContent with the nodes created by the parsing of the given string.\n3. The engine `doc  = DOMParser.parseFromString()`\n\n```zig\nconst z = @import(\"zexplorer\");\nconst allocator = std.testing.allocator;\n\nconst doc: *HTMLDocument = try z.createDocument();\ndefer z.destroyDocument(doc);\n\ntry z.insertHTML(doc, \"<div></div>\");\nconst body: *DomNode = z.bodyNode(doc).?;\n\n// you can create programmatically and append elements to a node\nconst p: *HTMLElement = try z.createElement(doc, \"p\");\nz.appendChild(body, z.elementToNode(p));\n```\n\nYour document now contains this HTML:\n\n```html\n<head></head>\n<body>\n  <div></div>\n  <p></p>\n</body>\n```\n\n</details>\n\n---\n\n<details><summary>Example: scrap the web and explore a page</summary>\n\n```zig\ntest \"scrap example.com\" {\n  const allocator = std.testing.allocator;\n\n  const page = try z.get(allocator, \"https://example.com\");\n  defer allocator.free(page);\n\n  const doc = try z.parseHTML(allocator, page);\n  defer z.destroyDocument(doc);\n\n  const html = z.documentRoot(doc).?;\n  try z.prettyPrint(allocator, html); // see image below\n\n  var css_engine = try z.createCssEngine(allocator);\n  defer css_engine.deinit();\n\n  const a_link = try css_engine.querySelector(html, \"a[href]\");\n\n  const href_value = z.getAttribute_zc(z.nodeToElement(a_link.?).?, \"href\").?;\n  std.debug.z.print(\"\\n{s}\\n\", .{href_value}); // result below\n\n  var css_content: []const u8 = undefined;\n  const style_by_css = try css_engine.querySelector(html, \"style\");\n\n  if (style_by_css) |style| {\n      css_content = z.textContent_zc(style);\n      z.print(\"\\n{s}\\n\", .{css_content}); // see below\n  }\n\n  // alternative search by DOM traverse\n  const style_by_walker = z.getElementByTag(html, .style);\n  if (style_by_walker) |style| {\n      const css_content_walker = z.textContent_zc(z.elementToNode(style));\n      std.debug.assert(std.mem.eql(u8, css_content, css_content_walker));\n  }\n}\n```\n\nYou will get a colourful print in your terminal, where the attributes, values, html elements get coloured.\n\nHTML content of example.com\n\n<img width=\"965\" height=\"739\" alt=\"Screenshot 2025-09-09 at 13 54 12\" src=\"https://github.com/user-attachments/assets/ff770cdb-95ab-468b-aa5e-5bbc30cf6649\" />\n\nYou will also see the value of the `href` attribute of a the first `<a>` link:\n\n```txt\n https://www.iana.org/domains/example\n ```\n\n```css\nbody {\n    background-color: #f0f0f2;\n    margin: 0;\n    padding: 0;\n    font-family: -apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    \n}\ndiv {\n    width: 600px;\n    margin: 5em auto;\n    padding: 2em;\n    background-color: #fdfdff;\n    border-radius: 0.5em;\n    box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);\n}\na:link, a:visited {\n    color: #38488f;\n    text-decoration: none;\n}\n@media (max-width: 700px) {\n    div {\n        margin: 0 auto;\n        width: auto;\n    }\n}\n```\n\n</details>\n\n\n<details><summary>Example: scan a page for potential malicious content</summary>\n\nThe intent is to highlight potential XSS threats. It works by parsing the string into a fragment. When a HTMLElement gets an unknown attribute, its colour is white and the attribute value is highlighted in RED.\n\nLet's parse and print the following HTML string:\n\n```html\nconst html_string = \n    <div>\n    <!-- a comment -->\n    <button disabled hidden onclick=\"alert('XSS')\" phx-click=\"increment\" data-invalid=\"bad\" scope=\"invalid\">Dangerous button</button>\n    <img src=\"javascript:alert('XSS')\" alt=\"not safe\" onerror=\"alert('hack')\" loading=\"unknown\">\n    <a href=\"javascript:alert('XSS')\" target=\"_self\" role=\"invalid\">Dangerous link</a>\n    <p id=\"valid\" class=\"good\" aria-label=\"ok\" style=\"bad\" onload=\"bad()\">Mixed attributes</p>\n    <custom-elt><p>Hi there</p></custom-elt>\n    <template><span>Reuse me</span></template>\n    </div>\n```\n\nYou parse this HTML string:\n\n```zig\nconst doc = try z.parseHTML(allocator, html_string);\ndefer z.destroyDocument(doc);\n\nconst body = z.bodyNode(doc).?;\ntry z.prettyPrint(allocator, body);\n```\n\nYou get the following output in your terminal.\n\n<img width=\"931\" height=\"499\" alt=\"Screenshot 2025-09-09 at 16 08 19\" src=\"https://github.com/user-attachments/assets/45cfea8b-73d9-401e-8c23-457e0a6f92e1\" />\n\nWe can then run a _sanitization_ process against the DOM, so you get a context where the attributes are whitelisted.\n\n```zig\ntry z.sanitizeNode(allocator, body, .permissive);\ntry z.prettyPrint(allocator, body);\n```\n\nThe result is shown below.\n\n<img width=\"900\" height=\"500\" alt=\"Screenshot 2025-09-09 at 16 11 30\" src=\"https://github.com/user-attachments/assets/ff7fa678-328b-495a-8a81-2ff465141be3\" />\n\n</details>\n\n---\n\n<details><summary>Example: using the parser with sanitization option</summary>\n\nYou can create a sanitized document with the parser (a ready-to-use parsing engine).\n\n```zig\nvar parser = try z.DOMParser.init(testing.allocator);\ndefer parser.deinit();\n\nconst doc = try parser.parseFromString(html, .none);\ndefer z.destroyDocument(doc);\n```\n\n</details>\n\n---\n\n<details><summary>Example: Processing streams</summary>\n\nYou receive chunks and build a document.\n\n```zig\nconst z = @import(\"zexplorer\");\nconst print = std.debug.print;\n\nfn demoStreamParser(allocator: std.mem.Allocator) !void {\n\n    var streamer = try z.Stream.init(allocator);\n    defer streamer.deinit();\n\n    try streamer.beginParsing();\n\n    const streams = [_][]const u8{\n        \"<!DOCTYPE html><html><head><title>Large\",\n        \" Document</title></head><body>\",\n        \"<table id=\\\"producttable\\\">\",\n        \"<caption>Company data</caption><thead>\",\n        \"<tr><th scope=\\\"col\\\">\",\n        \"Code</th><th>Product_Name</th>\",\n        \"</tr></thead><tbody>\",\n    };\n    for (streams) |chunk| {\n        z.print(\"chunk:  {s}\\n\", .{chunk});\n        try streamer.processChunk(chunk);\n    }\n\n    for (0..2) |i| {\n        const li = try std.fmt.allocPrint(\n            allocator,\n            \"<tr id={}><th >Code: {}</th><td>Name: {}</td></tr>\",\n            .{ i, i, i },\n        );\n        defer allocator.free(li);\n        z.print(\"chunk:  {s}\\n\", .{li});\n\n        try streamer.processChunk(li);\n    }\n    const end_chunk = \"</tbody></table></body></html>\";\n    z.print(\"chunk:  {s}\\n\", .{end_chunk});\n    try streamer.processChunk(end_chunk);\n    try streamer.endParsing();\n\n    const html_doc = streamer.getDocument();\n    defer z.destroyDocument(html_doc);\n    const html_node = z.documentRoot(html_doc).?;\n\n    z.print(\"\\n\\n\", .{});\n    try z.prettyPrint(allocator, html_node);\n    z.print(\"\\n\", .{});\n    try z.printDocStruct(html_doc);\n}\n```\n\nYou get the output:\n\n```txt\nchunk:  <!DOCTYPE html><html><head><title>Large\nchunk:   Document</title></head><body>\nchunk:  <table id=\"producttable\">\nchunk:  <caption>Company data</caption><thead>\nchunk:  <tr><th scope=\"col\">Items</th><th>\nchunk:  Code</th><th>Product_Name</th>\nchunk:  </tr></thead><tbody>\nchunk:  <tr id=0><th >Code: 0</th><td>Name: 0</td></tr>\nchunk:  <tr id=1><th >Code: 1</th><td>Name: 1</td></tr>\nchunk:  </tbody></table></body></html>;\n```\n\n<p align=\"center\">\n  <img src=\"https://github.com/ndrean/z-html/blob/main/images/html-table.png\" width=\"300\" alt=\"image\"/>\n  <img src=\"https://github.com/ndrean/z-html/blob/main/images/tree-table.png\" width=\"300\" alt=\"image\"/>\n\n</p>\n</details>\n\n---\n\n<details><summary>Example: Search examples and attributes and classList DOMTOkenList like</summary>\n\nWe have two types of search available, each with different behaviors and use cases:\n\n```html\nconst html = \n    <div class=\"main-container\">\n        <h1 class=\"title main\">Main Title</h1>\n        <section class=\"content\">\n        <p class=\"text main-text\">First paragraph</p>\n        <div class=\"box main-box\">Box content</div>\n        <article class=\"post main-post\">Article content</article>\n        </section>\n        <aside class=\"sidebar\">\n            <h2 class=\"subtitle\">Sidebar Title</h2>\n            <p class=\"text sidebar-text\">Sidebar paragraph</p>\n            <div class=\"widget\">Widget content</div>\n        </aside>\n        <footer class=\"main-footer\" aria-label=\"foot\">\n        <p class=\"copyright\">© 2024</p>\n        </footer>\n    </div>\n```\n\nA CSS Selector search and some walker search and attributes:\n\n```zig\nconst doc = try z.parseHTML(allocator,html);\ndefer z.destroyDocument(doc);\nconst body = z.bodyNode(doc).?;\n\nvar css_engine = try CssSelectorEngine.init(allocator);\ndefer engine.deinit();\n\nconst divs = try css_engine.querySelectorAll(body, \"div\");\nstd.debug.assert(divs.len == 3);\n\nconst p1 = try css_engine.querySelector(body, \"p.text\");\nconst p_elt = z.nodeToElement(p1.?).?;\nconst cl_p1 = z.classList_zc(p_elt);\n\nstd.debug.assert(std.mem.eql(u8, \"text main-text\", cl_p1));\n\nconst p2 = z.getElementByClass(body, \"text\").?;\nconst cl_p2 = z.classList_zc(p2);\nstd.debug.assert(std.mem.eql(u8, cl_p1, cl_p2));\n\nconst footer = z.getElementByAttribute(body, \"aria-label\").?;\nconst aria_value = z.getAttribute_zc(footer, \"aria-label\").?;\nstd.debug.assert(std.mem.eql(u8, \"foot\", aria_value));\n```\n\nWorking the `classList` like a DOMTokenList\n\n```zig\nvar footer_token_list = try z.ClassList.init(allocator, footer);\ndefer footer_token_list.deinit();\n\ntry footer_token_list.add(\"new-footer\");\nstd.debug.assert(footer_token_list.contains(\"new-footer\"));\n\n_ = try footer_token_list.toggle(\"new-footer\");\nstd.debug.assert(!footer_token_list.contains(\"new-footer\"));\n```\n\n</details>\n\n---\n\n### Provide other examples\n\nMove main() to src/examples\n\n---\n\n## Notes\n\n### Notes on `lexbor` DOM memory management: Document Ownership and zero-copy functions\n\nIn `lexbor`, nodes belong to documents, and the document acts as the memory manager.\n\nWhen a node is attached to a document (either directly or through a fragment that gets appended), the document owns it.\n\nEvery time you create a document, you need to call `destroyDocument()`: it automatically destroys ALL nodes that belong to it.\n\nWhen a node is NOT attached to any document, you must manually destroy it.\n\nSome functions borrow memory from `lexbor` for zero-copy operations: their result is consumed immediately.\n\nWe opted for the following convention: add `_zc` (for _zero_copy_) to the **non allocated** version of a function. For example, you can get the qualifiedName of an HTMLElement with the allocated version `qualifiedName(allocator, node)` or by mapping to `lexbor` memory with `qualifiedName_zc(node)`. The non-allocated must be consumed immediately whilst the allocated result can outlive the calling function.\n\n### **The Event Loop**\n\n<details><summary>TO BE MOVED INTO TECH DOCS</summary>\n\n```mermaid\ngraph TD\n    %% Nodes\n    Start((Loop Start)) --> SignalCheck{Ctrl+C?}\n    SignalCheck -- Yes --> Exit\n    SignalCheck -- No --> Microtasks1\n\n    subgraph \"Phase 1: Microtasks (High Priority)\"\n    Microtasks1[Flush Pending Jobs]\n    note1[Executes all .then callbacks]\n    end\n\n    Microtasks1 --> ExitCheck{Can Exit?}\n    ExitCheck -- Empty Queue & No Timers --> Exit\n    ExitCheck -- Active --> Timers\n\n    subgraph \"Phase 2: Timers (Macrotask)\"\n    Timers[Check Timers]\n    note2[Did a timer fire?]\n    end\n\n    Timers -- Yes! Fired one --> Start\n    Timers -- No, all waiting --> Workers\n\n    subgraph \"Phase 3: Native Workers (Macrotask)\"\n    Workers[Check Worker Queue]\n    note3[Did a thread finish?]\n    end\n\n    Workers -- Yes! Task Resolved --> Start\n    Workers -- No, queue empty --> Sleep\n\n    subgraph \"Phase 4: Idle\"\n    Sleep[Sleep for Min Timer, 10ms]\n    end\n\n    Sleep --> Start\n\n    %% Styling\n    style Microtasks1 fill:#f96,stroke:#333,stroke-width:2px\n    style Start fill:#bbf,stroke:#333\n    style Exit fill:#f66,stroke:#333\n```\n\n</details>\n\n---\n\n## Install\n\n[![Zig support](https://img.shields.io/badge/Zig-0.15.1-color?logo=zig&color=%23f3ab20)](http://github.com/ndrean/z-html)\n\nTO BE REVIEWED\n\n```sh\nzig fetch --save https://github.com/ndrean/zexplorer/archive/main.tar.gz\n```\n\nIn your _build.zig_:\n\n```zig\nconst zexplorer = b.dependency(\"zexplorer\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"zexplorer\", zexplorer.module(\"zexplorer\"));\n```\n\n## Building the lib\n\n- `lexbor` is built with static linking\n\n```sh\nLEXBOR_VERSION=2.7 LEXBOR_DIR=vendor/lexbor_master  make -f Makefile.lexbor\n```\n\n- tests: The _build.zig_ file runs all the tests from _root.zig_. It imports all the submodules and runs the tests.\n\n```sh\nzig build test --summary all\n```\n\n- run the demo in the __main.zig_ demo with:\n\n```sh\nzig build run -Doptimize=ReleaseFast\n```\n\n- Use the library: check _LIBRARY.md_.\n\n---\n\n### Special Notes\n\nlexbor: Update vendored repo:\n\n```sh\ngit submodule update --remote vendor/lexbor_src_master\n```\n\nminiz: use the release <https://github.com/richgel999/miniz/releases>\n\nDebug JS in Zig\n\n```sh\nzig build example -Dname=js-bench-preact && ./zig-out/bin/example-js-bench-preact 2>&1 | tail -20\n```\n\n```sh\nzig build example -Dname=js-bench-preact && dsymutil ./zig-out/bin/example-js-bench-preact && lldb -b -o \"run\" -o \"bt 20\" -- ./zig-out/bin/example-js-bench-preact\n```\n\nLeaks:\n\n```sh\ncat > ./debug.entitlements <<EOF\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>com.apple.security.get-task-allow</key>\n    <true/>\n</dict>\n</plist>\nEOF\n```\n\n```sh\ncodesign -s - --entitlements ./debug.entitlements --force ./zig-out/bin/zxp\n```\n\n```sh\nMallocStackLogging=1 leaks -atExit ./zig-out/bin/zxp -- sanitize src/examples/test_text_align.html -o sanitized.html > san_report.txt 2>&1\n```\n\n#### url hash\n\nExample:\n\n```sh\ncurl -s https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css | openssl dgst -sha384 -binary | base64 \n```\n\n#### on search in `lexbor` source/examples\n\n<https://github.com/lexbor/lexbor/tree/master/examples/lexbor>\n\nOnce you build `lexbor`, you have the static object located at _/lexbor_src_master/build/liblexbor_static.a_.\n\nTo check which primitives are exported, you can use:\n\n```sh\nnm vendor/lexbor_src_master/build/liblexbor_static.a | grep \" T \" | grep -i \"serialize\"\n```\n\nDirectly in the source code:\n\n```sh\nfind vendor/lexbor_src_master/source -name \"*.h\" | xargs grep -l \"lxb_html_seralize_tree_cb\"\n\ngrep -r \"lxb_html_serialize_tree_cb\" vendor/lexbor_src_master/source/lexbor/\n```\n\n## Licenses\n\n- `lexbor` [License Apache 2.0](https://github.com/lexbor/lexbor/blob/master/LICENSE)\n- `quickjs` [License MIT](https://github.com/quickjs-ng/quickjs/blob/master/LICENSE)\n- `libwebp` [License BSD3](https://github.com/webmproject/libwebp/blob/main/COPYING)\n- `thorvg` [License MIT](https://github.com/thorvg/thorvg/blob/master/LICENSE)\n- `yoga` [License MIT](https://github.com/facebook/yoga/blob/main/LICENSE)\n- `stb_image` [License MIT](https://github.com/nothings/stb/blob/master/LICENSE)\n- `zig-quickjs` [License MIT](https://github.com/nDimensional/zig-quickjs/blob/main/LICENSE)\n- `zig-curl` [License MIT](https://github.com/jiacai2050/zig-curl/blob/main/LICENSE)\n- `htm`[htm](https://github.com/developit/htm/blob/master/LICENSE)\n\n---\n\n## COCOMO analysis\n\n<https://github.com/boyter/scc>\n\n```txt\n───────────────────────────────────────────────────────────────────────────────\nLanguage            Files       Lines    Blanks  Comments       Code Complexity\n───────────────────────────────────────────────────────────────────────────────\nZig                   179      81,092     7,497     7,766     65,829     10,895\nJavaScript             69       7,082       545       326      6,211      1,023\nHTML                   51       8,292       973       154      7,165          0\nSVG                     9         302        36        22        244          0\nMarkdown                8       4,740     1,187         0      3,553          0\nJSON                    6       1,160         3         0      1,157          0\nJSX                     3         336        41         3        292          7\nPlain Text              3         346        57         0        289          0\nC                       2         341        55        72        214         61\nCSS                     2          24         2         0         22          0\nLicense                 1          21         4         0         17          0\nShell                   1         106        19        14         73          7\nSvelte                  1         181         6         0        175          3\nTypeScript              1           1         0         0          1          0\n───────────────────────────────────────────────────────────────────────────────\nTotal                 336     104,024    10,425     8,357     85,242     11,996\n───────────────────────────────────────────────────────────────────────────────\nEstimated Cost to Develop (organic) $2,875,952\nEstimated Schedule Effort (organic) 20.55 months\nEstimated People Required (organic) 12.44\n───────────────────────────────────────────────────────────────────────────────\nProcessed 5152069 bytes, 5.152 megabytes (SI)\n───────────────────────────────────────────────────────────────────────────────\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6793008?u=f81c36d15847387f1389fbe3edda20d815ef5e0e&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "프랑스",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 36,
  "owner_following": 142,
  "owner_created_at": "2014-02-26T11:25:23Z",
  "homepage": "https://ndrean.github.io/zexplorer",
  "license": "MIT",
  "category": "library"
}