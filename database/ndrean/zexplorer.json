{
  "name": "zexplorer",
  "owner": "ndrean",
  "repo": "zexplorer",
  "description": "WIP. HTML parser with JavaScript execution on steroids",
  "type": "package",
  "topics": [
    "lexbor",
    "zig",
    "zig-package"
  ],
  "stars": 4,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-01-05T11:05:41Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# zexplorer: HTML parser & JavaScript execution at native speed on a server\n\n## WIP\n\n- Extend [lexbor](https://lexbor.com/) to run JavaScript with [quickJS integration](https://quickjs-ng.github.io/quickjs/).\n\n- or extends `quickJS` with the Window API using `lexbor`.\n\nThis library can be used for:\n\n- ‚û° One-shot usage (examples in `main.zig`)\n- ‚û° long-running with event-loop/async\n\n```txt\nLong-running Process (main loop)\n-> JS_Runtime  + EventLoop (created once, persists) \n-> Per request:\n    JS_Context (ephemeral)\n    - DOM class registered \n    - Prototype attached (SHARED)\n    - Process request\n    - Cleanup & destroy context\n```\n\n> Most of the DOM API primitives have automatic bindings  [lxb->qjs] generated by running `zig run gen_bindings.zig` whenever possible (in `gen_bindings.zig`) with static functions (on 'document') and elements methods (on 'elemment' or 'node').\n> Async workers auto-generated with positional or objects arguments.\n\nWeb API integrated:\n\n- [Console](https://developer.mozilla.org/en-US/docs/Web/API/console)\n- [SetTimeout](https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout), [setInterval](https://developer.mozilla.org/en-US/docs/Web/API/Window/setInterval),\n\n**WIP**:\n\n> 1. EventLoop + WorkerPool + Async Tasks. Promises created on main thread, resolved in worker pool (4?). Two queues, jobs and results.\n> 2. `fetch`: use `libcurl` ?\n> 3. pur Zig functions injection (eg statistics, CSV parsing etc) into quickJS usable code.\n\n```mermaid\ngraph TD\n    Start((Start Tick)) --> SignalCheck{Ctrl+C?}\n    SignalCheck -- Yes --> Exit\n    SignalCheck -- No --> Microtasks1\n\n    subgraph \"Phase 1: Cleanup\"\n    Microtasks1[Flush Pending Jobs]\n    note1[Executes .then from previous tick]\n    end\n\n    Microtasks1 --> Timers\n\n    subgraph \"Phase 2: Timers\"\n    Timers[Process Timers]\n    note2[Checks setTimeout / setInterval]\n    end\n\n    Timers --> AsyncIO\n\n    subgraph \"Phase 3: Poll / Async I/O\"\n    AsyncIO[Process Worker Queue]\n    note3[Checks if fetch/file threads finished]\n    end\n\n    AsyncIO --> Microtasks2\n\n    subgraph \"Phase 4: Reaction\"\n    Microtasks2[Flush Pending Jobs]\n    note4[Executes .then triggered by Phase 3]\n    end\n\n    Microtasks2 --> AutoExit{Mode = Script?}\n    \n    AutoExit -- Yes & Empty --> Exit\n    AutoExit -- No --> Sleep\n    \n    Sleep[Sleep / Idle] --> Start\n```\n\n**Expectations**:\n\n- Native Speed: Lexbor parses/manipulates HTML at C speeds\n- No Serialization: JS directly manipulates real DOM via FFI\n- Memory Efficient: Single DOM tree, no virtual DOM overhead\n- Zero Network: All SSR happens in-process\n- Tiny footprint: 0.6MB, very fast start-up\n\n- NO JIT Compilation: QuickJS compiles JS to bytecode. Very performant for one-shot, short-lived scripts, cold starts. Not suited for long-lived scripts, CPU intensive, loop heavy ‚û° Move hot paths to `Zig` for this! (data processing, CSV parsing, batch and send to Zig...)\n\n[![Zig support](https://img.shields.io/badge/Zig-0.15.2-color?logo=zig&color=%23f3ab20)](http://github.com/ndrean/z-html)\n[![Scc Code Badge](https://sloc.xyz/github/ndrean/z-html/)](https://github.com/ndrean/z-html)\n\n## Use cases\n\n- Testing frameworks - Headless DOM for tests\n- Templating & Static Site Generation - (can use template components), outputs static HTML files\n- Email templates - Server-side rendering\n- PDF generation - HTML ‚Üí PDF pipelines\n- API gateways - Transform HTML responses\n- Web scrapping on steroids.\n- A lightweight and fast jsdom alternative\n- A native SSR engine for any JS framework\n- A programmable HTML processor with full JS power\n- An HTMX backend powerhouse\nThis is useful for web scraping, email sanitization, test engine for integrated tests, SSR post-processing of fragments.\n\nThe primitives exposed stay as close as possible to `JavaScript` semantics.\n\n## ‚ö†Ô∏è Challenges\n\n- Partial Browser APIs - fetch via `libcurl`\n- Module System - Need to implement import/export\n- No planned WASM support - Would need separate runtime integration\n  \n## QuickJS & Lexbor integration status\n\nAn example of `JavaScript` code running DOM primitives, executed by `Zig`!\n\n```js\nconsole.log(\"\\nLet's populate the DOM!\\n\");\n\nconst list = document.createElement(\"ul\");\n\nfor (let i = 1; i<4; i++) {\n    const item = document.createElement(\"li\");\n    item.setContentAsText(\"Item \" + i * 10);\n    list.appendChild(item);\n}\n\ncontainer.appendChild(list);\nconst body = document.bodyElement();\nbody.appendChild(container);\nconsole.log(\"\\n‚úì Document tree properly built!\\n\");\n\n```\n\nAnd the Zig code to run this snippet:\n\n```zig\nconst ctx = w.Context.init(rt);\nerrdefer ctx.deinit();\nctx.setAllocator(&allocator);\n\nvar bridge = try DOMBridge.init(allocator, ctx);\ndefer ctx.deinit();\ndefer bridge.deinit();  \ntry bridge.installAPIs();\n\n// 'html' is the JavaScript snippet above \nconst result = try ctx.eval(html,\"<ssr>\",.{});\ndefer ctx.freeValue(result);\n\nconst root = z.bodyNode(bridge.doc).?;\ntry z.prettyPrint(allocator, root);\n```\n\nThe output is shown below\n\n```txt\nLet's populate the DOM!\n\nDocument tree properly built!\n\n<body>\n    <ul>\n        <li id=\"1\">\n            \"Item 10\"\n        </li>\n        <li id=\"2\">\n            \"Item 20\"\n        </li>\n        <li id=\"3\">\n            \"Item 30\"\n        </li>\n    </ul>\n</body>\n```\n\nThis project exposes a significant / essential subset of all available `lexbor` functions:\n\n- Direct parsing or parsing with a parser engine (document or fragment context-aware)\n- streaming and chunk processing\n- Serialization\n- Sanitization\n- CSS selectors search with cached CSS selectors parsing\n- Support of `<template>` elements.\n- Attribute search\n- DOM manipulation\n- DOM / HTML-string normalization with options (remove comments, whitespace, empty nodes)\n- Pretty printing\n\n### `lexbor` DOM memory management: Document Ownership and zero-copy functions\n\nIn `lexbor`, nodes belong to documents, and the document acts as the memory manager.\n\nWhen a node is attached to a document (either directly or through a fragment that gets appended), the document owns it.\n\nEvery time you create a document, you need to call `destroyDocument()`: it automatically destroys ALL nodes that belong to it.\n\nWhen a node is NOT attached to any document, you must manually destroy it.\n\nSome functions borrow memory from `lexbor` for zero-copy operations: their result is consumed immediately.\n\nWe opted for the following convention: add `_zc` (for _zero_copy_) to the **non allocated** version of a function. For example, you can get the qualifiedName of an HTMLElement with the allocated version `qualifiedName(allocator, node)` or by mapping to `lexbor` memory with `qualifiedName_zc(node)`. The non-allocated must be consumed immediately whilst the allocated result can outlive the calling function.\n\n---\n\n## Install\n\n[![Zig support](https://img.shields.io/badge/Zig-0.15.1-color?logo=zig&color=%23f3ab20)](http://github.com/ndrean/z-html)\n\n```sh\nzig fetch --save https://github.com/ndrean/zexplorer/archive/main.tar.gz\n```\n\nIn your _build.zig_:\n\n```zig\nconst zexplorer = b.dependency(\"zexplorer\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"zexplorer\", zexplorer.module(\"zexplorer\"));\n```\n\n\n## Example: Create document and parse\n\nYou have two methods available.\n\n1. The `parseString()` creates a `<head>` and a `<body>` element and replaces BODY innerContent with the nodes created by the parsing of the given string.\n\n```zig\nconst z = @import(\"zexplorer\");\n\nconst doc: *HTMLDocument = try z.createDocument();\ndefer z.destroyDocument(doc);\n\ntry z.parseString(doc, \"<div></div>\");\nconst body: *DomNode = z.bodyNode(doc).?;\n\n// you can create programmatically and append elements to a node\nconst p: *HTMLElement = try z.createElement(doc, \"p\");\nz.appendChild(body, z.elementToNode(p));\n```\n\nYour document now contains this HTML:\n\n```html\n<head></head>\n<body>\n  <div></div>\n  <p></p>\n</body>\n```\n\nYou have a shortcut to directly create and parse an HTML string with `createDocFromString()`.\n\n```zig\nconst doc: *HTMLDocument = try z.createDocFromString(\"<div></div><p></p>\");\ndefer z.destroyDocument(doc);\n```\n\n2. You have the _parser engine_:\n\n```zig\nvar parser = try z.Parser.init(allocator);\ndefer parser.deinit();\nconst doc = try parser.parse(\"<div><p></p></div>\");\ndefer z.destroyDocument(doc);\n```\n\n\n<hr>\n\n## Example: scrap the web and explore a page\n\n```zig\ntest \"scrap example.com\" {\n  const allocator = std.testing.allocator;\n\n  const page = try z.get(allocator, \"https://example.com\");\n  defer allocator.free(page);\n\n  const doc = try z.createDocFromString(page);\n  defer z.destroyDocument(doc);\n\n  const html = z.documentRoot(doc).?;\n  try z.prettyPrint(allocator, html); // see image below\n\n  var css_engine = try z.createCssEngine(allocator);\n  defer css_engine.deinit();\n\n  const a_link = try css_engine.querySelector(html, \"a[href]\");\n\n  const href_value = z.getAttribute_zc(z.nodeToElement(a_link.?).?, \"href\").?;\n  std.debug.z.print(\"\\n{s}\\n\", .{href_value}); // result below\n\n  var css_content: []const u8 = undefined;\n  const style_by_css = try css_engine.querySelector(html, \"style\");\n\n  if (style_by_css) |style| {\n      css_content = z.textContent_zc(style);\n      z.print(\"\\n{s}\\n\", .{css_content}); // see below\n  }\n\n  // alternative search by DOM traverse\n  const style_by_walker = z.getElementByTag(html, .style);\n  if (style_by_walker) |style| {\n      const css_content_walker = z.textContent_zc(z.elementToNode(style));\n      std.debug.assert(std.mem.eql(u8, css_content, css_content_walker));\n  }\n}\n```\n\n<br>\n\nYou will get a colourful print in your terminal, where the attributes, values, html elements get coloured.\n\n<details><summary> HTML content of example.com</summary>\n\n<img width=\"965\" height=\"739\" alt=\"Screenshot 2025-09-09 at 13 54 12\" src=\"https://github.com/user-attachments/assets/ff770cdb-95ab-468b-aa5e-5bbc30cf6649\" />\n\n</details>\n<br>\n\nYou will also see the value of the `href` attribute of a the first `<a>` link:\n\n```txt\n https://www.iana.org/domains/example\n ```\n\n<details>\n<summary>You will then see the text content of the STYLE element (no CSS parsing):</summary>\n\n```css\nbody {\n    background-color: #f0f0f2;\n    margin: 0;\n    padding: 0;\n    font-family: -apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    \n}\ndiv {\n    width: 600px;\n    margin: 5em auto;\n    padding: 2em;\n    background-color: #fdfdff;\n    border-radius: 0.5em;\n    box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);\n}\na:link, a:visited {\n    color: #38488f;\n    text-decoration: none;\n}\n@media (max-width: 700px) {\n    div {\n        margin: 0 auto;\n        width: auto;\n    }\n}\n```\n\n</details>\n\n<hr>\n\n## HTMX Server-Side Rendering with Template Interpolation\n\nThis example demonstrates high-performance server-side rendering with `HTMX` integration and template interpolation, achieving 280K+ operations per second.\n\nThe rendering is _stateless_. The state is server-side driven, maintained in a database.\n\nThere is no need for a templating langugage: using multiline strings and loops or conditionals is largely enough to build HTML strings, and faster.\n\n<details><summary>Fake HTML page</summary>\n\n```zig\nconst blog_html =\n    \\\\<!DOCTYPE html>\n    \\\\<html lang=\"en\">\n    \\\\  <head>\n    \\\\    <meta charset=\"UTF-8\"/>\n    \\\\    <title>HTMX Blog - High Performance Server Rendering</title>\n    \\\\    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n    \\\\    <script src=\"https://unpkg.com/htmx.org@1.9.6\"></script>\n    \\\\    <style>\n    \\\\      .blog-post { margin: 2rem 0; padding: 1.5rem; border: 1px solid #ddd; \n}\n    \\\\      .post-title { color: #333; font-size: 1.5rem; cursor: pointer; }\n    \\\\      .post-title:hover { color: #0066cc; }\n    \\\\      .post-meta { color: #666; font-size: 0.9rem; margin: 0.5rem 0; }\n    \\\\      .post-actions { margin-top: 1rem; }\n    \\\\      .post-actions button { margin-right: 0.5rem; padding: 0.25rem 0.5rem; \n}\n    \\\\    </style>\n    \\\\  </head>\n    \\\\  <body>\n    \\\\    <main class=\"content\">\n    \\\\      <article class=\"blog-post\" data-post-id=\"{post_id}\">\n    \\\\        <header class=\"post-header\">\n    \\\\          <h2 class=\"post-title\" hx-get=\"/posts/{post_id}/edit\" \nhx-target=\"#edit-modal\">\n    \\\\            {title_template}\n    \\\\          </h2>\n    \\\\          <div class=\"post-meta\">\n    \\\\            <span class=\"author\">{author_name}</span>\n    \\\\            <time datetime=\"2024-01-01\">{publish_date}</time>\n    \\\\            <span class=\"views\" hx-get=\"/posts/{post_id}/views\"\nhx-trigger=\"revealed\">\n    \\\\              {view_count} views\n    \\\\            </span>\n    \\\\          </div>\n    \\\\        </header>\n    \\\\\n    \\\\        <div class=\"post-content\">\n    \\\\          <p>Welcome {user_name}! This demonstrates high-performance HTMX\nserver-side rendering with Zig.</p>\n    \\\\          <p>Current user: <strong>{user_name}</strong>, Post ID:\n<strong>{post_id}</strong></p>\n    \\\\        </div>\n    \\\\\n    \\\\        <footer class=\"post-actions\">\n    \\\\          <button hx-post=\"/posts/{post_id}/like\" hx-swap=\"innerHTML\">\n    \\\\            ‚ù§Ô∏è {like_count}\n    \\\\          </button>\n    \\\\          <button hx-get=\"/posts/{post_id}/comments\"\nhx-target=\"#comments-{post_id}\">\n    \\\\            üí¨ {comment_count}\n    \\\\          </button>\n    \\\\          <button hx-delete=\"/posts/{post_id}\" hx-confirm=\"Delete this\npost?\" hx-target=\"closest .blog-post\">\n    \\\\            üóëÔ∏è Delete\n    \\\\          </button>\n    \\\\        </footer>\n    \\\\      </article>\n    \\\\    </main>\n    \\\\  </body>\n    \\\\</html>\n;\n```\n\n</details>\n<br>\n\nThe code below parses the whole HTML delivered when the client connects, and starts the parser and css engine.\n\nWhen the webserver receives an HTMX request, the server returns a serialized updated HTML string.\n\n```zig\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n\npub fn main() !void {\n    const gpa = std.heap.c_allocator;\n\n    // One-time setup (server startup)\n    const doc = try z.createDocFromString(blog_html);\n    defer z.destroyDocument(doc);\n\n    var css_engine = try z.createCssEngine(allocator);\n    defer css_engine.deinit();\n\n    var parser = try z.Parser.init(allocator);\n    defer parser.deinit();\n\n    // 1. start the webserver: not implemented\n    // 2. Simulate handling requests received by the webserver\n    try requestHandler(gpa, doc, &css_engine, &parser);\n}\n\n// an example: tailored for each request\nfn requestHandler(\n    allocator: std.mem.Allocator,\n    doc: *z.HTMLDocument,\n    css_engine: *z.CssSelectorEngine,\n    parser: *z.Parser,\n) !void {\n\n    // 1. Target elements with CSS selectors\n    const title_elements = try css_engine.querySelectorAll(allocator, doc, \".post-title\");\n    defer allocator.free(title_elements);\n\n    if (title_elements.len > 0) {\n        // 2. Clone element for modification (original DOM stays pristine)\n        const cloned_title = z.cloneNode(z.elementToNode(title_elements[0])).?;\n        defer z.destroyNode(cloned_title);\n\n        // 3. Template interpolation with curly brackets after reading the db or kv store\n        const template = \"{user_name}'s Blog Post #{post_id}: {title}\";\n        var content = try interpolateTemplate(allocator, template, \"user_name\",\n\"Mr Magoo\");\n        defer allocator.free(content);\n\n        const post_id_str = try std.fmt.allocPrint(allocator, \"{}\", .{42});\n        defer allocator.free(post_id_str);\n\n        const temp = try interpolateTemplate(allocator, content, \"post_id\",\npost_id_str);\n        defer allocator.free(temp);\n\n        const final_content = try interpolateTemplate(allocator, temp, \"title\",\n\"HTMX Performance\");\n        defer allocator.free(final_content);\n\n        // 4. Update element content and HTMX attributes\n        _ = try z.setInnerHTML(z.nodeToElement(cloned_title).?, final_content);\n\n        // Interpolate HTMX attributes dynamically\n        const hx_get_value = try interpolateTemplate(allocator,\n\"/posts/{post_id}/edit\", \"post_id\", post_id_str);\n        defer allocator.free(hx_get_value);\n        _ = z.setAttribute(z.nodeToElement(cloned_title).?, \"hx-get\",\nhx_get_value);\n\n        // 5. Serialize modified element (ready to send to client)\n        const response_html = try z.outerHTML(allocator,\nz.nodeToElement(cloned_title).?);\n        defer allocator.free(response_html);\n\n        // POST back to the client\n        std.debug.print(\"HTMX Response: {s}\\n\", .{response_html});\n        // Output: <h2 class=\"post-title\" hx-get=\"/posts/42/edit\">M. Magoo's Blog\nPost #42: HTMX Performance</h2>\n    }\n}\n\n// Template interpolation helper - replaces {key} with values\nfn interpolateTemplate(\n    allocator: std.mem.Allocator, \n    template: []const u8, \n    key: []const u8, \n    value: []const u8) ![]u8 {\n    const placeholder = try std.fmt.allocPrint(allocator, \"{{{s}}}\", .{key});\n    defer allocator.free(placeholder);\n\n    // Count occurrences for efficient pre-allocation\n    var count: usize = 0;\n    var pos: usize = 0;\n    while (std.mem.indexOf(u8, template[pos..], placeholder)) |found| {\n        count += 1;\n        pos += found + placeholder.len;\n    }\n\n    if (count == 0) return try allocator.dupe(u8, template);\n\n    // Pre-allocate and replace all occurrences\n    const new_size = template.len + (value.len * count) - (placeholder.len *\ncount);\n    var result = try std.ArrayList(u8).initCapacity(allocator, new_size);\n\n    pos = 0;\n    while (std.mem.indexOf(u8, template[pos..], placeholder)) |found| {\n        const actual_pos = pos + found;\n        try result.appendSlice(allocator, template[pos..actual_pos]);\n        try result.appendSlice(allocator, value);\n        pos = actual_pos + placeholder.len;\n    }\n    try result.appendSlice(allocator, template[pos..]);\n\n    return result.toOwnedSlice(allocator);\n}\n```\n\n<hr>\n\n## Example: scan a page for potential malicious content\n\nThe intent is to highlight potential XSS threats. It works by parsing the string into a fragment. When a HTMLElement gets an unknown attribute, its colour is white and the attribute value is highlighted in RED.\n\nLet's parse and print the following HTML string:\n\n```html\nconst html_string = \n    <div>\n    <!-- a comment -->\n    <button disabled hidden onclick=\"alert('XSS')\" phx-click=\"increment\" data-invalid=\"bad\" scope=\"invalid\">Dangerous button</button>\n    <img src=\"javascript:alert('XSS')\" alt=\"not safe\" onerror=\"alert('hack')\" loading=\"unknown\">\n    <a href=\"javascript:alert('XSS')\" target=\"_self\" role=\"invalid\">Dangerous link</a>\n    <p id=\"valid\" class=\"good\" aria-label=\"ok\" style=\"bad\" onload=\"bad()\">Mixed attributes</p>\n    <custom-elt><p>Hi there</p></custom-elt>\n    <template><span>Reuse me</span></template>\n    </div>\n```\n\nYou parse this HTML string:\n\n```zig\nconst doc = try z.createDocFromString(html_string);\ndefer z.destroyDocument(doc);\n\nconst body = z.bodyNode(doc).?;\ntry z.prettyPrint(allocator, body);\n```\n\nYou get the following output in your terminal.\n\n<br>\n<img width=\"931\" height=\"499\" alt=\"Screenshot 2025-09-09 at 16 08 19\" src=\"https://github.com/user-attachments/assets/45cfea8b-73d9-401e-8c23-457e0a6f92e1\" />\n<br>\n\nWe can then run a _sanitization_ process against the DOM, so you get a context where the attributes are whitelisted.\n\n```zig\ntry z.sanitizeNode(allocator, body, .permissive);\ntry z.prettyPrint(allocator, body);\n```\n\nThe result is shown below.\n\n<br>\n<img width=\"900\" height=\"500\" alt=\"Screenshot 2025-09-09 at 16 11 30\" src=\"https://github.com/user-attachments/assets/ff7fa678-328b-495a-8a81-2ff465141be3\" />\n\n<br>\n<hr>\n\n## Example: using the parser with sanitization option\n\nYou can create a sanitized document with the parser (a ready-to-use parsing engine).\n\n```c\nvar parser = try z.Parser.init(testing.allocator);\ndefer parser.deinit();\n\nconst doc = try parser.parse(html, .none);\ndefer z.destroyDocument(doc);\n```\n\n<hr>\n\n## Example: Processing streams\n\nYou receive chunks and build a document.\n\n```zig\nconst z = @import(\"zexplorer\");\nconst print = std.debug.print;\n\nfn demoStreamParser(allocator: std.mem.Allocator) !void {\n\n    var streamer = try z.Stream.init(allocator);\n    defer streamer.deinit();\n\n    try streamer.beginParsing();\n\n    const streams = [_][]const u8{\n        \"<!DOCTYPE html><html><head><title>Large\",\n        \" Document</title></head><body>\",\n        \"<table id=\\\"producttable\\\">\",\n        \"<caption>Company data</caption><thead>\",\n        \"<tr><th scope=\\\"col\\\">\",\n        \"Code</th><th>Product_Name</th>\",\n        \"</tr></thead><tbody>\",\n    };\n    for (streams) |chunk| {\n        z.print(\"chunk:  {s}\\n\", .{chunk});\n        try streamer.processChunk(chunk);\n    }\n\n    for (0..2) |i| {\n        const li = try std.fmt.allocPrint(\n            allocator,\n            \"<tr id={}><th >Code: {}</th><td>Name: {}</td></tr>\",\n            .{ i, i, i },\n        );\n        defer allocator.free(li);\n        z.print(\"chunk:  {s}\\n\", .{li});\n\n        try streamer.processChunk(li);\n    }\n    const end_chunk = \"</tbody></table></body></html>\";\n    z.print(\"chunk:  {s}\\n\", .{end_chunk});\n    try streamer.processChunk(end_chunk);\n    try streamer.endParsing();\n\n    const html_doc = streamer.getDocument();\n    defer z.destroyDocument(html_doc);\n    const html_node = z.documentRoot(html_doc).?;\n\n    z.print(\"\\n\\n\", .{});\n    try z.prettyPrint(allocator, html_node);\n    z.print(\"\\n\", .{});\n    try z.printDocStruct(html_doc);\n}\n```\n\nYou get the output:\n\n```txt\nchunk:  <!DOCTYPE html><html><head><title>Large\nchunk:   Document</title></head><body>\nchunk:  <table id=\"producttable\">\nchunk:  <caption>Company data</caption><thead>\nchunk:  <tr><th scope=\"col\">Items</th><th>\nchunk:  Code</th><th>Product_Name</th>\nchunk:  </tr></thead><tbody>\nchunk:  <tr id=0><th >Code: 0</th><td>Name: 0</td></tr>\nchunk:  <tr id=1><th >Code: 1</th><td>Name: 1</td></tr>\nchunk:  </tbody></table></body></html>;\n```\n\n<p align=\"center\">\n  <img src=\"https://github.com/ndrean/z-html/blob/main/images/html-table.png\" width=\"300\" alt=\"image\"/>\n  <img src=\"https://github.com/ndrean/z-html/blob/main/images/tree-table.png\" width=\"300\" alt=\"image\"/>\n</p>\n\n<hr>\n\n## Example: Search examples and attributes and classList DOMTOkenList like\n\nWe have two types of search available, each with different behaviors and use cases:\n\n```html\nconst html = \n    <div class=\"main-container\">\n        <h1 class=\"title main\">Main Title</h1>\n        <section class=\"content\">\n        <p class=\"text main-text\">First paragraph</p>\n        <div class=\"box main-box\">Box content</div>\n        <article class=\"post main-post\">Article content</article>\n        </section>\n        <aside class=\"sidebar\">\n            <h2 class=\"subtitle\">Sidebar Title</h2>\n            <p class=\"text sidebar-text\">Sidebar paragraph</p>\n            <div class=\"widget\">Widget content</div>\n        </aside>\n        <footer class=\"main-footer\" aria-label=\"foot\">\n        <p class=\"copyright\">¬© 2024</p>\n        </footer>\n    </div>\n```\n\nA CSS Selector search and some walker search and attributes:\n\n```zig\nconst doc = try z.createDocFromString(html);\ndefer z.destroyDocument(doc);\nconst body = z.bodyNode(doc).?;\n\nvar css_engine = try z.createCssEngine(allocator);\ndefer css_engine.deinit();\n\nconst divs = try css_engine.querySelectorAll(body, \"div\");\nstd.debug.assert(divs.len == 3);\n\nconst p1 = try css_engine.querySelector(body, \"p.text\");\nconst p_elt = z.nodeToElement(p1.?).?;\nconst cl_p1 = z.classList_zc(p_elt);\n\nstd.debug.assert(std.mem.eql(u8, \"text main-text\", cl_p1));\n\nconst p2 = z.getElementByClass(body, \"text\").?;\nconst cl_p2 = z.classList_zc(p2);\nstd.debug.assert(std.mem.eql(u8, cl_p1, cl_p2));\n\nconst footer = z.getElementByAttribute(body, \"aria-label\").?;\nconst aria_value = z.getAttribute_zc(footer, \"aria-label\").?;\nstd.debug.assert(std.mem.eql(u8, \"foot\", aria_value));\n```\n\nWorking the `classList` like a DOMTokenList\n\n```zig\nvar footer_token_list = try z.ClassList.init(allocator, footer);\ndefer footer_token_list.deinit();\n\ntry footer_token_list.add(\"new-footer\");\nstd.debug.assert(footer_token_list.contains(\"new-footer\"));\n\n_ = try footer_token_list.toggle(\"new-footer\");\nstd.debug.assert(!footer_token_list.contains(\"new-footer\"));\n```\n\n<hr>\n\n## Example: HTML Normalization\n\nThe library provides both DOM-based and string-based HTML normalization to clean up whitespace and comments.\n\nThis helps to visualize a clean output in the terminal and also minimize what is potentially sent back over the wire (e.g. when using `HTMX` frontend).\n\nDOM-based normalization works on parsed documents and provides browser-like behavior. It is the best choice.\n\nWe take the example below:\n\n```zig\nconst doc = try z.createDocument();\ndefer z.destroyDocument(doc);\n\nconst messy_html = \n    \\\\<div>\n    \\\\<!-- comment -->\n    \\\\\n    \\\\<p>Content</p>\n    \\\\\n    \\\\<pre>  preserve  this  </pre>\n    \\\\\n    \\\\</div>\n;\n```\n\n```zig\nconst expected = \"<div><!-- comment --><p>Content</p><pre>  preserve  this  </pre></div>\";\n```\n\nDom-base normalization:\n\n```zig\ntry z.parseString(doc, messy_html);\n\nconst body_elt1 = z.bodyElement(doc).?;\ntry z.normalizeDOM(gpa, body_elt1);\n\nconst result1 = try z.innerHTML(gpa, body_elt1);\ndefer gpa.free(result1);\n\nstd.debug.assert(std.mem.eql(u8, expected, result1));\n```\n\nString-based \"pre-normalization\":\n\n```zig\nconst cleaned = try z.normalizeHtmlStringWithOptions(\n    gpa,\n    messy_html,\n    .{ .remove_comments = false },\n);\ndefer gpa.free(cleaned);\n\nstd.debug.assert(std.mem.eql(u8, cleaned, result1));\n\ntry z.parseString(doc, cleaned);\nconst body_elt2 = z.bodyElement(doc).?;\nconst result2 = try z.innerHTML(gpa, body_elt2);\ndefer gpa.free(result2);\n\nstd.debug.assert(std.mem.eql(u8, result2, result1));\n```\n\nSome results shown in the _ main.zig_  file of parsing a 38kB HTML string (average 500 iterations using `std.heap.c_allocator` and `-release=fast`).\n\nTo parse a 38kB string, it takes 50¬µs on average.\n\nThe overhead of normalization:\n\n```txt\n--- Speed Results ---\ncreateDoc -> parseString:                        0.05 ms/op, 830 kB/s\nnew parser -> new doc = parser.parse -> DOMnorm:     0.06 ms/op, 660 kB/s\ncreateDoc -> normString -> parseString:   0.08 ms/op, 470 kB/s\n```\n\n<hr>\n\n\n## Other examples in _main.zig_\n\nThe file _main.zig_ shows more use cases with parsing and serialization as well as the tests  (`setInnerHTML`, `setInnerSafeHTML`, `insertAdjacentElement` or `insertAdjacentHTML`...)\n\n<hr>\n\n## Building the lib\n\n- `lexbor` is built with static linking\n\n```sh\nLEXOBR_VERSION=2.6 LEXBOR_DIR=vendor/lexbor_master  make -f Makefile.lexbor\n```\n\n- tests: The _build.zig_ file runs all the tests from _root.zig_. It imports all the submodules and runs the tests.\n\n```sh\nzig build test --summary all\n```\n\n- run the demo in the __main.zig_ demo with:\n\n```sh\nzig build run -Doptimize=ReleaseFast\n```\n\n- Use the library: check _LIBRARY.md_.\n\n---\n\n### Notes on search in `lexbor` source/examples\n\n<https://github.com/lexbor/lexbor/tree/master/examples/lexbor>\n\nOnce you build `lexbor`, you have the static object located at _/lexbor_src_master/build/liblexbor_static.a_.\n\nTo check which primitives are exported, you can use:\n\n```sh\nnm lexbor_src_master/build/liblexbor_static.a | grep -i \"serialize\"\n```\n\nDirectly in the source code:\n\n```sh\nfind lexbor_src_master/source -name \"*.h\" | xargs grep -l \"lxb_selectors_opt_set_noi\"\n```\n\n## License\n\n- `lexbor` [License](https://github.com/lexbor/lexbor/blob/master/LICENSE)\n- `quickjs` [License](https://github.com/quickjs-ng/quickjs/blob/master/LICENSE)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6793008?u=f81c36d15847387f1389fbe3edda20d815ef5e0e&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "ÌîÑÎûëÏä§",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 35,
  "owner_following": 140,
  "owner_created_at": "2014-02-26T11:25:23Z",
  "homepage": "https://ndrean.github.io/zexplorer",
  "license": "MIT",
  "category": "library"
}