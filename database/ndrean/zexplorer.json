{
  "name": "zexplorer",
  "owner": "ndrean",
  "repo": "zexplorer",
  "description": "Programmable HTML processor with JavaScript execution on steroids",
  "type": "package",
  "topics": [
    "lexbor",
    "zig",
    "zig-package",
    "css-parser",
    "css-sanitization",
    "html-parser",
    "javascript-tools",
    "sanitize-html"
  ],
  "stars": 5,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-02T15:43:59Z",
  "dependencies": [
    {
      "name": "mailbox",
      "url": "git+https://github.com/g41797/mailbox#d0187c156f0fd956f57f36320fda52e555ebaef5",
      "hash": "mailbox-0.0.13-8ABL0gVeAAAVfcvotP06FEWeAW_gLUGCnUB2rlxNXdjB"
    },
    {
      "name": "curl",
      "url": "https://github.com/jiacai2050/zig-curl/archive/refs/tags/v0.3.2.tar.gz",
      "hash": "curl-0.3.2-P4tT4SXPAACuV6f5eyh4jG_1SspjWwMm_vRJfoKrQep5"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# zexplorer: a JavaScript programmable HTML processor on steroids\n\n![Zig support](https://img.shields.io/badge/Zig-0.15.2-color?logo=zig&color=%23f3ab20)\n\n[WIP]\n\nAn opinionated  `Zig` based HTML processor that lets you write JavaScript and executes at native speed on a server.\n\nBased on [lexbor](https://lexbor.com/) and [quickJS-ng](https://quickjs-ng.github.io/quickjs/).\n\n## Project description\n\nWhat it has:\n\n- runs most DOM primitives and executes ES6 JavaScript\n- sandboxed file system (upload directory only),\n- `fetch` API (via Curl Multi HTTP requests),\n- `Workers`(OS threads for parallel processing),\n- DOM/CSS native sanitizer (based on H5SC testing suite),\n- can inject native Zig primitives (statistics, CSV parsing...),\n- integrated Web API classes: `Worker`, `URL`, `ULRSearchParams`, `Headers`, `Event`, `DocumentFragment`, `DOMParser`, `Blob`, `FormData`, `File`, `FileReaderSync`, `FileReader`, `Fetch`.\n\nIt can be compared to [JSDOM](https://github.com/jsdom/jsdom) with [DOMPurify](https://github.com/cure53/DOMPurify) included a native speed.\n\nWhat it does not have (yet): async I/O\n\nThis is not:\n\n- a headless browser,\n- not `Node.js` nor `bun`,\n- not for streaming/async I/O workloads.\n\n**Security**:\n\n- Runtime limits (memory, stack size, interruptible) for DoS.\n- Downloads limited to HTTPS and declared in _import_map.json_,\n- sandboxed File system limited to current directory and beyond, and no loading if symlink for LFI.\n- Load sanitized and sandboxed HTML, CSS and scripts\n  - The `Zanitizer` module is 5 to 50 times faster than DOMPurify integrated in the `Sanitizerconfig`.\n  - It is based on a declarative security policy (_html_specs.zig_) and is \"context aware\": it is executed in a virtual _DomFragment_ before being merged into the active _Document_.\n  - it is tested against the HTML5 Security Cheatsheet  Test  (<https://github.com/cure53/H5SC>) with _ZERO_ exploitable vulnerabilities among the 139 tests, and against the DOMPurify  test (<https://cure53.de/purify>).\n\nIt is performant:\n\n- 24kB of the DOMPurify HTML test is processed in 1ms and the H5SC is processed (in debug/test mode) in 1.3ms.\n- It runs the js-framework  vanilla JavaScript benchmark tests much faster than `jsdom`.\n\nThis program can be used for:\n\n## Use cases\n\n- Email sanitization if you need zero XSS and maximum speed\n- SSR with untrusted templates with sandbox processing\n- HTML transformation pipelines: inject `Zig` code for hot paths (CSV parsing, crypto...)\n- Testing frameworks - Fast and sandboxed\n- Templating & Static Site Generation - (can use template components): no async needed, pure speed.\n- Web scraping on steroids.\n\n## Tests\n\nThe goal is to review the [DOM examples repo](https://github.com/mdn/dom-examples).\n\n### zexplorer running js-framework-benchmark VanillaJS code\n\nTo ensure the Web primitives are correctly implemented in `zexplorer`, we run VanillaJS code from the [js-vanilla-benchframework tests](https://github.com/krausest/js-framework-benchmark).\n\nThe engine runs all tests below 80ms.\n\nThe examples can be built and run with the commands:\n\n```sh\nzig build example -Dname=js-bench-1 -Doptimize=ReleaseFast\nzig build example -Dname=js-bench-2 -Doptimize=ReleaseFast\nzig build example -Dname=js-bench-3 -Doptimize=ReleaseFast\n```\n\n| test                 | t1    | t2    | t3    |\n| -------------------- | ----- | ----- | ----- |\n| Create 1k            | 2.68  | 1.90  | 1.75  |\n| Replace 1k           | 2.56  | 2.34  | 1.81  |\n| Partial Update (10k) | 2.92  | 1.64  | 6.73  |\n| Select Row           | 0.05  | 0.01  | 0.02  |\n| Swap Rows            | 0.06  | 0.10  | 0.14  |\n| Remove Row           | 0.01  | 0.05  | 0.05  |\n| Create 10k           | 27.66 | 20.84 | 16.54 |\n| Append 1k            | 2.76  | 7.41  | 4.02  |\n| Clear                | 4.11  | 7.72  | 5.94  |\n| --                   | --    | --    | --    |\n| Total Engine         | 76    | 70    | 75    |\n\n[TODO]: a CLI ? to run:\n\n```sh\nzxp loc/index.html loc/bench.js loc/test-runner.js\n```\n\n### zexplorer vs jsdom\n\n<details><summary>HTML with embedded benchmark Script</summary>\n\n```html\n<!DOCTYPE html>\n<html>\n  <body>\n    <div id=\"root\"></div>\n    <script>\n      const nb = 10_000;\n      const root = document.getElementById(\"root\");\n      for (let i = 0; i < nb; i++) {\n        const span = document.createElement(\"span\");\n        span.textContent = \"Item \" + i;\n        root.appendChild(span);\n      }\n      const all = document.querySelectorAll(\"span\");\n      let total = 0;\n      for (let i = 0; i < all.length; i++) {\n        total += all[i].textContent.length;\n      }\n      console.log(\"Total chars: \" + total);\n    </script>\n  </body>\n</html>\n```\n\n</details>\n\n<details><summary>jsdom runner script:</summary>\n\n```js\nconsole.time(\"Total\");\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\nconst fs = require(\"fs\");\n\nconst html = fs.readFileSync(\"bench.html\", \"utf8\");\nconst dom = new JSDOM(html, { runScripts: \"dangerously\" });\nconsole.timeEnd(\"Total\");\n```\n\n</details>\n\n<details><summary>Zexplorer script:</summary>\n\n```zig\nfn bench(allocator: std.mem.Allocator, sandbox_root: []const u8) !void {\n    var engine = try ScriptEngine.init(allocator, sandbox_root);\n    defer engine.deinit();\n\n    const start = std.time.nanoTimestamp();\n\n    const html = @embedFile(\"bench.html\")\n    try engine.loadHTML(html);\n\n    try engine.executeScripts(allocator, \".\");\n    try engine.run();\n\n\n    const end = std.time.nanoTimestamp();\n    const ms = @divFloor(end - start, 1_000_000);\n    std.debug.print(\"‚ö°Ô∏è Zexplorer Engine Total Time: {d}ms\\n\", .{ms});\n}\n```\n\n</details>\n\n**Results**\n\n| #rows     | Zexplorer | jsdom  |\n| --------- | --------- | ------ |\n| 100       | 0.13ms    | 241ms  |\n| 1_000     | 0.7ms     | 251ms  |\n| 10_000    | 52ms      | 331ms  |\n| 20_000    | 115ms     | 421ms  |\n| 50_000    | 279ms     | 662ms  |\n| 100_000   | 633ms     | 1062ms |\n| 500_000   | 4323ms    | 4213ms |\n| 1_000_000 | 15165ms   | 9216ms |\n\n---\n\n### Tests Zaniter module\n\nTh module is faster than DOMPurify but probably not as complete. It is based on DOM parsing into a documentFragment, applying whitelisting and html_specs rules before injecting back into the DOM.\n\n- DOMPurify test suite: <https://github.com/cure53/DOMPurify/tree/main/test>\n- OWASP XSS Filter Evasion Cheat Sheet: <https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html>\n- PortSwigger XSS cheat sheet: <https://portswigger.net/web-security/cross-site-scripting/cheat-sheet>\n- DOMPurify CVEs: Especially CVE-2024-47875 (mXSS via nesting) <https://github.com/cure53/DOMPurify>\n\n#### H5SC Quality test\n\n139 real-world XSS attack vectors from [html5sec.org](https://html5sec.org/)\n\nResults:\n\n#### Speed test\n\n```sh\nzig build example -Dname=dom_purify -Doptimize=ReleaseFast\n```\n\nThe test is to process _src/examples/dom_purify.html_:\n\n```txt\n=== DOMPurify Benchmark -------\n\nInput size: 36526 bytes\nOutput size: 16501 bytes\nTotal Engine time: 1.052 ms\n\nDOMPurify reference: ~11 ms\n(without JSDom overhead)\n```\n\n---\n\n## A few examples\n\nThe folder _src/examples_  (will!) contains all the test cases.\n\nRun the file name with:  `zig build example -Dname=test_solidjs -Doptimize=ReleaseFast`\n\n**TODO**: migrate from _main.zig_ to /examples\n\n### Reactive framework : SolidJS (no JSX)\n\n```html\n<html>\n  <body>\n    <h1>Testing CDN import: SolidJS</h1>\n    <div id=\"root\"></div>\n    <script type=\"module\">\n      import { createSignal, createEffect, onCleanup } from \"solid-js\";\n      import { render } from \"solid-js/web\";\n      // Skip html template tag - it has regex issues in QuickJS\n      // import html from \"solid-js/html\";\n\n      console.log(\"[JS] SolidJS loaded\");\n      console.log(\"[JS] createSignal:\", typeof createSignal);\n      console.log(\"[JS] render:\", typeof render);\n\n      // Basic reactivity test\n      const [count, setCount] = createSignal(1);\n\n      // Component using manual DOM (works with QuickJS)\n      const Counter = () => {\n        const [localCount, setLocalCount] = createSignal(0);\n\n        // Create DOM elements manually\n        const container = document.createElement(\"div\");\n        const p = document.createElement(\"p\");\n        const button = document.createElement(\"button\");\n        button.textContent = \"Add +1\";\n\n        // Reactive effect updates the DOM when signal changes\n        createEffect(() => {\n          console.log(`[JS] Rendered! Count: ${localCount()}`);\n          p.textContent = `Count: ${localCount()}`;\n        });\n\n        // Button click handler\n        button.onclick = () => setLocalCount((c) => c + 1);\n\n        // Auto-increment every 500ms, stop after 3 iterations\n        let iterations = 0;\n        const interval = setInterval(() => {\n          iterations++;\n          setLocalCount((c) => c + 1);\n          if (iterations >= 3) {\n            clearInterval(interval);\n            console.log(\"[JS] Auto-increment stopped after 3 iterations\");\n          }\n        }, 500);\n        onCleanup(() => clearInterval(interval));\n\n        container.appendChild(p);\n        container.appendChild(button);\n        return container;\n      };\n\n      try {\n        render(Counter, document.getElementById(\"root\"));\n        console.log(\"[JS] SolidJS render success!\");\n      } catch (e) {\n        console.log(\"[JS] SolidJS Error:\", e.message);\n        if (e.stack)\n          console.log(\n            \"[JS] Stack:\",\n            e.stack.split(\"\\n\").slice(0, 3).join(\"\\n\"),\n          );\n      }\n    </script>\n  </body>\n</html>\n```\n\n```zig\nfn run_test(gpa: std.mem.Allocator, sandbox_root: []const u8) !void {\n    var engine = try ScriptEngine.init(gpa, sandbox_root);\n    defer engine.deinit();\n\n    const html = @embedFile(\"test_solidjs.html\");\n    try engine.loadHTML(html);\n    try engine.executeScripts(gpa, \".\");\n    engine.run() catch |err| {\n        z.print(\"Run error: {}\\n\", .{err});\n        return err;\n    };\n    const root = z.getElementById(engine.dom.doc, \"root\");\n    try z.prettyPrint(gpa, z.elementToNode(root.?));\n}\n```\n\n`zig build example -Dname=test_solidjs`\n\n```txt\n[Zig] Import map: solid-js -> https://unpkg.com/solid-js@1.8.0/dist/solid.js\n[Zig] Import map: solid-js/web -> https://unpkg.com/solid-js@1.8.0/web/dist/web.js\n[Zig] Import map: solid-js -> https://unpkg.com/solid-js@1.8.0/dist/solid.js\n\n[JS] SolidJS loaded\n[JS] createSignal: function\n[JS] render: function\n[JS] Rendered! Count: 0\n[JS] SolidJS render success!\n[JS] Rendered! Count: 1\n[JS] Rendered! Count: 2\n[JS] Rendered! Count: 3\n[JS] Auto-increment stopped after 3 iterations\n\n<div id=\"root\">\n  <div>\n    <p>\n      \"Count: 3\"\n    </p>\n    <button>\n      \"Add +1\"\n    </button>\n  </div>\n</div>\n```\n\n### Upload a file\n\nCreate a filetext blob and append it to a formData object and upload to the test endpoint `httpbin` (it returns the data it received).\n\n```js\nconst formData = new FormData();\nconst blob = new Blob([\"Hello form data!\"], { type: \"text/plain\" });\nformData.append(\"file\", blob, \"hello.txt\");\n\nconsole.log(\"Sending POST...\");\n\nfetch('https://httpbin.org/post', {\n    method: 'POST',\n   body: formData\n})\n.then(res => res.json())\n.then(data => {\n    console.log(\"üü¢ Server received:\", data);\n})\n.catch(err => console.log(\"üî¥ Error:\", err));\n```\n\n```zig\nfn uploadFile(allocator: std.mem.Allocator, sbx: []const u8) !void {\n    var engine = try ScriptEngine.init(allocator, sbx);\n    defer engine.deinit();\n\n    cosnt script = readFile(\"js/test_send_post.js\");\n    defer allocator.free(script);\n\n    const res = try engine.eval(script, \"<fetch>\", .module);\n    engine.ctx.freeValue(res);\n    try engine.run();\n}\n```\n\nThe output in the terminal is:\n\n```txt\nüü¢ Server received: {\n  \"args\": {},\n  \"data\": \"\",\n  \"files\": {\n    \"file\": \"Hello form data!\"\n  },\n  \"form\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Content-Length\": \"205\",\n    \"Content-Type\": \"multipart/form-data; boundary=----ZigQuickJSBoundary1769609637330069000\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"zig-curl/0.3.2\",\n    \"X-Amzn-Trace-Id\": \"Root=1-697a19a5-3c4d5687799f935028ffcfeb\"\n  },\n  \"json\": null,\n  \"origin\": \"90.93.234.63\",\n  \"url\": \"https://httpbin.org/post\"\n}\n```\n\n### CSS and JS executed (using file sources)\n\nFile: _/js/js-and-css/style.css_\n\n```css\n\n#pid {\n  color: green;\n  font-size: 20px;\n}\n```\n\nFile: _/js/js-and-css/main.js_\n\n```js\nconst changeText = () =>{\n  const p = document.getElementById(\"pid\");\n  p.textContent = \"New text\";\n}\n\nconst btn = document.querySelector(\"button\");\nbtn.addEventListener(\"click\", () => {\n  changeText();\n  const p = document.getElementById(\"pid\");\n  const p_color = p.style.getProperyValue(\"color\");\n  const p_font_size = window.getComputedStyle(p).getPropertyValue(\"font-size\");\n  console.log(\"[JS] 'p' properties: \", p_color, p_font_size);\n  console.log(\"[JS] 'p' textContent: \", p.textContent);\n});\n\nbtn.dispatchEvent(new Event(\"click\")  );\n```\n\nFile: _/js/js-and-css/index.html_\n\n```html\n<!-- js/js-and-css/index.html -->\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n  </head>\n <body>\n  <p id=\"pid\">Some text</p>\n  <form>\n    <button type=\"button\">Change text</button>\n  </form>\n  <script type=\"module\" src=\"main.js\"></script>\n</body>\n</html>\n```\n\nThe following `Zig` code runs successfully:\n\n```zig\nfn css_js_external_file(allocator: std.mem.Allocator, sandbox_root: []const u8) !void {\n  const engine = try ScriptEngine.init(allocator, sandbox_root);\n  defer engine.deinit();\n\n  try engine.loadHTML(html);\n  try engine.loadExternalStylesheets(\"js/js-and-css/\");\n  try engine.executeScripts(allocator, \"js/js-and-css\");\n  try engine.run();\n\n  const p_el = z.getElementById(bridge.doc, \"pid\").?;\n  const computed_color = try z.getComputedStyle(allocator, p_el, \"color\");\n  const computed_font_size = try z.getComputedStyle(allocator, p_el, \"font-size\");\n  defer if (computed_color) |c| allocator.free(c);\n  defer if (computed_font_size) |c| allocator.free(c);\n\n\n  z.print(\"[Zig] p_color: {s}, p_font_size: {s}\\n\", .{ computed_color.?, computed_font_size.? });\n\n  try z.printDOM(allocator, engine.dom.doc, \"link-stylesheet and Script with 'external' file\");\n}\n```\n\nIn the terminal:\n\n```txt\n[JS] 'p' properties: green, 20px\n[JS] 'p' textContent: New text\n[Zig] p_color: green, p_font_size: 20px\n\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <title>\n      \"link-stylesheet and Script with 'external' file\"\n    </title>\n  </head>\n  <body>\n    <p id=\"pid\">\n      \"New text\"\n    </p>\n    <form>\n      <button type=\"button\">\n        \"Change text\"\n      </button>\n    </form>\n    <script type=\"module\" src=\"main.js\">\n    </script>\n  </body>\n</html>\n```\n\n## Zig to JS intercomm and native function injection in JS\n\nTODO\n\nYou can send p from Zig to JS and receive typed data from JS to Zig.\n\nYou can use native Zig functions in JS\n\n\n## DOM API integration\n  \n- **Event Loop**. Native Zig thread-safe loop handling Timers (microtasks) and  Promises (macrotasks).\n- **Worker pool**: OS-threaded with message passing and library import support for CPU-intensive tasks (eg CSV parsing); inject Zig functions into JS code.\n- **EventListeners** (add, remove, dispatch) and _bubbling_ supported.\n- **ES6 Module System**: Load external, third-party libraries (es-toolkit) from disk, resolving paths, handling extensions, and executing them natively.\n- **CCSOM**: _inline_ CSS-inJS and _StyleSheet_ support. [WIP] The 500+ CSS properties (`Object.keys(document.body.style).filter(k => !k.startsWith('webkit'))`). Currently,  functional accessors: `Element.getPropertyValue()` and `Element.setProperty()` and `getComputedStyles()`.\n- Templating support.\n- **DOM Sanitizer**. Handles templates. To become closer to `DOMPurify`, [TODO] Missing full support of SVG sanitization and only basic CSS sanitization.\n- `fetch` API (via libCurl Multi).\n- Binary Interop: Zero-copy passing of ArrayBuffers and efficient Tuples.\n- **Security: RCE**. Sandboxing.\n\n**Expectations**:\n\n- instant start, low footprint\n- No JIT Compilation: QuickJS compiles JS to bytecode. Very performant for one-shot, short-lived scripts, cold starts.\n- For long-lived scripts, CPU intensive, loop heavy ‚û° Move hot paths to `Zig`: embed native Zig functions for this! (data processing, CSV parsing, batch and send to Zig...)\n\n## Limitations\n\nNo AsyncIO, no WebSocket, no planned WASM support.\n  \n## Examples\n\n**Import CSS**\n\n```zig\nfn additional_stylesheet_style_tag(allocator: std.mem.Allocator) !void {\n    const html =\n        \\\\<html>\n        \\\\  <head>\n        \\\\    <style>\n        \\\\      #pid {  color: green;  font-size: 20px; }\n        \\\\    </style>\n        \\\\  </head>\n        \\\\  <body>\n        \\\\      <p id=\"pid\">Some text</p>\n        \\\\      <form>\n        \\\\          <button type=\"button\">Change text</button>\n        \\\\      </form>\n        \\\\  </body>\n        \\\\</html>\n    ;\n\n    const css =\n        \\\\#pid {\n        \\\\  color: red;\n        \\\\  font-size: 30px;\n        \\\\}\n    ;\n\n    const js =\n        \\\\function changeText() {\n        \\\\  const p = document.getElementById(\"pid\")\n        \\\\  p.textContent = \"New text\"\n        \\\\}\n        \\\\const btn = document.querySelector(\"button\");\n        \\\\btn.addEventListener(\"click\", () => {\n        \\\\  changeText();\n        \\\\});\n        \\\\\n        \\\\ btn.dispatchEvent(new Event('click'), (e) => {\n        \\\\  console.log(\"Button clicked\");\n        \\\\});\n    ;\n\n    const engine = try ScriptEngine.init(allocator);\n    defer engine.deinit();\n\n    const bridge = engine.dom;\n\n    try engine.loadHTML(html);\n    try z.parseStylesheet(bridge.stylesheet, bridge.css_style_parser, css);\n    try z.attachStylesheet(bridge.doc, bridge.stylesheet);\n\n    const val = try engine.eval(js, \"style_test.js\");\n    defer engine.ctx.freeValue(val);\n\n    const p_el = z.getElementById(bridge.doc, \"pid\").?;\n\n    const computed_color = try z.getComputedStyle(allocator, p_el, \"color\");\n    const computed_font_size = try z.getComputedStyle(allocator, p_el, \"font-size\");\n    defer if (computed_color) |c| allocator.free(c);\n    defer if (computed_font_size) |c| allocator.free(c);\n\n    try std.testing.expectEqualStrings(\"red\", computed_color.?);\n    try std.testing.expectEqualStrings(\"30px\", computed_font_size.?);\n    try std.testing.expectEqualStrings(\"New text\", z.textContent_zc(z.elementToNode(p_el)));\n\n    try z.prettyPrint(allocator, z.bodyNode(engine.dom.doc).?);\n}\n```\n\n**Use Reactive DOM primitives in async JavaScript code executed by `Zig`**\n\n```js\nconst btn = document.createElement(\"button\");\nconst form = document.createElement(\"form\");\nform.appendChild(btn);\ndocument.body.appendChild(form);\n\nconst mylist = document.createElement(\"ul\");\nfor (let i = 1; i < 3; i++) {\n  const item = document.createElement(\"li\");\n  item.setContentAsText(\"Item \" + i * 10);\n  item.setAttribute(\"id\", i);\n  mylist.appendChild(item);\n}\ndocument.body.appendChild(mylist);\nconsole.log(\"[JS] Initial document\", document.body.innerHTML);\n\n// --------------------------------------------------------------------\n// DOM Event Listener with Delayed action with Timer\n// --------------------------------------------------------------------\n\nform.addEventListener(\"submit\", (e) => {\n  e.preventDefault(); // Prevent actual form submission\n  console.log(\"[JS] ‚åõÔ∏è üìù Form Submitted! Event Type:\", e.type);\n});\n\nconsole.log(\"[JS] Submit the form! ‚è≥\");\nsetTimeout(() => {\n  form.dispatchEvent(\"submit\");\n  console.log(\"[JS] Final HTML: \", document.body.innerHTML);\n}, 1000);\n\n// --------------------------------------------------------------------\n// Simple reactive object\n// --------------------------------------------------------------------\n\nfunction createReactiveObject(target, callback) {\n  return new Proxy(target, {\n    set(obj, prop, value) {\n      const oldValue = obj[prop];\n      obj[prop] = value;\n\n      // Trigger callback on change\n      if (oldValue !== value) {\n        const prop_id = prop === \"name\" ? \"#1\" : prop === \"age\" ? \"#2\" : null;\n        document.querySelector(prop_id).setContentAsText(value); // Normal DOM update\n        callback(prop, oldValue, value);\n      }\n\n      return true;\n    },\n\n    get(obj, prop) {\n      return obj[prop];\n    },\n  });\n}\n\n// Instantiate the data and update the DOM\nconst data = { name: \"John\", age: 30 };\ndocument.querySelector(\"#1\").setContentAsText(data.name);\ndocument.querySelector(\"#2\").setContentAsText(data.age);\nconsole.log(\"[JS] Direct DOM update: \", document.body.innerHTML);\n\n// Reactive function\nconst reactiveData = createReactiveObject(data, (prop, oldVal, newVal) => {\n  console.log(\"[JS] reaction:\", document.body.innerHTML);\n});\n\n// 1. First reaction via property change\nreactiveData.name = \"Jane\";\n\n// Second reaction trigger via Event Listener to change age\nbtn.addEventListener(\"click\", (e) => {\n  console.log(\"[JS] ‚ö°Ô∏è Button Clicked! Event Type:\", e.type);\n  reactiveData.age *= 2;\n});\n\nconsole.log(\"[JS] Click the button! ‚úÖ\");\nbtn.dispatchEvent(\"click\");\n```\n\nThe output:\n\n```txt\n[JS] Initial document <form><button></button></form><ul><li id=\"1\">Item 10</li><li id=\"2\">Item 20</li></ul>\n\n[JS] Direct DOM injection:  <form><button></button></form><ul><li id=\"1\">John</li><li id=\"2\">30</li></ul>\n\n[JS] Reaction: change 'name' <form><button></button></form><ul><li id=\"1\">Jane</li><li id=\"2\">30</li></ul>\n\n[JS] Click the button! ‚úÖ\n[JS] ‚ö°Ô∏è Button Clicked! Event Type: click\n[JS] Reaction: change 'age' <form><button></button></form><ul><li id=\"1\">Jane</li><li id=\"2\">60</li></ul>\n\n[JS] Submit the form! ‚è≥\n[JS] ‚åõÔ∏è üìù Form Submitted! Event Type: submit\n[JS] Final HTML:  <form><button></button></form><ul><li id=\"1\">Jane</li><li id=\"2\">60</li></ul>\n\n[Zig-serialized-DOM-string]\n<html>\n  <head>\n  </head>\n  <body>\n    <form>\n      <button>\n      </button>\n    </form>\n    <ul>\n      <li id=\"1\">\n        \"Jane\"\n      </li>\n      <li id=\"2\">\n        \"60\"\n      </li>\n    </ul>\n  </body>\n</html>\n```\n\nAnd the Zig code to run this snippet:\n\n```zig\n    const engine = try ScriptEngine.init(allocator);\n    defer engine.deinit();\n\n    const source = try std.fs.cwd().readFileAlloc(allocator, \"js/dom_event_listener.js\", 1024);\n    defer allocator.free(source);\n\n    const c_source = try allocator.dupeZ(u8, source);\n    defer allocator.free(c_source);\n\n    const val = try engine.evalModule(c_source, \"dom_event_listener.js\");\n\n    engine.ctx.freeValue(val);\n\n    // Run Main Loop (Handles Events)\n    try engine.run();\n\n    const body_node = z.documentRoot(engine.dom.doc);\n    try z.prettyPrint(allocator, body_node.?);\n```\n\n**Import JavaScript libraries**: `es-toolkit`\n\nDownload the `es-toolikt` library:\n\n```sh\n curl -L https://cdn.jsdelivr.net/npm/es-toolkit@1.43.0/+esm  -o es-toolkit.min.js\n```\n\nThe JavaScript module _js/import_test.js_:\n\n```js\nimport * as Module from \"js/vendor/es-toolkit.min.js\";\n\nconsole.log(\"\\n[JS] üöÄ Testing external library: es-toolkit\\n\");\nconsole.log(\n  \"\\nimport ESM module: https://cdn.jsdelivr.net/npm/es-toolkit@1.43.0/+esm \\n\"\n);\nconsole.log(Object.keys(Module).join(\", \"));\nconsole.log(\"\\n\");\n\n// 1. Test 'mean' function\nconst numbers = [10, 50, 5, 100, 2];\nconst m = Module.mean(numbers);\nconsole.log(`[JS] ‚úÖ Mean value is: ${m}\\n`);\n\n// 2. Test 'chunk' function\nconst list = [1, 2, 3, 4, 5, 6];\nconst chunks = Module.chunk(list, 2);\nconsole.log(`[JS] ‚úÖ Chunked array: ${JSON.stringify(chunks)}`);\n// Should be [[1,2], [3,4], [5,6]]\n```\n\nThe output is:\n\n```txt\n[JS] üöÄ Testing external library: es-toolkit\n\n\nimport ESM module: https://cdn.jsdelivr.net/npm/es-toolkit@1.43.0/+esm\n\nAbortError, Mutex, Semaphore, TimeoutError, after, ary, ... zip, zipObject, zipWith\n\n\n[JS] ‚úÖ Mean value is: 33.4\n\n[JS] ‚úÖ Chunked array: [[1,2],[3,4],[5,6]]\n-----------------------------------------\n```\n\nThe Zig code ot run this:\n\n```zig\nfn importModule(allocator: std.mem.Allocator) !void {\n    const engine = try ScriptEngine.init(allocator);\n    defer engine.deinit();\n\n    const source = std.fs.cwd().readFileAlloc(\n        allocator,\n        \"js/import_test.js\",\n        1024 * 1024,\n    ) catch |err| {\n        z.print(\"Error: Could not  find 'js/import_test.js'\\n\", .{});\n        return err;\n    };\n\n    defer allocator.free(source);\n\n    const c_source = try allocator.dupeZ(u8, source);\n    defer allocator.free(c_source);\n\n    // 2. Evaluate as Module\n    // Our loader will see 'import ... from \"js/vendor/es-toolkit.min.js\"'\n    // and automatically load that file too.\n    const val = try engine.evalModule(c_source, \"import_test.js\");\n    defer engine.ctx.freeValue(val);\n\n    // Imports are resolved asynchronously\n    try engine.run();\n}\n```\n\n**Worker**\n\n```mermaid\nsequenceDiagram\n    participant MainJS as Main JS\n    participant MainZig as Zig (Main)\n    participant WorkerZig as Zig (Worker)\n    participant WorkerJS as Worker JS\n\n    Note over MainJS, WorkerJS: 1. Main sends message (Action)\n    MainJS->>MainZig: worker.postMessage(\"hello\")\n    Note right of MainJS: Calls C function js_Worker_postMessage\n    MainZig->>WorkerZig: Mailbox Send\n\n    Note over MainJS, WorkerJS: 2. Worker receives message (Reaction)\n    WorkerZig->>WorkerZig: Loop detects message\n    WorkerZig->>WorkerJS: CALLS global.onmessage(\"hello\")\n    Note right of WorkerZig: Looks up property \"onmessage\"\n```\n\n### DOM API integration\n\nThis project exposes a significant / essential subset of all available `lexbor` functions:\n\n- DOM parser engine (document or fragment context-aware)\n- CSS cascade stylesheet(s) and inline CSS (CSS-in-JS)\n- streaming and chunk processing\n- Serialization\n- Sanitization\n- CSS selectors search with cached CSS selectors parsing\n- Support of `<template>` elements.\n- Attribute search\n- DOM manipulation\n- DOM / HTML-string normalization with options (remove comments, whitespace, empty nodes)\n- Pretty printing\n\n### `lexbor` DOM memory management: Document Ownership and zero-copy functions\n\nIn `lexbor`, nodes belong to documents, and the document acts as the memory manager.\n\nWhen a node is attached to a document (either directly or through a fragment that gets appended), the document owns it.\n\nEvery time you create a document, you need to call `destroyDocument()`: it automatically destroys ALL nodes that belong to it.\n\nWhen a node is NOT attached to any document, you must manually destroy it.\n\nSome functions borrow memory from `lexbor` for zero-copy operations: their result is consumed immediately.\n\nWe opted for the following convention: add `_zc` (for _zero_copy_) to the **non allocated** version of a function. For example, you can get the qualifiedName of an HTMLElement with the allocated version `qualifiedName(allocator, node)` or by mapping to `lexbor` memory with `qualifiedName_zc(node)`. The non-allocated must be consumed immediately whilst the allocated result can outlive the calling function.\n\n### **The Event Loop**\n\n```mermaid\ngraph TD\n    %% Nodes\n    Start((Loop Start)) --> SignalCheck{Ctrl+C?}\n    SignalCheck -- Yes --> Exit\n    SignalCheck -- No --> Microtasks1\n\n    subgraph \"Phase 1: Microtasks (High Priority)\"\n    Microtasks1[Flush Pending Jobs]\n    note1[Executes all .then callbacks]\n    end\n\n    Microtasks1 --> ExitCheck{Can Exit?}\n    ExitCheck -- Empty Queue & No Timers --> Exit\n    ExitCheck -- Active --> Timers\n\n    subgraph \"Phase 2: Timers (Macrotask)\"\n    Timers[Check Timers]\n    note2[Did a timer fire?]\n    end\n\n    Timers -- Yes! Fired one --> Start\n    Timers -- No, all waiting --> Workers\n\n    subgraph \"Phase 3: Native Workers (Macrotask)\"\n    Workers[Check Worker Queue]\n    note3[Did a thread finish?]\n    end\n\n    Workers -- Yes! Task Resolved --> Start\n    Workers -- No, queue empty --> Sleep\n\n    subgraph \"Phase 4: Idle\"\n    Sleep[Sleep for Min Timer, 10ms]\n    end\n\n    Sleep --> Start\n\n    %% Styling\n    style Microtasks1 fill:#f96,stroke:#333,stroke-width:2px\n    style Start fill:#bbf,stroke:#333\n    style Exit fill:#f66,stroke:#333\n```\n\n---\n\n## Install\n\n[![Zig support](https://img.shields.io/badge/Zig-0.15.1-color?logo=zig&color=%23f3ab20)](http://github.com/ndrean/z-html)\n\n```sh\nzig fetch --save https://github.com/ndrean/zexplorer/archive/main.tar.gz\n```\n\nIn your _build.zig_:\n\n```zig\nconst zexplorer = b.dependency(\"zexplorer\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"zexplorer\", zexplorer.module(\"zexplorer\"));\n```\n\n## Example: Create document and parse\n\nYou have a few methods available.\n\n1. You  create a document with `createDocument()` and populate it with `inserHTML(doc, html)`\n2. The `parseHTML(allocator, \"\")` creates a `<head>` and a `<body>` element and replaces BODY innerContent with the nodes created by the parsing of the given string.\n3. The engine `doc  = DOMParser.parseFromString()`\n\n```zig\nconst z = @import(\"zexplorer\");\nconst allocator = std.testing.allocator;\n\nconst doc: *HTMLDocument = try z.createDocument();\ndefer z.destroyDocument(doc);\n\ntry z.insertHTML(doc, \"<div></div>\");\nconst body: *DomNode = z.bodyNode(doc).?;\n\n// you can create programmatically and append elements to a node\nconst p: *HTMLElement = try z.createElement(doc, \"p\");\nz.appendChild(body, z.elementToNode(p));\n```\n\nYour document now contains this HTML:\n\n```html\n<head></head>\n<body>\n  <div></div>\n  <p></p>\n</body>\n```\n\n[TODO] Ref in examples\n\n---\n\n## Example: scrap the web and explore a page\n\n```zig\ntest \"scrap example.com\" {\n  const allocator = std.testing.allocator;\n\n  const page = try z.get(allocator, \"https://example.com\");\n  defer allocator.free(page);\n\n  const doc = try z.parseHTML(allocator, page);\n  defer z.destroyDocument(doc);\n\n  const html = z.documentRoot(doc).?;\n  try z.prettyPrint(allocator, html); // see image below\n\n  var css_engine = try z.createCssEngine(allocator);\n  defer css_engine.deinit();\n\n  const a_link = try css_engine.querySelector(html, \"a[href]\");\n\n  const href_value = z.getAttribute_zc(z.nodeToElement(a_link.?).?, \"href\").?;\n  std.debug.z.print(\"\\n{s}\\n\", .{href_value}); // result below\n\n  var css_content: []const u8 = undefined;\n  const style_by_css = try css_engine.querySelector(html, \"style\");\n\n  if (style_by_css) |style| {\n      css_content = z.textContent_zc(style);\n      z.print(\"\\n{s}\\n\", .{css_content}); // see below\n  }\n\n  // alternative search by DOM traverse\n  const style_by_walker = z.getElementByTag(html, .style);\n  if (style_by_walker) |style| {\n      const css_content_walker = z.textContent_zc(z.elementToNode(style));\n      std.debug.assert(std.mem.eql(u8, css_content, css_content_walker));\n  }\n}\n```\n\n---\n\nYou will get a colourful print in your terminal, where the attributes, values, html elements get coloured.\n\n<details><summary> HTML content of example.com</summary>\n\n<img width=\"965\" height=\"739\" alt=\"Screenshot 2025-09-09 at 13 54 12\" src=\"https://github.com/user-attachments/assets/ff770cdb-95ab-468b-aa5e-5bbc30cf6649\" />\n\n</details>\n\nYou will also see the value of the `href` attribute of a the first `<a>` link:\n\n```txt\n https://www.iana.org/domains/example\n ```\n\n<details>\n<summary>You will then see the text content of the STYLE element (no CSS parsing):</summary>\n\n```css\nbody {\n    background-color: #f0f0f2;\n    margin: 0;\n    padding: 0;\n    font-family: -apple-system, system-ui, BlinkMacSystemFont, \"Segoe UI\", \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n    \n}\ndiv {\n    width: 600px;\n    margin: 5em auto;\n    padding: 2em;\n    background-color: #fdfdff;\n    border-radius: 0.5em;\n    box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);\n}\na:link, a:visited {\n    color: #38488f;\n    text-decoration: none;\n}\n@media (max-width: 700px) {\n    div {\n        margin: 0 auto;\n        width: auto;\n    }\n}\n```\n\n</details>\n\n---\n\n## HTMX Server-Side Rendering with Template Interpolation\n\nThis example demonstrates high-performance server-side rendering with `HTMX` integration and template interpolation, achieving 280K+ operations per second.\n\nThe rendering is _stateless_. The state is server-side driven, maintained in a database.\n\nThere is no need for a templating langugage: using multiline strings and loops or conditionals is largely enough to build HTML strings, and faster.\n\n<details><summary>Fake HTML page</summary>\n\n```zig\nconst blog_html =\n    \\\\<!DOCTYPE html>\n    \\\\<html lang=\"en\">\n    \\\\  <head>\n    \\\\    <meta charset=\"UTF-8\"/>\n    \\\\    <title>HTMX Blog - High Performance Server Rendering</title>\n    \\\\    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\n    \\\\    <script src=\"https://unpkg.com/htmx.org@1.9.6\"></script>\n    \\\\    <style>\n    \\\\      .blog-post { margin: 2rem 0; padding: 1.5rem; border: 1px solid #ddd; \n}\n    \\\\      .post-title { color: #333; font-size: 1.5rem; cursor: pointer; }\n    \\\\      .post-title:hover { color: #0066cc; }\n    \\\\      .post-meta { color: #666; font-size: 0.9rem; margin: 0.5rem 0; }\n    \\\\      .post-actions { margin-top: 1rem; }\n    \\\\      .post-actions button { margin-right: 0.5rem; padding: 0.25rem 0.5rem; \n}\n    \\\\    </style>\n    \\\\  </head>\n    \\\\  <body>\n    \\\\    <main class=\"content\">\n    \\\\      <article class=\"blog-post\" data-post-id=\"{post_id}\">\n    \\\\        <header class=\"post-header\">\n    \\\\          <h2 class=\"post-title\" hx-get=\"/posts/{post_id}/edit\" \nhx-target=\"#edit-modal\">\n    \\\\            {title_template}\n    \\\\          </h2>\n    \\\\          <div class=\"post-meta\">\n    \\\\            <span class=\"author\">{author_name}</span>\n    \\\\            <time datetime=\"2024-01-01\">{publish_date}</time>\n    \\\\            <span class=\"views\" hx-get=\"/posts/{post_id}/views\"\nhx-trigger=\"revealed\">\n    \\\\              {view_count} views\n    \\\\            </span>\n    \\\\          </div>\n    \\\\        </header>\n    \\\\\n    \\\\        <div class=\"post-content\">\n    \\\\          <p>Welcome {user_name}! This demonstrates high-performance HTMX\nserver-side rendering with Zig.</p>\n    \\\\          <p>Current user: <strong>{user_name}</strong>, Post ID:\n<strong>{post_id}</strong></p>\n    \\\\        </div>\n    \\\\\n    \\\\        <footer class=\"post-actions\">\n    \\\\          <button hx-post=\"/posts/{post_id}/like\" hx-swap=\"innerHTML\">\n    \\\\            ‚ù§Ô∏è {like_count}\n    \\\\          </button>\n    \\\\          <button hx-get=\"/posts/{post_id}/comments\"\nhx-target=\"#comments-{post_id}\">\n    \\\\            üí¨ {comment_count}\n    \\\\          </button>\n    \\\\          <button hx-delete=\"/posts/{post_id}\" hx-confirm=\"Delete this\npost?\" hx-target=\"closest .blog-post\">\n    \\\\            üóëÔ∏è Delete\n    \\\\          </button>\n    \\\\        </footer>\n    \\\\      </article>\n    \\\\    </main>\n    \\\\  </body>\n    \\\\</html>\n;\n```\n\n</details>\n\n---\n\nThe code below parses the whole HTML delivered when the client connects, and starts the parser and css engine.\n\nWhen the webserver receives an HTMX request, the server returns a serialized updated HTML string.\n\n```zig\nconst std = @import(\"std\");\nconst z = @import(\"zexplorer\");\n\npub fn main() !void {\n    const gpa = std.heap.c_allocator;\n\n    // One-time setup (server startup)\n    const doc = try z.parseHTML(gpa, blog_html);\n    defer z.destroyDocument(doc);\n\n    var css_engine = try z.createCssEngine(allocator);\n    defer css_engine.deinit();\n\n    var parser = try z.Parser.init(allocator);\n    defer parser.deinit();\n\n    // 1. start the webserver: not implemented\n    // 2. Simulate handling requests received by the webserver\n    try requestHandler(gpa, doc, &css_engine, &parser);\n}\n\n// an example: tailored for each request\nfn requestHandler(\n    allocator: std.mem.Allocator,\n    doc: *z.HTMLDocument,\n    css_engine: *z.CssSelectorEngine,\n    parser: *z.Parser,\n) !void {\n\n    // 1. Target elements with CSS selectors\n    const title_elements = try css_engine.querySelectorAll(allocator, doc, \".post-title\");\n    defer allocator.free(title_elements);\n\n    if (title_elements.len > 0) {\n        // 2. Clone element for modification (original DOM stays pristine)\n        const cloned_title = z.cloneNode(z.elementToNode(title_elements[0])).?;\n        defer z.destroyNode(cloned_title);\n\n        // 3. Template interpolation with curly brackets after reading the db or kv store\n        const template = \"{user_name}'s Blog Post #{post_id}: {title}\";\n        var content = try interpolateTemplate(allocator, template, \"user_name\",\n\"Mr Magoo\");\n        defer allocator.free(content);\n\n        const post_id_str = try std.fmt.allocPrint(allocator, \"{}\", .{42});\n        defer allocator.free(post_id_str);\n\n        const temp = try interpolateTemplate(allocator, content, \"post_id\",\npost_id_str);\n        defer allocator.free(temp);\n\n        const final_content = try interpolateTemplate(allocator, temp, \"title\",\n\"HTMX Performance\");\n        defer allocator.free(final_content);\n\n        // 4. Update element content and HTMX attributes\n        _ = try z.setInnerHTML(z.nodeToElement(cloned_title).?, final_content);\n\n        // Interpolate HTMX attributes dynamically\n        const hx_get_value = try interpolateTemplate(allocator,\n\"/posts/{post_id}/edit\", \"post_id\", post_id_str);\n        defer allocator.free(hx_get_value);\n        _ = z.setAttribute(z.nodeToElement(cloned_title).?, \"hx-get\",\nhx_get_value);\n\n        // 5. Serialize modified element (ready to send to client)\n        const response_html = try z.outerHTML(allocator,\nz.nodeToElement(cloned_title).?);\n        defer allocator.free(response_html);\n\n        // POST back to the client\n        std.debug.print(\"HTMX Response: {s}\\n\", .{response_html});\n        // Output: <h2 class=\"post-title\" hx-get=\"/posts/42/edit\">M. Magoo's Blog\nPost #42: HTMX Performance</h2>\n    }\n}\n\n// Template interpolation helper - replaces {key} with values\nfn interpolateTemplate(\n    allocator: std.mem.Allocator, \n    template: []const u8, \n    key: []const u8, \n    value: []const u8) ![]u8 {\n    const placeholder = try std.fmt.allocPrint(allocator, \"{{{s}}}\", .{key});\n    defer allocator.free(placeholder);\n\n    // Count occurrences for efficient pre-allocation\n    var count: usize = 0;\n    var pos: usize = 0;\n    while (std.mem.indexOf(u8, template[pos..], placeholder)) |found| {\n        count += 1;\n        pos += found + placeholder.len;\n    }\n\n    if (count == 0) return try allocator.dupe(u8, template);\n\n    // Pre-allocate and replace all occurrences\n    const new_size = template.len + (value.len * count) - (placeholder.len *\ncount);\n    var result = try std.ArrayList(u8).initCapacity(allocator, new_size);\n\n    pos = 0;\n    while (std.mem.indexOf(u8, template[pos..], placeholder)) |found| {\n        const actual_pos = pos + found;\n        try result.appendSlice(allocator, template[pos..actual_pos]);\n        try result.appendSlice(allocator, value);\n        pos = actual_pos + placeholder.len;\n    }\n    try result.appendSlice(allocator, template[pos..]);\n\n    return result.toOwnedSlice(allocator);\n}\n```\n\n---\n\n## Example: scan a page for potential malicious content\n\nThe intent is to highlight potential XSS threats. It works by parsing the string into a fragment. When a HTMLElement gets an unknown attribute, its colour is white and the attribute value is highlighted in RED.\n\nLet's parse and print the following HTML string:\n\n```html\nconst html_string = \n    <div>\n    <!-- a comment -->\n    <button disabled hidden onclick=\"alert('XSS')\" phx-click=\"increment\" data-invalid=\"bad\" scope=\"invalid\">Dangerous button</button>\n    <img src=\"javascript:alert('XSS')\" alt=\"not safe\" onerror=\"alert('hack')\" loading=\"unknown\">\n    <a href=\"javascript:alert('XSS')\" target=\"_self\" role=\"invalid\">Dangerous link</a>\n    <p id=\"valid\" class=\"good\" aria-label=\"ok\" style=\"bad\" onload=\"bad()\">Mixed attributes</p>\n    <custom-elt><p>Hi there</p></custom-elt>\n    <template><span>Reuse me</span></template>\n    </div>\n```\n\nYou parse this HTML string:\n\n```zig\nconst doc = try z.parseHTML(allocator, html_string);\ndefer z.destroyDocument(doc);\n\nconst body = z.bodyNode(doc).?;\ntry z.prettyPrint(allocator, body);\n```\n\nYou get the following output in your terminal.\n\n---\n\n<img width=\"931\" height=\"499\" alt=\"Screenshot 2025-09-09 at 16 08 19\" src=\"https://github.com/user-attachments/assets/45cfea8b-73d9-401e-8c23-457e0a6f92e1\" />\n\n---\n\nWe can then run a _sanitization_ process against the DOM, so you get a context where the attributes are whitelisted.\n\n```zig\ntry z.sanitizeNode(allocator, body, .permissive);\ntry z.prettyPrint(allocator, body);\n```\n\nThe result is shown below.\n\n<img width=\"900\" height=\"500\" alt=\"Screenshot 2025-09-09 at 16 11 30\" src=\"https://github.com/user-attachments/assets/ff7fa678-328b-495a-8a81-2ff465141be3\" />\n\n---\n\n## Example: using the parser with sanitization option\n\nYou can create a sanitized document with the parser (a ready-to-use parsing engine).\n\n```c\nvar parser = try z.DOMParser.init(testing.allocator);\ndefer parser.deinit();\n\nconst doc = try parser.parseFromString(html, .none);\ndefer z.destroyDocument(doc);\n```\n\n---\n\n## Example: Processing streams\n\nYou receive chunks and build a document.\n\n```zig\nconst z = @import(\"zexplorer\");\nconst print = std.debug.print;\n\nfn demoStreamParser(allocator: std.mem.Allocator) !void {\n\n    var streamer = try z.Stream.init(allocator);\n    defer streamer.deinit();\n\n    try streamer.beginParsing();\n\n    const streams = [_][]const u8{\n        \"<!DOCTYPE html><html><head><title>Large\",\n        \" Document</title></head><body>\",\n        \"<table id=\\\"producttable\\\">\",\n        \"<caption>Company data</caption><thead>\",\n        \"<tr><th scope=\\\"col\\\">\",\n        \"Code</th><th>Product_Name</th>\",\n        \"</tr></thead><tbody>\",\n    };\n    for (streams) |chunk| {\n        z.print(\"chunk:  {s}\\n\", .{chunk});\n        try streamer.processChunk(chunk);\n    }\n\n    for (0..2) |i| {\n        const li = try std.fmt.allocPrint(\n            allocator,\n            \"<tr id={}><th >Code: {}</th><td>Name: {}</td></tr>\",\n            .{ i, i, i },\n        );\n        defer allocator.free(li);\n        z.print(\"chunk:  {s}\\n\", .{li});\n\n        try streamer.processChunk(li);\n    }\n    const end_chunk = \"</tbody></table></body></html>\";\n    z.print(\"chunk:  {s}\\n\", .{end_chunk});\n    try streamer.processChunk(end_chunk);\n    try streamer.endParsing();\n\n    const html_doc = streamer.getDocument();\n    defer z.destroyDocument(html_doc);\n    const html_node = z.documentRoot(html_doc).?;\n\n    z.print(\"\\n\\n\", .{});\n    try z.prettyPrint(allocator, html_node);\n    z.print(\"\\n\", .{});\n    try z.printDocStruct(html_doc);\n}\n```\n\nYou get the output:\n\n```txt\nchunk:  <!DOCTYPE html><html><head><title>Large\nchunk:   Document</title></head><body>\nchunk:  <table id=\"producttable\">\nchunk:  <caption>Company data</caption><thead>\nchunk:  <tr><th scope=\"col\">Items</th><th>\nchunk:  Code</th><th>Product_Name</th>\nchunk:  </tr></thead><tbody>\nchunk:  <tr id=0><th >Code: 0</th><td>Name: 0</td></tr>\nchunk:  <tr id=1><th >Code: 1</th><td>Name: 1</td></tr>\nchunk:  </tbody></table></body></html>;\n```\n\n<p align=\"center\">\n  <img src=\"https://github.com/ndrean/z-html/blob/main/images/html-table.png\" width=\"300\" alt=\"image\"/>\n  <img src=\"https://github.com/ndrean/z-html/blob/main/images/tree-table.png\" width=\"300\" alt=\"image\"/>\n</p>\n\n---\n\n## Example: Search examples and attributes and classList DOMTOkenList like\n\nWe have two types of search available, each with different behaviors and use cases:\n\n```html\nconst html = \n    <div class=\"main-container\">\n        <h1 class=\"title main\">Main Title</h1>\n        <section class=\"content\">\n        <p class=\"text main-text\">First paragraph</p>\n        <div class=\"box main-box\">Box content</div>\n        <article class=\"post main-post\">Article content</article>\n        </section>\n        <aside class=\"sidebar\">\n            <h2 class=\"subtitle\">Sidebar Title</h2>\n            <p class=\"text sidebar-text\">Sidebar paragraph</p>\n            <div class=\"widget\">Widget content</div>\n        </aside>\n        <footer class=\"main-footer\" aria-label=\"foot\">\n        <p class=\"copyright\">¬© 2024</p>\n        </footer>\n    </div>\n```\n\nA CSS Selector search and some walker search and attributes:\n\n```zig\nconst doc = try z.createDocFromString(html);\ndefer z.destroyDocument(doc);\nconst body = z.bodyNode(doc).?;\n\nvar css_engine = try z.createCssEngine(allocator);\ndefer css_engine.deinit();\n\nconst divs = try css_engine.querySelectorAll(body, \"div\");\nstd.debug.assert(divs.len == 3);\n\nconst p1 = try css_engine.querySelector(body, \"p.text\");\nconst p_elt = z.nodeToElement(p1.?).?;\nconst cl_p1 = z.classList_zc(p_elt);\n\nstd.debug.assert(std.mem.eql(u8, \"text main-text\", cl_p1));\n\nconst p2 = z.getElementByClass(body, \"text\").?;\nconst cl_p2 = z.classList_zc(p2);\nstd.debug.assert(std.mem.eql(u8, cl_p1, cl_p2));\n\nconst footer = z.getElementByAttribute(body, \"aria-label\").?;\nconst aria_value = z.getAttribute_zc(footer, \"aria-label\").?;\nstd.debug.assert(std.mem.eql(u8, \"foot\", aria_value));\n```\n\nWorking the `classList` like a DOMTokenList\n\n```zig\nvar footer_token_list = try z.ClassList.init(allocator, footer);\ndefer footer_token_list.deinit();\n\ntry footer_token_list.add(\"new-footer\");\nstd.debug.assert(footer_token_list.contains(\"new-footer\"));\n\n_ = try footer_token_list.toggle(\"new-footer\");\nstd.debug.assert(!footer_token_list.contains(\"new-footer\"));\n```\n\n## Other examples in _main.zig_\n\nThe file _main.zig_ shows more use cases with parsing and serialization as well as the tests  (`setInnerHTML`, `setInnerSafeHTML`, `insertAdjacentElement` or `insertAdjacentHTML`...)\n\n---\n\n## Building the lib\n\n- `lexbor` is built with static linking\n\n```sh\nLEXBOR_VERSION=2.7 LEXBOR_DIR=vendor/lexbor_master  make -f Makefile.lexbor\n```\n\n- tests: The _build.zig_ file runs all the tests from _root.zig_. It imports all the submodules and runs the tests.\n\n```sh\nzig build test --summary all\n```\n\n- run the demo in the __main.zig_ demo with:\n\n```sh\nzig build run -Doptimize=ReleaseFast\n```\n\n- Use the library: check _LIBRARY.md_.\n\n---\n\n### Notes\n\n#### url hash\n\nExample:\n\n```sh\ncurl -s https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css | openssl dgst -sha384 -binary | base64 \n```\n\n#### on search in `lexbor` source/examples\n\n<https://github.com/lexbor/lexbor/tree/master/examples/lexbor>\n\nOnce you build `lexbor`, you have the static object located at _/lexbor_src_master/build/liblexbor_static.a_.\n\nTo check which primitives are exported, you can use:\n\n```sh\nnm vendor/lexbor_src_master/build/liblexbor_static.a | grep \" T \" | grep -i \"serialize\"\n```\n\nDirectly in the source code:\n\n```sh\nfind vendor/lexbor_src_master/source -name \"*.h\" | xargs grep -l \"lxb_html_seralize_tree_cb\"\n\ngrep -r \"lxb_html_serialize_tree_cb\" vendor/lexbor_src_master/source/lexbor/\n```\n\n## License\n\n- `lexbor` [License Apache 2.0](https://github.com/lexbor/lexbor/blob/master/LICENSE)\n- `quickjs` [License MIT](https://github.com/quickjs-ng/quickjs/blob/master/LICENSE)\n- `zig-quickjs` [License MIT](https://github.com/nDimensional/zig-quickjs/blob/main/LICENSE)\n- `zig-curl` [License MIT](https://github.com/jiacai2050/zig-curl/blob/main/LICENSE)\n\n---\n\n## COCOMO analysis\n\n<https://github.com/boyter/scc>\n\n```txt\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nLanguage            Files       Lines    Blanks  Comments       Code Complexity\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nZig                   120      64,448     5,480     6,105     52,863      9,450\nJavaScript             23       2,459       253       165      2,041        205\nHTML                   20       5,190       494       152      4,544          0\nMarkdown                5       2,662       647         0      2,015          0\nJSON                    3          32         0         0         32          0\nC                       1         210        34        39        137         29\nLicense                 1          21         4         0         17          0\nPlain Text              1         332        57         0        275          0\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nTotal                 174      75,354     6,969     6,461     61,924      9,684\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nEstimated Cost to Develop (organic) $2,056,114\nEstimated Schedule Effort (organic) 18.09 months\nEstimated People Required (organic) 10.10\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nProcessed 3039412 bytes, 3.039 megabytes (SI)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6793008?u=f81c36d15847387f1389fbe3edda20d815ef5e0e&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "ÌîÑÎûëÏä§",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 35,
  "owner_following": 142,
  "owner_created_at": "2014-02-26T11:25:23Z",
  "homepage": "https://ndrean.github.io/zexplorer",
  "license": "MIT",
  "category": "library"
}