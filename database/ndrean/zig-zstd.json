{
  "name": "zig-zstd",
  "owner": "ndrean",
  "repo": "zig-zstd",
  "description": "Zig wrapper of zstandard",
  "type": "package",
  "topics": [
    "zig",
    "zig-package"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-10-14T08:37:30Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# z-std\n\n![Zig support](https://img.shields.io/badge/Zig-0.15.1-color?logo=zig&color=%23f3ab20)\n\nA Zig wrapper for the Zstandard (zstd) compression library, licensed under GPL2.\n\nThis module provides idiomatic Zig bindings to the zstd C library using the C ABI (`extern \"c\"`), offering a clean, simplified API with flexible configuration.\n\n**Goal**: Build a standalone, well-documented library wrapping zstd functionality with Zig's memory safety and error handling.\n\n## Architecture\n\nThis library uses:\n\n- **C ABI interop**: Direct `extern \"c\"` function declarations to call zstd functions\n- **Static linking**: Links against `libzstd.a` built from source\n- **Zero-cost abstractions**: Thin Zig wrappers that add type safety and error handling without runtime overhead\n\n## Features\n\n- **Context-based API**: Simple compress/decompress with flexible configuration\n- **Streaming API**: Chunk-by-chunk compression for large files with multiple modes (continue, flush, end)\n- **Dictionary support**: Train dictionaries and use them for better compression of small similar files\n- **Compression recipes**: Optimized presets for different data types (fast, balanced, maximum, text, structured_data, binary)\n- **Memory control**: Optional memory limits for decompression contexts\n- **Context reuse**: Efficient reset functions for compressing multiple independent frames\n\n## Quick Start\n\n```zig\nconst z = @import(\"z_std\");\n\n// Initialize contexts\nconst cctx = try z.init_compressor(.{}); // uses balanced defaults (level 3, dfast)\ndefer _ = z.free_compressor(cctx);\n\nconst dctx = try z.init_decompressor(.{}); // no memory limit\ndefer _ = z.free_decompressor(dctx);\n\n// Compress and decompress\nconst compressed = try z.compress(allocator, cctx, data);\ndefer allocator.free(compressed);\n\nconst decompressed = try z.decompress(allocator, dctx, compressed); // auto-detects size\ndefer allocator.free(decompressed);\n```\n\n## Configuration Options\n\n### Compression Context\n\nUse `CompressionConfig` for flexible initialization:\n\n```zig\n// Use recipe defaults (recommended)\nconst cctx = try z.init_compressor(.{ .recipe = .text });\n// → level 9 + btopt algorithm\n\n// Override level while keeping recipe's algorithm\nconst cctx = try z.init_compressor(.{ .compression_level = 15, .recipe = .text });\n// → level 15 + btopt algorithm\n\n// Custom level with default algorithm\nconst cctx = try z.init_compressor(.{ .compression_level = 5 });\n// → level 5 + dfast algorithm\n\n// Use all defaults\nconst cctx = try z.init_compressor(.{});\n// → level 3 + dfast algorithm (balanced)\n```\n\n### Compression Recipes\n\nEach recipe provides optimized defaults for compression level and ZSTD algorithm:\n\n- **`.fast`** - Fastest compression (level 1, fast algorithm)\n- **`.balanced`** - Good balance (level 3, dfast algorithm, **default**)\n- **`.maximum`** - Maximum compression (level 22, btultra2 algorithm)\n- **`.text`** - Optimized for text/code (level 9, btopt algorithm)\n- **`.structured_data`** - Optimized for JSON/XML (level 9, btultra algorithm)\n- **`.binary`** - Optimized for binary data (level 6, lazy2 algorithm)\n\n### Decompression Context\n\nUse `DecompressionConfig` for optional memory limits:\n\n```zig\n// Use defaults (no memory limit)\nconst dctx = try z.init_decompressor(.{});\n\n// Limit memory usage (window log 20 = 1MB window)\nconst dctx = try z.init_decompressor(.{ .max_window_log = 20 });\n```\n\n## Advanced Examples\n\n### Context Reuse\n\nReuse contexts for better performance when compressing multiple items:\n\n```zig\nconst cctx = try z.init_compressor(.{ .recipe = .text });\ndefer _ = z.free_compressor(cctx);\n\nconst dctx = try z.init_decompressor(.{});\ndefer _ = z.free_decompressor(dctx);\n\n// Compress first item\nconst compressed1 = try z.compress(allocator, cctx, data1);\ndefer allocator.free(compressed1);\n\n// Reset and reuse for next item\ntry z.reset_compressor_session(cctx);\nconst compressed2 = try z.compress(allocator, cctx, data2);\ndefer allocator.free(compressed2);\n```\n\n### Streaming Compression\n\nFor large files, use streaming API with different modes:\n\n```zig\nconst cctx = try z.init_compressor(.{});\ndefer _ = z.free_compressor(cctx);\n\nvar compressed_buffer = try allocator.alloc(u8, output_size);\ndefer allocator.free(compressed_buffer);\nvar compressed_pos: usize = 0;\n\n// Process chunks\nwhile (reading_data) {\n    var in_buf = z.ZSTD_inBuffer{\n        .src = chunk.ptr,\n        .size = chunk.len,\n        .pos = 0,\n    };\n\n    const is_last = (no_more_data);\n    const end_op = if (is_last) z.ZSTD_EndDirective.ZSTD_e_end else z.ZSTD_EndDirective.ZSTD_e_continue;\n\n    while (in_buf.pos < in_buf.size or (is_last and end_op == .ZSTD_e_end)) {\n        var out_buf = z.ZSTD_outBuffer{\n            .dst = compressed_buffer.ptr + compressed_pos,\n            .size = compressed_buffer.len - compressed_pos,\n            .pos = 0,\n        };\n\n        const remaining = try z.compressStream(cctx, &out_buf, &in_buf, end_op);\n        compressed_pos += out_buf.pos;\n\n        if (is_last and remaining == 0) break;\n    }\n}\n```\n\n**EndDirective modes:**\n\n- **`ZSTD_e_continue`** - Buffer data for better compression (may produce no output)\n- **`ZSTD_e_flush`** - Force output for each chunk (for real-time streaming)\n- **`ZSTD_e_end`** - Finalize frame with footer/checksum\n\n### Dictionary Training and Usage\n\nTrain a dictionary from sample data for better compression of many small similar files:\n\n```zig\n// 1. Collect sample data\nconst samples = [_][]const u8{\n    \"{\\\"id\\\": 1, \\\"name\\\": \\\"Alice\\\", \\\"email\\\": \\\"alice@example.com\\\"}\",\n    \"{\\\"id\\\": 2, \\\"name\\\": \\\"Bob\\\", \\\"email\\\": \\\"bob@example.com\\\"}\",\n    \"{\\\"id\\\": 3, \\\"name\\\": \\\"Charlie\\\", \\\"email\\\": \\\"charlie@example.com\\\"}\",\n};\n\n// 2. Train dictionary (100KB target size)\nconst dictionary = try z.train_dictionary(allocator, &samples, 100 * 1024);\ndefer allocator.free(dictionary);\n\n// 3. Load dictionary into contexts for reuse\nconst cctx = try z.init_compressor(.{ .recipe = .structured_data });\ndefer _ = z.free_compressor(cctx);\ntry z.load_compression_dictionary(cctx, dictionary);\n\nconst dctx = try z.init_decompressor(.{});\ndefer _ = z.free_decompressor(dctx);\ntry z.load_decompression_dictionary(dctx, dictionary);\n\n// 4. Compress/decompress with loaded dictionary (more efficient for multiple operations)\nconst compressed = try z.compress(allocator, cctx, new_data);\ndefer allocator.free(compressed);\n\nconst decompressed = try z.decompress(allocator, dctx, compressed);\ndefer allocator.free(decompressed);\n\n// Alternative: One-shot compression with dictionary\nconst compressed_oneshot = try z.compress_with_dict(allocator, cctx, new_data, dictionary, 3);\ndefer allocator.free(compressed_oneshot);\n```\n\n## API Reference\n\n### Initialization Functions\n\n```zig\n// Compression context\npub fn init_compressor(config: CompressionConfig) !*ZSTD_CCtx\npub fn free_compressor(ctx: *ZSTD_CCtx) usize\n\n// Decompression context\npub fn init_decompressor(config: DecompressionConfig) !*ZSTD_DCtx\npub fn free_decompressor(ctx: *ZSTD_DCtx) usize\n```\n\n### Core Compression/Decompression\n\n```zig\n// One-shot operations\npub fn compress(allocator: Allocator, ctx: *ZSTD_CCtx, input: []const u8) ![]u8\npub fn decompress(allocator: Allocator, ctx: *ZSTD_DCtx, input: []const u8) ![]u8\n```\n\n### Context Management\n\n```zig\npub fn reset_compressor_session(ctx: *ZSTD_CCtx) !void\npub fn reset_decompressor_session(ctx: *ZSTD_DCtx) !void\n```\n\n### Streaming API\n\n```zig\npub fn compressStream(ctx: *ZSTD_CCtx, output: *ZSTD_outBuffer, input: *ZSTD_inBuffer, endOp: ZSTD_EndDirective) !usize\npub fn decompressStream(ctx: *ZSTD_DCtx, output: *ZSTD_outBuffer, input: *ZSTD_inBuffer) !usize\n\npub fn getStreamInSize() usize\npub fn getStreamOutSize() usize\npub fn getDecompressStreamInSize() usize\npub fn getDecompressStreamOutSize() usize\n```\n\n### Dictionary Support\n\n```zig\n// Train dictionary from samples\npub fn train_dictionary(allocator: Allocator, samples: []const []const u8, dict_size: usize) ![]u8\n\n// Load dictionary into context (efficient for multiple operations)\npub fn load_compression_dictionary(ctx: *ZSTD_CCtx, dictionary: []const u8) !void\npub fn load_decompression_dictionary(ctx: *ZSTD_DCtx, dictionary: []const u8) !void\n\n// One-shot compression/decompression with dictionary\npub fn compress_with_dict(allocator: Allocator, ctx: *ZSTD_CCtx, input: []const u8, dictionary: []const u8, level: i32) ![]u8\npub fn decompress_with_dict(allocator: Allocator, ctx: *ZSTD_DCtx, input: []const u8, dictionary: []const u8, output_size: usize) ![]u8\n```\n\n### Utilities\n\n```zig\npub fn get_decompressed_size(compressed: []const u8) !usize\npub fn version() []const u8\n```\n\n## Testing\n\nSee `src/main.zig` for comprehensive usage examples of all APIs, including:\n- Basic compression and decompression\n- Context reuse with different data types\n- Streaming compression and decompression\n- Compression recipes comparison\n- Dictionary training and usage\n- Memory-limited decompression\n\n## Building\n\n### 1. Build the zstd static library\n\nThe project uses a static archive of zstd (`libzstd.a`). Build it from the vendored source:\n\n```sh\nmake\n```\n\nThis invokes the Makefile which builds `vendor/zstd/libzstd.a`.\n\n### 2. Build the Zig wrapper\n\n```sh\nzig build\n```\n\nThe `build.zig` file:\n\n1. Runs `make` to ensure `libzstd.a` exists\n2. Links the static library via C ABI\n3. Produces `libz_zstd.a` (the Zig wrapper)\n\n### 3. Run tests\n\n```sh\nzig build test\n```\n\nThis runs all tests in `src/main.zig`, demonstrating each API.\n\n## References\n\n- [Zstandard API Documentation](https://facebook.github.io/zstd/doc/api_manual_latest.html)\n- [Zstandard GitHub](https://github.com/facebook/zstd)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6793008?u=f81c36d15847387f1389fbe3edda20d815ef5e0e&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "프랑스",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 35,
  "owner_following": 137,
  "owner_created_at": "2014-02-26T11:25:23Z",
  "homepage": "https://ndrean.github.io/zig-zstd",
  "category": "library"
}