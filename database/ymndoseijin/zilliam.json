{
  "name": "zilliam",
  "owner": "ymndoseijin",
  "repo": "zilliam",
  "description": "A Geometric Algebra library for Zig",
  "type": "package",
  "topics": [
    "3d-graphics",
    "clifford-algebras",
    "geometric-algebra",
    "zig",
    "zig-package"
  ],
  "stars": 36,
  "forks": 1,
  "watchers": 3,
  "updated_at": "2025-11-24T23:58:48Z",
  "dependencies": [
    {
      "name": "comath",
      "url": "https://github.com/InKryption/comath/archive/07fd1acfe20e05e260ede883b762c878e8724dac.tar.gz",
      "hash": "1220bbc10c8f8a4ed95e44a1e79b32caebc4ebb3ae952fe1341505be45f9d176ee11"
    }
  ],
  "readme": "# zilliam\n\nZilliam is a Geometric Algebra library that generates a SIMD optimized library for any given Cl(p,q,r) algebra. It can be used for:\n\n* PGA (projective geometric algebra, for which Zilliam has a special for generating all needed mask types) where you can easily construct points, lines and planes in any dimension and do projection, rotations, intersections and more between all of them under the same syntax. It has many uses for computer graphics and physics. It can also model conformal transformations using CGA.\n* Modelling complex numbers, quaternions, dual numbers and many more other Clifford algebras under a single interface, generating SIMD optimized code for all of them. This makes it possible to use Zilliam for automatic differentiation, complex analysis\n* Calculate Lorentz boosts and more using an STA (spacetime algebra) which also provides a very useful model for doing Electrodynamics work.\n\nFor all these applications, Zilliam gives you access to useful functions such as the trigonometric functions, the exponential and also useful concepts such as the Poincare dual and wedge operations. It also provides a sort of operation overloading through a [comath](https://github.com/InKryption/comath) interface, which allows you to evaluate complex expressions more easily and without much compile time cost.\n\nIt currently has the following operations (syntax for the eval function):\n- a*b: geo\n- ~a: reverse\n- a^b: wedge\n- a&b: regressive\n- *a: dual\n- a|b: inner product\n- #a: grade involution\n- a$k: grade projection\n- %a: undual\n\nIt generates SIMD operations for any generic Clifford algebra for all these operations, and for any generic type as well:\n\n```zig\nconst Alg = Algebra(i32, 2, 1, 1);\n\ntry std.testing.expectEqualSlices(\n    i32,\n    &(try Alg.eval(\"(14*e1) - (21*e2) - (7*e12) - 24\", .{})).val,\n    &(try Alg.eval(\"(2*e1+3*e2+5*e12) * (11*e1+13*e2+17*e12)\", .{})).val,\n);\n\ntry std.testing.expectEqualSlices(\n    i32,\n    &(try Alg.eval(\"109 + 654*e0 + 129*e1 + 127*e2 + 214*e12\", .{})).val,\n    &(try Alg.eval(\"(23*e0+2*e1+3*e2+5*e12+7) | (31*e0+11*e1+13*e2+17*e12+19)\", .{})).val,\n);\n```\n\nAs you can see, it also uses the amazing [comath](https://github.com/InKryption/comath) library to overload operations.\n\nIn the case where you know the grade of the multivectors you are working with (which is most practical cases), zilliam generates types for like k-vector plus the even subalgebra and dispatches among them.\n```zig\nconst Alg = Algebra(f32, 3, 0, 1);\nconst Blades = getBlades(Alg);\nconst Types = Blades.Types;\n\nconst Vector = Types[1];\nconst Bivector = Types[2];\nconst Trivector = Types[3];\n\npub fn main() !void {\n    const BivectorBatch = Bivector.getBatchType(2);\n    const VectorBatch = Vector.getBatchType(2);\n\n    for (0..Bivector.Count) |a_i| {\n        for (0..Vector.Count) |b_i| {\n            var a = BivectorBatch{};\n            var b = VectorBatch{};\n            a.val[a_i] = .{ 1, 2 };\n            b.val[b_i] = .{ 1, 2 };\n            var buf: [2048]u8 = undefined;\n\n            // This is a Trivector, it gets properly dispatched\n            const res = a.wedge(b);\n\n            for (0..2) |i| {\n                const r_w = res.get(i);\n\n                var r_s = try a.get(i).print(&buf);\n                std.debug.print(\"{s} ^ \", .{r_s});\n                r_s = try b.get(i).print(&buf);\n                std.debug.print(\"{s} = \", .{r_s});\n                r_s = try r_w.print(&buf);\n                std.debug.print(\"{s}\\n\", .{r_s});\n            }\n            std.debug.print(\"\\n\", .{});\n        }\n    }\n}\n\n// ...\n// 1.0000e13 ^ 1.0000e0 = 1.0000e013\n// 2.0000e13 ^ 2.0000e0 = 4.0000e013\n// ...\n```\n\nFor more examples and a guide for using Zilliam on your project, check the [wiki](https://github.com/ymndoseijin/zilliam/wiki/Examples).\n\n# Todo\n- Add more general utilities beyond just the PGA one and improve the calculation of functions\n- Eventually, hook it up to my graphics library to start doing visualizations (maybe something on par with ganja.js)\n\n# References\n- Thanks to [klein](https://github.com/jeremyong/klein) specially, who gave me the idea to generate SIMD operations and something to compare the generated code to.\n- Also thanks to the people at [biVector.net](https://bivector.net/index.html) and specially their [/tools](https://bivector.net/tools.html) page, whose tables and calculators helped me verifying the correctness of my own code.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/10215376?u=ddc8947ba94ec3663ecede945d53f47c4f8a8e1e&v=4",
  "releases": [],
  "owner_bio": "brazilian 20-something physics student who's interested in mathematics, linguistics, computers, 3D modelling and everything really.\r\n\r\n日伯英中羅西",
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 9,
  "owner_following": 9,
  "owner_created_at": "2014-12-17T01:35:54Z",
  "license": "MIT",
  "category": "library"
}