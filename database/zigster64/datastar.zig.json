{
  "name": "datastar.zig",
  "owner": "zigster64",
  "repo": "datastar.zig",
  "description": "Datastar SDK for zig 0.16",
  "type": "package",
  "topics": [
    "data-star",
    "datastar",
    "zig-package",
    "zig-library"
  ],
  "stars": 4,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-01-10T12:21:38Z",
  "dependencies": [
    {
      "name": "pubsub",
      "url": "git+https://github.com/zigster64/pubsub.zig#39a63b812a85106023dd086d109bcc9fc334661b",
      "hash": "pubsub-0.0.0-6dy2Ad9-AADIGIqYoxa7AAmOsIiMji7HZo0uVTJJflTd"
    }
  ],
  "minimum_zig_version": "0.16.0-dev.1912+0cbaaa5eb",
  "readme": "# Datastar lib for zig 0.16-dev\n\n![Cyberpunk Datastar Zig SDK - Sydney Metro Rail - Leica XV](assets/datastar.zig.jpg)\n\nA Zig library for 0.16 / latest stdlib that conforms to the Datastar SDK specification.\n\nhttps://github.com/starfederation/datastar/blob/develop/sdk/ADR.md\n\n.. and passes the official Datastar test cases.\n\nVersions :\n- Datastar 1.0.0-RC7\n- Zig 0.16-dev\n\nNOTE - Zig 0.16-dev has frequent breaking changes, and will for while. Keep this in mind if having fun\nwith being on the bleeding edge !! You have been warned !!\n\nStatus 10-Jan-2026\n- 0.16.0-dev.2040+c475f1fcd ... now includes the \"Juicy Main\" changes\n\nFor stable Zig 0.15.2 - see https://github.com/zigster64/datastar.http.zig\n\n# Audience and Scope\n\nWho is this repo for ?\n\n- Anyone interested in using Datastar. https://data-star.dev.\n\nDatastar allows you to build interactive Web UIs, driven from the backend server, using only\ndeclarative HTML on the frontend, and streaming events from the backend.\n\nIt is particularly good for doing real time push updates, event sourcing, and\nmulti-player or collaborative applications.\n\nSee the end of this document for more resources if you want to know more about Datastar in detail.\n\nDatastar uses a well defined SSE-first protocol that is backend agnostic - you can use the the same simple \nSDK functions to write the same app in Go, Clojure, C#, PHP, Python, Bun, Ruby, Rust, Lisp, Racket, Java, etc. \n\nThis project adds Zig 0.16-dev to that list of supported SDK languages.\n\n_Why consider the Zig version then ? Who is that for ?_\n\n- Existing Zig programmers who want to try working with Web+Datastar under 0.16-dev\n- Datastar app builders who want to experiment with performance, and dabble in new backend languages\n\nConsider Zig if every microsecond counts, or you want small memory footprints.\n\nTry it out.\n\n# Installation and Usage\n\nTo build an application using this SDK\n\n1) Add datastar.zig as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save=\"datastar\" \"git+https://github.com/zigstser64/datastar.zig\"\n```\n\n2) In your `build.zig`, add the `datastar` module as a dependency you your program:\n\n```zig\nconst datastar = b.dependency(\"datastar\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"datastar\", datastar.module(\"datastar\"));\n\n// or add the module \"datastar\" to the .imports section of your exe\n```\n\n3) In your application code\n\nDepends on the HTTP Framework you are using.\n\nThis SDK does include a complete HTTP Framework for Zig 0.16 to get \nyou started. Here is a full example using this built in HTTP Server\nwith Datastar specific SSE events.\n\n```zig\n\nconst std = @import(\"std\");\nconst datastar = @import(\"datastar\");\nconst HTTPServer = datastar.HTTPServer;\nconst HTTPRequest = datastar.HTTPRequest;\n\nconst ADDRESS = \"0.0.0.0\"; // all IP addresses\nconst PORT = 8080; \n\npub fn main(init: std.process.Init) !void {\n    const allocator = init.arena.allocator();\n    const io = init.io;\n\n    var server = try HTTPServer.init(io, allocator, ADDRESS, PORT);\n    defer server.deinit();\n\n    // Setup all the routes\n    const r = server.router;\n    r.get(\"/\", index);\n    r.get(\"/sse/:id\", sseEndpoint);\n    ... all the routes\n\n    std.debug.print(\"Server listening on http://{s}:{}\\n\", .{ADDRESS, PORT});\n    try server.run();\n}\n\n// Index page handler code\nfn index(http: *HTTPRequest) !void {\n    // Note\n    // - Include the Datastar bundle (or you can host your own)\n    // - The body makes a call to /see to fetch content\n    // - The div id=\"hello\" is a target for updating in the /sse call\n    // - The data-json-signals element provides debugging output for the current state of signals\n    return http.html(\n        \\\\<!DOCTYPE html>\n        \\\\<head>\n        \\\\  <script type=\"module\"\n        \\\\    src=\"https://cdn.jsdelivr.net/gh/starfederation/datastar@1.0.0-RC.7/bundles/datastar.js\">\n        \\\\  </script>\n        \\\\</head>\n\n        \\\\<body data-init=\"/sse/zig\">\n        \\\\  <div id=\"hello\">Loading ...</div>\n        \\\\  <div>Foo <span data-text:foo></span></div>\n        \\\\  <div>Bar <input data-bind:bar /></div>\n        \\\\  <pre data-json-signals></pre>\n        \\\\</body>\n    );\n}\n\n// A simple SSE endpoint that generates a set of events over the stream \nfn sseEndpoint(http: *HTTPRequest) !void {\n    const id = http.params.get(\"id\") orelse return error.NoID;\n\n    // turn the endpoint into an SSE stream\n    var sse = try http.NewSSE();\n    defer sse.close();\n\n    // Now we can send multiple actions over the SSE stream\n\n    // Update just the id='hello' element in the DOM\n    try sse.patchElements(\"<div id='hello'>Hello World</div>\");\n\n    // send a batch of signals for reactive DOM updates\n    try sse.patchSignals(.{.foo = 42, .bar = \"Datastar Rocks\"});\n\n    // invoke scripts directly from the backend\n    try sse.executeScriptFmt(\"alert('All your base are belong to {s}')\", .{id});\n}\n```\n\n# Web Server that works with Zig 0.16-dev ?\n\nThis 0.16 Version of the Datastar SDK includes a basic web development framework and fast radix-tree\nbased router that uses the stdlib http server.\n\nIt uses similar API conventions to https://github.com/karlseguin/http.zig, tuned\nspecifically for use with Datastar applications.\n\nYou can use this built-in server, or you can use any other HTTP Server Framework that works with\nZig 0.16. \n\nSee the example above in the install step about using the built in HTTP Server.\n\nSee notes at the end of this document about adapting other HTTP Server Frameworks.\n\n\n# Quick Start Introduction\n\nIf you just want to quickly install this, and try out the demo programs first, do this :\n\n```\n... get zig 0.16-dev installed on your machine, then ...\n\ngit clone https://github.com/zigster64/datastar.zig\ncd datastar.zig\nzig build\n./zig-out/bin/example_1\n```\n\nThen open your browser to http://localhost:8081\n\n\nThis will bring up a kitchen sink app that shows each of the SDK functions in use in the browser, with a \nsection that displays the code to use on your backend to drive the page you are looking at.\n\nSuggest that you use the Browser DevTools to have a look at whats happening over the wire in each case.\n\nFor the SSE streams, you can see that the request contains a stream of small payloads that contain \nan event header, some params, followed by multiple lines of data.\n\n![Screenshot of example_1](./docs/images/example_1a.png)\n\n![Show Code example](./docs/images/show_code.png)\n\n---\nExample of SVG and MathML morphing from the backend\n\nThe SDK allows you to patch interior elements of an SVG or MathML block, without having to re-render the\nentire block. \n\nhttps://github.com/user-attachments/assets/e8f48b44-c84d-4c43-9c1c-58a057db3e33\n\nhttps://github.com/user-attachments/assets/2383156f-6ba1-40de-8b45-117bbf59ed84\n\n---\n\n`./zig-out/bin/example_2` - a simple cat auction site.\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\n\n![Screenshot of example_2](./docs/images/example_2.png)\n\n---\n\n`./zig-out/bin/example_3` - a more complex WildCat aution site, with session based preferences managed\nat the backend.\n\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\nChange preferences, and watch that all browser windows in the same session get their preferences updated.\n\nUse a different machine, or browser to simulate a new session.\n\nNote that the bids update in realtime across all clients, and just the preferences changes are sticky\nacross all clients belonging to the same session.\n\nWhen the backend generates an update for each connected client, the output is customized by the backend\nto suit the session preferences.\n\nThere is no logic being applied on the frontend in this example - its all driven from the backend.\n\n![Screenshot of example_3](./docs/images/example_3.png)\n\n---\n\n`./zig-out/bin/example_5` - an excellent and exciting multi-player farming simulator, where users can plant and attend \nto various crops to help them grow to harvest (or whither and die if neglected)\n\n![Screenshot of example_5](./docs/images/example_5.png)\n\n# Validation Test\n\nWhen you run `zig build`, it will compile several apps into `./zig-out/bin` including a binary called `validation-test`\n\nRun `./zig-out/bin/validation-test`, which will start a server on port 7331\n\nThen follow the procedure documented at\n\nhttps://github.com/starfederation/datastar/blob/main/sdk/tests/README.md\n\nTo run the official Datastar validation suite against this test harness\n\nThe source code for the `validation-test` program is in the file `tests/validation.zig`\n\nCurrent version passes all tests.\n\n\n# Functions\n\n## Cheatsheet of all Datastar SDK functions\n\n```zig\nconst datastar = @import(\"datastar\");\n\n// read signals either from GET or POST\nhttp.readSignals(comptime T: type) !T  // for use with the built in HTTPServer, where http = *HTTPRequest\ndatastar.readSignals(comptime T: type, arena: std.mem.Allocator, req: *std.http.Server.Request) !T // generic interface if you are not using the built in HTTPServer\n\n// set the connection to SSE, and return an SSE object\nvar sse = http.NewSSE() !SSE\nvar sse = http.NewSSESync() !SSE\nvar sse = http.NewSSEOpt(sse_options) !SSE\n\n// when you are finished with this connection - you will want to do ONE of these\ndefer sse.close()\ndefer sse.flush()\n\n// when you want to keep the connection alive for a long time \n// then you might want to send keepalive pings every minute or\n// so to ensure that the connection is tracked.\n// Call this to send a \"keepalive\" SSE event\nsse.keepalive()\n\n// patch elements function variants\nsse.patchElements(elementsHTML, elements_options) !void\nsse.patchElementsFmt(comptime elementsHTML, arguments, elements_options) !void\nsse.patchElementsWriter(elements_options) *std.Io.Writer \n\n// patch signals function variants\nsse.patchSignals(value, json_options, signals_options) !void\nsse.patchSignalsWriter(signals_options) *std.Io.Writer\n\n// execute scripts function variants\nsse.executeScript(script, script_options) !void\nsse.executeScriptFmt(comptime script, arguments, script_options) !void\nsse.executeScriptWriter(script_options) *std.Io.Writer\n```\n\n## Cheatsheet of all HTTPServer functions\n\n```zig\n// Generate a Server type that has no global context\n// handler signatures are handler(HTTPRequest)\nServer(void)\n\n// Generate a Server type that takes a type as a global app context\n// handler signatures are handler(Context, HTTPRequest)\nServer(T)\nserver.setContext(ctx)\n\n// create a server given an address\nserver.init(io, allocator, address, port) !Server\n// create a server listening on all interfaces with both IPv4 and IPv6\nserver.initIp6(io, allocator, port) !Server\n// server instance cleanup\nserver.deinit()\n// run the server\nserver.run()\n// tell the whole app to reload and reboot whenever the program is re-compiled\nserver.rebooter(args)\n```\n\nThe built in HTTPServer provides a simple fast router \n\n```zig\nvar app = App.init(allocator); // create a global state context for this app\nvar server = try datastar.Server(*App).initIp6(io, allocator, PORT);\nserver.setContext(&app);\n\nvar r = server.router;  // get the router from the Server we created\n\nr.get(path, handler)\nr.post(path, handler)\nr.patch(path, handler)\nr.delete(path, handler)\n\n// Generic route\nr.add(method, path, handler)\n\n// Path Parameters example\nr.get(\"/users/:id/:action\", userHandler)\n\nfn userHandler(app: *App, http *HTTPRequest) !void {\n    const id = http.params.get(\"id\");\n    const action = http.params.get(\"action\");\n    ...\n}\n\n```\n\nWhen using the built in HTTPServer, all handlers receive either : \n- a single paramater of type `*HTTPRequest` for servers of type `Server(void)`\n- a context, and a `*HTTPRequest` for servers of type `Server(T)`\n\nSee the above code example, where a global context of type `App` is created,\nand the server is defined as `Server(*App)`, followed by `server.setContext(&app)`.\n\nIn this case, the handler functions now all receive that global context.\n\nThis HTTPRequest has the following features :\n\n```zig\n// Internal values\n\nhttp.req     - the *std.http.Server.Request value\nhttp.io      - which std.Io interface is in use when calling this handler\nhttp.arena   - a per-request arena for doing allocations in your handler\nhttp.params  - the route parameters used in the request\n\n// Functions\nhttp.html(data) !void            // output data as text/html\nhttp.htmlFmt(format, args) !void // print formatted output data as text/html\nhttp.json(data) !void            // convert data to JSON and output as application/json\nhttp.query() ![]const u8         // get the query string for this request \nhttp.readSignals(T) !T           // read the signals from the request into struct of given type\nhttp.setCookie(name, value)      // set a cookie with the response\nhttp.getCookie(name)             // get a cookie from the requesnt\n\n// Route Parameters \nhttp.params.get(name) ?[]const u8  // get the value of named parameter :name\nhttp.params.getInt(T, name) ?T     // get the value of named parameter :name as an Integer\n```\n\nThe built in functions allow you to easily return text/html or application/json. (as well as Datastar SSE actions, as shown below)\n\nIf you want to do anything more exotic, just use the `http.req` to construct whatever other response type you might need ... the new 0.16 stdlib\nprovides a lot of very low level control options for returning responses there.\n\n# Using the Datastar SDK\n\n## The SSE Object\n\nCalling NewSSE on the HTTPRequest will return an object of type SSE.\n\n```zig\n    sse.NewSSE() !SSE \n```\n\nThis will configure the connnection for SSE transfers, and provides an object with Datastar methods for\npatching elements, patching signals, executing scripts, etc.\n\nWhen you are finished with this SSE object, you must call `sse.close()` to finish the handler.\n\nWhen running in this default mode (named internally as 'batched mode'), all of the SSE patches are batched\nup, and then passed up to the HTTP library for transmission, and closing the connection.\n\nIn batched mode, the entire payload is sent as a single transmission with a fixed content-length header, \nand no chunked encoding.\n\nYou can declare your sse object early in the handler, and then set headers / cookies etc at any time \nin the handler. Because actual network updates are batched till the end, everything goes out in the correct order.\n\n```zig\n    sse.NewSSESync() !SSE \n```\nWill create an SSE object that will do immediate Synchronous Writes to the browser as each `patchElements()` call is made.\n\nFinally, there is a NewSSE variant that takes a set of options, for special cases\n\n```zig\n    sse.NewSSEOpt(SSEOptions) !SSE\n\n    // Where options are \n    const SSEOptions = struct {\n        buffer_size: usize = 16 * 1024, // internal buffer size for batched mode\n        sync: bool = false,\n        extra_headers: ?[]const std.http.Header = null,\n    };\n```\n\n## Reading Signals from the request\n\nUsing the built in HTTPServer\n```zig\n    pub fn http.readSignals(comptime T: type) !T\n```\n\nUsing a generic version for other HTTP Frameworks\n```zig\n    pub fn datastar.readSignals(comptime T: type, arena: std.mem.Allocator, req: *std.http.Server.Request) !T\n```\n\nWill take a Type (struct) and a HTTP request, and returns a filled in struct of the requested type.\n\nIf the request is a `HTTP GET` request, it will extract the signals from the query params. You will see that \nyour GET requests have a `?datastar=...` query param in most cases. This is how Datastar passes signals to\nyour backend via a GET request.\n\nIf the request is a `HTTP POST` or other request that uses a payload body, this function will use the \npayload body to extract the signals. This is how Datastar passes signals to your backend when using POST, etc.\n\nEither way, provide `readSignals` with a type that you want to read the signals into, and it will use the\nrequest method to work out which way to fill in the struct.\n\nExample :\n```zig\n    const FooBar = struct {\n        foor: []const u8,\n        bar: []const u8,\n    };\n\n    const signals = try http.readSignals(FooBar);\n    std.debug.print(\"Request sent foo: {s}, bar: {s}\\n\", .{signals.foo, signals.bar});\n```\n\nIf you prefer, you can use anonymous structs too - can make the code more readable :\n\n```zig\n    const signals = try http.readSignals(struct {foo: []const u8, bar: []const u8});\n    std.debug.print(\"Request sent foo: {s}, bar: {s}\\n\", .{signals.foo, signals.bar});\n```\n\n\n## Patching Elements\n\nThe SDK Provides 3 functions to patch elements over SSE.\n\nThese are all member functions of the SSE type that NewSSE(http) returns.\n\n\n```zig\n    pub fn patchElements(self: *SSE, elements: []const u8, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsFmt(self: *SSE, comptime elements: []const u8, args: anytype, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsWriter(self: *SSE, opt: PatchElementsOptions) *std.Io.Writer \n```\n\nUse `sse.patchElements` to directly patch the DOM with the given \"elements\" string.\n\nUse `sse.patchElementsFmt` to directly patch the DOM with a formatted print (where elements,args is the format string + args).\n\nUse `sse.patchElementsWriter` to return a std.Io.Writer object that you can programmatically write to using complex logic.\n\nWhen using the writer, you can call `w.flush()` to manually flush the writer ... but you generally \ndont need to worry about this, as the sse object will correctly terminate an existing writer, as\nsoon as the next `patchElements / patchSignals` is issued, or at the end of the handler cleanup\nas the `defer sse.close() / defer sse.deinit()` functions are called.\n\nSee the example apps for best working examples.\n\n\nPatchElementsOptions is defined as :\n\n```zig\npub const PatchElementsOptions = struct {\n    mode: PatchMode = .outer,\n    selector: ?[]const u8 = null,\n    view_transition: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n    namespace: NameSpace = .html,\n};\n\npub const PatchMode = enum {\n    inner,\n    outer,\n    replace,\n    prepend,\n    append,\n    before,\n    after,\n    remove,\n};\n\npub const NameSpace = enum {\n    html,\n    svg,\n    mathml,\n};\n```\n\nSee the Datastar documentation for the usage of these options when using patchElements.\n\nhttps://data-star.dev/reference/sse_events\n\nMost of the time, you will want to simply pass an empty tuple `.{}` as the options parameter. \n\nExample handler (from `examples/01_basic.zig`)\n\n```zig\nfn patchElements(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n```\n\n## Patching Signals\n\nThe SDK provides 2 functions to patch signals over SSE.\n\nThese are all member functions of the SSE type that NewSSE(http) returns.\n\n```zig\n    pub fn patchSignals(self: *SSE, value: anytype, json_opt: std.json.Stringify.Options, opt: PatchSignalsOptions) !void\n\n    pub fn patchSignalsWriter(self: *SSE, opt: PatchSignalsOptions) *std.Io.Writer\n```\n\nPatchSignalsOptions is defined as :\n```zig\npub const PatchSignalsOptions = struct {\n    only_if_missing: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `patchSignals` to directly patch the signals, passing in a value that will be JSON stringified into signals.\n\nUse `patchSignalsWriter` to return a std.Io.Writer object that you can programmatically write raw JSON to.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn patchSignals(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    const foo = prng.random().intRangeAtMost(u8, 0, 255);\n    const bar = prng.random().intRangeAtMost(u8, 0, 255);\n\n    try sse.patchSignals(.{\n        .foo = foo,\n        .bar = bar,\n    }, .{}, .{});\n}\n```\n\n## Executing Scripts\n\nThe SDK provides 3 functions to initiate executing scripts over SSE.\n\n```zig\n\n    pub fn executeScript(self: *SSE, script: []const u8, opt: ExecuteScriptOptions) !void\n\n    pub fn executeScriptFmt(self: *SSE, comptime script: []const u8, args: anytype, opt: ExecuteScriptOptions) !void \n\n    pub fn executeScriptWriter(self: *SSE, opt: ExecuteScriptOptions) *std.Io.Writer\n```\n\nExecuteScriptOptions is defined as :\n```zig\npub const ExecuteScriptOptions = struct {\n    auto_remove: bool = true, // by default remove the script after use, otherwise explicity set this to false if you want to keep the script loaded\n    attributes: ?ScriptAttributes = null,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `executeScript` to send the given script to the frontend for execution.\n\nUse `executeScriptFmt` to use a formatted print to create the script, and send it to the frontend for execution. \nWhere (script, args) is the same as print(format, args).\n\nUse `executeScriptWriter` to return a std.Io.Writer object that you can programmatically write the script to, for\nmore complex cases.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn executeScript(req: *httpz.Request, res: *httpz.Response) !void {\n    const value = req.param(\"value\"); // can be null\n\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    try sse.executeScriptFmt(\"console.log('You asked me to print {s}')\"\", .{\n            value orelse \"nothing at all\",\n    });\n}\n```\n\n# Adding Response Headers\n\nThere are a couple of ways you can send additional headers with your responses.\n\nSee this example in `examples/01_basic.zig`\n\n```zig\nfn patchElements(http: *HTTPRequest) !void {\n    var t1 = try std.time.Timer.start();\n    defer std.debug.print(\"patchElements elapsed {}(μs)\\n\", .{t1.read() / std.time.ns_per_ms});\n\n    // Apply extra headers to the HTTPRequest before the response is sent\n    http.extra_headers = &.{\n        .{ .name = \"X-More-Headers\", .value = \"Top level http extra headers\" },\n        .{ .name = \"X-Even-More-Headers\", .value = \"Top level http more headers\" },\n    };\n\n    // Append additional headers to a HTTPRequest before the response is sent\n    http.extra_headers = try http.mergeHeaders(&.{\n        .{ .name = \"X-Appended-Headers\", .value = \"These were appended to the top level\" },\n        .{ .name = \"X-Even-More-Appended-eaders\", .value = \"More appended to the top level\" },\n    });\n\n    // Define extra headers here when creating the SSE response\n    var sse = try http.NewSSEOpt(.{ .extra_headers = &.{\n        .{ .name = \"X-SSE-More-Headers\", .value = \"Patch Elements Example\" },\n        .{ .name = \"X-SSE-Even-More-Headers\", .value = \"All the Headers\" },\n    } });\n    defer sse.close();\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n\n```\n# Advanced SSE Topics\n\n## Batched Writes vs Synchronous Writes \n\nBy default, when you create a `NewSSE(http)`, and do various actions on it such as `patchElements()`, this \nwill buffer up the converted SSE stream, which is then written to the client browser as the request is \nfinalised.\n\nIn some cases you may want to do Synchronous Writes to the client browser as each operation is performed in the\nhandler, so that as each `patchElements()` call is made, the patch is written immediately to the browser.\n\nIn this case use `NewSSESync(http)` to set the SSE into Synchronous Mode.\n\nFor example - in the SVGMorph demo, we want to generate a randomized SVG update, then write that to the client \nbrowser, then pause for 100ms and repeat, to provide a smooth animation of the SVG.\n\n![NewSSE vs NewSSESync](docs/images/newsse_newssesync.png)\n\n## Namespaces - SVG and MathML (Datastar RC7 feature)\n\n`patchElements()` works great when morphing small fragments into existing DOM content, using the element ID,\nor other selectors.\n\nUnfortunately, when we have a large chunk of SVG or MathML content, the standard HTML morphing \ncannot reach down inside the SVG markup to pick out individual child elements for individual updates.\n\nHowever, you can now use the `.namespace = svg` or `.namespace = mathml` options for `patchElements()` now\nto do exactly this.\n\nSee the SVG and MathML demo code in example_1 to see this in action.\n\n# Publish and Subscribe\n\nPublish and Subscribe is at the heart of reactive Multi-Player apps. We want to exploit the SSE streams to push updates to clients from\nthe backend, and we need a message bus of sorts to track all the connected clients and what topics they are listening on.\n\nThe older `datastar.http.zig` SDK for use with Zig 0.15.2 (here - https://github.com/zigster64/datastar.http.zig) has a built in pub/sub\nsystem that exploits the fact that http.zig allows you to detach sockets from handlers for later use.\n\nIn Zig 0.16 - The recommended approach here will be to use the Evented IO to create long running coroutines \nfor those handlers that want to subscribe to topics. For now, we are using Io.Threaded in the examples until Io.Evented \nis fully baked. Io.Threaded isnt a huge overhead, since each thread is put to sleep whilst its waiting for the next message, so its\njust the memory overhead. Zig allows you to easily tune the stack size used for threads down to some maximum to keep that nicely under control.\n\nFor publishing to topics in a production environment, then just connect in a message bus such as Redis, or NATS, or Postgres listen/notify and thats all thats needed.\n\nThe example apps in this SDK that require PubSub, use this embedded message broker https://github.com/zigster64/pubsub.zig .. which was custom built specifically for these Datastar SSE runners.\n\nYou dont _have to_ use this message broker, but its bundled into this SDK for convenience to get you started.\n\nSwap in your own PubSub / Mailbox / Message Queue engine as you need, and follow the same basic logic \n- Create an SSE response in sync mode, with `NewSSESync()`\n- `defer sse.close()` to close the connection when complete\n- Send the first payload now, before the loop\n- In the handler, connect to whatever message broker you are using\n- Subscribe to various topics\n- Loop forever getting messages\n    - perform some action on the message\n\nYou can see this being used in `02_cats.zig` for example, to update bids on the cat auctions.\n\n```zig\n// Optional embedded PubSub broker is bundled in the SDK for easy access\nconst pubsub = datastar.pubsub;\n\n// SSE persistent handler that subscribes to the message broker\nfn catsList(app: *App, http: *HTTPRequest) !void {\n    var sse = try http.NewSSESync();\n    defer sse.close();\n    try pushCatList(app, &sse);\n\n    var mq = try app.pubsub.connect(); // <-- the broker is referenced here\n    defer mq.deinit();\n\n    // Subscribe to the message broker\n    try mq.subscribe(.cats); \n    mq.setTimeout(.fromSeconds(30));\n\n    // loop forever over the events\n    while (try mq.next()) |event| {\n        switch (event) {\n            .msg => try pushCatList(app, &sse),\n            .timeout => try sse.keepalive(),\n        }\n    }\n}\n\n// elsewhere, when a new bid has been posted\nfn postBid(app: *App, http: *HTTPRequest) !void {\n    ... do stuff ... then ..\n\n    try app.pubsub.publish(.{ .cats = {} }, .all);\n}\n\n```\n\n# Local Development Utilities\n\nThe Zig Datastar SDK provides some built in tools to make local development and testing more pleasant.\n\nFor hot reloads of the browser, there are a couple of idiomatic ways of dealing with this.\n\nIf your application uses any persistent SSE connections to regularly update state, then ideally you should\nwrite these so that they output enough information to completely update the client content and state.\n\nThat could mean sending the complete page (aka a \"Fat Morph\"), and letting the morph engine on the browser \nsort out which DOM elements need updating.\n\nWhen the backend server stops and starts, the persistent SSE is closed, which triggers Datastar in the browser\nto try to re-establish that connection. When it re-establishes, it will send enough updated content and signals to \ncorrectly re-render the browser.\n\nSometimes that is not practical, or sometimes your app has no persistent SSE connection that can do this.\n\nIf you have a look in `01_basic.zig` - the code for example_1 ... we dont have any persistent SSE connection\nto do this, so this app adds an endpoint `/hotreload/:id`\n\nWhen the app is started, it will store the current timestamp as the unique \"Deployment ID\", which is\nthen hard coded into `data-init=\"@post('/hotreload/DEPLOYMENT_ID')\"` in `01_index.html`.\n\nThis `POST /hotreload/:id` endpoint is a long lived SSE connection.\n\nSo when the server stops and starts (due to a re-deployment) the browser will automatically try to\nreconnect the dropped SSE connection, but pass the old DEPLOYMENT_ID.\n\nThe server detects this, and sends a `window.location.reload()` to the browser.\n\n* Restart Server on Re-Compile *\n\nTo compliment the browser hotreload, the Zig Datastar SDK provides a utility function you can add \nto your server code, to automatically reload the server executable whenever it is recompiled.\n\nYou can achieve this by adding a call to `server.rebooter(args)` during startup :\n\n```zig\n    var server = try HTTPServer.initIp6(io, allocator, PORT);\n    defer server.deinit();\n\n    const r = server.router;\n    r.get(\"/\", index);\n    ... add other routes here\n\n    // HOT Reloader setup\n    r.post(\"/hotreload/:id\", hotreloadHandler); // Turn on the Hotreloader\n\n    // Tell the server to reboot on recompile\n    try server.rebooter(init.minimal.Args); // <---- ADD THIS\n\n    std.debug.print(\"Server listening on http://localhost:{}\\n\", .{PORT});\n    try server.run();\n```\n\nIf you do both of those things, then in dev mode, you just compile in your IDE of choice,\nif it succeeds then the server restarts, which triggers the frontend to also hot reload.\n\nOf course, if you run the zig compiler in --watch mode, then everytime you save, it will\nrecompile, which triggers a reload of the server, which triggers a frontend hot reload as \nwell.\n\n# Adapting this SDK to other non-stdlib HTTP libraries\n\nShould be relatively straightforward to do.\n\nSimple Solution :\n\n- Use the HTTP Server & Router abstrations already provided by your HTTP framework.\n- If the response can be a simple `text/html` or `application/json` .. just send that, understanding how Datastar is able\n  to use these to patch both elements and signals, without SSE processing.\n- For SSE packaged responses, use whatever mechanisms your HTTP framework provides to setup an EventStream response,\n  with appropriate chunked encoding and keep-alive connection protocol.\n- Use the top level `datastar.patchElements()` / `datastar.patchSignals()` / `datastar.executeScript()` of the EventStream \n  generators, which all take raw string data for patching Elements and Scripts, or an arbitrary struct for patching Signals, \n  and then return a processed string for the event stream.\n- Write the contents of this processed string to the HTTP response.\n- Done !\n\nMore complex Solution (For HTTP Framework Authors) :\n\n- This SDK defines an interface for managing HTTP Requests with Datastar\n- Copy `http_request.zig` from this code, and use that as the bones to write your own interface implementation.\n- The implementation of the Datastar + SEE Processing is contained in `datastar.zig`, and is independent of the HTTPRequest implementation.\n- So ... its only the application code and handlers that are tied to a HTTPRequest implementation, via the interface.\n- Write a HTTPRequest compatible wrapper for your HTTP Framework. If you provide that, then any application code that works with the\n  built-in HTTP Server from this package will also work with your adapted HTTP Framework, by swapping over the HTTPRequest implementation.\n\nMaybe future option :\n\n- Its probably more idiomatic Zig to implement HTTPRequest as an interface with a VTable.\n- But thats an extra layer of complexity that might be overkill.\n- Will wait an see if this is even an actual demand before committing to making that change.\n\n![Datastar HTTPRequest Interface](docs/http_request.png)\n\nThe HTTPRequest interface currently looks like this :  (is WIP, may change a little)\n```zig\n/// Return a new SSE object for a simple 1 shot response\npub fn NewSSE(http: *HTTPRequest) !SSE\n\n/// Return a new SSE object setup for a series of synchronous responses or persistent connection\npub fn NewSSESync(http: *HTTPRequest) !SSE\n\n/// Return a new SSE object with custom options\npub fn NewSSEOpt(http: *HTTPRequest, opt: SSEOptions) !SSE\n\n/// you can use this to construct extra_headers when creating any response\n/// it will pull in self.extra_headers, and merge them with the new set\n/// to provide a complete set for the actual request\n/// See http.setCookie() for an example where this is needed\npub fn mergeHeaders(self: *HTTPRequest, extra: []const std.http.Header) ![]const std.http.Header\n\n/// send a response of type text/html with the given data\npub fn html(self: *HTTPRequest, data: []const u8) !void\n\n/// send a response of type text/html with a formatted print\npub fn htmlFmt(self: *HTTPRequest, comptime fmt: []const u8, args: anytype) !void\n\n/// send a response of type application/json with the given data\npub fn json(self: *HTTPRequest, data: anytype) !void\n\n/// extract the full query params from the request\npub fn query(self: HTTPRequest) ![]const u8\n\n/// read Datastar signals from the request into the given struct type, return an instance of this struct\npub fn readSignals(self: HTTPRequest, comptime T: type) !T\n\n/// set a cookie that will be included in the response header\npub fn setCookie(self: *HTTPRequest, name: []const u8, value: []const u8)\n\n/// get a cookie from the request\npub fn getCookie(self: *HTTPRequest, name: []const u8) ?[]const u8\n\n```\n\n# More Info on Datastar\n\nIf you like the idea of using The Web as an application platform, but feel that the current directions in WebDev have \nsomehow lost the plot, then you might be the target audience for Datastar.\n\nThe following videos will give you a really good idea if Datastar is for you or not :\n\n[![Why We’re Building the Front End Wrong](https://img.youtube.com/vi/FtAuSAOMNtM/0.jpg)](https://www.youtube.com/watch?v=FtAuSAOMNtM)\n\n\nShort Independent Overview\n\n[![Episode 1 - Datastar | Datastar Series](https://img.youtube.com/vi/I8QLWWPGT-c/0.jpg)](https://youtu.be/I8QLWWPGT-c)\n\n[![Episode 2 - Rockets Eye Overview | Datastar Series](https://img.youtube.com/vi/zQAz7fV95OU/0.jpg)](https://youtu.be/zQAz7fV95OU)\n\n\nDatastar Discord\n[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/YfFn7pKx)\n\nZig Discord\n[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/Chk5WKM5)\n\n# Contrib Policy\n\nAll contribs welcome.\n\nPlease raise a github issue first before adding a PR, and reference the issue in the PR title. \n\nThis allows room for open discussion, as well as tracking of issues opened and closed.\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/72305366?u=cf46defe1dc7db6770201913a79150fbcbddb6ff&v=4",
  "releases": [],
  "owner_bio": "Half Stack Dev.\r\n\r\nI’m into minimalist code and tools.\r\n\r\n\r\n",
  "owner_company": null,
  "owner_location": "Outback Australia, middle of nowhere",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 57,
  "owner_following": 59,
  "owner_created_at": "2020-10-03T12:46:34Z",
  "license": "MIT",
  "category": "library"
}