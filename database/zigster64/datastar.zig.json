{
  "name": "datastar.zig",
  "owner": "zigster64",
  "repo": "datastar.zig",
  "description": "Datastar SDK for zig 0.16",
  "type": "package",
  "topics": [
    "data-star",
    "datastar",
    "zig-package"
  ],
  "stars": 4,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-01-01T13:34:46Z",
  "dependencies": [
    {
      "name": "pubsub",
      "url": "git+https://github.com/zigster64/pubsub.zig#9c114b2d66df3c1e0ee1db5d72495ecf3f30fd08",
      "hash": "pubsub-0.0.0-6dy2AQZ7AAB7dj1lHPLsDlGY9ejDgrpNxae_FW4kEMn1"
    }
  ],
  "minimum_zig_version": "0.16.0-dev",
  "readme": "# Datastar lib for zig 0.16-dev\n\n![Cyberpunk Datastar Zig SDK - Sydney Metro Rail - Leica XV](assets/datastar.zig.jpg)\n\nA Zig library for 0.16 / latest async/concurrent stdlib that conforms to the Datastar SDK specification.\n\nhttps://github.com/starfederation/datastar/blob/develop/sdk/ADR.md\n\n.. and passes the official test cases.\n\nVersions :\n- Datastar 1.0.0-RC7\n- Zig 0.16.x\n\nSee Also http://github.com/zigster64/datastar.http.zig for the Datastar SDK for zig 0.15.2 sitting on top of http.zig\n\n# Audience and Scope\n\nWho is this repo for ?\n\n- Anyone interested in using Datastar. https://data-star.dev.\n\nIt is a state of the art Hypermedia-first library for building apps. \n\nIts not \"yet another frontend framework\" - its a 10kb JS shim that allows you to write application code\nat the backend, and leverage modern browser standards to have a very fast, very light, reactive UI \nwith none of the junk. There are no build steps, no npm deps - just declarative HTML and reactive signals,\ndriven from the backend.\n\nIf you know, you know.\n\nIt uses a well defined SSE-first protocol that is backend agnostic - you can use the the same simple \nSDK functions to write the same app in Go, Clojure, C#, PHP, Python, Bun, Ruby, Rust, Lisp, Racket, Java, etc. \n\nThis project adds Zig to that list of supported SDK languages.\n\nIt uses the exact same spec as all the other SDK's, and reads extremely similarly to say - a Go program\nor a Python program using the same SDK.\n\nWhy consider the Zig version then ? Who is that for ?\n\n- Existing Zig programmers who want to try Datastar\n- Datastar app builders who want to experiment with performance, and dabble in new backend languages\n\nConsider Zig if every microsecond counts, or you want stupidly small memory footprints that dont grow.\n\nZig gives you some pretty good tuning options if you want to chase benchmarks and break records too.\n\nWe are talking orders of magnitude performance and resource usage gains for your existing Datastar app, depending\non what you are currently using. \n\nTry it out.\n\n# Quick Start Introduction\n\nIf you just want to quickly install this, and try out the demo programs first, do this :\n\n```\n... get zig 0.16-dev installed on your machine\ngit clone https://github.com/zigster64/datastar.zig\ncd datastar.zig\nzig build\n./zig-out/bin/01_basic\n```\n\nThen open your browser to http://localhost:8081\n\n\nThis will bring up a kitchen sink app that shows each of the SDK functions in use in the browser, with a \nsection that displays the code to use on your backend to drive the page you are looking at.\n\n![Screenshot of example_1](./docs/images/example_1a.png)\n\n\n---\n\nTo run the additional example apps, try\n\n`./zig-out/bin/example_2` - a simple cat auction site.\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\n\n![Screenshot of example_2](./docs/images/example_2.png)\n\n---\n\n`./zig-out/bin/example_22` - a more complex cat aution site, with session based preferences managed at the backend.\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\nChange preferences, and watch that all browser windows in the same session get their preferences updated.\n\nUse a different machine, or browser, or use the 'Profiles' feature in Chrome/Safari/Firefox to simulate a new session.\nNote that the bids update in realtime across all browsers, and just the preferences changes are sticky across all \nwindows belonging to the same machine/profile.\n\n![Screenshot of example_22](./docs/images/example_22.png)\n\n---\n\n`./zig-out/bin/example_5` - an excellent and exciting multi-player farming simulator, where users can plant and attend \nto various crops to help them grow to harvest (or whither and die if neglected)\n\n![Screenshot of example_5](./docs/images/example_5.png)\n\n# Validation Test\n\nWhen you run `zig build`, it will compile several apps into `./zig-out/bin` including a binary called `validation-test`\n\nRun `./zig-out/bin/validation-test`, which will start a server on port 7331\n\nThen follow the procedure documented at\n\nhttps://github.com/starfederation/datastar/blob/main/sdk/tests/README.md\n\nTo run the official Datastar validation suite against this test harness\n\nThe source code for the `validation-test` program is in the file `tests/validation.zig`\n\nCurrent version passes all tests.\n\n\n# Example Apps\n\nWhen you run `zig build` it will compile several apps into `./zig-out/bin/` to demonstrate using different parts \nof the api\n\n- example_1  shows using the Datastar API using basic SDK handlers\n- example_2  shows an example multi-user auction site for cats with realtime updates using pub/sub\n- example_22 Same cat auction as above, but with per-user preferences, all handled on the backend only\n\n<!-- - example_3  shows an example multi-user pigeon racing betting site with realtime updates -->\n<!-- - example_4  shows an example multi-game, multi-player TicTacToe site, using the backstage actor framework -->\n\n- example_5  shows an example multi-player Gardening Simulator using pub/sub\n\n\n# Installation and Usage\n\nTo build an application using this SDK\n\n1) Add datastar.zig as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save=\"datastar\" \"git+https://github.com/zigstser64/datastar.zig#master\"\n```\n\n2) In your `build.zig`, add the `datastar` module as a dependency you your program:\n\n```zig\nconst datastar = b.dependency(\"datastar\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"datastar\", datastar.module(\"datastar\"));\n```\n\n# Web Server ?\n\nThis 0.16 Version of the Datastar SDK includes a basic web server and fast radix-tree based router that uses the stdlib server.\n\nYou can use this built-in server if you want to start experiminting with Zig 0.16-dev, as it has no other dependencies outside of stdlib.\n\nFull example of a main() using the \n\n```zig \nconst std = @import(\"std\");\nconst datastar = @import(\"datastar\");\n\nconst Io = std.Io;\n\nconst PORT = 8080;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    var threaded: Io.Threaded = .init(allocator);\n    defer threaded.deinit();\n    const io = threaded.io();\n\n    // Create a server listening on all IP addresses, including IPv6\n    const HTTPServer = datastar.Server(void);\n    var server = try HTTPServer.initIp6(io, allocator, PORT);\n    defer server.deinit();\n\n    // Add some routes with different http methods\n    const r = server.router;\n    r.get(\"/\", index);\n    r.get(\"/text-html\", textHtml);\n    r.get(\"/patch\", patchElements);\n    r.post(\"/patch/opts\", patchElementsOpts);\n    r.get(\"/code/:snip\", code);\n\n    std.debug.print(\"Server listening on http://localhost:{}\\n\", .{PORT});\n\n    // optional function to reboot the server on re-compile\n    // try this if you are doing local dev - is handy\n    try server.rebooter();\n\n    // everything is set, so start the server up\n    try server.run();\n}\n\n// all handlers receive a single HTTPRequest param\nfn index(http: *datastar.HTTPRequest) !void {\n    // http has verbs such as html() to send HTML, json() to send JSON, etc\n    return try http.html(@embedFile(\"index.html\"));\n}\n\nfn patchElements(http: *datastar.HTTPRequest) !void {\n    // here we call NewSSE() on the http request, which sets this into \n    // event-stream mode.\n    var sse = try datastar.NewSSE(http);\n    defer sse.close(); // Sends off the SSE event stream, and closes the connection\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n```\n\n# Functions\n\n## Cheatsheet of all Datastar SDK functions\n\n```zig\nconst datastar = @import(\"datastar\");\n\n// read signals either from GET or POST\nhttp.readSignals(comptime T: type) !T  // for use with the built in HTTPServer, where http = *HTTPRequest\ndatastar.readSignals(comptime T: type, arena: std.mem.Allocator, req: *std.http.Server.Request) !T // generic interface if you are not using the built in HTTPServer\n\n// set the connection to SSE, and return an SSE object\nvar sse = datastar.NewSSE(http) !SSE\nvar sse = datastar.NewSSESync(http) !SSE\nvar sse = datastar.NewSSEOpt(http, sse_options) !SSE\n\n// when you are finished with this connection\nsse.close()\n\n// when you want to keep the connection alive for a long time \n// then call this in your handler. It will continue until the \n// browser closes the connection\nsse.keepalive(io, duration)\n\n// patch elements function variants\nsse.patchElements(elementsHTML, elements_options) !void\nsse.patchElementsFmt(comptime elementsHTML, arguments, elements_options) !void\nsse.patchElementsWriter(elements_options) *std.Io.Writer \n\n// patch signals function variants\nsse.patchSignals(value, json_options, signals_options) !void\nsse.patchSignalsWriter(signals_options) *std.Io.Writer\n\n// execute scripts function variants\nsse.executeScript(script, script_options) !void\nsse.executeScriptFmt(comptime script, arguments, script_options) !void\nsse.executeScriptWriter(script_options) *std.Io.Writer\n```\n\n## Cheatsheet of all HTTPServer functions\n\n```zig\n// Generate a Server type that has no global context\nServer(void)\n... handler signatures are handler(HTTPRequest)\n// Generate a Server type that takes a type as a global app context\nServer(T)\nserver.setContext(ctx)\n... handler signatures are handler(Context, HTTPRequest)\n\n// create a server given an address\nserver.init(io, allocator, address, port) !Server\n// create a server listening on all interfaces with IPv6\nserver.initIp6(io, allocator, port) !Server\n// server instance cleanup\nserver.deinit()\n// run the server\nserver.run()\n// tell the whole app to reload and reboot whenever the program is re-compiled\nserver.rebooter()\n```\n\nThe built in HTTPServer provides a simple fast router \n\n```zig\nvar app = App.init(allocator); // create a global state context for this app\nvar server = try datastar.Server(*App).initIp6(io, allocator, PORT);\nvar r = server.router;  // get the router from the Server we created\n\nr.get(path, handler)\nr.post(path, handler)\nr.patch(path, handler)\nr.delete(path, handler)\n\n// Generic route\nr.add(method, path, handler)\n\n// Path Parameters example\nr.get(\"/users/:id\", userHandler)\n\nfn userHandler(app: *App, http *HTTPRequest) !void {\n    const id = http.params.get(\"id\");\n    ...\n}\n\n```\n\nWhen using the built in HTTPServer, all handlers receive either : \n- a single paramater of type `*HTTPRequest` for servers of type `Server(void)`\n- a context, and a `*HTTPRequest` for servers of type `Server(T)`\n\n\nThis HTTPRequest has the following features :\n\n```zig\n// Internal values\n\nhttp.req     - the *std.http.Server.Request value\nhttp.io      - which std.Io interface is in use when calling this handler\nhttp.arena   - a per-request arena for doing allocations in your handler\nhttp.params  - the route parameters used in the request\n\n// Functions\nhttp.html(data) !void            // output data as text/html\nhttp.htmlFmt(format, args) !void // print formatted output data as text/html\nhttp.json(data) !void            // convert data to JSON and output as application/json\nhttp.query() ![]const u8         // get the query string for this request \nhttp.readSignals(T) !T           // read the signals from the request into struct of given type\n\n// Route Parameters \nhttp.params.get(name) ?[]const u8  // get the value of named parameter :name\n```\n\nThe built in functions allow you to easily return text/html or application/json. (as well as Datastar SSE actions, as shown below)\n\nIf you want to do anything more exotic, just use the `http.req` to construct whatever other response type you might need ... the new 0.16 stdlib\nprovides a lot of very low level control options for returning responses there.\n\n# Using the Datastar SDK\n\n## The SSE Object\n\nCalling NewSSE, passing a HTTPRequest, will return an object of type SSE.\n\n```zig\n    pub fn NewSSE(http) !SSE \n```\n\nThis will configure the connnection for SSE transfers, and provides an object with Datastar methods for\npatching elements, patching signals, executing scripts, etc.\n\nWhen you are finished with this SSE object, you must call `sse.close()` to finish the handler.\n\nWhen running in this default mode (named internally as 'batched mode'), all of the SSE patches are batched\nup, and then passed up to the HTTP library for transmission, and closing the connection.\n\nIn batched mode, the entire payload is sent as a single transmission with a fixed content-length header, \nand no chunked encoding.\n\nYou can declare your sse object early in the handler, and then set headers / cookies etc at any time \nin the handler. Because actual network updates are batched till the end, everything goes out in the correct order.\n\n```zig\n    pub fn NewSSESync(http) !SSE \n```\nWill create an SSE object that will do immediate Synchronous Writes to the browser as each `patchElements()` call is made.\n\nFinally, there is a NewSSE variant that takes a set of options, for special cases\n\n```zig\n    pub fn NewSSEOpt(http, SSEOptions) !SSE\n\n    // Where options are \n    const SSEOptions = struct {\n        buffer_size: usize = 16 * 1024, // internal buffer size for batched mode\n        sync: bool = false,\n    };\n```\n\n## Reading Signals from the request\n\nUsing the built in HTTPServer\n```zig\n    pub fn http.readSignals(comptime T: type) !T\n```\n\nUsing other HTTP Server libs - generic version \n```zig\n    pub fn datastar.readSignals(comptime T: type, arena: std.mem.Allocator, req: *std.http.Server.Request) !T\n```\n\nWill take a Type (struct) and a HTTP request, and returns a filled in struct of the requested type.\n\nIf the request is a `HTTP GET` request, it will extract the signals from the query params. You will see that \nyour GET requests have a `?datastar=...` query param in most cases. This is how Datastar passes signals to\nyour backend via a GET request.\n\nIf the request is a `HTTP POST` or other request that uses a payload body, this function will use the \npayload body to extract the signals. This is how Datastar passes signals to your backend when using POST, etc.\n\nEither way, provide `readSignals` with a type that you want to read the signals into, and it will use the\nrequest method to work out which way to fill in the struct.\n\nExample :\n```zig\n    const FooBar = struct {\n        foor: []const u8,\n        bar: []const u8,\n    };\n\n    const signals = try http.readSignals(FooBar);\n    std.debug.print(\"Request sent foo: {s}, bar: {s}\\n\", .{signals.foo, signals.bar});\n```\n\n\n## Patching Elements\n\nThe SDK Provides 3 functions to patch elements over SSE.\n\nThese are all member functions of the SSE type that NewSSE(http) returns.\n\n\n```zig\n    pub fn patchElements(self: *SSE, elements: []const u8, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsFmt(self: *SSE, comptime elements: []const u8, args: anytype, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsWriter(self: *SSE, opt: PatchElementsOptions) *std.Io.Writer \n```\n\nUse `sse.patchElements` to directly patch the DOM with the given \"elements\" string.\n\nUse `sse.patchElementsFmt` to directly patch the DOM with a formatted print (where elements,args is the format string + args).\n\nUse `sse.patchElementsWriter` to return a std.Io.Writer object that you can programmatically write to using complex logic.\n\nWhen using the writer, you can call `w.flush()` to manually flush the writer ... but you generally \ndont need to worry about this, as the sse object will correctly terminate an existing writer, as\nsoon as the next `patchElements / patchSignals` is issued, or at the end of the handler cleanup\nas the `defer sse.close() / defer sse.deinit()` functions are called.\n\nSee the example apps for best working examples.\n\n\nPatchElementsOptions is defined as :\n\n```zig\npub const PatchElementsOptions = struct {\n    mode: PatchMode = .outer,\n    selector: ?[]const u8 = null,\n    view_transition: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n    namespace: NameSpace = .html,\n};\n\npub const PatchMode = enum {\n    inner,\n    outer,\n    replace,\n    prepend,\n    append,\n    before,\n    after,\n    remove,\n};\n\npub const NameSpace = enum {\n    html,\n    svg,\n    mathml,\n};\n```\n\nSee the Datastar documentation for the usage of these options when using patchElements.\n\nhttps://data-star.dev/reference/sse_events\n\nMost of the time, you will want to simply pass an empty tuple `.{}` as the options parameter. \n\nExample handler (from `examples/01_basic.zig`)\n\n```zig\nfn patchElements(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n```\n\n## Patching Signals\n\nThe SDK provides 2 functions to patch signals over SSE.\n\nThese are all member functions of the SSE type that NewSSE(http) returns.\n\n```zig\n    pub fn patchSignals(self: *SSE, value: anytype, json_opt: std.json.Stringify.Options, opt: PatchSignalsOptions) !void\n\n    pub fn patchSignalsWriter(self: *SSE, opt: PatchSignalsOptions) *std.Io.Writer\n```\n\nPatchSignalsOptions is defined as :\n```zig\npub const PatchSignalsOptions = struct {\n    only_if_missing: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `patchSignals` to directly patch the signals, passing in a value that will be JSON stringified into signals.\n\nUse `patchSignalsWriter` to return a std.Io.Writer object that you can programmatically write raw JSON to.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn patchSignals(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    const foo = prng.random().intRangeAtMost(u8, 0, 255);\n    const bar = prng.random().intRangeAtMost(u8, 0, 255);\n\n    try sse.patchSignals(.{\n        .foo = foo,\n        .bar = bar,\n    }, .{}, .{});\n}\n```\n\n## Executing Scripts\n\nThe SDK provides 3 functions to initiate executing scripts over SSE.\n\n```zig\n\n    pub fn executeScript(self: *SSE, script: []const u8, opt: ExecuteScriptOptions) !void\n\n    pub fn executeScriptFmt(self: *SSE, comptime script: []const u8, args: anytype, opt: ExecuteScriptOptions) !void \n\n    pub fn executeScriptWriter(self: *SSE, opt: ExecuteScriptOptions) *std.Io.Writer\n```\n\nExecuteScriptOptions is defined as :\n```zig\npub const ExecuteScriptOptions = struct {\n    auto_remove: bool = true, // by default remove the script after use, otherwise explicity set this to false if you want to keep the script loaded\n    attributes: ?ScriptAttributes = null,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `executeScript` to send the given script to the frontend for execution.\n\nUse `executeScriptFmt` to use a formatted print to create the script, and send it to the frontend for execution. \nWhere (script, args) is the same as print(format, args).\n\nUse `executeScriptWriter` to return a std.Io.Writer object that you can programmatically write the script to, for\nmore complex cases.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn executeScript(req: *httpz.Request, res: *httpz.Response) !void {\n    const value = req.param(\"value\"); // can be null\n\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    try sse.executeScriptFmt(\"console.log('You asked me to print {s}')\"\", .{\n            value orelse \"nothing at all\",\n    });\n}\n```\n\n# Advanced SSE Topics\n\n## Synchronous Writes \n\nBy default, when you create a `NewSSE(http)`, and do various actions on it such as `patchElements()`, this \nwill buffer up the converted SSE stream, which is then written to the client browser as the request is \nfinalised.\n\nIn some cases you may want to do Synchronous Writes to the client browser as each operation is performed in the\nhandler, so that as each `patchElements()` call is made, the patch is written immediately to the browser.\n\nIn this case use `NewSSESync(http)` to set the SSE into Synchronous Mode.\n\nFor example - in the SVGMorph demo, we want to generate a randomized SVG update, then write that to the client \nbrowser, then pause for 100ms and repeat, to provide a smooth animation of the SVG.\n\n## Namespaces - SVG and MathML (Datastar RC7 feature)\n\n`patchElements()` works great when morphing small fragments into existing DOM content, using the element ID,\nor other selectors.\n\nUnfortunately, when we have a large chunk of SVG or MathML content, the standard HTML morphing \ncannot reach down inside the SVG markup to pick out individual child elements for individual updates.\n\nHowever, you can now use the `.namespace = svg` or `.namespace = mathml` options for `patchElements()` now\nto do exactly this.\n\nSee the SVG and MathML demo code in example_1 to see this in action.\n\n# Publish and Subscribe\n\nThe `datastar.http.zig` SDK (here - https://github.com/zigster64/datastar.http.zig) has a built in pub/sub\nsystem that exploits the fact that http.zig allows you to detach sockets from handlers for later use.\n\nIn Zig 0.16 - The recommended approach here will be to use the Evented IO to create long running coroutines \nfor those handlers that want to subscribe to topics.\n\nFor publishing to topics in a production environment, then just connect in a message bus such as Redis, or NATS, or Postgres listen/notify and thats all thats needed.\n\nThis version of the SDK also implements the pub/sub  \n\n# Long Lived Connections\n\nWhen using a pub/sub setup with your application (be it the built in pubsub, or some more robust multi-service messaging backbone), you will want\nyour connections to be long lived.\n\nSome examples for different ways to acheive this :\n\n```zig\n// Using the built in pub-sub\n// Sit this thread in a loop that will generate keepalive pings every 30 seconds\n// whilst other threads write data to the same connection via the publish callback\nfn catsList(app: *App, http: *HTTPRequest) !void {\n    var sse = try datastar.NewSSESync(http);\n\n    try app.subscribers.subscribe(\"cats\", &sse, App.publishCatList);\n    sse.keepalive(http.io, .fromSeconds(30));\n    subs.unsubscribe(&sse);\n}\n\n// Using an external pub-sub message queue\nfn catsList(app: *App, http: *HTTPRequest) !void {\n    var sse = try datastar.NewSSESync(http);\n\n    var mq = app.pubsub.subscribe(\"cats\");\n    while (mq.next()) {\n        app.publishCatList();\n    }\n}\n\n\n```\n\n\n\n\n# Contrib Policy\n\nAll contribs welcome.\n\nPlease raise a github issue first before adding a PR, and reference the issue in the PR title. \n\nThis allows room for open discussion, as well as tracking of issues opened and closed.\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/72305366?u=cf46defe1dc7db6770201913a79150fbcbddb6ff&v=4",
  "releases": [],
  "owner_bio": "Half Stack Dev.\r\n\r\nIâ€™m into minimalist code and tools.\r\n\r\n\r\n",
  "owner_company": null,
  "owner_location": "Outback Australia, middle of nowhere",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 54,
  "owner_following": 58,
  "owner_created_at": "2020-10-03T12:46:34Z",
  "license": "MIT",
  "category": "library"
}