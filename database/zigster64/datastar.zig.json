{
  "name": "datastar.zig",
  "owner": "zigster64",
  "repo": "datastar.zig",
  "description": "Datastar SDK for zig 0.16",
  "type": "package",
  "topics": [
    "data-star",
    "datastar",
    "zig-package"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-12-26T06:25:18Z",
  "minimum_zig_version": "0.16.0-dev",
  "readme": "# Datastar lib for zig 0.16-dev\n\nA Zig library for 0.16 / latest async/concurrent stdlib that conforms to the Datastar SDK specification.\n\nhttps://github.com/starfederation/datastar/blob/develop/sdk/ADR.md\n\n.. and passes the official test cases.\n\nVersions :\n- Datastar 1.0.0-RC7\n- Zig 0.16.x\n\nSee Also http://github.com/zigster64/datastar.http.zig for the Datastar SDK for zig 0.15.2 sitting on top of http.zig\n\n# Audience and Scope\n\nWho is this repo for ?\n\n- Anyone interested in using Datastar. https://data-star.dev.\n\nIt is a state of the art Hypermedia-first library for building apps. \n\nIts not \"yet another frontend framework\" - its a 10kb JS shim that allows you to write application code\nat the backend, and leverage modern browser standards to have a very fast, very light, reactive UI \nwith none of the junk. There are no build steps, no npm deps - just declarative HTML and reactive signals,\ndriven from the backend.\n\nIf you know, you know.\n\nIt uses a well defined SSE-first protocol that is backend agnostic - you can use the the same simple \nSDK functions to write the same app in Go, Clojure, C#, PHP, Python, Bun, Ruby, Rust, Lisp, Racket, Java, etc. \n\nThis project adds Zig to that list of supported SDK languages.\n\nIt uses the exact same spec as all the other SDK's, and reads extremely similarly to say - a Go program\nor a Python program using the same SDK.\n\nWhy consider the Zig version then ? Who is that for ?\n\n- Existing Zig programmers who want to try Datastar\n- Datastar app builders who want to experiment with performance, and dabble in new backend languages\n\nConsider Zig if every microsecond counts, or you want stupidly small memory footprints that dont grow.\n\nZig gives you some pretty good tuning options if you want to chase benchmarks and break records too.\n\nWe are talking orders of magnitude performance and resource usage gains for your existing Datastar app, depending\non what you are currently using. \n\nTry it out.\n\n# Quick Start Introduction\n\nIf you just want to quickly install this, and try out the demo programs first, do this :\n\n```\n... get zig 0.15.2 installed on your machine\ngit clone https://github.com/zigster64/datastar.http.zig\ncd datastar.http.zig\nzig build\n./zig-out/bin/example_1\n```\n\nThen open your browser to http://localhost:8081\n\n\nThis will bring up a kitchen sink app that shows each of the SDK functions in use in the browser, with a \nsection that displays the code to use on your backend to drive the page you are looking at.\n\n![Screenshot of example_1](./docs/images/example_1a.png)\n\n`./zig-out/bin/tokamak_basic` - Same application, but using Tokamak instead of directly using http.zig\n\n---\n\nTo run the additional example apps, try\n\n`./zig-out/bin/example_2` - a simple cat auction site.\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\n\n![Screenshot of example_2](./docs/images/example_2.png)\n\n---\n\n`./zig-out/bin/example_22` - a more complex cat aution site, with session based preferences managed at the backend.\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\nChange preferences, and watch that all browser windows in the same session get their preferences updated.\n\nUse a different machine, or browser, or use the 'Profiles' feature in Chrome/Safari/Firefox to simulate a new session.\nNote that the bids update in realtime across all browsers, and just the preferences changes are sticky across all \nwindows belonging to the same machine/profile.\n\n![Screenshot of example_22](./docs/images/example_22.png)\n\n---\n\n`./zig-out/bin/example_5` - an excellent and exciting multi-player farming simulator, where users can plant and attend \nto various crops to help them grow to harvest (or whither and die if neglected)\n\n![Screenshot of example_5](./docs/images/example_5.png)\n\n# Validation Test\n\nWhen you run `zig build`, it will compile several apps into `./zig-out/bin` including a binary called `validation-test`\n\nRun `./zig-out/bin/validation-test`, which will start a server on port 7331\n\nThen follow the procedure documented at\n\nhttps://github.com/starfederation/datastar/blob/main/sdk/tests/README.md\n\nTo run the official Datastar validation suite against this test harness\n\nThe source code for the `validation-test` program is in the file `tests/validation.zig`\n\nCurrent version passes all tests.\n\n# Contrib Policy\n\nAll contribs welcome.\n\nPlease raise a github issue first before adding a PR, and reference the issue in the PR title. \n\nThis allows room for open discussion, as well as tracking of issues opened and closed.\n\n\n# Example Apps\n\nWhen you run `zig build` it will compile several apps into `./zig-out/bin/` to demonstrate using different parts \nof the api\n\nUsing http.zig :\n\n- example_1  shows using the Datastar API using basic SDK handlers\n- example_2  shows an example multi-user auction site for cats with realtime updates using pub/sub\n- example_22 Same cat auction as above, but with per-user preferences, all handled on the backend only\n\n<!-- - example_3  shows an example multi-user pigeon racing betting site with realtime updates -->\n<!-- - example_4  shows an example multi-game, multi-player TicTacToe site, using the backstage actor framework -->\n\n- example_5  shows an example multi-player Gardening Simulator using pub/sub\n\n\n# Installation and Usage\n\nTo build an application using this SDK\n\n1) Add datastar.http.zig as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save=\"datastar\" \"git+https://github.com/zigstser64/datastar.zig#master\"\n```\n\n2) In your `build.zig`, add the `datastar` module as a dependency you your program:\n\n```zig\nconst datastar = b.dependency(\"datastar\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"datastar\", datastar.module(\"datastar\"));\n```\n\n# Web Server ?\n\nThis 0.16 Version of the Datastar SDK includes a basic web server and fast radix-tree based router that uses the stdlib server.\n\nYou can optionally use this built-in server if you want to start experiminting with Zig 0.16-dev, as it has no other dependencies outside of stdlib.\n\nTo use the built in HTTP server :\n\n```zig \nconst std = @import(\"std\");\nconst datastar = @import(\"datastar\");\nconst HTTPRequest = datastar.HTTPRequest;\n\nconst Io = std.Io;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    var threaded: Io.Threaded = .init(allocator);\n    defer threaded.deinit();\n    const io = threaded.io();\n\n    // pass an IO, an allocator, an address, and a port number to listen on\n    var server = try datastar.Server.init(io, allocator, \"0.0.0.0\", 8080);\n    defer server.deinit();\n\n    // Add some routes with different http methods\n    const r = server.router;\n    try r.get(\"/\", index);\n    try r.get(\"/text-html\", textHtml);\n    try r.get(\"/patch\", patchElements);\n    try r.post(\"/patch/opts\", patchElementsOpts);\n    try r.get(\"/code/:snip\", code);\n\n    std.debug.print(\"Server listening on http://localhost:8080\\n\", .{});\n    try server.run();\n}\n\n// all handlers receive a single HTTPRequest param\nfn index(http: HTTPRequest) !void {\n    // http has verbs such as html() to send HTML, json() to send JSON, etc\n    return try http.html(@embedFile(\"index.html\"));\n}\n\nfn patchElements(http: HTTPRequest) !void {\n    // here we call NewSSE() on the http request, which sets this into \n    // event-stream mode.\n    var buf: [1024]u8 = undefined;\n    var sse = try datastar.NewSSE(http, &buf);\n    defer sse.close(); // Sends off the SSE event stream, and closes the connection\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n```\n\n# Functions\n\n## Cheatsheet of all SDK functions\n\n```zig\nconst datastar = @import(\"datastar\");\n\n// read signals either from GET or POST\ndatastar.readSignals(comptime T: type, req: anytype) !T\n\n// set the connection to SSE, and return an SSE object\nvar sse = datastar.NewSSE(req) !SSE\nvar sse = datastar.NewSSEOpt(req, sse_options) !SSE\n\n// set the connection to SSE, and return an SSE object in Synchronous Write mode\nvar sse = datastar.NewSSESync(req) !SSE\ndefer sse.close();\n\n// patch elements function variants\nsse.patchElements(elementsHTML, elements_options) !void\nsse.patchElementsFmt(comptime elementsHTML, arguments, elements_options) !void\nsse.patchElementsWriter(elements_options) *std.Io.Writer \n\n// patch signals function variants\nsse.patchSignals(value, json_options, signals_options) !void\nsse.patchSignalsWriter(signals_options) *std.Io.Writer\n\n// execute scripts function variants\nsse.executeScript(script, script_options) !void\nsse.executeScriptFmt(comptime script, arguments, script_options) !void\nsse.executeScriptWriter(script_options) *std.Io.Writer\n\n\n# Using the Datastar SDK\n\n## The SSE Object\n\nCalling NewSSE, passing a request and response, will return an object of type SSE.\n\n```zig\n    pub fn NewSSE(req) !SSE \n```\n\nThis will configure the connnection for SSE transfers, and provides an object with Datastar methods for\npatching elements, patching signals, executing scripts, etc.\n\nWhen you are finished with this SSE object, you must call `sse.close()` to finish the handler.\n\nWhen running in this default mode (named internally as 'batched mode'), all of the SSE patches are batched\nup, and then passed up to the HTTP library for transmission, and closing the connection.\n\nIn batched mode, the entire payload is sent as a single transmission with a fixed content-length header, \nand no chunked encoding.\n\nYou can declare your sse object early in the handler, and then set headers / cookies etc at any time \nin the handler. Because actual network updates are batched till the end, everything goes out in the correct order.\n\nFinally, there is a NewSSE variant that takes a set of options, for special cases\n\n```zig\n    pub fn NewSSEOpt(req, res, SSEOptions) !SSE\n\n    // Where options are \n    const SSEOptions = struct {\n        mode: SSEMode = .batch,\n        buffer_size: usize = 16 * 1024, // internal buffer size for batched mode\n    };\n\n    const SSEMode = enum {\n        batch, // batch up output in memory, and sort it out at the end of the handler\n        sync,  // use chunked encoding and output patches on the wire as soon as they are called\n    };\n```\n\n## Reading Signals from the request\n\n```zig\n    pub fn readSignals(comptime T: type, req: anytype) !T\n```\n\nWill take a Type (struct) and a HTTP request, and returns a filled in struct of the requested type.\n\nIf the request is a `HTTP GET` request, it will extract the signals from the query params. You will see that \nyour GET requests have a `?datastar=...` query param in most cases. This is how Datastar passes signals to\nyour backend via a GET request.\n\nIf the request is a `HTTP POST` or other request that uses a payload body, this function will use the \npayload body to extract the signals. This is how Datastar passes signals to your backend when using POST, etc.\n\nEither way, provide `readSignals` with a type that you want to read the signals into, and it will use the\nrequest method to work out which way to fill in the struct.\n\nExample :\n```zig\n    const FooBar = struct {\n        foor: []const u8,\n        bar: []const u8,\n    };\n\n    const signals = try datastar.readSignals(FooBar, req);\n    std.debug.print(\"Request sent foo: {s}, bar: {s}\\n\", .{signals.foo, signals.bar});\n```\n\n\n## Patching Elements\n\nThe SDK Provides 3 functions to patch elements over SSE.\n\nThese are all member functions of the SSE type that NewSSE(req, res) returns.\n\n\n```zig\n    pub fn patchElements(self: *SSE, elements: []const u8, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsFmt(self: *SSE, comptime elements: []const u8, args: anytype, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsWriter(self: *SSE, opt: PatchElementsOptions) *std.Io.Writer \n```\n\nUse `sse.patchElements` to directly patch the DOM with the given \"elements\" string.\n\nUse `sse.patchElementsFmt` to directly patch the DOM with a formatted print (where elements,args is the format string + args).\n\nUse `sse.patchElementsWriter` to return a std.Io.Writer object that you can programmatically write to using complex logic.\n\nWhen using the writer, you can call `w.flush()` to manually flush the writer ... but you generally \ndont need to worry about this, as the sse object will correctly terminate an existing writer, as\nsoon as the next `patchElements / patchSignals` is issued, or at the end of the handler cleanup\nas the `defer sse.close() / defer sse.deinit()` functions are called.\n\nSee the example apps for best working examples.\n\n\nPatchElementsOptions is defined as :\n\n```zig\npub const PatchElementsOptions = struct {\n    mode: PatchMode = .outer,\n    selector: ?[]const u8 = null,\n    view_transition: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n    namespace: NameSpace = .html,\n};\n\npub const PatchMode = enum {\n    inner,\n    outer,\n    replace,\n    prepend,\n    append,\n    before,\n    after,\n    remove,\n};\n\npub const NameSpace = enum {\n    html,\n    svg,\n    mathml,\n};\n```\n\nSee the Datastar documentation for the usage of these options when using patchElements.\n\nhttps://data-star.dev/reference/sse_events\n\nMost of the time, you will want to simply pass an empty tuple `.{}` as the options parameter. \n\nExample handler (from `examples/01_basic.zig`)\n\n```zig\nfn patchElements(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(req, res);\n    defer sse.close(res);\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n```\n\n## Patching Signals\n\nThe SDK provides 2 functions to patch signals over SSE.\n\nThese are all member functions of the SSE type that NewSSE(req, res) returns.\n\n```zig\n    pub fn patchSignals(self: *SSE, value: anytype, json_opt: std.json.Stringify.Options, opt: PatchSignalsOptions) !void\n\n    pub fn patchSignalsWriter(self: *SSE, opt: PatchSignalsOptions) *std.Io.Writer\n```\n\nPatchSignalsOptions is defined as :\n```zig\npub const PatchSignalsOptions = struct {\n    only_if_missing: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `patchSignals` to directly patch the signals, passing in a value that will be JSON stringified into signals.\n\nUse `patchSignalsWriter` to return a std.Io.Writer object that you can programmatically write raw JSON to.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn patchSignals(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(req, res);\n    defer sse.close(res);\n\n    const foo = prng.random().intRangeAtMost(u8, 0, 255);\n    const bar = prng.random().intRangeAtMost(u8, 0, 255);\n\n    try sse.patchSignals(.{\n        .foo = foo,\n        .bar = bar,\n    }, .{}, .{});\n}\n```\n\n## Executing Scripts\n\nThe SDK provides 3 functions to initiate executing scripts over SSE.\n\n```zig\n\n    pub fn executeScript(self: *SSE, script: []const u8, opt: ExecuteScriptOptions) !void\n\n    pub fn executeScriptFmt(self: *SSE, comptime script: []const u8, args: anytype, opt: ExecuteScriptOptions) !void \n\n    pub fn executeScriptWriter(self: *SSE, opt: ExecuteScriptOptions) *std.Io.Writer\n```\n\nExecuteScriptOptions is defined as :\n```zig\npub const ExecuteScriptOptions = struct {\n    auto_remove: bool = true, // by default remove the script after use, otherwise explicity set this to false if you want to keep the script loaded\n    attributes: ?ScriptAttributes = null,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `executeScript` to send the given script to the frontend for execution.\n\nUse `executeScriptFmt` to use a formatted print to create the script, and send it to the frontend for execution. \nWhere (script, args) is the same as print(format, args).\n\nUse `executeScriptWriter` to return a std.Io.Writer object that you can programmatically write the script to, for\nmore complex cases.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn executeScript(req: *httpz.Request, res: *httpz.Response) !void {\n    const value = req.param(\"value\"); // can be null\n\n    var sse = try datastar.NewSSE(req, res);\n    defer sse.close(res);\n\n    try sse.executeScriptFmt(\"console.log('You asked me to print {s}')\"\", .{\n            value orelse \"nothing at all\",\n    });\n}\n```\n\n# Advanced SSE Topics\n\n## Namespaces - SVG and MathML (Datastar RC7 feature)\n\n`patchElements()` works great when morphing small fragments into existing DOM content, using the element ID,\nor other selectors.\n\nUnfortunately, when we have a large chunk of SVG or MathML content, the standard HTML morphing \ncannot reach down inside the SVG markup to pick out individual child elements for individual updates.\n\nHowever, you can now use the `.namespace = svg` or `.namespace = mathml` options for `patchElements()` now\nto do exactly this.\n\nSee the SVG and MathML demo code in example_1 to see this in action.\n\n# Publish and Subscribe\n\nThe `datastar.http.zig` SDK (here - https://github.com/zigster64/datastar.http.zig) has a built in pub/sub\nsystem that exploits the fact that http.zig allows you to detach sockets from handlers for later use.\n\nIn Zig 0.16 - The recommended approach here will be to use the Evented IO to create long running coroutines \nfor those handlers that want to subscribe to topics.\n\nFor publishing to topics, then just connect in a message bus such as Redis, or NATS, or Postgres listen/notify and thats all thats needed.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/72305366?u=cf46defe1dc7db6770201913a79150fbcbddb6ff&v=4",
  "releases": [],
  "owner_bio": "Half Stack Dev.\r\n\r\nIâ€™m into minimalist code and tools.\r\n\r\n\r\n",
  "owner_company": null,
  "owner_location": "Outback Australia, middle of nowhere",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 53,
  "owner_following": 57,
  "owner_created_at": "2020-10-03T12:46:34Z",
  "license": "MIT",
  "category": "library"
}