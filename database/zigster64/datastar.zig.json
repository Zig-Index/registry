{
  "name": "datastar.zig",
  "owner": "zigster64",
  "repo": "datastar.zig",
  "description": "Datastar SDK for zig 0.16",
  "type": "package",
  "topics": [
    "data-star",
    "datastar",
    "zig-package",
    "zig-library"
  ],
  "stars": 4,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-01-05T03:40:18Z",
  "dependencies": [
    {
      "name": "pubsub",
      "url": "git+https://github.com/zigster64/pubsub.zig#56d36eebb7d3ca877374e1af4a702163803d3708",
      "hash": "pubsub-0.0.0-6dy2AZ9_AAB9BtgLy_SedPDb2SHiMjORuT1ybJ1TCITc"
    }
  ],
  "minimum_zig_version": "0.16.0-dev",
  "readme": "# Datastar lib for zig 0.16-dev\n\n![Cyberpunk Datastar Zig SDK - Sydney Metro Rail - Leica XV](assets/datastar.zig.jpg)\n\nA Zig library for 0.16 / latest stdlib that conforms to the Datastar SDK specification.\n\nhttps://github.com/starfederation/datastar/blob/develop/sdk/ADR.md\n\n.. and passes the official Datastar test cases.\n\nVersions :\n- Datastar 1.0.0-RC7\n- Zig 0.16-dev\n\n\nFor stable Zig 0.15.2 - see https://github.com/zigster64/datastar.http.zig\n\n# Audience and Scope\n\nWho is this repo for ?\n\n- Anyone interested in using Datastar. https://data-star.dev.\n\nDatastar allows you to build interactive Web UIs, driven from the backend server, using\ndeclarative HTML. It is particularly good for doing real time push updates, event sourcing, and\nmulti-player or collaborative applications.\n\nSee the end of this document for more resources if you want to know more \nabout Datastar.\n\nDatastar uses a well defined SSE-first protocol that is backend agnostic - you can use the the same simple \nSDK functions to write the same app in Go, Clojure, C#, PHP, Python, Bun, Ruby, Rust, Lisp, Racket, Java, etc. \n\nThis project adds Zig 0.16-dev to that list of supported SDK languages.\n\n_Why consider the Zig version then ? Who is that for ?_\n\n- Existing Zig programmers who want to try Datastar\n- Datastar app builders who want to experiment with performance, and dabble in new backend languages\n\nConsider Zig if every microsecond counts, or you want small memory footprints.\n\nTry it out.\n\n# Installation and Usage\n\nTo build an application using this SDK\n\n1) Add datastar.zig as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save=\"datastar\" \"git+https://github.com/zigstser64/datastar.zig#master\"\n```\n\n2) In your `build.zig`, add the `datastar` module as a dependency you your program:\n\n```zig\nconst datastar = b.dependency(\"datastar\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"datastar\", datastar.module(\"datastar\"));\n\n// or add the module \"datastar\" to the .imports section of your exe\n```\n\n3) In your application code\n\nDepends on the HTTP Framework you are using.\n\nThis SDK does include a complete HTTP Framework for Zig 0.16 to get \nyou started. Here is a full example using this built in HTTP Server\nwith Datastar specific SSE events.\n\n```zig\n\nconst ADDRESS = \"0.0.0.0\"; // all IP addresses\nconst PORT = 8080; \n\npub fn main() !void {\n    var gpa = std.heap.DebugAllocator(.{}).init;\n    const allocator = gpa.allocator();\n\n    // Evented isnt really working yet, so stick with Threaded IO for now\n    // Once Evented is functional, its just a 1 line change here to swap\n    // from heavy threads to coroutines\n    var threaded: Io.Threaded = .init(allocator);\n    defer threaded.deinit();\n    const io = threaded.io();\n\n    // Create a server listening for new HTTP connections\n    var server = try HTTPServer.init(io, allocator, ADDRESS, PORT);\n    defer server.deinit();\n\n    // Setup all the routes\n    const r = server.router;\n    r.get(\"/\", index);\n    r.get(\"/sse/:id\", sseEndpoint);\n    ... all the routes\n\n    std.debug.print(\"Server listening on http://{s}:{}\\n\", .{ADDRESS, PORT});\n    try server.run();\n}\n\n// Handler code\nfn index(http: *HTTPRequest) !void {\n    // Note\n    // - Include the Datastar bundle (or you can host your own)\n    // - The body makes a call to /see to fetch content\n    // - The div id=\"hello\" is a target for updating in the /sse call\n    // - The data-json-signals element provides debugging output for the current state of signals\n    return http.html(\n        \\\\<!DOCTYPE html>\n        \\\\<head>\n        \\\\  <script type=\"module\"\n        \\\\    src=\"https://cdn.jsdelivr.net/gh/starfederation/datastar@1.0.0-RC.7/bundles/datastar.js\">\n        \\\\  </script>\n        \\\\</head>\n\n        \\\\<body data-init=\"/sse/zig\">\n        \\\\  <div id=\"hello\">Loading ...</div>\n        \\\\  <pre data-json-signals></pre>\n        \\\\</body>\n    );\n}\n\n// A simple SSE endpoint that generates a set of events over the stream \nfn sseEndpoint(http: *HTTPRequest) !void {\n    const id = http.params.get(\"id\") orelse return error.NoID;\n\n    var sse = try http.NewSSE();\n    defer sse.close();\n\n    // Update just the id='hello' element in the DOM\n    try sse.patchElements(\"<div id='hello'>Hello World</div>\");\n\n\n    try sse.patchSignals(.{.foo = 42, .bar = \"Datastar Rocks\"});\n    try sse.executeScriptFmt(\"alert('All your base are belong to {s}')\", .{id});\n}\n```\n\n# Web Server that works with Zig 0.16-dev ?\n\nThis 0.16 Version of the Datastar SDK includes a basic web development framework and fast radix-tree\nbased router that uses the stdlib http server.\n\nIt uses similar API conventions to https://github.com/karlseguin/http.zig, tuned\nspecifically for use with Datastar applications.\n\nYou can use this built-in server, or you can use any other HTTP Server Framework that works with\nZig 0.16. \n\nSee the example above in the install step about using the built in HTTP Server.\n\nSee notes at the end of this document about adapting other HTTP Server Frameworks.\n\n\n# Quick Start Introduction\n\nIf you just want to quickly install this, and try out the demo programs first, do this :\n\n```\n... get zig 0.16-dev installed on your machine, then ...\n\ngit clone https://github.com/zigster64/datastar.zig\ncd datastar.zig\nzig build\n./zig-out/bin/example_1\n```\n\nThen open your browser to http://localhost:8081\n\n\nThis will bring up a kitchen sink app that shows each of the SDK functions in use in the browser, with a \nsection that displays the code to use on your backend to drive the page you are looking at.\n\n![Screenshot of example_1](./docs/images/example_1a.png)\n\n![Show Code example](./docs/images/show_code.png)\n\n---\nExample of SVG and MathML morphing from the backend\n\nThe SDK allows you to patch interior elements of an SVG or MathML block, without having to re-render the\nentire block. \n\nhttps://github.com/user-attachments/assets/e8f48b44-c84d-4c43-9c1c-58a057db3e33\n\nhttps://github.com/user-attachments/assets/2383156f-6ba1-40de-8b45-117bbf59ed84\n\n---\n\n`./zig-out/bin/example_2` - a simple cat auction site.\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\n\n![Screenshot of example_2](./docs/images/example_2.png)\n\n---\n\n`./zig-out/bin/example_3` - a more complex WildCat aution site, with session based preferences managed\nat the backend.\n\nBring up multiple browser windows and watch the bids get updated in realtime to all windows.\nChange preferences, and watch that all browser windows in the same session get their preferences updated.\n\nUse a different machine, or browser to simulate a new session.\n\nNote that the bids update in realtime across all clients, and just the preferences changes are sticky\nacross all clients belonging to the same session.\n\n![Screenshot of example_3](./docs/images/example_3.png)\n\n---\n\n`./zig-out/bin/example_5` - an excellent and exciting multi-player farming simulator, where users can plant and attend \nto various crops to help them grow to harvest (or whither and die if neglected)\n\n![Screenshot of example_5](./docs/images/example_5.png)\n\n# Validation Test\n\nWhen you run `zig build`, it will compile several apps into `./zig-out/bin` including a binary called `validation-test`\n\nRun `./zig-out/bin/validation-test`, which will start a server on port 7331\n\nThen follow the procedure documented at\n\nhttps://github.com/starfederation/datastar/blob/main/sdk/tests/README.md\n\nTo run the official Datastar validation suite against this test harness\n\nThe source code for the `validation-test` program is in the file `tests/validation.zig`\n\nCurrent version passes all tests.\n\n\n# Example Apps\n\nWhen you run `zig build` it will compile several apps into `./zig-out/bin/` to demonstrate using different parts \nof the api\n\n- example_1  Using the Datastar API using basic SDK handlers\n- example_2  An example multi-user auction site for cats with realtime updates using pub/sub\n- example_3  Same cat auction as above, but with per-user preferences managed by the backend\n- example_4  (TODO) - a betting app simulator with realtime updates\n- example_5  shows an example multi-player Gardening Simulator using pub/sub\n- example_6  (TODO) - a multi-tenant TicTacToe game, with lobby, and anon viewing\n\n\n\n# Functions\n\n## Cheatsheet of all Datastar SDK functions\n\n```zig\nconst datastar = @import(\"datastar\");\n\n// read signals either from GET or POST\nhttp.readSignals(comptime T: type) !T  // for use with the built in HTTPServer, where http = *HTTPRequest\ndatastar.readSignals(comptime T: type, arena: std.mem.Allocator, req: *std.http.Server.Request) !T // generic interface if you are not using the built in HTTPServer\n\n// set the connection to SSE, and return an SSE object\nvar sse = http.NewSSE() !SSE\nvar sse = http.NewSSESync() !SSE\nvar sse = http.NewSSEOpt(sse_options) !SSE\n\n// when you are finished with this connection\nsse.close()\n\n// when you want to keep the connection alive for a long time \n// then call this in your handler. It will continue until the \n// browser closes the connection\nsse.keepalive(io, duration)\n\n// patch elements function variants\nsse.patchElements(elementsHTML, elements_options) !void\nsse.patchElementsFmt(comptime elementsHTML, arguments, elements_options) !void\nsse.patchElementsWriter(elements_options) *std.Io.Writer \n\n// patch signals function variants\nsse.patchSignals(value, json_options, signals_options) !void\nsse.patchSignalsWriter(signals_options) *std.Io.Writer\n\n// execute scripts function variants\nsse.executeScript(script, script_options) !void\nsse.executeScriptFmt(comptime script, arguments, script_options) !void\nsse.executeScriptWriter(script_options) *std.Io.Writer\n```\n\n## Cheatsheet of all HTTPServer functions\n\n```zig\n// Generate a Server type that has no global context\nServer(void)\n... handler signatures are handler(HTTPRequest)\n// Generate a Server type that takes a type as a global app context\nServer(T)\nserver.setContext(ctx)\n... handler signatures are handler(Context, HTTPRequest)\n\n// create a server given an address\nserver.init(io, allocator, address, port) !Server\n// create a server listening on all interfaces with IPv6\nserver.initIp6(io, allocator, port) !Server\n// server instance cleanup\nserver.deinit()\n// run the server\nserver.run()\n// tell the whole app to reload and reboot whenever the program is re-compiled\nserver.rebooter()\n```\n\nThe built in HTTPServer provides a simple fast router \n\n```zig\nvar app = App.init(allocator); // create a global state context for this app\nvar server = try datastar.Server(*App).initIp6(io, allocator, PORT);\nserver.setContext(&app);\n\nvar r = server.router;  // get the router from the Server we created\n\nr.get(path, handler)\nr.post(path, handler)\nr.patch(path, handler)\nr.delete(path, handler)\n\n// Generic route\nr.add(method, path, handler)\n\n// Path Parameters example\nr.get(\"/users/:id\", userHandler)\n\nfn userHandler(app: *App, http *HTTPRequest) !void {\n    const id = http.params.get(\"id\");\n    ...\n}\n\n```\n\nWhen using the built in HTTPServer, all handlers receive either : \n- a single paramater of type `*HTTPRequest` for servers of type `Server(void)`\n- a context, and a `*HTTPRequest` for servers of type `Server(T)`\n\nSee the above code example, where a global context of type `App` is created,\nand the server is defined as `Server(*App)`, followed by `server.setContext(&app)`.\n\nIn this case, the handler functions now all receive that global context.\n\nThis HTTPRequest has the following features :\n\n```zig\n// Internal values\n\nhttp.req     - the *std.http.Server.Request value\nhttp.io      - which std.Io interface is in use when calling this handler\nhttp.arena   - a per-request arena for doing allocations in your handler\nhttp.params  - the route parameters used in the request\n\n// Functions\nhttp.html(data) !void            // output data as text/html\nhttp.htmlFmt(format, args) !void // print formatted output data as text/html\nhttp.json(data) !void            // convert data to JSON and output as application/json\nhttp.query() ![]const u8         // get the query string for this request \nhttp.readSignals(T) !T           // read the signals from the request into struct of given type\n\n// Route Parameters \nhttp.params.get(name) ?[]const u8  // get the value of named parameter :name\nhttp.params.getInt(T, name) ?T     // get the value of named parameter :name as an Integer\n```\n\nThe built in functions allow you to easily return text/html or application/json. (as well as Datastar SSE actions, as shown below)\n\nIf you want to do anything more exotic, just use the `http.req` to construct whatever other response type you might need ... the new 0.16 stdlib\nprovides a lot of very low level control options for returning responses there.\n\n# Using the Datastar SDK\n\n## The SSE Object\n\nCalling NewSSE on the HTTPRequest will return an object of type SSE.\n\n```zig\n    sse.NewSSE() !SSE \n```\n\nThis will configure the connnection for SSE transfers, and provides an object with Datastar methods for\npatching elements, patching signals, executing scripts, etc.\n\nWhen you are finished with this SSE object, you must call `sse.close()` to finish the handler.\n\nWhen running in this default mode (named internally as 'batched mode'), all of the SSE patches are batched\nup, and then passed up to the HTTP library for transmission, and closing the connection.\n\nIn batched mode, the entire payload is sent as a single transmission with a fixed content-length header, \nand no chunked encoding.\n\nYou can declare your sse object early in the handler, and then set headers / cookies etc at any time \nin the handler. Because actual network updates are batched till the end, everything goes out in the correct order.\n\n```zig\n    sse.NewSSESync() !SSE \n```\nWill create an SSE object that will do immediate Synchronous Writes to the browser as each `patchElements()` call is made.\n\nFinally, there is a NewSSE variant that takes a set of options, for special cases\n\n```zig\n    sse.NewSSEOpt(SSEOptions) !SSE\n\n    // Where options are \n    const SSEOptions = struct {\n        buffer_size: usize = 16 * 1024, // internal buffer size for batched mode\n        sync: bool = false,\n    };\n```\n\n## Reading Signals from the request\n\nUsing the built in HTTPServer\n```zig\n    pub fn http.readSignals(comptime T: type) !T\n```\n\nUsing a generic version for other HTTP Frameworks\n```zig\n    pub fn datastar.readSignals(comptime T: type, arena: std.mem.Allocator, req: *std.http.Server.Request) !T\n```\n\nWill take a Type (struct) and a HTTP request, and returns a filled in struct of the requested type.\n\nIf the request is a `HTTP GET` request, it will extract the signals from the query params. You will see that \nyour GET requests have a `?datastar=...` query param in most cases. This is how Datastar passes signals to\nyour backend via a GET request.\n\nIf the request is a `HTTP POST` or other request that uses a payload body, this function will use the \npayload body to extract the signals. This is how Datastar passes signals to your backend when using POST, etc.\n\nEither way, provide `readSignals` with a type that you want to read the signals into, and it will use the\nrequest method to work out which way to fill in the struct.\n\nExample :\n```zig\n    const FooBar = struct {\n        foor: []const u8,\n        bar: []const u8,\n    };\n\n    const signals = try http.readSignals(FooBar);\n    std.debug.print(\"Request sent foo: {s}, bar: {s}\\n\", .{signals.foo, signals.bar});\n```\n\nIf you prefer, you can use anonymous structs too - can make the code more readable :\n\n```zig\n    const signals = try http.readSignals(struct {foo: []const u8, bar: []const u8});\n    std.debug.print(\"Request sent foo: {s}, bar: {s}\\n\", .{signals.foo, signals.bar});\n```\n\n\n## Patching Elements\n\nThe SDK Provides 3 functions to patch elements over SSE.\n\nThese are all member functions of the SSE type that NewSSE(http) returns.\n\n\n```zig\n    pub fn patchElements(self: *SSE, elements: []const u8, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsFmt(self: *SSE, comptime elements: []const u8, args: anytype, opt: PatchElementsOptions) !void\n\n    pub fn patchElementsWriter(self: *SSE, opt: PatchElementsOptions) *std.Io.Writer \n```\n\nUse `sse.patchElements` to directly patch the DOM with the given \"elements\" string.\n\nUse `sse.patchElementsFmt` to directly patch the DOM with a formatted print (where elements,args is the format string + args).\n\nUse `sse.patchElementsWriter` to return a std.Io.Writer object that you can programmatically write to using complex logic.\n\nWhen using the writer, you can call `w.flush()` to manually flush the writer ... but you generally \ndont need to worry about this, as the sse object will correctly terminate an existing writer, as\nsoon as the next `patchElements / patchSignals` is issued, or at the end of the handler cleanup\nas the `defer sse.close() / defer sse.deinit()` functions are called.\n\nSee the example apps for best working examples.\n\n\nPatchElementsOptions is defined as :\n\n```zig\npub const PatchElementsOptions = struct {\n    mode: PatchMode = .outer,\n    selector: ?[]const u8 = null,\n    view_transition: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n    namespace: NameSpace = .html,\n};\n\npub const PatchMode = enum {\n    inner,\n    outer,\n    replace,\n    prepend,\n    append,\n    before,\n    after,\n    remove,\n};\n\npub const NameSpace = enum {\n    html,\n    svg,\n    mathml,\n};\n```\n\nSee the Datastar documentation for the usage of these options when using patchElements.\n\nhttps://data-star.dev/reference/sse_events\n\nMost of the time, you will want to simply pass an empty tuple `.{}` as the options parameter. \n\nExample handler (from `examples/01_basic.zig`)\n\n```zig\nfn patchElements(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    try sse.patchElementsFmt(\n        \\\\<p id=\"mf-patch\">This is update number {d}</p>\n    ,\n        .{getCountAndIncrement()},\n        .{},\n    );\n}\n```\n\n## Patching Signals\n\nThe SDK provides 2 functions to patch signals over SSE.\n\nThese are all member functions of the SSE type that NewSSE(http) returns.\n\n```zig\n    pub fn patchSignals(self: *SSE, value: anytype, json_opt: std.json.Stringify.Options, opt: PatchSignalsOptions) !void\n\n    pub fn patchSignalsWriter(self: *SSE, opt: PatchSignalsOptions) *std.Io.Writer\n```\n\nPatchSignalsOptions is defined as :\n```zig\npub const PatchSignalsOptions = struct {\n    only_if_missing: bool = false,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `patchSignals` to directly patch the signals, passing in a value that will be JSON stringified into signals.\n\nUse `patchSignalsWriter` to return a std.Io.Writer object that you can programmatically write raw JSON to.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn patchSignals(req: *httpz.Request, res: *httpz.Response) !void {\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    const foo = prng.random().intRangeAtMost(u8, 0, 255);\n    const bar = prng.random().intRangeAtMost(u8, 0, 255);\n\n    try sse.patchSignals(.{\n        .foo = foo,\n        .bar = bar,\n    }, .{}, .{});\n}\n```\n\n## Executing Scripts\n\nThe SDK provides 3 functions to initiate executing scripts over SSE.\n\n```zig\n\n    pub fn executeScript(self: *SSE, script: []const u8, opt: ExecuteScriptOptions) !void\n\n    pub fn executeScriptFmt(self: *SSE, comptime script: []const u8, args: anytype, opt: ExecuteScriptOptions) !void \n\n    pub fn executeScriptWriter(self: *SSE, opt: ExecuteScriptOptions) *std.Io.Writer\n```\n\nExecuteScriptOptions is defined as :\n```zig\npub const ExecuteScriptOptions = struct {\n    auto_remove: bool = true, // by default remove the script after use, otherwise explicity set this to false if you want to keep the script loaded\n    attributes: ?ScriptAttributes = null,\n    event_id: ?[]const u8 = null,\n    retry_duration: ?i64 = null,\n};\n```\n\nUse `executeScript` to send the given script to the frontend for execution.\n\nUse `executeScriptFmt` to use a formatted print to create the script, and send it to the frontend for execution. \nWhere (script, args) is the same as print(format, args).\n\nUse `executeScriptWriter` to return a std.Io.Writer object that you can programmatically write the script to, for\nmore complex cases.\n\nExample handler (from `examples/01_basic.zig`)\n```zig\nfn executeScript(req: *httpz.Request, res: *httpz.Response) !void {\n    const value = req.param(\"value\"); // can be null\n\n    var sse = try datastar.NewSSE(http);\n    defer sse.close();\n\n    try sse.executeScriptFmt(\"console.log('You asked me to print {s}')\"\", .{\n            value orelse \"nothing at all\",\n    });\n}\n```\n\n# Advanced SSE Topics\n\n## Batched Writes vs Synchronous Writes \n\nBy default, when you create a `NewSSE(http)`, and do various actions on it such as `patchElements()`, this \nwill buffer up the converted SSE stream, which is then written to the client browser as the request is \nfinalised.\n\nIn some cases you may want to do Synchronous Writes to the client browser as each operation is performed in the\nhandler, so that as each `patchElements()` call is made, the patch is written immediately to the browser.\n\nIn this case use `NewSSESync(http)` to set the SSE into Synchronous Mode.\n\nFor example - in the SVGMorph demo, we want to generate a randomized SVG update, then write that to the client \nbrowser, then pause for 100ms and repeat, to provide a smooth animation of the SVG.\n\n![NewSSE vs NewSSESync](docs/images/newsse_newssesync.png)\n\n## Namespaces - SVG and MathML (Datastar RC7 feature)\n\n`patchElements()` works great when morphing small fragments into existing DOM content, using the element ID,\nor other selectors.\n\nUnfortunately, when we have a large chunk of SVG or MathML content, the standard HTML morphing \ncannot reach down inside the SVG markup to pick out individual child elements for individual updates.\n\nHowever, you can now use the `.namespace = svg` or `.namespace = mathml` options for `patchElements()` now\nto do exactly this.\n\nSee the SVG and MathML demo code in example_1 to see this in action.\n\n# Publish and Subscribe\n\nThe `datastar.http.zig` SDK (here - https://github.com/zigster64/datastar.http.zig) has a built in pub/sub\nsystem that exploits the fact that http.zig allows you to detach sockets from handlers for later use.\n\nIn Zig 0.16 - The recommended approach here will be to use the Evented IO to create long running coroutines \nfor those handlers that want to subscribe to topics.\n\nFor publishing to topics in a production environment, then just connect in a message bus such as Redis, or NATS, or Postgres listen/notify and thats all thats needed.\n\nThe example apps in this SDK that require PubSub, use this embedded message broker https://github.com/zigster64/pubsub.zig\n\n.. which was custom built specifically for these Datastar SSE runners.\n\nThis message broker is optional, but it is already bundled in the SDK if you want to make use of it.\n\nYou can see this being used in `02_cats.zig` for example, to update bids on cat auction.\n\n```zig\n// Optional embedded PubSub broker is bundled in the SDK for easy access\nconst pubsub = datastar.pubsub;\n\n// SSE persistent handler that subscribes to the message broker\nfn catsList(app: *App, http: *HTTPRequest) !void {\n    var sse = try http.NewSSESync();\n    defer sse.close();\n    try pushCatList(app, &sse);\n\n    var mq = try app.pubsub.connect(); // <-- the broker is referenced here\n    defer mq.deinit();\n\n    // Subscribe to the message broker\n    try mq.subscribe(.cats); \n    mq.setTimeout(30 * std.time.ns_per_s);\n\n    // loop forever over the events\n    while (try mq.next()) |event| {\n        switch (event) {\n            .msg => try pushCatList(app, &sse),\n            .timeout => try sse.keepalive(),\n        }\n    }\n}\n\n// elsewhere, when a new bid has been posted\nfn postBid(app: *App, http: *HTTPRequest) !void {\n    ... do stuff ... then ..\n\n    try app.pubsub.publish(.{ .cats = {} }, .all);\n}\n\n```\n\n# Local Development Utilities\n\nThe Zig Datastar SDK provides some built in tools to make local development and testing more pleasant.\n\nFor hot reloads of the browser, there are a couple of idiomatic ways of dealing with this.\n\nIf your application uses any persistent SSE connections to regularly update state, then ideally you should\nwrite these so that they output enough information to completely update the client content and state.\n\nThat could mean sending the complete page (aka a \"Fat Morph\"), and letting the morph engine on the browser \nsort out which DOM elements need updating.\n\nWhen the backend server stops and starts, the persistent SSE is closed, which triggers Datastar in the browser\nto try to re-establish that connection. When it re-establishes, it will send enough updated content and signals to \ncorrectly re-render the browser.\n\nSometimes that is not practical, or sometimes your app has no persistent SSE connection that can do this.\n\nIf you have a look in `01_basic.zig` - the code for example_1 ... we dont have any persistent SSE connection\nto do this, so this app adds an endpoint `/hotreload/:id`\n\nWhen the index page is first requested, it will \n\n```zig\n// add this route to your application\n// you can use whatever name for the endpoint you want, just connect it to the \n// provided handler, like so :\n  r.post(\"/hotreload\", datastar.hotreload); \n```\n\nThen add this HTML snippet at the end of your initial index.html (or whatever doc you first load)\n```html\n   Create a long lived SSE connection that will detect refreshes on an outdated server \n   instance, and force the browser to reload\n  <div data-init=\"@post('/hotreload', {retryMaxCount: 1000,retryInterval:20, retryMaxWaitMs:200})\"></div>\n\n  Same, but with a full debug of signals if you like\n  <pre data-init=\"@post('/hotreload', {retryMaxCount: 1000,retryInterval:20, retryMaxWaitMs:200})\" data-json-signals></pre>\n```\n\nTo compliment that, the Zig Datastar SDK provides another utility function you can add \nto your server code, to automatically reload the server executable whenever it is recompiled.\n\nYou can do achieve this by adding this code to your server during startup :\n\n```zig\n    var server = try HTTPServer.initIp6(io, allocator, PORT);\n    defer server.deinit();\n\n    const r = server.router;\n    r.get(\"/\", index);\n    ... add other routes here\n\n    // HOT Reloader setup\n    r.post(\"/hotreload\", datastar.hotreload); // Turn on the Hotreloader\n    try server.rebooter(); // Tells the server to reboot on recompile\n\n    std.debug.print(\"Server listening on http://localhost:{}\\n\", .{PORT});\n    try server.run();\n```\n\nIf you do both of those things, then in dev mode, you just compile in your IDE of choice,\nif it succeeds then the server restarts, which triggers the frontend to also hot reload.\n\nOf course, if you run the zig compiler in --watch mode, then everytime you save, it will\nrecompile, which triggers a reload of the server, which triggers a frontend hot reload as \nwell.\n\n# Adapting this SDK to other non-stdlib HTTP libraries\n\nShould be relatively straightforward to do.\n\nSimple Solution :\n\n- Use the HTTP Server & Router abstrations already provided by your HTTP framework.\n- If the response can be a simple `text/html` or `application/json` .. just send that, understanding how Datastar is able\n  to use these to patch both elements and signals, without SSE processing.\n- For SSE packaged responses, use whatever mechanisms your HTTP framework provides to setup an EventStream response,\n  with appropriate chunked encoding and keep-alive connection protocol.\n- Use the top level `datastar.patchElements()` / `datastar.patchSignals()` / `datastar.executeScript()` of the EventStream \n  generators, which all take raw string data for patching Elements and Scripts, or an arbitrary struct for patching Signals, \n  and then return a processed string for the event stream.\n- Write the contents of this processed string to the HTTP response.\n- Done !\n\nMore complex Solution (For HTTP Framework Authors) :\n\n- This SDK defines an interface for managing HTTP Requests with Datastar\n- Copy `http_request.zig` from this code, and use that as the bones to write your own interface implementation.\n- The implementation of the Datastar + SEE Processing is contained in `datastar.zig`, and is independent of the HTTPRequest implementation.\n- So ... its only the application code and handlers that are tied to a HTTPRequest implementation, via the interface.\n- Write a HTTPRequest compatible wrapper for your HTTP Framework. If you provide that, then any application code that works with the\n  built-in HTTP Server from this package will also work with your adapted HTTP Framework, by swapping over the HTTPRequest implementation.\n\n![Datastar HTTPRequest Interface](docs/http_request.png)\n\nThe HTTPRequest interface currently looks like this :  (is WIP, may change a little)\n```zig\n/// Return a new SSE object for a simple 1 shot response\npub fn NewSSE(http: *HTTPRequest) !SSE\n\n/// Return a new SSE object setup for a series of synchronous responses or persistent connection\npub fn NewSSESync(http: *HTTPRequest) !SSE\n\n/// Return a new SSE object with custom options\npub fn NewSSEOpt(http: *HTTPRequest, opt: SSEOptions) !SSE\n\n/// use this to construct extra_headers when creating any response\n/// it will pull in self.extra_headers, and merge them with the new set\n/// to provide a complete set for the actual request\n/// See http.setCookie() for an example where this is needed\npub fn mergeHeaders(self: *HTTPRequest, extra: []const std.http.Header) ![]const std.http.Header\n\n/// send a response of type text/html with the given data\npub fn html(self: *HTTPRequest, data: []const u8) !void\n\n/// send a response of type text/html with a formatted print\npub fn htmlFmt(self: *HTTPRequest, comptime fmt: []const u8, args: anytype) !void\n\n/// send a response of type application/json with the given data\npub fn json(self: *HTTPRequest, data: anytype) !void\n\n/// extract the full query params from the request\npub fn query(self: HTTPRequest) ![]const u8\n\n/// read Datastar signals from the request into the given struct type, return an instance of this struct\npub fn readSignals(self: HTTPRequest, comptime T: type) !T\n\n/// set a cookie that will be included in the response header\npub fn setCookie(self: *HTTPRequest, name: []const u8, value: []const u8)\n\n/// get a cookie from the request\npub fn getCookie(self: *HTTPRequest, name: []const u8) ?[]const u8\n\n```\n\n# More Info on Datastar\n\nIf you are still curious about Datastar, and wondering if its right for your app, here are some more resources\nto peruse. \n\nThe following videos will give you a really good idea if Datastar is for you or not.\n\nShort Overview\n\n[![Episode 1 - Datastar | Datastar Series](https://img.youtube.com/vi/I8QLWWPGT-c/0.jpg)](https://youtu.be/I8QLWWPGT-c)\n\n[![Episode 2 - Rockets Eye Overview | Datastar Series](https://img.youtube.com/vi/zQAz7fV95OU/0.jpg)](https://youtu.be/zQAz7fV95OU)\n\nIn-Depth dive from the creator of Datastar\n\n[![Why We’re Building the Front End Wrong](https://img.youtube.com/vi/FtAuSAOMNtM/0.jpg)](https://www.youtube.com/watch?v=FtAuSAOMNtM)\n\nOther recommended viewing\n\n[![Datastar Hypermedia Framework - combining HTMX + Alpine.js functionality!](https://img.youtube.com/vi/u4_rNG--QMc/0.jpg)](https://youtu.be/u4_rNG--QMc)\n\n[![Real-time Hypermedia - Delaney Gillilan](https://img.youtube.com/vi/0K71AyAF6E4/0.jpg)](https://youtu.be/0K71AyAF6E4)\n\n[![Intro to Datastar (and Craft CMS)](https://img.youtube.com/vi/aVjU1st-52g/0.jpg)](https://www.youtube.com/live/aVjU1st-52g)\n\n[![What Datastar is Not, with JLarky](https://img.youtube.com/vi/p4X02rEPkJY/0.jpg)](https://youtu.be/p4X02rEPkJY)\n\nDatastar Discord\n[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/YfFn7pKx)\n\nZig Discord\n[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/Chk5WKM5)\n\n# Contrib Policy\n\nAll contribs welcome.\n\nPlease raise a github issue first before adding a PR, and reference the issue in the PR title. \n\nThis allows room for open discussion, as well as tracking of issues opened and closed.\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/72305366?u=cf46defe1dc7db6770201913a79150fbcbddb6ff&v=4",
  "releases": [],
  "owner_bio": "Half Stack Dev.\r\n\r\nI’m into minimalist code and tools.\r\n\r\n\r\n",
  "owner_company": null,
  "owner_location": "Outback Australia, middle of nowhere",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 55,
  "owner_following": 58,
  "owner_created_at": "2020-10-03T12:46:34Z",
  "license": "MIT",
  "category": "library"
}