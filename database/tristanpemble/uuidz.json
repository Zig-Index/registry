{
  "name": "uuidz",
  "owner": "tristanpemble",
  "repo": "uuidz",
  "description": "A thread safe, RFC compliant UUID v1, v2, v3, v4, v5, v6, v7, and v8 library written in Zig.",
  "type": "package",
  "topics": [
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 10,
  "forks": 1,
  "watchers": 1,
  "updated_at": "2025-11-05T02:17:46Z",
  "dependencies": [
    {
      "name": "uuid_zig",
      "url": "git+https://github.com/r4gus/uuid-zig#58ed00d4df6b08ca2570602758c486989d019693",
      "hash": "uuid-0.3.2-oOieIY54AACgyWA1nI8rtVBRqHwAg2DPnuKiM2FycatZ"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# uuidz\n\nAn [RFC 9562](https://datatracker.ietf.org/doc/html/rfc9562) compliant UUID implementation for Zig.\n\n## About\n\n- **Version support**: Implements all UUID versions including the latest v6, v7, and v8\n- **Type safety**: Use the `Uuid` union to accept any version, or `Uuid.V7` to only accept V7 UUIDs\n- **Thread safety**: Generate time-based UUIDs from multiple threads without coordination or duplicate values\n- **Packed structs**: All UUID types can cast directly to integers and work with raw bytes without overhead\n- **Compliant**: Generates UUIDs with correct bit layouts, version/variant fields, and timestamp formats\n- **Non-compliant**: Represent UUIDs that don't follow RFC 9562 for interoperability\n- **Flexible clocks**: Configurable clock sources for time-based UUIDs with multi and single-threaded implementations\n- **Zero dependencies**: Uses only Zig's standard library\n\nThe design is heavily influenced by the Rust [uuid](https://github.com/uuid-rs/uuid) crate, with some Zig specific flavoring.\n\n## Documentation\n\nSee the [API reference documentation](https://tristanpemble.github.io/uuidz/) on the GitHub pages.\n\n## Installation\n\n```bash\nzig fetch --save git+https://github.com/tristanpemble/uuidz.git\n```\n\nThen add to your `build.zig`:\n\n```zig\nconst uuidz = b.dependency(\"uuidz\", .{});\nexe.root_module.addImport(\"uuidz\", uuidz.module(\"uuidz\"));\n```\n\n## Usage\n\n```zig\nconst Uuid = @import(\"uuidz\").Uuid;\n\n// Typed versions to accept only one version\nconst t1: Uuid.V1 = .now(0x001122334455);\nconst t3: Uuid.V3 = .init(.dns, \"tristanpemble.com\");\nconst t4: Uuid.V4 = .init(std.crypto.random);\nconst t5: Uuid.V5 = .init(.dns, \"tristanpemble.com\");\nconst t6: Uuid.V6 = .now(0x001122334455);\nconst t7: Uuid.V7 = .now();\nconst t8: Uuid.V8 = .init(0x123456789abcdef);\n\n// Union type to accept any version\nconst u1: Uuid = .{ .v1 = .now(0x001122334455) };\nconst u3: Uuid = .{ .v3 = .init(.dns, \"tristanpemble.com\") };\nconst u4: Uuid = .{ .v4 = .init(std.crypto.random) };\nconst u5: Uuid = .{ .v5 = .init(.dns, \"tristanpemble.com\") };\nconst u6: Uuid = .{ .v6 = .now(0x001122334455) };\nconst u7: Uuid = .{ .v7 = .now() };\nconst u8: Uuid = .{ .v8 = .init(0xC0FFEE_101) };\n\n// Compare\nconst is_equal: bool = u1.eql(u2);\nconst order: std.math.Order = u1.order(u2);\n\n// Convert formats\nconst uuid = try Uuid.parse(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\");\nconst uuid_ne: Uuid = .fromNative(0x6ba7b810_9dad_11d1_80b4_00c04fd430c8);\nconst uuid_be: Uuid = .fromBig(0x6ba7b810_9dad_11d1_80b4_00c04fd430c8);\nconst uuid_le: Uuid = .fromLittle(0x6ba7b810_9dad_11d1_80b4_00c04fd430c8);\nconst uuid_by: Uuid = .fromBytes(.{0x6b,0xa7,0xb8,0x10,0x9d,0xad,0x11,0xd1,0x80,0xb4,0x00,0xc0,0x4f,0xd4,0x30,0xc8});\nconst int_ne: u128 = uuid.toNative();\nconst int_be: u128 = uuid.toBig();\nconst int_le: u128 = uuid.toLittle();\nconst bytes: [16]u8 = uuid.toBytes();\nconst string: [36]u8 = uuid.toString();\n\n// Inspect\nconst variant: Uuid.Variant = uuid.getVariant();\nconst version: ?Uuid.Version = uuid.getVersion().?;\n\nconst time = switch (version) {\n    .v1 => uuid.v1.getTime(),\n    .v6 => uuid.v6.getTime(),\n    .v7 => uuid.v7.getTime(),\n    else => @panic(\"unhandled uuid version\"),\n}\n```\n\n## Clocks, clock sequences & entropy\n\nFor time-based UUIDs (v1, v6, v7), clock sequences ensure uniqueness when multiple UUIDs are generated at the same\ntimestamp. It does this by using a random initial sequence value that increments for each UUID within the same tick,\nas per RFC9562.\n\nWe provide two ClockSequence implementations, but you are free to write your own:\n\n- `SafeClockSequence`: The default, slower, thread-safe, unpredictable sequence for maximum safety.\n- `FastClockSequence`: Faster, single-threaded, predictable sequence for maximum throughput.\n\nThey both ensure monotonicity. The trade-off is between speed and security. Both implementations accept a `Clock`,\nso that you can customize their behavior. We provide two clocks:\n\n- `Clock.system`: Uses the system clock to generate timestamps.\n- `Clock.zero`: Always returns zero.\n\nThe `SafeClockSequence` also accept a `std.Random`, allowing you to use a custom random number generator, or reduce its\nentropy for increased performance. It defaults to `std.crypto.random`.\n\nFor example, to use a `SafeClockSequence`, that only outputs a zero timestamp:\n\n```zig\nvar clock_seq = Uuid.SafeClockSequence(Uuid.V7.Timestamp){\n    .clock = .zero,\n};\n\nconst uuid: Uuid.V7 = .init(clock_seq.next());\n```\n\n### SafeClockSequence\n\nThe current implementation of `SafeClockSequence` was coded for correctness (as far as I can verify it), and not\nperformance. I am not an expert in lockless concurrent algorithms. My hope is that someone more capable may provide\na faster implementation in the future. In the end, it is more than sufficiently performant for the most typical usecases.\n\nThe algorithm works like this:\n\n- Get the current timestamp.\n- If the timestamp increased monotonically:\n  - Generate a new cryptographically secure random sequence value.\n- If the timestamp did not increase monotonically:\n  - Increment the sequence value with a new cryptographically secure random value.\n  - If this would cause an overflow, try again.\n\nThis all occurs in an atomic compare-and-swap loop until the we obtain a unique timestamp and sequence counter.\n\n### Custom Clocks\n\nYou can create and use your own clocks if you need custom behavior for your usecase.\n\n```zig\nconst FixedClock = struct {\n    fixed_ns: i128,\n\n    fn nanoTimestamp(self: *FixedClock) i128 {\n        return self.fixed_ns;\n    }\n\n    fn toClock(self: *FixedClock) Clock {\n        return Uuid.Clock.init(self, FixedClock.nanoTimestamp)\n    }\n};\n```\n\n## Examples\n\nThere is example code in `example.zig`. You can run them:\n\n```bash\nzig build example\n```\n\n## Benchmarking\n\nIn case you care about generating UUIDs faster than you can put them anywhere, there's a benchmark:\n\n```bash\nzig build bench\n```\n\nOn my AMD Ryzen 9 5950X, the results are:\n\n```\nbenchmark        n  runs        total     avg ±     σ   min ...   max     p75    p99   p995\n-------------------------------------------------------------------------------------------\nuuidz.parse      1  1000000   174.8ms     2ms ±  99us   2ms ...   2ms     2ms    2ms    2ms\nuuidz.toString   1  1000000     7.2ms    72us ±   8us  66us ... 116us    70us  116us  116us\nuuidz.V1 fast    1  1000000    28.6ms   286us ±   5us 279us ... 301us   288us  301us  301us\nuuidz.V1 safe    1  1000000    64.1ms   641us ±  27us 619us ... 766us   646us  766us  766us\nuuidz.V1 safe    2  1000000    99.4ms   994us ± 213us 803us ...   2ms     1ms    2ms    2ms\nuuidz.V1 safe    4  1000000   143.7ms     1ms ± 165us 989us ...   2ms     2ms    2ms    2ms\nuuidz.V1 safe    8  1000000   197.8ms     2ms ± 192us   1ms ...   2ms     2ms    2ms    2ms\nuuidz.V3         1  1000000    86.9ms   869us ±  63us 824us ...   1ms   864us    1ms    1ms\nuuidz.V4         1  1000000    10.0ms   100us ±  15us  91us ... 151us   100us  151us  151us\nuuidz.V5         1  1000000    75.3ms   753us ±   6us 737us ... 772us   756us  772us  772us\nuuidz.V6 fast    1  1000000    28.8ms   288us ±   3us 283us ... 299us   290us  299us  299us\nuuidz.V6 safe    1  1000000    63.2ms   632us ±   4us 623us ... 657us   634us  657us  657us\nuuidz.V6 safe    2  1000000   103.8ms     1ms ± 198us 855us ...   2ms     1ms    2ms    2ms\nuuidz.V6 safe    4  1000000   145.1ms     1ms ± 155us 954us ...   2ms     2ms    2ms    2ms\nuuidz.V6 safe    8  1000000   207.2ms     2ms ± 122us   2ms ...   2ms     2ms    2ms    2ms\nuuidz.V7 fast    1  1000000    39.5ms   395us ±  35us 366us ... 500us   408us  500us  500us\nuuidz.V7 safe    1  1000000    51.1ms   511us ±   4us 503us ... 525us   514us  525us  525us\nuuidz.V7 safe    2  1000000    85.0ms   850us ± 136us 699us ...   1ms   889us    1ms    1ms\nuuidz.V7 safe    4  1000000   143.7ms     1ms ± 190us 995us ...   2ms     2ms    2ms    2ms\nuuidz.V7 safe    8  1000000   179.1ms     2ms ± 119us   1ms ...   2ms     2ms    2ms    2ms\nuuid_zig.V4      1  1000000     9.2ms    92us ±  13us  84us ... 181us    93us  181us  181us\nuuid_zig.V7      1  1000000    36.6ms   366us ±  31us 346us ... 478us   369us  478us  478us\n```\n\n## License\n\nMIT\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/2466322?u=2d6f0262c6156fd96454bf86e97110336e4d3f4c&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Portland, OR",
  "owner_blog": "tristanpemble.com",
  "owner_twitter_username": null,
  "owner_followers": 28,
  "owner_following": 9,
  "owner_created_at": "2012-10-01T19:24:04Z",
  "homepage": "https://tristanpemble.github.io/uuidz/",
  "license": "MIT",
  "category": "library"
}