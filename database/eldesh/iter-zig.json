{
  "name": "iter-zig",
  "owner": "eldesh",
  "repo": "iter-zig",
  "description": "A basic iterator library written in Zig",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 9,
  "forks": 3,
  "watchers": 1,
  "updated_at": "2025-05-14T08:05:51Z",
  "readme": "# iter-zig\n\n**iter-zig** is a lazy style generic iterator combinator library written in Zig.\nWhere the *iterator* means that the types enumrating all element of a set of values.\n\n\n## Support\n\nThis library is developped with:\n\n- Debian (x86_64) 10.4\n- Zig 0.10.0 and Zigmod r80\n- Zig 0.9.1 and Zigmod r79\n\n\n## Build\n\n```sh\nzig build\n```\n\n\n## Unit Test\n\nTo performs unit tests of iter-zig:\n\n\n```sh\nzig build test\n```\n\n\n## Example\n\nAn example program using iter-zig is provided.\nThe program can be performed with:\n\n```sh\nzig build example\n```\n\nSource code of this program is `src/main.zig`.\n\n\n## Generate docs\n\nTo generate documentations:\n\n\n```sh\nzig build doc\n```\n\nA html documents would be generated under the `./docs` directory.\n\n\n## Iterator Concept\n\n**Iterator** is a generic concept that objects that enumrating a set of values.\nEspecially, in this library, Iterator is a value of a kind of types that satisfies follow constraints.\n\nThe constraints are:\n- Have `Self` type\n- Have `Item` type\n- Have `next` method takes `*Self` and returns `?Item`.\n\nWhere the `Self` type specifies the type itself (equals to `@This()`), the `Item` type represents the type of elements returns from the iterator, and the `next` method returns a 'next' value of the container.\nIf the next value is not exists, 'null' must be returned.\nThe order of occurence of values are implementation defined.\nHowever, all values must occur exactly once before 'null' is returned.\n\n\n## Features\n\n### Meta function\n\n[The type constraints required as an Iterator](#iterator-concept) is able to be checked by `isIterator` function statically.\n\n```zig\ncomptime assert(isIterator(SliceIter(u32)));\ncomptime assert(!isIterator(u32));\n```\n\nWhen you implement a new type to be an iterator, it must ensure that `isIterator` returns `true`.\n\n\n### Container Iterators\n\n**iter-zig** provides several basic iterators that wraps standard containers.\n\n- ArrayIter\n- SliceIter\n- ArrayListIter\n- SinglyLinkedListIter\n- BoundedArrayIter\n- TailQueueIter\n\nFor example, an iterator on a slice is able to be used as follows:\n\n```zig\nvar arr = [_]u32{ 1, 2, 3 };\nvar iter = SliceIter(u32).new(arr[0..]);\ntry expectEqual(@as(u32, 1), iter.next().?.*);\ntry expectEqual(@as(u32, 2), iter.next().?.*);\ntry expectEqual(@as(u32, 3), iter.next().?.*);\ntry expectEqual(@as(?*u32, null), iter.next());\n```\n\nFurther, `Const` variations are defined for each containers.\nThese iterators behaves as same to non-const variations except for returns const pointers.\n\n- ArrayConstIter\n- SliceConstIter\n- ArrayListConstIter\n- SinglyLinkedListConstIter\n- BoundedArrayConstIter\n- TailQueueConstIter\n\n```zig\nvar arr = [_]u32{ 1, 2, 3 };\nvar iter = SliceConstIter(u32).new(arr[0..]);\niter.next().?.* += 1; // error: cannot assign to constant\n```\n\nNote that, these iterators not own container values into it.\nThe user must release the memory holding the container if necessary.\n\n\n### Iterators to Containers\n\nIterator to container converters are defined for some std containers.\n\n- slice_from_iter\n- array_list_from_iter\n- bounded_array_from_iter\n- singly_linked_list_from_iter\n\nThese converters consume the input iterator and build a container.\nThe constructed container contains all the elements of the iterator and no other elements.\n\n\n### Range Iterator\n\n`range` creates a Range value such that it represents a range of numbers.\nFor example, `range(0, 10)` means that the numbers from `0` to `10`, which is mathematics is denoted as `[0,10)`.\n\nIn particular, Range instantiated with integral type to be iterator.\n\n```zig\nvar rng = range(@as(u32, 0), 3);\ntry expectEqual(@as(u32, 0), rng.next().?);\ntry expectEqual(@as(u32, 1), rng.next().?);\ntry expectEqual(@as(u32, 2), rng.next().?);\ntry expectEqual(@as(?u32, null), rng.next());\n```\n\n\nSimilarly, `range_from` creates an instance of `RangeFrom` to represents an endless sequence of numbers.\ne.g. `range_from(@as(u32, 0))` creates an endless sequence of natural numbers `0,1,2,...`.\n\n```zig\nvar rng = range_from(@as(u32, 0));\ntry expectEqual(@as(u32, 0), rng.next().?);\ntry expectEqual(@as(u32, 1), rng.next().?);\ntry expectEqual(@as(u32, 2), rng.next().?);\n..\n```\n\n\nWhen `Range` or `RangeFrom` is instantiated with a type of floating numbers,\nit would not be an Iterator. It is just a range of values.\n\n```zig\ncomptime assert(!concept.isIterator(range.Range(f64)));\ncomptime assert(!concept.isIterator(range.RangeFrom(f64)));\ncomptime assert( range.range(@as(f64, 2.0), 3.0).contains(2.5))\ncomptime assert(!range.range(@as(f64, 2.0), 3.0).contains(1.5))\n```\n\n\n### Iterator Operators\n\nAll iterators defined in this library provide iterator functions below.\n\n- peekable\n- position\n- cycle\n- copied\n- cloned\n- nth\n- last\n- flat_map\n- flatten\n- partial_cmp\n- cmp\n- le\n- ge\n- lt\n- gt\n- sum\n- product\n- eq\n- ne\n- max\n- max_by\n- max_by_key\n- min\n- min_by\n- min_by_key\n- reduce\n- skip\n- scan\n- step_by\n- fold\n- try_fold\n- try_foreach\n- for_each\n- take_while\n- skip_while\n- map\n- map_while\n- filter\n- filter_map\n- chain\n- enumerate\n- all\n- any\n- take\n- count\n- find\n- find_map\n- inspect\n- fuse\n- zip\n\n\nThese functions are almost same to [functions on Iterator trait of Rust](https://doc.rust-lang.org/std/iter/trait.Iterator.html) except for experimental api.\n\n#### Adaptor style iterator\n\nSome functions above return an iterator from the iterator itself.\nFor that case, the functions are implemented in adaptor style.\nFor example, the `map` function returns a new iterator object `Map` rather than apply a function to each elements from the iterator.\n\n```zig\nvar arr = [_]u32{ 1, 2, 3 };\nvar iter = SliceIter(u32).new(arr[0..]);\nfn incr(x:u32) u32 { return x+1; }\n// Calculations have not yet been performed.\nvar map: Map(SliceIter(u32), fn (u32) u32) = iter.map(incr);\n\ntry expectEqual(@as(u32, 2), map.next().?.*); // incr is performed\ntry expectEqual(@as(u32, 3), map.next().?.*); // incr is performed\ntry expectEqual(@as(u32, 4), map.next().?.*); // incr is performed\ntry expectEqual(@as(?*u32, null), map.next());\n```\n\n\n### Implementing Iterator\n\n**iter-zig** allows library users to implement a new iterator type by their self.\nFurther, it is easy to implement all functions showed in [Iterator Operators](#iterator-operators) to your new iterator type using `DeriveIterator`.\n\nFor example, let's make an iterator `Counter` which counts from `1` to `5`.\n\n```zig\nconst Counter = struct {\n  pub const Self = @This();\n  pub const Item = u32;\n  count: u32,\n  pub fn new() Self { return .{ .count = 0 }; }\n  pub fn next(self: *Self) ?Item {\n    self.count += 1;\n    if (self.count < 6)\n      return self.count;\n    return null;\n  }\n};\n```\n\nNow we can use it as an iterator.\n\n```zig\ncomptime assert(isIterator(Counter));\nvar counter = Counter.new();\ntry expectEqual(@as(u32, 1), counter.next().?);\ntry expectEqual(@as(u32, 2), counter.next().?);\ntry expectEqual(@as(u32, 3), counter.next().?);\ntry expectEqual(@as(u32, 4), counter.next().?);\ntry expectEqual(@as(u32, 5), counter.next().?);\ntry expectEqual(@as(?u32, null), counter.next());\n```\n\nHowever, `Counter` not implement utility functions like `map` or `count` etc ...\nTo implement these functions, use `DeriveIterator` meta function like below.\n\n```zig\nconst CounterExt = struct {\n  pub const Self = @This();\n  pub const Item = u32;\n  pub usingnamespace DeriveIterator(@This()); // Add\n\n  count: u32,\n  pub fn new() Self { return .{ .count = 0 }; }\n  pub fn next(self: *Self) ?Item {\n    self.count += 1;\n    if (self.count < 6)\n      return self.count;\n    return null;\n  }\n};\n```\n\nIn above code, `CounterExt` difference from `Counter` is only the `DeriveIterator(@This())` line.\nNow, you can use all functions showed in [Iterator Operators](#iterator-operators).\n\n```zig\nfn incr(x:u32) u32 { return x+1; }\nfn even(x:u32) bool { return x % 2 == 0; }\nfn sum(st:*u32, v:u32) ?u32 {\n  st.* += v;\n  return st.*;\n}\nvar counter = CounterExt.new();\nvar iter = counter\n             .map(incr)     // 2,3,4,5,6\n             .filter(even)  // 2,4,6\n             .scan(@as(u32, 0), sum); // 2,6,12\ntry expectEqual(@as(u32, 2), iter.next().?);\ntry expectEqual(@as(u32, 6), iter.next().?);\ntry expectEqual(@as(u32, 12), iter.next().?);\ntry expectEqual(@as(?u32, null), iter.next());\n```\n\nIf you can implement some method efficiently rather than using `next` method, just implement that method (in `CounterExt` in the above).\n`DeriveIterator` suppresses the generation of that function.\n\n\n#### Convention\n\n**iter-zig** adopts naming conventions for implementing iterators.\nFirst, when defining a new iterator type, the type constructor must be named `MakeT` where type `T` is a name of the type.\nAnd the constructor should take a `Derive` function like below.\n\n```zig\npub fn MakeCounter(comptime Derive: fn (type) type) type {\n  return struct {\n    pub const Self = @This();\n    pub const Item = u32;\n    pub usingnamespace Derive(@This());\n    count: u32,\n    pub fn next(self: *Self) ?Item {\n      ...\n    }\n  };\n}\n```\n\nThis allows users to switch the function used for deriving.\n\n\nSecond, a type constructor should be named `T`.\nAnd the constructor should forward `DeriveIterator` to `MakeT`.\n\n```zig\npub fn Counter() type {\n  return MakeCounter(DeriveIterator);\n}\n```\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/379570?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Tokyo",
  "owner_blog": "http://d.hatena.ne.jp/eldesh",
  "owner_twitter_username": null,
  "owner_followers": 31,
  "owner_following": 65,
  "owner_created_at": "2010-08-29T07:31:56Z",
  "license": "BSD-2-Clause",
  "category": "library"
}