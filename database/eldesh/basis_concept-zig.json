{
  "name": "basis_concept-zig",
  "owner": "eldesh",
  "repo": "basis_concept-zig",
  "description": "A collection of basis concept and their operations",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-01-03T01:41:16Z",
  "readme": "# Basis Concept Zig\n\n**basis_concept-zig** is a collection library of \"basis concept\" and some operations on them.\nSome basic concepts such as `Copyable` are provided.\n\n\n## Concept\n\n*Concept* are named constraints on types such as `Clonable`.\n\n\nIn the Zig language, polymorphic functions are sometimes typed `fn (anytype) t`.\nOften, however, functions with such types implicitly require some properties for their types.\nThe `Concept` allows such implicit constraints to be named.\n\nNaming such implicit constraint allows us to deal explicitly with constraints on types.\nFurther, some associated polymorphic functions are able to be implemented to each Concept such like `Cloneable.clone`.\n\n\n## Examples\n\n### Equivalence of generic data type\n\nTo compare equivalence of data of various types:\n\n```\n/// A type constructed from various `isEq` types\nconst S = struct {\n  val_int: u32,\n  val_opt: ?u8,\n  val_eit: error{MyError}![5]u8,\n};\n\nconst s1: S = ...;\nconst s2: S = ...;\nif (Eq.eq(&s1, &s2)) {\n    ...\n}\n```\n\n\n### Check for cloneability\n\nWhen you want to implement `clone` on a container type only for types that are clonable.\n\n```\npub fn Container(comptime T: type) type {\n  return struct {\n    pub const Self: type = @This();\n    pub const CloneError: type = std.mem.Allocator.Error;\n    ..\n    pub usingnamespace if (isClonable(T))\n      struct {\n        pub fn clone(self: *const Self) CloneError!Self {\n          .. T.clone() ..\n        }\n      }\n    else\n      struct {}; // empty\n  };\n}\n\n// For a clonable type C:\nvar c = Container(C);\nvar d = try c.clone(); // clonable\n\n// For a not clonable type N:\nvar n = Container(N);\n// _ = try n.clone(); // compilation error\n```\n\n\n### Comparison by total order\n\nWhen you want to pass an ordering function for a key type of a Mapping container.\n\n```\nvar map: Map(Key, Value) = MakeKeyValueMap(Key, Value, Ord.on(Key));\nmap.insert(key1, value1);\nmap.insert(key2, value2);\n...\n```\n\n\n## Support\n\nThis library is developped with:\n\n- Debian (x86_64) 10.4\n- Zig 0.9.1 with Zigmod r79\n- Zig 0.10.0 with Zigmod r80\n\n\n## Build\n\nTo build, executing the following commands:\n\n```sh\nzigmod fetch\nzig build\n```\n\n\n## Unit Test\n\nTo performs unit tests:\n\n```sh\nzig build test\n```\n\n\n## Generate docs\n\nTo generate documents:\n\n```sh\nzig build doc\n```\n\nA html documents would be generated under the `./docs` directory.\n\n\n## Provided Concept\n\n- TrivialEq\n  Concept for types that trivially comparable value with `==`.\n  This concept is defined for checking the type is comparable with `==`.\n  Then any extra method is not provided.\n\n- TrivialDestroy\n  Concept for types that trivially destroyable implicitly.\n  Then any extra method is not provided.\n\n- Copyable\n  Trivially copyable values with `=`.\n  `Copy` means to duplicate a value that has no resources shared with the original one.\n  In other words, it must not contain a pointer.\n\n- Clonable\n  Duplicable values using `clone` method if exists.\n  Similar to Copyable, `Clonable` means that the value can be duplicated. However, the concept can be satisfied if the `clone` method is implemented even if the value cannot be copied in the trivial way.\n  In other words, if a type is `Copyable`, it is automatically `Clonable` as well.\n\n- PartialEq\n  `PartialEq` concept means that a partial equivalence relation is defined for the type.\n  The partiality comes from the fact that the relation does not require reflexivity.\n  That is, the relation must satisfy the following properties. for all x, y and z:\n\n  - `PartialEq.eq(x, y) == PartialEq.eq(y, x)`\n  - `PartialEq.eq(x, y) == PartialEq.eq(y, z) == PartialEq.eq(x, z)`\n\n- Eq\n  `Eq` concept means that a full equivalence relation is defined for the type.\n  Addition to `PartialEq`, this concept requires relations to have reflexivity.\n\n  - `Eq.eq(x, y) == Eq.eq(y, x)`\n  - `Eq.eq(x, y) and Eq.eq(y, z)` implies `Eq.eq(x, z)`\n  - `Eq.eq(x, x)`\n\n  Furthermore, this concept also contains `ne` method, which must be consistent with `eq`.\n\n- PartialOrd\n  `PartialOrd` concept means parial ordering relation.\n  Such relations require the type satisfies properties and have consistensy to `PartialEq`.\n\n  - `PartialOrd.partial_cmp(x, y).?.compare(.eq)` implies `PartialEq.eq(x, y)`\n  - `PartialOrd.partial_cmp(x, y).?.compare(.le)` implies `PartialOrd.partial_cmp(x, y).?.compare(.lt) or PartialEq.eq(x, y)`\n  - `PartialOrd.partial_cmp(x, y).?.compare(.ge)` implies `PartialOrd.partial_cmp(x, y).?.compare(.lt) or PartialEq.eq(x, y)`\n\n\n- Ord\n  Concept for types that forms total order.\n  Implementations must be consistent with `PartialOrd`.\n\n  - `Ord.cmp(x, y) == PartialOrd.partial_cmp(x, y).?`\n\n- Destroy\n  The `Destroy` concept provides an interface for destroying values.\n  Values of types implementing this concept can be destroyed by `destroy(@This())` or `destroy(@This(), std.mem.Allocator)`.\n\n\n## Module Hierarchy\n\n\n- basis_concept (the root module)\n    - copy\n\t\t- isCopyable\n    - clone\n        - isClonable\n        - Clone\n    - partial_ord\n        - isPartialOrd\n        - PartialOrd\n    - ord\n        - isOrd\n        - Ord\n    - trivial_eq\n        - isTrivialEq\n    - partial_eq\n        - isPartialEq\n        - PartialEq\n    - eq\n        - isEq\n        - Eq\n    - trivial_destroy\n        - isTrivialDestroy\n    - destroy\n        - Destroy\n    - prelude\n        - Clone\n        - PartialEq\n        - PartialOrd\n        - Ord\n        - Eq\n        - Destroy\n\n\n## Concept Convention\n\nImplementations of concept on types, are follows some conventions.\nFor any concept `C`, `implC`, `isC` and `C` maybe implemented.\n\n- `fn implC(comptime T:type) bool`  \n    Determine if the type `T` satisfies concept `C` directly.\n\n- `fn isC(comptime T:type) bool`  \n    Determine if the type `T` satisfies concept `C`.\n\n- `const C = struct { ... };`  \n    Namespace `C` that implements generic functions that depend on the concept `C`.\n\n- `fn DeriveC(comptime T:type) type`  \n    Derive functions that depend on `C`.\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/379570?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Tokyo",
  "owner_blog": "http://d.hatena.ne.jp/eldesh",
  "owner_twitter_username": null,
  "owner_followers": 30,
  "owner_following": 65,
  "owner_created_at": "2010-08-29T07:31:56Z",
  "license": "BSD-2-Clause",
  "category": "library"
}