{
  "name": "zig-netip",
  "owner": "ikavalio",
  "repo": "zig-netip",
  "description": "A simple IP address library for zig",
  "type": "package",
  "topics": [
    "ip",
    "zig",
    "ziglang",
    "zig-package"
  ],
  "stars": 0,
  "forks": 1,
  "watchers": 1,
  "updated_at": "2024-07-23T09:18:49Z",
  "readme": "# zig-netip\n\nThis is mostly an educational project to implement a library similar to go's [netip](https://pkg.go.dev/net/netip) \nusing zig idioms and comptime features. \n\nThe library targets the latest stable release which is currently `0.13`.\n\n# Definitions\n\n* `Ip4Addr`, `Ip6Addr`, `Ip6AddrScoped` (and an `Addr` union) address types that're small value types.\nThey can be converted to `std.net.Ip4Address` or \n`std.net.Ip6Address`. All types have a bunch of comptime \nfriendly methods, e.g. `parse`, `get`, `toArray`, and \nflexible-ish `format` specifiers.\n* `Ip4Prefix`, `Ip6Prefix` (and a `Prefix` union) address types that're built on top of \n`Ip4Addr` and `Ip6Addr` abstractions.\n\n# Examples\n\nCheck [the netip tests](../main/src/netip.zig) for more.\n\n```zig\ntest \"Addr Example\" {\n    // ipv4 create\n    const v4_addr1 = comptime try Ip4Addr.parse(\"192.0.2.1\");\n    const v4_addr2 = try Addr.parse(\"192.0.2.1\");\n    const v4_addr3 = Ip4Addr.fromArray(u8, [_]u8{ 192, 0, 2, 2 });\n    const v4_addr4 = Ip4Addr.fromArray(u16, [_]u16{ 0xC000, 0x0202 });\n    const v4_addr5 = Addr.init4(Ip4Addr.init(0xC0000203));\n    const v4_addr6 = Ip4Addr.fromNetAddress(try std.net.Ip4Address.parse(\"192.0.2.3\", 1));\n\n    // ipv6 create\n    const v6_addr1 = comptime try Ip6Addr.parse(\"2001:db8::1\");\n    const v6_addr2 = try Addr.parse(\"2001:db8::1\");\n    const v6_addr3 = Ip6Addr.fromArray(u8, [_]u8{ 0x20, 0x1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2 });\n    const v6_addr4 = Ip6Addr.fromArray(u16, [_]u16{ 0x2001, 0xdb8, 0, 0, 0, 0, 0, 0x2 });\n    const v6_addr5 = Addr.init6(Ip6Addr.init(0x2001_0db8_0000_0000_0000_0000_0000_0003));\n    const v6_addr6 = Ip6Addr.fromNetAddress(try std.net.Ip6Address.parse(\"2001:db8::3\", 1));\n\n    // ipv6 scoped\n    const v6_scoped1 = comptime try Ip6AddrScoped.parse(\"2001:db8::1%eth2\");\n    const v6_scoped2 = try Addr.parse(\"2001:db8::2%4\");\n\n    // handle parsing errors\n    try testing.expect(Ip4Addr.parse(\"-=_=-\") == Ip4Addr.ParseError.InvalidCharacter);\n    try testing.expect(Addr.parse(\"0.-=_=-\") == Addr.ParseError.InvalidCharacter);\n    try testing.expect(Ip6Addr.parse(\"-=_=-\") == Ip6Addr.ParseError.InvalidCharacter);\n    try testing.expect(Addr.parse(\"::-=_=-\") == Addr.ParseError.InvalidCharacter);\n\n    // copy\n    const v4_addr7 = v4_addr5;\n    const v6_addr8 = v6_addr3;\n\n    _ = .{v4_addr7, v4_addr4, v4_addr6, v6_scoped1, v6_scoped2, v6_addr4, v6_addr6};\n\n    // compare via values\n    try testing.expectEqual(math.Order.eq, order(v4_addr1, v4_addr2.v4));\n    try testing.expectEqual(math.Order.lt, order(v6_addr1, v6_addr8));\n    try testing.expectEqual(math.Order.gt, order(v6_addr8, v6_addr1));\n    try testing.expectEqual(math.Order.gt, order(v6_addr2, v4_addr2)); // cross AF comparison\n\n    // print\n    try testing.expectFmt(\"192.0.2.1\", \"{}\", .{v4_addr1});\n    try testing.expectFmt(\"c0.00.02.02\", \"{X}\", .{v4_addr3});\n    try testing.expectFmt(\"11000000.0.10.11\", \"{b}\", .{v4_addr5});\n    try testing.expectFmt(\"2001:db8::1\", \"{}\", .{v6_addr1});\n    try testing.expectFmt(\"2001:db8:0:0:0:0:0:2\", \"{xE}\", .{v6_addr3});\n    try testing.expectFmt(\"2001:0db8::0003\", \"{X}\", .{v6_addr5});\n    try testing.expectFmt(\"2001:0db8:0000:0000:0000:0000:0000:0001\", \"{XE}\", .{v6_addr2});\n}\n\ntest \"Prefix Example\" {\n    // create a ipv6 prefix\n    const v6_prefix1 = try Ip6Prefix.init(try Ip6Addr.parse(\"2001:db8:85a3::1\"), 48);\n    const v6_prefix2 = try Prefix.parse(\"2001:db8:85a3::/48\");\n\n    // create a prefix\n    const v4_prefix1 = try Ip4Prefix.init(try Ip4Addr.parse(\"192.0.2.1\"), 24);\n    const v4_prefix2 = try Prefix.parse(\"192.0.2.1/24\");\n\n    // compare mask bits\n    try testing.expectEqual(v6_prefix1.maskBits(), v6_prefix2.v6.maskBits());\n    try testing.expectEqual(v4_prefix1.maskBits(), v4_prefix2.v4.maskBits());\n\n    // handle parsing errors\n    try testing.expectError(Prefix.ParseError.Overflow, Prefix.parse(\"2001:db8::/256\"));\n    try testing.expectError(Prefix.ParseError.Overflow, Prefix.parse(\"1.1.1.1/33\"));\n\n    // print\n    try testing.expectFmt(\"2001:db8:85a3::1/48\", \"{}\", .{v6_prefix1});\n    try testing.expectFmt(\"2001:0db8:85a3::0001/48\", \"{X}\", .{v6_prefix1});\n    try testing.expectFmt(\"2001:db8:85a3::-2001:db8:85a3:ffff:ffff:ffff:ffff:ffff\", \"{R}\", .{v6_prefix1});\n    try testing.expectFmt(\"192.0.2.0/24\", \"{}\", .{v4_prefix1.canonical()});\n    try testing.expectFmt(\"192.0.2.0-192.0.2.255\", \"{R}\", .{v4_prefix1});\n\n    // contains address\n    try testing.expect(v6_prefix2.containsAddr(try Addr.parse(\"2001:db8:85a3:cafe::efac\")));\n    try testing.expect(v4_prefix2.containsAddr(try Addr.parse(\"192.0.2.42\")));\n\n    // inclusion and overlap test\n    try testing.expectEqual(PrefixInclusion.sub, v6_prefix1.testInclusion(try Ip6Prefix.parse(\"2001:db8::/32\")));\n    try testing.expect(v6_prefix2.overlaps(try Prefix.parse(\"2001:db8::/32\")));\n    try testing.expectEqual(PrefixInclusion.sub, v4_prefix1.testInclusion(try Ip4Prefix.parse(\"192.0.2.0/16\")));\n    try testing.expect(v4_prefix2.overlaps(try Prefix.parse(\"192.0.2.0/16\")));\n}\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/5453785?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Dublin, Ireland",
  "owner_blog": "https://www.ikavalio.de",
  "owner_twitter_username": null,
  "owner_followers": 12,
  "owner_following": 6,
  "owner_created_at": "2013-09-13T17:06:03Z",
  "license": "Unlicense",
  "category": "library"
}