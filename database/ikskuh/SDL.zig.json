{
  "name": "SDL.zig",
  "owner": "ikskuh",
  "repo": "SDL.zig",
  "description": "A shallow wrapper around SDL that provides object API and error handling",
  "type": "package",
  "topics": [
    "sdl",
    "zig",
    "zig-package",
    "ziglang",
    "sdl2",
    "gamedev"
  ],
  "stars": 431,
  "forks": 85,
  "watchers": 4,
  "updated_at": "2025-12-09T13:35:12Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# SDL.zig\n\nA Zig package that provides you with the means to link SDL2 to your project, as well as a Zig-infused header implementation (allows you to not have the SDL2 headers on your system and still compile for SDL2) and a shallow wrapper around the SDL apis that allow a more Zig-style coding with Zig error handling and tagged unions.\n\n## Getting started\n\n### Linking SDL2 to your project\n\nThis is an example `build.zig` that will link the SDL2 library to your project.\n\n```zig\nconst std = @import(\"std\");\nconst sdl = @import(\"sdl\"); // Replace with the actual name in your build.zig.zon\n\npub fn build(b: *std.Build) !void {\n    // Determine compilation target\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Create a new instance of the SDL2 Sdk\n    // Specify dependency name explicitly if necessary (use sdl by default)\n    const sdk = sdl.init(b, .{});\n\n    // Create executable for our example\n    const root_module = b.createModule(.{\n        .root_source_file = b.path(\"my-game.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    const demo_basic = b.addExecutable(.{\n        .name = \"demo-basic\",\n        .root_module = root_module,\n    });\n\n    sdk.link(demo_basic, .dynamic, sdl.Library.SDL2); // link SDL2 as a shared library\n\n    // Add \"sdl2\" package that exposes the SDL2 api (like SDL_Init or SDL_CreateWindow)\n    root_module.addImport(\"sdl2\", sdk.getNativeModule());\n\n    // Install the executable into the prefix when invoking \"zig build\"\n    b.installArtifact(demo_basic);\n}\n```\n\n### Using the native API\n\nThis package exposes the SDL2 API as defined in the SDL headers. Use this to create a normal SDL2 program:\n\n```zig\nconst std = @import(\"std\");\nconst SDL = @import(\"sdl2\"); // Add this package by using sdk.getNativeModule\n\npub fn main() !void {\n    if (SDL.SDL_Init(SDL.SDL_INIT_VIDEO | SDL.SDL_INIT_EVENTS | SDL.SDL_INIT_AUDIO) < 0)\n        sdlPanic();\n    defer SDL.SDL_Quit();\n\n    var window = SDL.SDL_CreateWindow(\n        \"SDL2 Native Demo\",\n        SDL.SDL_WINDOWPOS_CENTERED, SDL.SDL_WINDOWPOS_CENTERED,\n        640, 480,\n        SDL.SDL_WINDOW_SHOWN,\n    ) orelse sdlPanic();\n    defer _ = SDL.SDL_DestroyWindow(window);\n\n    var renderer = SDL.SDL_CreateRenderer(window, -1, SDL.SDL_RENDERER_ACCELERATED) orelse sdlPanic();\n    defer _ = SDL.SDL_DestroyRenderer(renderer);\n\n    mainLoop: while (true) {\n        var ev: SDL.SDL_Event = undefined;\n        while (SDL.SDL_PollEvent(&ev) != 0) {\n            if(ev.type == SDL.SDL_QUIT)\n                break :mainLoop;\n        }\n\n        _ = SDL.SDL_SetRenderDrawColor(renderer, 0xF7, 0xA4, 0x1D, 0xFF);\n        _ = SDL.SDL_RenderClear(renderer);\n\n        SDL.SDL_RenderPresent(renderer);\n    }\n}\n\nfn sdlPanic() noreturn {\n    const str = @as(?[*:0]const u8, SDL.SDL_GetError()) orelse \"unknown error\";\n    @panic(std.mem.sliceTo(str, 0));\n}\n```\n\n### Using the wrapper API\n\nThis package also exposes the SDL2 API with a more Zig-style API. Use this if you want a more convenient Zig experience.\n\n**Note:** This API is experimental and might change in the future\n\n```zig\nconst std = @import(\"std\");\nconst SDL = @import(\"sdl2\"); // Created in build.zig by using exe.root_module.addImport(\"sdl2\", sdk.getWrapperModule());\n\npub fn main() !void {\n    try SDL.init(.{\n        .video = true,\n        .events = true,\n        .audio = true,\n    });\n    defer SDL.quit();\n\n    var window = try SDL.createWindow(\n        \"SDL2 Wrapper Demo\",\n        .{ .centered = {} }, .{ .centered = {} },\n        640, 480,\n        .{ .vis = .shown },\n    );\n    defer window.destroy();\n\n    var renderer = try SDL.createRenderer(window, null, .{ .accelerated = true });\n    defer renderer.destroy();\n\n    mainLoop: while (true) {\n        while (SDL.pollEvent()) |ev| {\n            switch (ev) {\n                .quit => break :mainLoop,\n                else => {},\n            }\n        }\n\n        try renderer.setColorRGB(0xF7, 0xA4, 0x1D);\n        try renderer.clear();\n\n        renderer.present();\n    }\n}\n```\n\n## `build.zig` API\n\n```zig\n/// Just call `Sdk.init(b, .{})` to obtain a handle to the Sdk!\n/// Use `sdl` as dependency name by default.\nconst Sdk = @This();\n\n/// Creates a instance of the Sdk and initializes internal steps.\n/// Initialize once, use everywhere (in your `build` function).\n///\n/// const SdkOption = struct {\n///     dep_name: ?[]const u8 = \"sdl\",\n///     maybe_config_path: ?[]const u8 = null,\n///     maybe_sdl_ttf_config_path: ?[]const u8 = null,\n/// };\npub fn init(b: *Build, opt: SdkOption) *Sdk\n\n/// Returns a module with the raw SDL api with proper argument types, but no functional/logical changes\n/// for a more *ziggy* feeling.\n/// This is similar to the *C import* result.\npub fn getNativeModule(sdk: *Sdk) *Build.Module;\n\n/// Returns a module with the raw SDL api with proper argument types, but no functional/logical changes\n/// for a more *ziggy* feeling, with Vulkan support! The Vulkan module provided by `vulkan-zig` must be\n/// provided as an argument.\n/// This is similar to the *C import* result.\npub fn getNativeModuleVulkan(sdk: *Sdk, vulkan: *Build.Module) *Build.Module;\n\n/// Returns the smart wrapper for the SDL api. Contains convenient zig types, tagged unions and so on.\npub fn getWrapperModule(sdk: *Sdk) *Build.Module;\n\n/// Returns the smart wrapper with Vulkan support. The Vulkan module provided by `vulkan-zig` must be\n/// provided as an argument.\npub fn getWrapperModuleVulkan(sdk: *Sdk, vulkan: *Build.Module) *Build.Module;\n\n/// Links SDL2 or SDL2_ttf to the given exe and adds required installs if necessary.\n/// **Important:** The target of the `exe` must already be set, otherwise the Sdk will do the wrong thing!\npub fn link(sdk: *Sdk, exe: *Build.Step.Compile, linkage: std.builtin.LinkMode, comptime library: Library) void;\n```\n\n## Dependencies\n\nAll of those are dependencies for the *target* platform, not for your host. Zig will run/build the same on all source platforms.\n\n### Windows\n\nFor Windows, you need to fetch the correct dev libraries from the [SDL download page](https://www.libsdl.org/download-2.0.php). It is recommended to use the MinGW versions if you don't require MSVC compatibility.\n\n### MacOS\n\nRight now, cross-compiling for MacOS isn't possible. On a Mac, install SDL2 via `brew`.\n\n### Linux\n\nIf you are cross-compiling, no dependencies exist. The build Sdk compiles a `libSDL2.so` stub which is used for linking.\n\nIf you compile to your target platform, you require SDL2 to be installed via your OS package manager.\n\n## Support Matrix\n\nThis project tries to provide you the best possible development experience for SDL2. Thus, this project supports\nthe maximum amount of cross-compilation targets for SDL2.\n\nThe following table documents this. The rows document the *target* whereas the columns are the *build host*:\n\n|                       | Windows (x86_64) | Windows (i386) | Linux (x86_64) | MacOS (x86_64) | MacOS (aarch64) |\n|-----------------------|------------------|----------------|----------------|----------------|-----------------|\n| `i386-windows-gnu`    | ‚úÖ               | ‚úÖ             | ‚úÖ             | ‚úÖ             | ‚ö†Ô∏è               |\n| `i386-windows-msvc`   | ‚úÖ               | ‚úÖ             | ‚úÖ             | ‚úÖ             | ‚ö†Ô∏è               |\n| `x86_64-windows-gnu`  | ‚úÖ               | ‚úÖ             | ‚úÖ             | ‚úÖ             | ‚ö†Ô∏è               |\n| `x86_64-windows-msvc` | ‚úÖ               | ‚úÖ             | ‚úÖ             | ‚úÖ             | ‚ö†Ô∏è               |\n| `x86_64-macos`        | ‚ùå               | ‚ùå             | ‚ùå             | ‚úÖ             | ‚ùå              |\n| `aarch64-macos`       | ‚ùå               | ‚ùå             | ‚ùå             | ‚ùå             | ‚ö†Ô∏è               |\n| `x86_64-linux-gnu`    | üß™               | üß™             | ‚úÖ             | üß™             | ‚ö†Ô∏è               |\n| `aarch64-linux-gnu`   | üß™               | üß™             | üß™             | üß™             | ‚ö†Ô∏è               |\n\nLegend:\n- ‚úÖ Cross-compilation is known to work and tested via CI\n- üß™ Experimental cross-compilation support, covered via CI\n- ‚ö†Ô∏è Cross-compilation *might* work, but is not tested via CI\n- ‚ùå Cross-compilation is not possible right now\n\n## Contributing\n\nYou can contribute to this project in several ways:\n- Use it!\n  This helps me to track bugs (which i know that there are some), and usability defects (which we can resolve then). I want this library to have the best development experience possible.\n- Implement/improve the linking experience:\n  Right now, it's not possible to cross-compile for MacOS, which is very sad. We might find a way to do so, though! Also VCPKG is not well supported on windows platforms.\n- Improve the wrapper.\n  Just add the functions you need and make a PR. Or improve existing ones. I won't do it for you, so you have to get your own hands dirty!\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/3932972?u=2893028da897d46ed12f55aa05a935a80e7c119b&v=4",
  "releases": [],
  "owner_bio": "Hacker, Dad & Demoscener from southern germany, loves lowlevel and oldschool stuff",
  "owner_company": null,
  "owner_location": "Stuttgart - Germany",
  "owner_blog": "https://random-projects.net/",
  "owner_twitter_username": "ikskuh",
  "owner_followers": 473,
  "owner_following": 72,
  "owner_created_at": "2013-03-21T16:08:06Z",
  "license": "MIT",
  "category": "library"
}