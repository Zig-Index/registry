{
  "name": "ZCS",
  "owner": "Games-by-Mason",
  "repo": "ZCS",
  "description": "A Zig ECS.",
  "type": "project",
  "topics": [
    "zig-package"
  ],
  "stars": 142,
  "forks": 4,
  "watchers": 4,
  "updated_at": "2025-12-01T23:27:01Z",
  "dependencies": [
    {
      "name": "slot_map",
      "url": "git+https://github.com/Games-By-Mason/SlotMap#fd2abfa97c2429c15015992e11da4b38196f0b9f",
      "hash": "slot_map-0.0.0-xUe6_GFMAACqypMFJeDpzVlnJ_Rab4CfrDiEMyzXnBFb"
    },
    {
      "name": "geom",
      "url": "git+https://github.com/Games-By-Mason/geom#058f649537c81c2954196ec328b6589d77317d69",
      "hash": "geom-0.0.0-U1ma31z1BACSF4c5MvG_S7PQPkjtd3JIB7nLpFG1bAmy"
    },
    {
      "name": "tracy",
      "url": "git+https://github.com/Games-By-Mason/tracy_zig#1cb0471b169637ebfc0a4f5ce827a3502412e564",
      "hash": "tracy-0.0.0-R7l8BVxEAQDC2E_f6SlQZy5_4BAI2klvP5equvriL47a"
    }
  ],
  "minimum_zig_version": "0.16.0-dev.1484+d0ba6642b",
  "readme": "# ZCS\n\nAn archetype based entity component system written in Zig.\n\n# Zig Version\n\n[`main`](https://github.com/Games-by-Mason/zcs/tree/main) loosely tracks Zig master. For support for previous Zig versions, see [releases](https://github.com/Games-by-Mason/ZCS/releases).\n\n# Status\n\nZCS is beta software. Once I've shipped a commercial game using ZCS, I'll start to stabilize the API and remove this disclaimer.\n\nIf there are no recent commits at the time you're reading this, the project isn't dead--I'm just working on a game!\n\n# Getting Started & Documentation\n\nHere's a quick look at what code using ZCS looks like:\n\n```zig\nconst std = @import(\"std\");\nconst zcs = @import(\"zcs\");\n\nconst Entities = zcs.Entities;\nconst Entity = zcs.Entity;\nconst CmdBuf = zcs.CmdBuf;\nconst Transform = zcs.ext.Transform2;\nconst Node = zcs.ext.Node;\n\npub fn main() !void {\n    // Reserve space for the game objects and for a command buffer.\n    // ZCS doesn't allocate any memory after initialization, but you\n    // can change the default capacities here if you like--or leave\n    // them at their defaults as in this example. If you ever exceed\n    // 20% capacity you'll get a warning by default.\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    var es: Entities = try .init(.{ .gpa = gpa.allocator() });\n    defer es.deinit(gpa.allocator());\n\n    var cb = try CmdBuf.init(.{\n        .name = \"cb\",\n        .gpa = gpa.allocator(),\n        .es = &es,\n    });\n    defer cb.deinit(gpa.allocator(), &es);\n\n    // Create an entity and associate some component data with it.\n    // We could do this directly, but instead we're demonstrating the\n    // command buffer API.\n    const e: Entity = .reserve(&cb);\n    e.add(&cb, Transform, .{});\n    e.add(&cb, Node, .{});\n\n    // Execute the command buffer\n    // We're using a helper from the `transform` extension here instead of\n    // executing it directly. This is part of ZCS's support for command\n    // buffer extensions, we'll touch more on this later.\n    Transform.Exec.immediate(&es, &cb);\n\n    // Iterate over entities that contain both transform and node\n    var iter = es.iterator(struct {\n        transform: *Transform,\n        node: *Node,\n    });\n    while (iter.next(&es)) |vw| {\n        // You can operate on `vw.transform.*` and `vw.node.*` here!\n        std.debug.print(\"transform: {any}\\n\", .{vw.transform.pos});\n    }\n}\n```\n\nFull documentation available [here](https://docs.gamesbymason.com/zcs/), you can generate up to date docs yourself with `zig build docs`.\n\nI'll add example projects to the repo as soon as I've set up a renderer that's easy to build without requiring various system libraries be installed etc, tracking issue [here](https://github.com/Games-by-Mason/ZCS/issues/34).\n\nFor now, you're welcome to reference [2Pew](https://github.com/MasonRemaley/2Pew/). Just keep in mind that 2Pew is a side project I don't have a lot of time for right now, it's a decent reference but not a full game.\n\n# Philosophy\n\nAn entity component system (or \"ECS\") is a way to manage your game objects that often resembles a relational database.\n\nAn entity is an object in your game, a component is a piece of data that's associated with an entity (for example a sprite), and a system is a piece of code that iterates over entities with a set of components and processes them.\n\nA simple alternative to working with an ECS would be something like [`std.MultiArrayList`](https://ziglang.org/documentation/master/std/#std.MultiArrayList); a growable struct of arrays.\n\nA well implemented ECS is more complex than `MultiArrayList`, but that complexity buys you a lot of convenience. Performance will be comparable.\n\nFor a discussion of what features are provided by this ECS see [Key Features](#Key-Features), for performance information see [Performance](#Performance), and for further elaboration on my philosophy on game engines and abstraction see my talk [It's Not About The Technology - Game Engines are Art Tools](https://gamesbymason.com/blog/2023/game-engines-are-art-tools/).\n\n# Key Features\n\n## Persistent Keys\n\nGames often feature objects whose lifetimes are not only dynamic, but depend on user input. ZCS provides persistent keys for entities, so they're never dangling:\n\n```zig\nassert(laser.exists(es));\nassert(laser.get(es, Sprite) != null);\n\nlaser.destroyImmediately(es);\n\nassert(!laser.exists(es));\nassert(laser.get(es, Sprite) == null);\n```\n\nThis is achieved through a 32 bit generation counter on each entity slot. Slots are retired when their generations are saturated to prevent false negatives, see [SlotMap](https://github.com/Games-by-Mason/SlotMap) for more info.\n\nThis strategy allows you to safely and easily store entity handles across frames or in component data.\n\nFor all allowed operations on an entity handle, see [`Entity`](https://docs.gamesbymason.com/zcs/#zcs.entity.Entity).\n\n## Archetype Based Iteration\n\nGameplay systems often end up coupled not due to bad coding practice, but because these interdependencies often lead to dynamic and interesting gameplay.\n\nArchetype based iteration via [`Entities.iterator`](https://docs.gamesbymason.com/zcs/#zcs.Entities.iterator) allows you to efficiently query for entities with a given set of components. This can be a convenient way to express this kind of coupling:\n\n```zig\nvar iter = es.iterator(struct {\n    mesh: *const Mesh,\n    transform: *const Transform,\n    effect: ?*const Effect,\n});\nwhile (iter.next()) |vw| {\n    vw.mesh.render(vw.transform, vw.effect);\n}\n```\n\nIf you prefer, [`forEach`](https://docs.gamesbymason.com/zcs/#zcs.Entities.forEach) syntax sugar is also provided. The string argument is only used if Tracy is enabled:\n```zig\nfn updateMeshWithEffect(\n    ctx: void,\n    mesh: *const Mesh,\n    transform: *const Transform,\n    effect: ?*const Effect,\n) void {\n    // ...\n}\n\nes.forEach(\"updateMeshWithEffect\", updateMeshWithEffect, {});\n```\n\n[`Entities.chunkIterator`](https://docs.gamesbymason.com/zcs/#zcs.Entities.chunkIterator) is also provided for iterating over contiguous chunks of component data instead of individual entities. This can be useful e.g. to optimize your systems with SIMD.\n\n### Optional Thread Pool Integration\n\nIf you're already making use of [`std.Thread.Pool`](https://ziglang.org/documentation/master/std/#std.Thread.Pool), you can operate on your chunks in parallel with [`forEachThreaded`](https://docs.gamesbymason.com/zcs/#zcs.Entities.forEachThreaded).\n\nHave your own job system? No problem. [`forEachThreaded`](https://docs.gamesbymason.com/zcs/#zcs.Entities.forEachThreaded) is implemented on top of ZCS's public interface, wiring it up to your own threading model won't require a fork.\n\n## Command Buffers\n\nGames often want to make destructive changes to the game state while processing a frame.\n\nCommand buffers allow you to make destructive changes without invalidating iterators, including in a multithreaded context.\n\n```zig\n// Allocate a command buffer\nvar cb: CmdBuf = try .init(.{ .gpa = gpa, .es = &es });\ndefer cb.deinit(allocator, &es);\n\n// Get the next reserved entity. By reserving entities up front, the\n// command buffer allows you to create entities from background threads\n// without contention.\nconst e = Entity.reserve(&cb);\n\n// Schedule an archetype change for the reserved entity, this will\n// assign it storage when the command buffer executes. If the component\n// is comptime known and larger than pointer sized, it will\n// automatically be stored by pointer instead of by value.\ne.add(&cb, RigidBody, .{ .mass = 20 });\ne.add(&cb, Sprite, .{ .index = .cat });\n\n// Execute the command buffer, and then clear it for reuse. This would\n// be done from the main thread.\nCmdBuf.Exec.immediate(&es, &cb);\n```\n\nFor more information, see [`CmdBuf`](https://docs.gamesbymason.com/zcs/#zcs.CmdBuf).\n\nWhen working with multiple threads, you'll likely want to use [`CmdPool`](https://docs.gamesbymason.com/zcs/#zcs.CmdPool) to manage your command buffer allocations instead of creating them directly. This will allocate a large number of smaller command buffers, and hand them out on a per chunk basis.\n\nThis saves you from needing to adjust the number of command buffers you allocate or their capacities based on core count or workload distribution.\n\nIf you need to bypass the command buffer system and make changes directly, you can. Invalidating an iterator while it's in use due to having bypassed the command buffer system is safety checked illegal behavior.\n\n## Command Buffer Extensions\n\nEntities often have relationships to one another. As such, operations like destroying an entity may have side effects on other entities. In ZCS this is achieved through command buffer extensions.\n\nThe key idea is that external code can add [extension commands](https://docs.gamesbymason.com/zcs/#zcs.CmdBuf.ext) with arbitrary payloads to the command buffer, and then later [iterate the command buffer](https://docs.gamesbymason.com/zcs/#zcs.CmdBuf.iterator) to execute those commands or react to the standard ones.\n\nThis allows extending the behavior of the command buffer executor without callbacks. This is important because the order of operation between various extensions and the default behavior is often important and very difficult to manage in a callback based system.\n\nTo avoid iterating the same command buffer multiple times--and to allow extension commands to change the behavior of the built in commands--you're expected to compose extension code with the default execution functions provided under [`CmdBuf.Exec`](https://docs.gamesbymason.com/zcs/#zcs.CmdBuf.Exec).\n\nAs an example of this pattern, [`zcs.ext`](https://docs.gamesbymason.com/zcs/#zcs.ext) provides a number of useful components and command buffer extensions that rely only on ZCS's public API...\n\n\n### Node\n\nThe [`Node`](https://docs.gamesbymason.com/zcs/#zcs.ext.Node) component allows for linking objects to other objects in parent child relationships. You can modify these relationships directly, or via command buffers:\n\n```zig\ncb.ext(Node.SetParent, .{\n    .child = thruster,\n    .parent = ship.toOptional(),\n});\n```\n\nHelper methods are provided to query parents, iterate children, etc:\n\n```zig\nvar children = ship.get(Node).?.childIterator();\nwhile (children.next()) |child| {\n    // Do something with `child`\n}\n\nif (thruster.get(Node).?.parent.get(&es)) |parent| {\n    // Do something with `parent`\n}\n```\n\n*The full list of supported features can be found in [the docs](https://docs.gamesbymason.com/zcs/#zcs.ext.Node).*\n\nNode doesn't have a maximum child count, and adding children does not allocate an array. This is possible because each node has the following fields:\n* `parent`\n* `first_child`\n* `prev_sib`\n* `next_sib`\n\n\nDeletion of child objects, cycle prevention, etc are all handled for you. You just need to use the provided helpers or command buffer extension command for setting the parent, and to call into [`Node.Exec.immediate`](https://docs.gamesbymason.com/zcs/#zcs.ext.Node.Exec.immediate) to execute your command buffer:\n```zig\nNode.Exec.immediate(&es, &cb);\n```\n\nKeep in mind that this will call the default exec behavior as well as implement the extended behavior provided by `Node`. If you're also integrating other unrelated extensions, a lower level composable API is provided in [`Node.Exec`](https://docs.gamesbymason.com/zcs/#zcs.ext.Node.Exec) for building your own executor.\n\n### Transform\n\nA generic transform is provided:\n* [`Transform`](https://docs.gamesbymason.com/zcs/#zcs.ext.Transform)\n\nAs well as some instantiations:\n* [`Transform2`](https://docs.gamesbymason.com/zcs/#zcs.ext.Transform2)\n* [`Transform3`](https://docs.gamesbymason.com/zcs/#zcs.ext.Transform3)\n\nA transform component represents the position and orientation of an entity in space. If an entity also has a [`Node`](https://docs.gamesbymason.com/zcs/#zcs.ext.Node) and `relative` is `true`, its local space is relative to that of its parent.\n\n```zig\nvw.transform.move(es, vw.rb.vel.scaled(delta_s));\nvw.transform.rotate(es, .fromAngle(vw.rb.rotation_vel * delta_s));\n```\n\nTransform children are immediately synchronized by these helpers, but you can defer synchronization until a later point by bypassing the helpers and then later calling `transform.sync(es)`.\n\nIf you call `Transform` yourself, you can also set types for the `layer` field. This value is ignored internally, but may be used by user code to change the render order. Defaults to `u0`.\n\nTransform depends on [geom](https://github.com/games-by-Mason/geom) for math.\n\n### ZoneCmd\n\nDeferred work can be hard to profile. As such, ZCS provides an extension [`ZoneCmd`](https://docs.gamesbymason.com/zcs/#zcs.ext.ZoneCmd) that allows you to start and end Tracy zones from within a command buffer:\n```zig\nconst exec_zone = ZoneCmd.begin(&cb, .{\n    .src = @src(),\n    .name = \"zombie pathfinding\",\n});\ndefer exec_zone.end(&cb);\n```\n\n## Tracy Integration\n\nZCS integrates with [Tracy](https://github.com/wolfpld/tracy) via [tracy_zig](https://github.com/Games-by-Mason/tracy_zig/). ZCS shouldn't be your bottleneck, but with this integration you can be sure of it--and you can track down where the bottleneck is.\n\nIn particular, ZCS...\n* Emits its own Tracy Zones\n* Supports attaching zones to sections of command buffers via the [`ZoneCmd`](https://docs.gamesbymason.com/zcs/#zcs.ext.ZoneCmd) extension\n* Emits plots to Tracy, including information on command buffer utilization\n\n## Generics\n\nMost ECS implementations use some form of generics to provide a friendly interface. ZCS is no exception, and Zig makes this easier than ever.\n\nHowever, when important types become generic, it infects the whole code base--everything that needs to interact with the ECS also needs to become generic, or at least depend on an instantiation of a generic type. This makes it hard to write modular/library code, and presumably will hurt incremental compile times in the near future.\n\nAs such, while ZCS uses generic methods where it's convenient, types at API boundaries are typically not generic. For example, [`Entities`](https://docs.gamesbymason.com/zcs/#zcs.Entities) which stores all the ECS data is not a generic type, and libraries are free to add new component types to entities without an explicit registration step.\n\n# Performance\n\nZCS is archetype based.\n\nAn \"archetype\" is a unique set of component types--for example, all entities that have both a `RigidBody` and a `Mesh` component share an archetype, whereas an entity that contains a `RigidBody` a `Mesh` and a `MonsterAi` has a different archetype.\n\nArchetypes are packed tightly in memory into [chunks](https://docs.gamesbymason.com/zcs/#zcs.chunk.Chunk) with the following layout:\n1. Chunk header\n2. Entity indices\n3. Component data\n\nComponent data is laid out in `AAABBBCCC` order within the chunk, sorted from greatest to least alignment requirements to minimize padding. Chunks size is configurable but must be a power of two, in practice this results in chunk sizes that are a multiple of the cache line size which prevents false sharing when operating on chunks in parallel.\n\nA simple [acceleration structure](https://docs.gamesbymason.com/zcs/#zcs.Arches) is provided to make finding all chunks compatible with a given archetype efficient.\n\nComparing performance with something like [`MultiArrayList`](https://ziglang.org/documentation/master/std/#std.MultiArrayList):\n* Iterating over all data results in nearly identical performance\n* Iterating over only data that contains supersets of a given archetype is nearly identical to if the [`MultiArrayList`](https://ziglang.org/documentation/master/std/#std.MultiArrayList) was somehow preprocessed to remove all the undesired results and then tightly packed before starting the timer\n* Inserting and removing entities is O(1), but more expensive than appending/popping from a [`MultiArrayList`](https://ziglang.org/documentation/master/std/#std.MultiArrayList) or leaving a hole in it since more bookkeeping is involved for the aforementioned acceleration and persistent handles\n* Random access is O(1), but more expensive than random access to a [`MultiArrayList`](https://ziglang.org/documentation/master/std/#std.MultiArrayList) as the persistent handles introduce a layer of indirection\n\nNo dynamic allocation is done after initialization.\n\n# Contributing\n\nContributions are welcome! If you'd like to add a major feature, please file a proposal or leave a comment on the relevant issue first.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/174537044?v=4",
  "releases": [
    {
      "tag_name": "v0.1.1",
      "name": "v0.1.1",
      "body": "This is the last release to target Zig v0.15.0.\r\n\r\nThanks to the folks who helped upgrade Zig versions and fix the examples!\r\n\r\n## What's Changed\r\n* update to latest zig by @alichraghi in https://github.com/Games-by-Mason/ZCS/pull/38\r\n* Make the first example standalone and compilable by @nurpax in https://github.com/Games-by-Mason/ZCS/pull/39\r\n* Tracks order of nodes even when they have no parents (Node extension) by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/40\r\n* ext.Node active flag by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/42\r\n* ext.Node: Search ancestors by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/43\r\n* Return pointers to encoded components/ext payloads on the command buffer by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/44\r\n* Adds ext.Tag by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/45\r\n* ext.Tag: Adds tests by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/46\r\n* ext.Tag: adds Tag.matches by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/47\r\n* ext.Transform3d by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/48\r\n* zcs.ext.Transform: layer/order API by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/49\r\n\r\n## New Contributors\r\n* @alichraghi made their first contribution in https://github.com/Games-by-Mason/ZCS/pull/38\r\n* @nurpax made their first contribution in https://github.com/Games-by-Mason/ZCS/pull/39\r\n\r\n**Full Changelog**: https://github.com/Games-by-Mason/ZCS/compare/v0.1.0...v0.1.1",
      "prerelease": false,
      "published_at": "2025-11-29T11:20:51Z",
      "html_url": "https://github.com/Games-by-Mason/ZCS/releases/tag/v0.1.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "v0.1.0",
      "body": "This is the last version to target Zig v0.14.0.\r\n\r\nAnnouncement post can be found [here.](https://gamesbymason.com/blog/2025/zcs/)\r\n\r\n## What's Changed\r\n* Support creating entities that reference eachother via command buffer by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/14\r\n* Hierarchy by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/18\r\n* Archetype by @MasonRemaley in https://github.com/Games-by-Mason/ZCS/pull/22\r\n\r\n## New Contributors\r\n* @MasonRemaley made their first contribution in https://github.com/Games-by-Mason/ZCS/pull/14\r\n\r\n**Full Changelog**: https://github.com/Games-by-Mason/ZCS/commits/v0.1.0",
      "prerelease": false,
      "published_at": "2025-05-13T00:12:32Z",
      "html_url": "https://github.com/Games-by-Mason/ZCS/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "",
  "owner_location": null,
  "owner_blog": "https://gamesbymason.com/",
  "owner_twitter_username": null,
  "owner_created_at": "2024-07-02T21:36:16Z",
  "license": "MIT",
  "category": "library"
}