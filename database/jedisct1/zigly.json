{
  "name": "zigly",
  "owner": "jedisct1",
  "repo": "zigly",
  "description": "The easiest way to write services for Fastly's Compute@Edge in Zig.",
  "type": "package",
  "topics": [
    "fastly",
    "webassembly",
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 93,
  "forks": 2,
  "watchers": 5,
  "updated_at": "2026-01-13T22:15:32Z",
  "readme": "![Zigly](logo.png)\n========\n\nThe easiest way to write Fastly Compute services in Zig.\n\n- [What is Fastly Compute?](#what-is-fastly-compute)\n- [What is Zigly?](#what-is-zigly)\n- [Usage](#usage)\n  - [Example application](#example-application)\n  - [Adding Zigly as a dependency](#adding-zigly-as-a-dependency)\n  - [A minimal WebAssembly program](#a-minimal-webassembly-program)\n  - [Testing Fastly Compute modules](#testing-fastly-compute-modules)\n  - [Using Zigly](#using-zigly)\n    - [Hello world!](#hello-world)\n    - [Inspecting incoming requests](#inspecting-incoming-requests)\n    - [Making HTTP queries](#making-http-queries)\n    - [Cache override](#cache-override)\n    - [Pipes](#pipes)\n  - [Proxying](#proxying)\n  - [Redirects](#redirects)\n  - [Response decompression](#response-decompression)\n    - [Dictionaries](#dictionaries)\n    - [Logging](#logging)\n    - [KV Store](#kv-store)\n    - [Geolocation](#geolocation)\n    - [User Agent Parsing](#user-agent-parsing)\n    - [Dynamic Backends](#dynamic-backends)\n- [Deployment to Fastly's platform](#deployment-to-fastlys-platform)\n\n## What is Fastly Compute?\n\n[Fastly Compute](https://www.fastly.com/products/compute) is [Fastly](https://fastly.com)'s service to run custom code directly on CDN nodes.\n\nThe service runs anything that can be compiled to WebAssembly, and exports a convenient set of functions to interact with the platform.\n\n## What is Zigly?\n\nZigly is a library that makes it easy to write Fastly Compute modules in [Zig](https://ziglang.org).\n\nBeyond the functions exported by the Fastly platform, Zigly will eventually include additional utility functions (cookie manipulation, JWT tokens, tracing...) to make application development as simple as possible.\n\nZigly is written for Zig 0.16.x and later versions.\n\n## Usage\n\n### Example application\n\nCheck out the `example` directory.\n\nThis contains an example Fastly application that relays all incoming traffic to a backend server, with transparent caching.\n\nIf you just want to use Fastly as a CDN, this is all you need!\n\n### Adding Zigly as a dependency\n\nAdd the dependency to your project:\n\n```sh\nzig fetch --save=zigly https://github.com/jedisct1/zigly/archive/refs/tags/0.1.11.tar.gz\n```\n\nAnd the following to your `build.zig` file:\n\n```zig\n    const zigly = b.dependency(\"zigly\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const exe_module = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n    exe_module.addImport(\"zigly\", zigly.module(\"zigly\"));\n    exe_module.linkLibrary(zigly.artifact(\"zigly\"));\n\n    const exe = b.addExecutable(.{\n        .name = \"my_app\",\n        .root_module = exe_module,\n    });\n\n    b.installArtifact(exe);\n```\n\nThe `zigly` structure can be imported in your application with:\n\n```zig\nconst zigly = @import(\"zigly\");\n```\n\n### A minimal WebAssembly program\n\n```zig\nconst std = @import(\"std\");\n\npub fn main() !void {\n    std.debug.print(\"Hello from WebAssembly and Zig!\\n\", .{});\n}\n```\n\nThe program can be compiled with (replace `example.zig` with the source file name):\n\n```sh\nzig build-exe -target wasm32-wasi example.zig\n```\n\nHappy with the result? Add `-Doptimize=ReleaseSmall` or `-Doptimize=ReleaseFast` to get very small or very fast module:\n\n```sh\nzig build-exe -target wasm32-wasi -Doptimize=ReleaseSmall example.zig\n```\n\nThe example above should not compile to more than 411 bytes.\n\nIf you are using a build file instead, define the target as `wasm32-wasi` in the `build.zig` file:\n\n```zig\nconst target = b.standardTargetOptions(.{ .default_target = .{ .cpu_arch = .wasm32, .os_tag = .wasi } });\n```\n\n...and build with `zig build -Doptimize=ReleaseSmall` or `-Doptimize=ReleaseFast` to get optimized modules.\n\n### Testing Fastly Compute modules\n\nThe easiest way to test the resulting modules is to use [Viceroy](https://github.com/fastly/Viceroy), a reimplementation of the Fastly API that runs locally.\n\n### Using Zigly\n\n#### Hello world!\n\n```zig\nconst downstream = try zigly.downstream();\nvar response = downstream.response;\ntry response.body.writeAll(\"Hello world!\");\ntry response.finish();\n```\n\n`downstream()` returns a type representing the initial connection, from a client to the proxy.\n\nThat type includes `response`, that can be used to send a response, as well as `request`, that can be used to inspect the incoming request.\n\nEvery function call may fail with an error from the `FastlyError` set.\n\nSlightly more complicated example:\n\n```zig\nconst downstream = try zigly.downstream();\nvar response = downstream.response;\n\ntry response.setStatus(201);\ntry response.headers.set(\"X-Example\", \"Header\");\n\ntry response.body.writeAll(\"Partial\");\ntry response.flush();\ntry response.body.writeAll(\"Response\");\ntry response.finish();\n\nvar logger = try zigly.Logger.open(\"logging_endpoint\");\ntry logger.write(\"Operation successful!\");\n```\n\nNote that calling `finish()` is always required in order to actually send a response to the client.\n\nBut realistically, most responses will either be simple redirects:\n\n```zig\nvar downstream = try zigly.downstream();\ntry downstream.redirect(302, \"https://www.perdu.com\");\n```\n\nor responding directly from the cache, proxying to the origin if the cached entry is nonexistent or expired:\n\n```zig\nvar downstream = try zigly.downstream();\ntry downstream.proxy(\"google\", \"www.google.com\");\n```\n\n#### Inspecting incoming requests\n\nApplications can read the body of an incoming requests as well as other informations such as the headers:\n\n```zig\nvar request = downstream.request;\nconst user_agent = try request.headers.get(allocator, \"user-agent\");\nif (try request.isPost()) {\n    // method is POST, read the body until the end, up to 1000000 bytes\n    const body = try request.body.readAll(allocator, 1000000);\n}\n```\n\nAs usual in Zig, memory allocations are never hidden, and applications can choose the allocator they want to use for individual function calls.\n\n#### Making HTTP queries\n\nMaking HTTP queries is easy:\n\n```zig\nvar query = try zigly.http.Request.new(\"GET\", \"https://example.com\");\nvar response = try query.send(\"backend\");\nconst body = try response.body.readAll(allocator, 0);\n```\n\nArbitrary headers can be added the the outgoing `query`:\n\n```zig\ntry query.headers.set(\"X-Custom-Header\", \"Custom value\");\n```\n\nBody content can also be pushed, even as chunks:\n\n```zig\ntry query.body.write(\"X\");\ntry query.body.write(\"Y\");\ntry query.body.close();\n```\n\nAnd the resulting `response` contains `headers` and `body` properties, that can be inspected the same way as a downstream query.\n\n#### Cache override\n\nCaching can be disabled or configured on a per-query basis with `setCachingPolicy()`:\n\n```zig\ntry query.setCachingPolicy(.{ .serve_stale = 600, .pci = true });\n```\n\nAttributes include:\n\n- `no_cache`\n- `ttl`\n- `serve_stale`\n- `pci`\n- `surrogate_key`\n\n#### Pipes\n\nWith `pipe()`, the response sent to a client can be a direct copy of another response. The application will then act as a proxy, optionally also copying the original status and headers.\n\n```zig\nvar query = try zigly.http.Request.new(\"GET\", \"https://google.com\");\nvar upstream_response = try query.send(\"google\");\nvar downstream = try zigly.downstream();\ntry downstream.response.pipe(&upstream_response, true, true);\n```\n\n### Proxying\n\nProxying is even easier to use than pipes when a query should be sent unmodified (with the exception of the `Host` header) to the origin:\n\n```zig\nvar downstream = try zigly.downstream();\ntry downstream.proxy(\"google\", \"www.google.com\");\n```\n\nThe second parameter is optional. If `null`, the original `Host` header will not be modified.\n\n### Redirects\n\nRedirecting the client to another address can be done with a single function call on the downstream object:\n\n```zig\nconst downstream = try zigly.downstream();\ntry downstream.redirect(302, \"https://www.perdu.com\");\n```\n\n### Response decompression\n\nBy default, responses are left as-is. Which means that if compression (`Content-Encoding`) was accepted by the client, the response can be compressed.\n\nCalling `setAutoDecompressResponse(true)` on a `Request` object configures the Fastly Compute runtime to decompress gzip-encoded responses before streaming them to the application.\n\n#### Dictionaries\n\n```zig\nconst dict = try zigly.Dictionary.open(\"name\");\nconst value = try dict.get(allocator, \"key\");\n```\n\n#### Logging\n\n```zig\nvar logger = try zigly.Logger.open(\"endpoint\");\ntry logger.write(\"Log entry\");\n```\n\n#### KV Store\n\nStore and retrieve key-value pairs using Fastly's object store:\n\n```zig\nvar store = try zigly.kv.Store.open(\"my_store\");\nconst value = try store.getAll(\"key\", allocator, 0);\n\n// Insert or replace a value\ntry store.replace(\"key\", \"new_value\");\n```\n\n#### Geolocation\n\nGet location information about IP addresses:\n\n```zig\nconst ip = zigly.geo.Ip{ .ip4 = .{ 8, 8, 8, 8 } };\nvar buf: [4096]u8 = undefined;\nconst location = try zigly.geo.lookup(allocator, ip, &buf);\n// Access location.value fields: city, country_code, latitude, longitude, etc.\n```\n\n#### User Agent Parsing\n\nParse user agent strings:\n\n```zig\nvar family: [64]u8 = undefined;\nvar major: [16]u8 = undefined;\nvar minor: [16]u8 = undefined;\nvar patch: [16]u8 = undefined;\nconst ua = try zigly.UserAgent.parse(user_agent_string, &family, &major, &minor, &patch);\n// Access ua.family, ua.major, ua.minor, ua.patch\n```\n\n#### Dynamic Backends\n\nRegister backends dynamically at runtime:\n\n```zig\nconst backend_config = zigly.DynamicBackend{\n    .name = \"my_backend\",\n    .target = \"example.com:443\",\n    .use_ssl = true,\n    .host_override = \"example.com\",\n    .sni_hostname = \"example.com\",\n    .cert_hostname = \"example.com\",\n    .connect_timeout_ms = 5000,\n    .first_byte_timeout_ms = 15000,\n    .between_bytes_timeout_ms = 10000,\n};\nconst backend = try backend_config.register();\n\n// Check backend properties\nconst exists = try zigly.Backend.exists(\"my_backend\");\nconst is_ssl = try backend.isSsl();\nconst port = try backend.getPort();\n```\n\n## Deployment to Fastly's platform\n\nThe `fastly` command-line tool only supports compilation of Rust and AssemblyScript at the moment.\nHowever, it can still be used to upload pre-compiled code written in other languages, including Zig.\n\n1. Create a new project:\n\n```sh\nfastly compute init\n```\n\nFor the language, select `Other (pre-compiled WASM binary)`.\n\n2. Add a build script:\n\nAdd the following lines to the fastly.toml file:\n\n```toml\n[scripts]\nbuild = \"zig build -Doptimize=ReleaseSmall -Dtarget=wasm32-wasi && mkdir -p bin && cp zig-out/bin/*.wasm bin/main.wasm\"\n```\n\n3. Compile and package the Fastly Compute module:\n\n```sh\nfastly compute build\n```\n\n4. Test locally\n\n```sh\nfastly compute serve\n```\n\n5. Deploy!\n\n```sh\nfastly compute deploy\n```\n\nIn order to deploy new versions, repeat steps 3 and 5.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/124872?v=4",
  "releases": [],
  "owner_bio": "Get my public keys here: https://sk.tl/7CPRo8kn",
  "owner_company": null,
  "owner_location": "Antibes, France",
  "owner_blog": "https://primulinus.tpopsite.com",
  "owner_twitter_username": "jedisct1",
  "owner_followers": 4112,
  "owner_following": 194,
  "owner_created_at": "2009-09-09T10:20:57Z",
  "license": "Apache-2.0",
  "category": "library"
}