{
  "name": "zig-blind-rsa-signatures",
  "owner": "jedisct1",
  "repo": "zig-blind-rsa-signatures",
  "description": "Blind RSA signatures implementation for Zig.",
  "type": "package",
  "topics": [
    "rsa",
    "blind",
    "signatures",
    "blind-signatures",
    "zig",
    "zig-package",
    "rsa-blinded-signatures",
    "rsa-blind-signatures"
  ],
  "stars": 19,
  "forks": 1,
  "watchers": 1,
  "updated_at": "2026-01-31T07:47:50Z",
  "readme": "# Blind RSA signatures\n\nAuthor-blinded RSASSA-PSS RSAE signatures.\n\nThis is an implementation of the [RSA Blind Signatures](https://www.rfc-editor.org/rfc/rfc9474.html) RFC.\n\nAlso implements [Partially Blind RSA Signatures](https://datatracker.ietf.org/doc/draft-irtf-cfrg-partially-blind-rsa/).\n\n## Protocol overview\n\nA client asks a server to sign a message. The server receives the message, and returns the signature.\n\nUsing that `(message, signature)` pair, the client can locally compute a second, valid `(message', signature')` pair.\n\nAnyone can verify that `(message', signature')` is valid for the server's public key, even though the server didn't see that pair before.\nBut no one besides the client can link `(message', signature')` to `(message, signature)`.\n\nUsing that scheme, a server can issue a token and verify that a client has a valid token, without being able to link both actions to the same client.\n\n1. The client creates a random message, optionally prefixes it with noise, and blinds it with a random, secret factor.\n2. The server receives the blind message, signs it and returns a blind signature.\n3. From the blind signature, and knowing the secret factor, the client can locally compute a `(message, signature)` pair that can be verified using the server's public key.\n4. Anyone, including the server, can thus later verify that `(message, signature)` is valid, without knowing when step 2 occurred.\n\nThe scheme was designed by David Chaum, and was originally implemented for anonymizing DigiCash transactions.\n\n## Dependencies\n\nThis implementation requires OpenSSL or BoringSSL.\n\n## Usage\n\n```zig\nconst BlindRsa = @import(\"rsa-blind-signatures\").brsa.BlindRsa;\n\n// [SERVER]: Generate a RSA-2048 key pair\nconst kp = try BlindRsa(2048).KeyPair.generate();\ndefer kp.deinit();\nconst pk = kp.pk;\nconst sk = kp.sk;\n\n// [CLIENT]: create a random message and blind it for the server whose public key is `pk`.\n// The client must store the message and the blinding result.\nconst msg = \"msg\";\nconst blinding_result = try pk.blind(msg);\n\n// [SERVER]: compute a signature for a blind message, to be sent to the client.\n// The client secret should not be sent to the server.\nconst blind_sig = try sk.blindSign(blinding_result.blind_message);\n\n// [CLIENT]: later, when the client wants to redeem a signed blind message,\n// using the blinding secret, it can locally compute the signature of the\n// original message.\n// The client then owns a new valid (message, signature) pair, and the\n// server cannot link it to a previous (blinded message, blind signature) pair.\n// Note that the finalization function also verifies that the new signature\n// is correct for the server public key.\nconst sig = try pk.finalize(blind_sig, &blinding_result, msg);\n\n// [SERVER]: a non-blind signature can be verified using the server's public key.\ntry pk.verify(sig, blinding_result.msg_randomizer, msg);\n```\n\n## RFC9474 Variants\n\nThe library supports all four variants defined in RFC9474:\n\n```zig\nconst brsa = @import(\"rsa-blind-signatures\").brsa;\n\n// RSABSSA-SHA384-PSS-Randomized (default, recommended)\nconst BRsa1 = brsa.BlindRsa(2048);\n\n// RSABSSA-SHA384-PSSZERO-Randomized\nconst BRsa2 = brsa.BlindRsaPSSZeroRandomized(2048);\n\n// RSABSSA-SHA384-PSS-Deterministic\nconst BRsa3 = brsa.BlindRsaPSSDeterministic(2048);\n\n// RSABSSA-SHA384-PSSZERO-Deterministic\nconst BRsa4 = brsa.BlindRsaDeterministic(2048);\n```\n\nFor specific use cases, custom hash functions and PSS modes are accessible via the `BlindRsaCustom` type:\n\n```zig\nconst BRsa = brsa.BlindRsaCustom(2048, .sha256, .pss, .randomized);\nconst kp = try BRsa.KeyPair.generate();\n```\n\n## Partially Blind RSA Signatures\n\nPartially blind signatures allow the signer to include public metadata in the signature, which is visible to both parties. This is useful when the server needs to embed information (like an expiration date) that will be part of the final signature.\n\n```zig\nconst PartiallyBlindRsa = @import(\"rsa-blind-signatures\").pbrsa.PartiallyBlindRsa;\n\n// [SERVER]: Generate a RSA-2048 master key pair\nconst kp = try PartiallyBlindRsa(2048).KeyPair.generate();\ndefer kp.deinit();\n\n// Public metadata that will be bound to the signature\nconst metadata = \"metadata\";\n\n// [SERVER]: Derive a key pair for the specific metadata\nconst derived_kp = try kp.deriveKeyPairForMetadata(metadata);\ndefer derived_kp.deinit();\nconst derived_pk = derived_kp.pk;\nconst derived_sk = derived_kp.sk;\n\n// [CLIENT]: Blind a message using the derived public key\nconst msg = \"msg\";\nconst blinding_result = try derived_pk.blind(msg, metadata);\n\n// [SERVER]: Sign the blinded message\nconst blind_sig = try derived_sk.blindSign(blinding_result.blind_message);\n\n// [CLIENT]: Finalize the signature\nconst sig = try derived_pk.finalize(blind_sig, &blinding_result, msg, metadata);\n\n// [SERVER]: Verify the signature (metadata is required for verification)\ntry derived_pk.verify(sig, blinding_result.msg_randomizer, msg, metadata);\n```\n\nThe same RFC9474 variants are available for partially blind signatures:\n\n```zig\nconst pbrsa = @import(\"rsa-blind-signatures\").pbrsa;\n\n// RSAPBSSA-SHA384-PSS-Randomized (default, recommended)\nconst PBRsa1 = pbrsa.PartiallyBlindRsa(2048);\n\n// RSAPBSSA-SHA384-PSSZERO-Randomized\nconst PBRsa2 = pbrsa.PartiallyBlindRsaPSSZeroRandomized(2048);\n\n// RSAPBSSA-SHA384-PSS-Deterministic\nconst PBRsa3 = pbrsa.PartiallyBlindRsaPSSDeterministic(2048);\n\n// RSAPBSSA-SHA384-PSSZERO-Deterministic\nconst PBRsa4 = pbrsa.PartiallyBlindRsaDeterministic(2048);\n```\n\n## Serialization\n\nKeys can be serialized and deserialized in multiple formats:\n\n```zig\nconst BRsa = brsa.BlindRsa(2048);\n\n// Public keys\nconst pk = kp.pk;\nvar buf: [1000]u8 = undefined;\n\n// Raw format\nconst raw = try pk.serialize(&buf);\nconst pk2 = try BRsa.PublicKey.import(raw);\n\n// DER format\nconst der = try pk.serialize_der(&buf);\nconst pk3 = try BRsa.PublicKey.import_der(der);\n\n// SPKI format (SubjectPublicKeyInfo)\nconst spki = try pk.serialize_spki(&buf);\nconst pk4 = try BRsa.PublicKey.import_spki(spki);\n\n// Secret keys (DER format)\nconst sk = kp.sk;\nconst sk_der = try sk.serialize(&buf);\nconst sk2 = try BRsa.SecretKey.import(sk_der);\n```\n\n## Accessing RSA Components\n\nRaw RSA key components can be accessed for interoperability:\n\n```zig\nvar buf: [256]u8 = undefined;\n\n// Public key components\nconst pk_components = pk.components();\nconst n = try pk_components.n(&buf); // modulus\nconst e = try pk_components.e(&buf); // public exponent\n\n// Secret key components\nconst sk_components = sk.components();\nconst d = try sk_components.d(&buf);    // private exponent\nconst p = try sk_components.p(&buf);    // first prime factor\nconst q = try sk_components.q(&buf);    // second prime factor\nconst dmp1 = try sk_components.dmp1(&buf); // d mod (p-1)\nconst dmq1 = try sk_components.dmq1(&buf); // d mod (q-1)\nconst iqmp = try sk_components.iqmp(&buf); // q^(-1) mod p\n```\n\nAll values are returned as big-endian byte slices.\n\n## For other languages\n\n* [Rust](https://github.com/jedisct1/rust-blind-rsa-signatures)\n* [C](https://github.com/jedisct1/blind-rsa-signatures)\n* [Go](https://github.com/cloudflare/circl/tree/master/blindsign)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/124872?v=4",
  "releases": [],
  "owner_bio": "Get my public keys here: https://sk.tl/7CPRo8kn",
  "owner_company": null,
  "owner_location": "Antibes, France",
  "owner_blog": "https://00f.net",
  "owner_twitter_username": "jedisct1",
  "owner_followers": 4156,
  "owner_following": 195,
  "owner_created_at": "2009-09-09T10:20:57Z",
  "license": "Apache-2.0",
  "category": "library"
}