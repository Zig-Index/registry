{
  "name": "zig-blind-rsa-signatures",
  "owner": "jedisct1",
  "repo": "zig-blind-rsa-signatures",
  "description": "Blind RSA signatures implementation for Zig.",
  "type": "package",
  "topics": [
    "rsa",
    "blind",
    "signatures",
    "blind-signatures",
    "zig",
    "zig-package",
    "rsa-blinded-signatures",
    "rsa-blind-signatures"
  ],
  "stars": 19,
  "forks": 1,
  "watchers": 1,
  "updated_at": "2025-10-06T09:09:41Z",
  "readme": "# Blind RSA signatures\n\nAuthor-blinded RSASSA-PSS RSAE signatures.\n\nThis is an implementation of the [RSA Blind Signatures](https://www.rfc-editor.org/rfc/rfc9474.html) RFC.\n\nAlso includes a preliminary implementation of the [Partially Blind RSA Signatures](https://datatracker.ietf.org/doc/draft-amjad-cfrg-partially-blind-rsa/) draft.\n\n## Protocol overview\n\nA client asks a server to sign a message. The server receives the message, and returns the signature.\n\nUsing that `(message, signature)` pair, the client can locally compute a second, valid `(message', signature')` pair.\n\nAnyone can verify that `(message', signature')` is valid for the server's public key, even though the server didn't see that pair before.\nBut no one besides the client can link `(message', signature')` to `(message, signature)`.\n\nUsing that scheme, a server can issue a token and verify that a client has a valid token, without being able to link both actions to the same client.\n\n1. The client creates a random message, optionally prefixes it with noise, and blinds it with a random, secret factor.\n2. The server receives the blind message, signs it and returns a blind signature.\n3. From the blind signature, and knowing the secret factor, the client can locally compute a `(message, signature)` pair that can be verified using the server's public key.\n4. Anyone, including the server, can thus later verify that `(message, signature)` is valid, without knowing when step 2 occurred.\n\nThe scheme was designed by David Chaum, and was originally implemented for anonymizing DigiCash transactions.\n\n## Dependencies\n\nThis implementation requires OpenSSL or BoringSSL.\n\n## Usage\n\n```zig\n    // [SERVER]: Generate a RSA-2048 key pair\n    const kp = try BlindRsa(2048).KeyPair.generate();\n    defer kp.deinit();\n    const pk = kp.pk;\n    const sk = kp.sk;\n\n    // [CLIENT]: create a random message and blind it for the server whose public key is `pk`.\n    // The second parameter determines whether noise should be added to the message.\n    // `true` adds noise, and returns it as `blinding_result.msg_randomizer`\n    // `false` doesn't prefix the message with noise.\n    // The client must store the message, the optional noise, and the secret.\n    const msg = \"msg\";\n    var blinding_result = try pk.blind(msg, true);\n\n    // [SERVER]: compute a signature for a blind message, to be sent to the client.\n    // The client secret should not be sent to the server.\n    const blind_sig = try sk.blindSign(blinding_result.blind_message);\n\n    // [CLIENT]: later, when the client wants to redeem a signed blind message,\n    // using the blinding secret, it can locally compute the signature of the\n    // original message.\n    // The client then owns a new valid (message, signature) pair, and the\n    // server cannot link it to a previous(blinded message, blind signature) pair.\n    // Note that the finalization function also verifies that the new signature\n    // is correct for the server public key.\n    // The noise parameter can be set to `null` if the message wasn't prefixed with noise.\n    const sig = try pk.finalize(blind_sig, blinding_result.secret,\n                                blinding_result.msg_randomizer, msg);\n\n    // [SERVER]: a non-blind signature can be verified using the server's public key.\n    try pk.verify(sig, blinding_result.msg_randomizer, msg);\n```\n\nDeterministic padding is also supported with the `BlindRsaDeterministic` type:\n\n```zig\nconst BRsa = BlindRsaDeterministic(2048);\nconst kp = BRSA.KeyPair.generate();\n...\n```\n\nFor specific use cases, custom hash functions and salt lengths are also accessible via the `BlindRsaCustom` type.\n\n```zig\nconst BRsa = BlindRsaCustom(2048, .sha256, 48);\nconst kp = BRSA.KeyPair.generate();\n...\n```\n\nSome helper functions are also included for key serialization and deserialization.\n\n## For other languages\n\n* [Rust](https://github.com/jedisct1/rust-blind-rsa-signatures)\n* [C](https://github.com/jedisct1/blind-rsa-signatures)\n* [Go](https://github.com/cloudflare/circl/tree/master/blindsign)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/124872?v=4",
  "releases": [],
  "owner_bio": "Get my public keys here: https://sk.tl/7CPRo8kn",
  "owner_company": null,
  "owner_location": "Antibes, France",
  "owner_blog": "https://primulinus.tpopsite.com",
  "owner_twitter_username": "jedisct1",
  "owner_followers": 4075,
  "owner_following": 194,
  "owner_created_at": "2009-09-09T10:20:57Z",
  "license": "Apache-2.0",
  "category": "library"
}