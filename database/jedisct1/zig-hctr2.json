{
  "name": "zig-hctr2",
  "owner": "jedisct1",
  "repo": "zig-hctr2",
  "description": "HCTR2 and HCTR3 length-preserving encryption algorithm for Zig.",
  "type": "package",
  "topics": [
    "accordion",
    "cipher",
    "encryption",
    "hctr2",
    "zig-package",
    "format-preserving",
    "hctr3",
    "chctr2",
    "hctr2-twkd"
  ],
  "stars": 6,
  "forks": 1,
  "watchers": 2,
  "updated_at": "2025-12-17T15:41:59Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# zig-hctr2\n\nPure Zig implementation of HCTR2, HCTR3, and their beyond-birthday-bound secure variants (CHCTR2, HCTR2-TwKD), plus format-preserving variants.\n\nHCTR2 and HCTR3 are length-preserving tweakable wide-block encryption modes. CHCTR2 and HCTR2-TwKD are beyond-birthday-bound (BBB) secure variants that achieve approximately 85-bit security instead of HCTR2's 64-bit birthday-bound security. The format-preserving variants (HCTR2-FP and HCTR3-FP) are also length-preserving and additionally preserve character sets (e.g., decimal digits remain decimal).\n\nThese modes are designed for full-disk encryption, filename encryption, and other applications where nonces and authentication tags would be impractical.\n\n## What is HCTR2/HCTR3?\n\nHCTR2 and HCTR3 are modern tweakable encryption modes that provide the following properties:\n\n- Length-preserving: ciphertext is the same length as plaintext (no expansion beyond a minimum length)\n- Wide-block: changing any single bit of plaintext affects the entire ciphertext\n- Tweakable: supports a public tweak parameter for domain separation\n- No authentication tag or nonce required\n- Built entirely from standard primitives (AES, Polyval, SHA-256)\n\nThese modes are particularly useful when you need encryption but cannot afford the overhead of nonces or authentication tags, such as encrypting fixed-size disk sectors, filenames, or database fields.\n\n## Which construction should I use?\n\n### HCTR2\n\nUse HCTR2 when you need:\n\n- Fast, single-key encryption\n- Good performance on modern hardware with AES-NI\n- A simpler construction with fewer moving parts\n- Compatibility with existing HCTR2 implementations\n\nHCTR2 uses a single key and relies on Polyval for universal hashing and XCTR mode for the wide-block construction.\n\n### HCTR3\n\nUse HCTR3 when you need:\n\n- Commitment security (resistance to key-manipulation attacks)\n- Protection in scenarios where encryption keys might be known or compromised (cloud storage, message franking)\n- Collision-resistant tweak processing for stronger domain separation\n- Applications requiring both confidentiality and commitment properties\n\nHCTR3 derives two keys from the input key and uses SHA-256 to hash tweaks before processing, providing collision resistance in known-key scenarios. This prevents commitment attacks (CMT-4) that break HCTR2 when adversaries can manipulate keys. HCTR3 employs ELK (Encrypted LFSR Keystream) mode with constant-time LFSR implementation instead of XCTR, providing additional security margins in constrained environments.\n\n### CHCTR2 (Cascaded HCTR2)\n\nUse CHCTR2 when you need:\n\n- Beyond-birthday-bound security (~85-bit instead of ~64-bit)\n- No restrictions on tweak usage\n- Multi-user security guarantees\n- Compatibility with NIST's BBB accordion mode requirements\n\nCHCTR2 cascades HCTR2 twice with two independent keys, achieving 2n/3-bit multi-user security. The construction optimizes the middle hash layers: Z_{1,2} = H1(T,R) XOR H2(T,R). Cost is 2 block cipher calls + 3 field multiplications per block.\n\nReference: \"Beyond-Birthday-Bound Security with HCTR2\" (ASIACRYPT 2025)\n\n### HCTR2-TwKD (Tweak-Based Key Derivation)\n\nUse HCTR2-TwKD when you need:\n\n- Beyond-birthday-bound security with minimal overhead\n- Same performance as standard HCTR2\n- Tweak-based key derivation (each unique tweak derives a unique key)\n- Applications where the same tweak is not reused excessively\n\nHCTR2-TwKD derives a fresh HCTR2 key from each tweak using the CENC construction, achieving 2n/3-bit security when the number of encryptions per tweak is bounded by approximately 2^42. Cost per block is identical to HCTR2 (1 BC call + 2 field multiplications), with a small per-tweak overhead for key derivation.\n\nReference: \"Beyond-Birthday-Bound Security with HCTR2\" (ASIACRYPT 2025)\n\n### Format-Preserving Variants (HCTR2-FP and HCTR3-FP)\n\nUse the format-preserving variants when you need:\n\n- Encryption that preserves the character set (e.g., decimal digits remain decimal)\n- Encrypted values in a specific radix (base-10, base-16, base-64, etc.)\n- Filename encryption where certain characters are forbidden\n- Database encryption where column types must be preserved\n\nLike standard HCTR2/HCTR3, the format-preserving variants are length-preserving (no ciphertext expansion). They additionally maintain the character set by operating on digits in a specified radix. HCTR2-FP and HCTR3-FP support any radix from 2 to 256. Pre-configured variants are provided for common radixes:\n\n- Decimal (radix 10): useful for credit cards, IDs, phone numbers\n- Hexadecimal (radix 16): useful for hex-encoded data\n- Base64 (radix 64): useful for URL-safe encryption\n\nNote that format-preserving modes have higher minimum message lengths (e.g., 39 digits for decimal, 32 for hex, 22 for base64) compared to standard HCTR2/HCTR3 (16 bytes minimum).\n\n### Common Radix Values\n\nThe following table shows common radix values for different use cases:\n\n| Radix | Alphabet               | Use Cases                                | Notes                                  |\n| ----- | ---------------------- | ---------------------------------------- | -------------------------------------- |\n| 2     | `01`                   | Binary data, bit flags                   | Maximum length, minimal alphabet       |\n| 4     | `ACGT` or `0123`       | DNA sequences, quaternary data           | Bioinformatics, compact binary         |\n| 8     | `0-7`                  | Octal numbers                            | Unix file permissions, legacy systems  |\n| 10    | `0-9`                  | Credit cards, phone numbers, numeric IDs | Pre-configured Human-readable numbers  |\n| 16    | `0-9A-F`               | Hex strings, hashes, MAC addresses       | Pre-configured Common in computing     |\n| 26    | `A-Z`                  | Alphabetic codes, license keys           | Case-insensitive text                  |\n| 32    | `A-Z2-7`               | Base32 (RFC 4648), TOTP keys             | No ambiguous chars, 2FA tokens         |\n| 32    | `0-9A-HJKMNP-TV-Z`     | Crockford Base32                         | Human-friendly, excludes I,L,O,U       |\n| 36    | `0-9A-Z`               | Short IDs, URL shorteners                | Case-insensitive, compact              |\n| 58    | `1-9A-HJ-NP-Za-km-z`   | Bitcoin/crypto addresses                 | No confusing chars (0,O,I,l removed)   |\n| 62    | `0-9A-Za-z`            | URL shorteners, compact IDs              | Case-sensitive, very compact           |\n| 63    | `0-9A-Za-z_`           | Programming identifiers                  | Alphanumeric + underscore              |\n| 64    | `A-Za-z0-9+/`          | Base64 encoding, binary data             | Pre-configured Standard Base64         |\n| 64    | `A-Za-z0-9-_`          | URL-safe Base64                          | Web-safe variant, no padding           |\n| 66    | `A-Za-z0-9-._~`        | URL unreserved chars (RFC 3986)          | Safe for URLs without encoding         |\n| 85    | ASCII printable        | Ascii85, binary encoding                 | Compact, printable characters          |\n| 91    | ASCII printable subset | Base91                                   | Very compact binary encoding           |\n| 95    | All printable ASCII    | Full printable character set             | Maximum compactness, may need escaping |\n\nFilesystem-Safe Radixes:\n\n- Radix 62-64: Safe across all major filesystems (Windows, Linux, macOS)\n- Radix 66: URL unreserved characters, safe for both filenames and URLs\n- Avoid characters: `/` (Unix/Linux), `\\/:*?\"<>|` (Windows), `:` (macOS Finder)\n\nCommon Pre-configured Variants:\n\n- `Hctr2Fp_128_Decimal` / `Hctr3Fp_128_Decimal`: Radix 10\n- `Hctr2Fp_128_Hex` / `Hctr3Fp_128_Hex`: Radix 16\n- `Hctr2Fp_128_Base64` / `Hctr3Fp_128_Base64`: Radix 64\n- AES-256 variants also available (e.g., `Hctr2Fp_256_Decimal`)\n\nYou can create custom radix variants for any use case:\n\n```zig\n// Base-36 for case-insensitive alphanumeric identifiers\nconst Cipher36 = hctr2.Hctr2Fp(std.crypto.core.aes.Aes128, 36);\n\n// Base-58 for cryptocurrency-style addresses\nconst Cipher58 = hctr2.Hctr3Fp(std.crypto.core.aes.Aes256, std.crypto.hash.sha2.Sha256, 58);\n\n// Base-62 for compact URL shorteners\nconst Cipher62 = hctr2.Hctr2Fp(std.crypto.core.aes.Aes128, 62);\n```\n\n## Installation\n\nAdd to your `build.zig.zon`:\n\n```zig\n.dependencies = .{\n    .hctr2 = .{\n        .url = \"https://github.com/jedisct1/zig-hctr2/archive/refs/tags/v0.1.6.tar.gz\",\n        .hash = \"...\",\n    },\n},\n```\n\nThen in your `build.zig`:\n\n```zig\nconst hctr2 = b.dependency(\"hctr2\", .{\n    .target = target,\n    .optimize = optimize,\n});\nexe.root_module.addImport(\"hctr2\", hctr2.module(\"hctr2\"));\n```\n\n## Usage Examples\n\n### HCTR2 Encryption\n\n```zig\nconst std = @import(\"std\");\nconst hctr2 = @import(\"hctr2\");\n\npub fn main() !void {\n    // Initialize cipher with a 128-bit key\n    const key: [16]u8 = @splat(0x00);\n    const cipher = hctr2.Hctr2_128.init(key);\n\n    // Encrypt a message\n    const plaintext = \"Hello, World!!!!\"; // Minimum 16 bytes\n    const tweak = \"sector-42\";\n    var ciphertext: [plaintext.len]u8 = undefined;\n\n    try cipher.encrypt(&ciphertext, plaintext, tweak);\n\n    // Decrypt the message\n    var decrypted: [plaintext.len]u8 = undefined;\n    try cipher.decrypt(&decrypted, &ciphertext, tweak);\n}\n```\n\n### HCTR3 Encryption\n\n```zig\nconst hctr2 = @import(\"hctr2\");\n\npub fn main() !void {\n    // Initialize with AES-256\n    const key: [32]u8 = @splat(0x00);\n    const cipher = hctr2.Hctr3_256.init(key);\n\n    const plaintext = \"Sensitive data here!\";\n    const tweak = \"database-record-123\";\n    var ciphertext: [plaintext.len]u8 = undefined;\n\n    try cipher.encrypt(&ciphertext, plaintext, tweak);\n    try cipher.decrypt(&plaintext_out, &ciphertext, tweak);\n}\n```\n\n### CHCTR2 Encryption (Beyond-Birthday-Bound)\n\n```zig\nconst hctr2 = @import(\"hctr2\");\n\npub fn main() !void {\n    // CHCTR2 requires two keys (combined into one 32-byte key for AES-128)\n    const key: [32]u8 = @splat(0x00);  // K1 || K2\n    var cipher = hctr2.Chctr2_128.init(key);\n\n    const plaintext = \"BBB-secure data!\";\n    const tweak = \"any-tweak-value\";\n    var ciphertext: [plaintext.len]u8 = undefined;\n\n    try cipher.encrypt(&ciphertext, plaintext, tweak);\n\n    var decrypted: [plaintext.len]u8 = undefined;\n    try cipher.decrypt(&decrypted, &ciphertext, tweak);\n\n    // Or initialize with separate keys:\n    const key1: [16]u8 = @splat(0x01);\n    const key2: [16]u8 = @splat(0x02);\n    var cipher2 = hctr2.Chctr2_128.initSplit(key1, key2);\n}\n```\n\n### HCTR2-TwKD Encryption (Tweak-Based Key Derivation)\n\n```zig\nconst hctr2 = @import(\"hctr2\");\n\npub fn main() !void {\n    // Master key for key derivation\n    const master_key: [16]u8 = @splat(0x00);\n    const cipher = hctr2.Hctr2TwKD_128.init(master_key);\n\n    const plaintext = \"Sector data here\";\n    const tweak = \"sector-42\";  // Max 14 bytes for KDF tweak\n    var ciphertext: [plaintext.len]u8 = undefined;\n\n    // Each unique tweak derives a unique HCTR2 key\n    try cipher.encrypt(&ciphertext, plaintext, tweak);\n\n    var decrypted: [plaintext.len]u8 = undefined;\n    try cipher.decrypt(&decrypted, &ciphertext, tweak);\n\n    // For longer tweaks, use split mode:\n    const kdf_tweak = \"short-part\";  // Used for key derivation (max 14 bytes)\n    const hctr2_tweak = \"longer-tweak-passed-to-hctr2\";  // Any length\n    try cipher.encryptSplit(&ciphertext, plaintext, kdf_tweak, hctr2_tweak);\n}\n```\n\n### Format-Preserving Encryption (Decimal)\n\n```zig\nconst hctr2 = @import(\"hctr2\");\n\npub fn main() !void {\n    const key: [16]u8 = @splat(0x00);\n    const cipher = hctr2.Hctr2Fp_128_Decimal.init(key);\n\n    // Encrypt a credit card number (all digits remain digits)\n    const plaintext = \"1234567890123456789012345678901234567890\"; // Min 39 digits for decimal\n    const tweak = \"user-cc-field\";\n    var ciphertext: [plaintext.len]u8 = undefined;\n\n    try cipher.encrypt(&ciphertext, plaintext, tweak);\n    // ciphertext contains only decimal digits\n\n    var decrypted: [plaintext.len]u8 = undefined;\n    try cipher.decrypt(&decrypted, &ciphertext, tweak);\n}\n```\n\n### Custom Radix Format-Preserving Encryption\n\n```zig\nconst hctr2 = @import(\"hctr2\");\nconst std = @import(\"std\");\n\npub fn main() !void {\n    // Create a base-36 cipher (0-9, a-z)\n    const Cipher = hctr2.Hctr2Fp(std.crypto.core.aes.Aes128, 36);\n    const key: [16]u8 = @splat(0x00);\n    const cipher = Cipher.init(key);\n\n    // Minimum length depends on radix\n    const min_len = Cipher.first_block_length;\n    // ... use cipher\n}\n```\n\n## Security Considerations\n\n### No authentication\n\nHCTR2 and HCTR3 provide confidentiality only, not authenticity. They do not detect tampering or forgery. If your threat model includes active attackers who can modify ciphertexts, you need additional authentication (e.g., HMAC, digital signatures) or should use an authenticated encryption mode like AES-GCM instead.\n\n### Minimum message lengths\n\n- HCTR2/HCTR3: 16 bytes minimum\n- HCTR2-FP/HCTR3-FP: depends on radix (e.g., 39 digits for radix-10, 32 digits for radix-16, 22 digits for radix-64)\n\nMessages shorter than the minimum will return `error.InputTooShort`.\n\nImportant: Format-preserving modes are length-preserving (no expansion). Input length in digits equals output length in digits.\n\n### Format-preserving first block encoding\n\nIn HCTR2-FP and HCTR3-FP, the first ciphertext block uses base-radix encoding, which may produce statistically distinguishable patterns. For example, in base-10 (decimal), the distribution of first-block digits may not appear uniformly random. However, the underlying encrypted data remains cryptographically secureâ€”the encoding bias does not leak information about the plaintext.\n\n### Key management\n\nStandard key management practices apply:\n\n- Use cryptographically secure random number generators for key generation\n- Store keys securely (e.g., hardware security modules, encrypted key stores)\n- Implement proper key rotation policies\n- Never hardcode keys in source code\n\n## Performance\n\nBoth HCTR2 and HCTR3 are designed to leverage AES-NI instructions on modern processors. Performance characteristics:\n\n- HCTR2 is slightly faster due to simpler construction\n- HCTR3 has higher security margins but slightly more overhead\n- Format-preserving modes have additional computational cost from radix conversion\n- Both scale well with message size (wide-block encryption is parallelized)\n\nRun `zig build bench -Doptimize=ReleaseFast` to measure performance on your hardware.\n\n## References\n\n- [Length-preserving encryption with HCTR2](https://eprint.iacr.org/2021/1441) - Paul Crowley, Nathan Huckleberry, Eric Biggers (IACR ePrint Archive)\n- [HCTR3](https://csrc.nist.gov/files/pubs/sp/800/197/iprd/docs/3_samvadini.pdf) - NIST SP 800-197 Workshop presentation\n- [Beyond-Birthday-Bound Security with HCTR2](https://doi.org/10.1007/978-3-031-85848-6_1) - Chen, Y.L., et al. (ASIACRYPT 2025, LNCS 16245, pp. 3-34)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/124872?v=4",
  "releases": [
    {
      "tag_name": "0.1.7",
      "name": "0.1.7",
      "body": "",
      "prerelease": false,
      "published_at": "2025-10-21T08:02:25Z",
      "html_url": "https://github.com/jedisct1/zig-hctr2/releases/tag/0.1.7",
      "assets": []
    },
    {
      "tag_name": "0.1.6",
      "name": "0.1.6",
      "body": "",
      "prerelease": false,
      "published_at": "2025-10-21T05:38:51Z",
      "html_url": "https://github.com/jedisct1/zig-hctr2/releases/tag/0.1.6",
      "assets": []
    },
    {
      "tag_name": "0.0.0",
      "name": "Initial release",
      "body": "",
      "prerelease": false,
      "published_at": "2025-03-13T12:05:22Z",
      "html_url": "https://github.com/jedisct1/zig-hctr2/releases/tag/0.0.0",
      "assets": []
    }
  ],
  "owner_bio": "Get my public keys here: https://sk.tl/7CPRo8kn",
  "owner_company": null,
  "owner_location": "Antibes, France",
  "owner_blog": "https://primulinus.tpopsite.com",
  "owner_twitter_username": "jedisct1",
  "owner_followers": 4102,
  "owner_following": 194,
  "owner_created_at": "2009-09-09T10:20:57Z",
  "license": "MIT",
  "category": "library"
}