{
  "name": "dbuz",
  "owner": "0xCatPKG",
  "repo": "dbuz",
  "description": "D-Bus client library written in pure zig",
  "type": "package",
  "topics": [
    "dbus",
    "zig-package",
    "zig",
    "ziglang"
  ],
  "stars": 2,
  "forks": 4,
  "watchers": 0,
  "updated_at": "2026-02-24T20:46:06Z",
  "dependencies": [
    {
      "name": "xml",
      "url": "git+https://github.com/edqx/dishwasher.git?branch=0.15.2#d0f03b6a4532f6f324a6640d474bfb653523c9ae",
      "hash": "dishwasher-2.0.0-aXVByZyrAQApDLVb6eVdAvh2_kG_zokxdGGxlXdxwsDy"
    }
  ],
  "minimum_zig_version": "0.14.1",
  "readme": "# DBuz - Pure Zig D-Bus client library\n\nThis library is more like a pet project and practice for me to learn Zig. It provides a simple interface to interact with D-Bus offloading multiple tasks to the zig's comptime.\n\n## Installation\n\n```sh\n$ zig fetch --save git+https://github.com/0xCatPKG/dbuz\n```\n\nThen in your build.zig file, do something like\n```zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const dbuz = b.dependency(\"dbuz\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // ...\n\n    exe_mod.addImport(\"dbuz\", dbuz.module(\"dbuz\"));\n    // ...\n}\n```\n\n## Usage\n\n### Simple example\n\n```zig\nconst std = @import(\"std\");\nconst dbuz = @import(\"dbuz\");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    /// Create connection to D-Bus session bus\n    const connection = try dbuz.connect(allocator, .Session);\n    defer connection.deinit();\n\n    var looper_exit: bool = false;\n    const looper_thread = try dbuz.spawnLooperThread(allocator, connection, &looper_exit);\n    defer looper_thread.join();\n\n    try connection.hello();\n    looper_exit = true;\n    std.debug.print('My unique name is: {?s}\\n', .{connection.unique_name});\n}\n```\n\n## Serialization rules\ndbuz serializes native types using compile time reflection. Following mapping exists:\n| DBus signature symbol | Native type | Notes |\n| --- | --- | --- |\n| `y` | u/i1..8 | Any int with less or equal to 8 bits is serialized as a byte |\n| `b` | bool | Boolean type |\n| `n` | i9..16 | Any int with less or equal to 16 bits is serialized as a short |\n| `q` | u9..16 | Any int with less or equal to 16 bits is serialized as a short |\n| `i` | i17..32 | Any int with less or equal to 32 bits is serialized as an int |\n| `u` | u17..32 | Any int with less or equal to 32 bits is serialized as an unsigned int |\n| `x` | i33..64 | Any int with less or equal to 64 bits is serialized as a long |\n| `t` | u33..64 | Any int with less or equal to 64 bits is serialized as an unsigned long |\n| `d` | f1..64 | All floats must be less than or equal to 64 bits |\n| `h` | any struct that contains .handle is considered to be fd | Out of band data, uses .handle as file descriptor |\n| `s` | dbuz.types.String | String type |\n| `o` | dbuz.types.ObjectPath | Object path type |\n| `g` | dbuz.types.Signature | Signature type |\n| `a` | []T | All pointers passed to de/serialization must be slices |\n| `()` | struct{...} | All structs **except tuples** are serialized recursively according to their field native types, tuples are serialized as sequence of values |\n| `{}` | struct{...} | All structs are serialized as dicts, if they have following declarations: put, getOrPut, getOrPutAdapted, get, iterator, KV |\n| `v` | union(enum) {...} | All union types are serialized as a variants. Duplicate types are unchecked illegal behavior |\n\nEnums are serialized as their corresponding tag type. Exhaustive arrays are not supported for deserialization, as DBus can return any value, and dbuz internally uses `@enumFromInt()` for enum deserialization.\n\n## Publishing interfaces\n\nSometimes you want to handle incoming method call or publish some properties on known path with some interface name.\ndbuz provides 2 general ways to handle incoming messages: DIY way where you filter all incoming messages by yourself,\nor by creating structure that implements dbuz.types.Interface. Here we will skip DIY way and will look into semi-automatic way.\n\nLets assume we want to implement some interface named `org.example.MyInterface` on path `/org/example/MyObject`.\n\n```zig\n\nconst dbuz = @import(\"dbuz\");\nconst Method = dbuz.types.Method;\nconst Signal = dbuz.types.Signal;\nconst Property = dbuz.types.Property;\n\nconst Interface = dbuz.types.Interface;\n\n// ...\n    const MyInterfacePrototype = struct {\\\n        // Required!\n        pub const interface_name: []const u8 = \"org.example.MyInterface\";\n        \n        // Our methods that we want glue code for.\n        pub const Echo = Method(echo, .{});\n        pub const Add = Method(add, .{});\n        pub const Fail = Method(fail, .{});\n\n        // Some property\n        pub const version = Property(u32, &1, .{});\n\n        // And some signal. Signals in interface prototypes are just used for DBus-introspection autogen.\n        pub const SomeSignal = Signal(struct{dbuz.types.String, u32}, .{});\n\n        fn echo(_: *MyInterfacePrototype, text: dbuz.types.String) dbuz.types.String {\n            return text;\n        }\n\n        fn add(_: *MyInterfacePrototype, a: u32, b: u32) u32 {\n            return a + b;\n        }\n\n        fn fail(_: *MyInterfacePrototype) !void {\n            return error.VeryError;\n        }\n    };\n\n    // We generate glue code for our interface prototype in comptime. Second argument can be used to provide our introspection xml\n    const MyInterface = Interface.AutoInterface(MyInterfacePrototype, null);\n    \n    // We assume that allocator already defined beforehand.\n    const iface_impl = try MyInterface.create(allocator);\n    defer if (iface_impl.interface.release() == 1) iface_impl.interface.deinit(allocator);\n\n    // Property initialization. (This step is required! Unless you want garbage data inside of your properties of course)\n    // You must explicitly initialize properties, for which no default value was provided! (In current example default value of 1 is provided for version)\n    iface_impl.properties = .{};\n\n    // Finally, register created interface on connection. Be sure to only register it after initialization, as we have no guarantee\n    // that some other bus connection will not start introspection and try to get values from unitialized .properties\n    // `allocator` here is an allocator used to allocate iface_impl in question. As there's no restriction on control flow,\n    // anyone can release last reference to an interface, so all parties must have original allocator used for allocation.\n    try connection.registerInterface(iface_impl, \"/org/example/MyObject\", allocator);\n    // Starting from that point, connection is capable of processing of method calls automatically. Only prerequisite is looper running\n    // or some other mechanism that will call connection.handleMessage\n\n    defer _ = connection.unregisterInterface(iface_impl, \"/org/example/MyObject\");\n// ...\n\n\n```\n\nThis design still not refined, and any suggestions are welcome.\n\n## Subbing to signals\n\nThis part assumes that you already have an proxy object (TODO: Proxy objects guide.). One of such objects is instance of `org.freedesktop.DBus` proxy located at `connection.dbus`\n\n\n```zig\n\nconst dbuz = @import(\"dbuz\");\nconst String = dbuz.types.String;\n\n// ...\n    \nfn name_owner_changed(name: String, old_owner: String, new_owner: String, _: ?*anyopaque) void {\n    std.debug.print(\"Name owner of \\\"{s}\\\" changed: {s} -> {s}\\n\", .{name.value, old_owner.value, new_owner.value});\n}\n\n// pub fn main() !void\n// ...\n\ntry conn.dbus.NameOwnerChanged.subscribe(&name_owner_changed, null, .Persistent);\n\n// ...\n\n```\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/42083774?u=7754da8e1ffe339eaacfe19ee33ad9de3166f7d5&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "file://localhost",
  "owner_twitter_username": null,
  "owner_followers": 3,
  "owner_following": 5,
  "owner_created_at": "2018-08-04T04:44:43Z",
  "category": "library"
}