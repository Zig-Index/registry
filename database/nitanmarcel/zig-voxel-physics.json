{
  "name": "zig-voxel-physics",
  "owner": "nitanmarcel",
  "repo": "zig-voxel-physics",
  "description": "A high-performance voxel-to-voxel physics engine written in Zig. Designed for my custom voxel rendering engine.",
  "type": "package",
  "topics": [
    "zig",
    "zig-lang",
    "zig-library",
    "zig-package",
    "game-dev",
    "collision-detection",
    "voxel-engine"
  ],
  "stars": 4,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-01-21T14:17:37Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# zig-voxel-physics\n\nA high-performance voxel-to-voxel physics engine written in Zig. Designed for my custom voxel rendering engine.\n\n## Features\n\n- **Voxel-Based Colliders** - Sparse brick structure (8×8×8 voxel bricks) with per-voxel type classification\n- **TGS Soft Solver** - Temporal Gauss-Seidel with soft constraints for stable stacking\n- **Speculative Contacts** - Prevents contact loss and micro-bouncing at rest\n- **Island-Based Sleeping** - Near-zero CPU cost when bodies are at rest (~0.003ms)\n- **Warm Starting** - Contact impulse caching for improved solver convergence\n- **Parallel Ready** - Thread pool support for narrow phase collision detection\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    VoxelPhysicsSystem                           │\n├─────────────────────────────────────────────────────────────────┤\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │  BroadPhase │→ │ NarrowPhase │→ │   Solver    │             │\n│  │  (AABB Tree)│  │(Voxel-Voxel)│  │  (TGS Soft) │             │\n│  └─────────────┘  └─────────────┘  └─────────────┘             │\n│         ↓                ↓                ↓                     │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │   Islands   │  │  Manifolds  │  │   Bodies    │             │\n│  │   Manager   │  │   Cache     │  │   Array     │             │\n│  └─────────────┘  └─────────────┘  └─────────────┘             │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### Core Components\n\n| Component | Description |\n|-----------|-------------|\n| `VoxelPhysicsSystem` | Main coordinator, manages bodies and runs the simulation loop |\n| `VoxelBody` | Rigid body with position, velocity, and mass properties |\n| `VoxelCollider` | Sparse voxel structure defining collision shape |\n| `BroadPhase` | Dynamic AABB tree for fast pair culling |\n| `NarrowPhase` | Voxel-to-voxel contact generation |\n| `ContactSolver` | TGS Soft constraint solver |\n| `IslandManager` | Groups connected bodies for parallel solving |\n\n---\n\n## Installation\n\nAdd to your `build.zig.zon`:\n\n```zig\n.dependencies = .{\n    .@\"zig-voxel-physics\" = .{\n        .url = \"https://github.com/yourusername/zig-voxel-physics/archive/refs/tags/v0.1.0.tar.gz\",\n        .hash = \"...\",\n    },\n},\n```\n\nThen in your `build.zig`:\n\n```zig\nconst voxel_physics = b.dependency(\"zig-voxel-physics\", .{\n    .target = target,\n    .optimize = optimize,\n});\nexe.root_module.addImport(\"zig-voxel-physics\", voxel_physics.module(\"zig-voxel-physics\"));\n```\n\n## Quick Start\n\n```zig\nconst physics = @import(\"zig-voxel-physics\");\n\n// Create physics system\nvar system = try physics.VoxelPhysicsSystem.init(allocator, .{\n    .gravity = physics.Vec3.init(0, -9.81, 0),\n});\ndefer system.deinit();\n\n// Create a collider\nvar collider = try allocator.create(physics.VoxelCollider);\ncollider.* = physics.VoxelCollider.init(allocator, 0.2); // 0.2m voxel size\n\n// Add voxels (3x3x3 cube with proper classification)\nvar z: i32 = -1;\nwhile (z <= 1) : (z += 1) {\n    var y: i32 = -1;\n    while (y <= 1) : (y += 1) {\n        var x: i32 = -1;\n        while (x <= 1) : (x += 1) {\n            const on_x = (x == -1 or x == 1);\n            const on_y = (y == -1 or y == 1);\n            const on_z = (z == -1 or z == 1);\n            const edges = @as(u8, @intFromBool(on_x)) + @as(u8, @intFromBool(on_y)) + @as(u8, @intFromBool(on_z));\n\n            const vtype: physics.VoxelType = switch (edges) {\n                3 => .corner,\n                2 => .edge,\n                1 => .face,\n                else => .inside,\n            };\n\n            var normal: u5 = 2;\n            if (on_x and x > 0) normal = 0;\n            if (on_x and x < 0) normal = 1;\n            if (on_y and y > 0) normal = 2;\n            if (on_y and y < 0) normal = 3;\n            if (on_z and z > 0) normal = 4;\n            if (on_z and z < 0) normal = 5;\n\n            const voxel = physics.CollisionVoxel.init(vtype, normal);\n            try collider.setCollisionVoxel(physics.IVec3.init(x, y, z), voxel);\n        }\n    }\n}\ncollider.recomputeMetadata();\n\n// Create dynamic body\nconst handle = try system.createDynamicBody(\n    physics.Vec3.init(0, 5, 0),\n    physics.Quat.identity,\n    collider,\n    1.0,\n);\nsystem.setColliderOwnership(handle, true);\n\n// Game loop\nwhile (running) {\n    system.update(dt);\n\n    if (system.getBodyConst(handle)) |body| {\n        const pos = body.getPosition();\n        // Use position for rendering...\n    }\n}\n```\n\n## Voxel Types\n\nVoxels must be classified correctly for collision detection to work:\n\n| Type | Description | Collides With |\n|------|-------------|---------------|\n| `.corner` | Corner voxel (3 exposed faces) | Everything |\n| `.edge` | Edge voxel (2 exposed faces) | Corners, edges |\n| `.face` | Surface voxel (1 exposed face) | Corners |\n| `.inside` | Interior voxel | Corners |\n| `.empty` | No collision | Nothing |\n\n**Important:** Face-to-face collisions are filtered out. Ensure shapes have proper corner/edge voxels for collision detection.\n\n## Configuration\n\n### PhysicsConfig\n\n```zig\nconst config = physics.PhysicsConfig{\n    // Core simulation\n    .gravity = physics.Vec3.init(0, -9.81, 0), // Gravity (m/s²)\n    .fixed_timestep = 1.0 / 60.0,              // Physics timestep (seconds)\n    .max_substeps = 8,                          // Max substeps per frame\n\n    // Solver\n    .solver = physics.SolverConfig{ ... },      // See SolverConfig below\n\n    // Capacity\n    .max_bodies = 1024,                         // Maximum number of bodies\n\n    // Material defaults\n    .default_friction = 0.6,                    // Friction coefficient\n    .default_restitution = 0.2,                 // Bounciness (0-1)\n    .default_density = 1.0,                     // kg per voxel\n\n    // Optimizations\n    .enable_sleeping = true,                    // Sleep idle bodies\n    .enable_warm_starting = true,               // Cache contact impulses\n    .enable_threading = false,                  // Multithreaded narrow phase\n    .thread_count = 0,                          // Worker threads (0 = auto)\n    .enable_islands = true,                     // Island-based solving\n    .enable_simd_broad_phase = true,            // SIMD optimizations\n    .min_parallel_batch_size = 16,              // Min pairs for parallel processing\n};\n```\n\n### SolverConfig\n\n```zig\nconst solver = physics.SolverConfig{\n    // Iterations\n    .substeps = 4,                              // Sub-steps per physics step\n    .velocity_iterations = 1,                   // Velocity iterations per substep\n    .position_iterations = 2,                   // Position iterations (after substeps)\n\n    // Soft constraints (Box2D 3.0 style)\n    .hertz = 30.0,                              // Spring frequency (Hz)\n    .damping_ratio = 1.0,                       // Damping (1.0 = critical)\n\n    // Position correction\n    .position_correction_rate = 0.2,            // Baumgarte stabilization rate\n    .max_position_correction = 0.04,            // Max correction per iteration (m)\n    .slop = 0.005,                              // Allowed penetration (m)\n\n    // Warm starting\n    .warm_starting = true,                      // Enable warm starting\n    .warm_start_scale = 0.8,                    // Impulse scale factor (0-1)\n\n    // Features\n    .gravity = physics.Vec3.init(0, -9.81, 0),  // Gravity for integration\n    .enable_friction = true,                    // Friction solving\n    .enable_restitution = true,                 // Bounciness\n    .disable_rotation = false,                  // Debug: disable angular velocity\n};\n```\n\n## Performance\n\n| Scenario | Typical Time |\n|----------|--------------|\n| All bodies sleeping | ~0.003ms |\n| 10 active bodies | ~2-5ms |\n| 50 active bodies | ~10-20ms |\n\n## Building\n\n```bash\n# Build library\nzig build\n\n# Run tests\nzig build test\n\n# Run example\nzig build example\n```\n\n## References\n\n- **Box2D** by Erin Catto ([box2d.org](https://box2d.org/))\n  - Used for the constraint solver, contact management, and warm starting\n- **Bullet Physics** ([bulletphysics.org](https://bulletphysics.org/))\n  - Broad phase culling, sleeping system, and threading approach\n- **Catto, E.** \"Soft Constraints\" (GDC 2011)\n  - Soft constraint math (the spring-damper model)\n- **Catto, E.** \"Solver2D\" (GDC 2024)\n  - TGS solver iteration structure\n- **Coumans, E.** \"Collision Detection\" (GDC)\n  - SAT algorithm for OBB collision testing\n- **Lengyel, E.** \"Voxel-Based Terrain for Real-Time Virtual Simulations\"\n  - Sparse voxel storage (changed from 16³ blocks to 8³ bricks for collision)\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/41646249?u=eafb0d26b0f6a583f3faa079723686ff38fb83af&v=4",
  "releases": [],
  "owner_company": "MARCEL'S SECURITY AND SOFTWARE TECHNOLOGIES",
  "owner_location": null,
  "owner_blog": "https://msectech.dev/",
  "owner_twitter_username": null,
  "owner_followers": 84,
  "owner_following": 6,
  "owner_created_at": "2018-07-24T17:50:08Z",
  "license": "MIT",
  "category": "library"
}