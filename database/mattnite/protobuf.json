{
  "name": "protobuf",
  "owner": "mattnite",
  "repo": "protobuf",
  "description": "A pure-Zig Protocol Buffers library with a standalone .proto parser, build-time code generator, and transport-agnostic RPC stub generation. Proto2 + proto3. Zero external dependencies.",
  "type": "package",
  "topics": [
    "protobuf",
    "rpc",
    "zig",
    "zig-package"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-03-02T04:25:20Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# protobuf\n\nPure-Zig Protocol Buffers. Compile `.proto` files to Zig structs at build time\nwith no dependency on `protoc` or any C library.\n\n- Proto2 and proto3 wire formats\n- Build-time code generation via `build.zig` step\n- Transport-agnostic RPC stub generation\n- 271 tests, ~11k lines, zero external dependencies\n\n## Quick start\n\nAdd the dependency to your `build.zig.zon`:\n\n```sh\nzig fetch --save git+https://codeberg.org/mattnite/protobuf\n```\n\nIn your `build.zig`:\n\n```zig\nconst protobuf = @import(\"protobuf\");\n\npub fn build(b: *std.Build) void {\n    const proto_dep = b.dependency(\"protobuf\", .{});\n    const proto_mod = protobuf.generate(b, proto_dep, .{\n        .proto_sources = b.path(\"proto/\"),\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"my-app\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .imports = &.{\n                .{ .name = \"proto\", .module = proto_mod },\n            },\n        }),\n    });\n    b.installArtifact(exe);\n}\n```\n\nThen use the generated types in your code:\n\n```zig\nconst proto = @import(\"proto\");\nconst Person = proto.@\"addressbook\".Person;\n\nconst person = Person{\n    .name = \"Alice\",\n    .id = 123,\n};\n\n// Serialize\nvar buf: [256]u8 = undefined;\nvar writer = std.Io.Writer.fixed(&buf);\ntry person.encode(&writer);\nconst bytes = buf[0..writer.pos];\n\n// Deserialize\nconst decoded = try Person.decode(allocator, bytes);\ndefer decoded.deinit(allocator);\n```\n\n## What gets generated\n\nGiven a `.proto` file:\n\n```protobuf\nsyntax = \"proto3\";\npackage example;\n\nmessage SearchRequest {\n    string query = 1;\n    int32 page_number = 2;\n    int32 results_per_page = 3;\n}\n```\n\nThe code generator produces a Zig struct with `encode`, `decode`, `calc_size`,\nand `deinit` methods:\n\n```zig\npub const SearchRequest = struct {\n    query: []const u8 = \"\",\n    page_number: i32 = 0,\n    results_per_page: i32 = 0,\n    _unknown_fields: []const u8 = \"\",\n\n    pub fn encode(self: @This(), writer: *std.Io.Writer) !void { ... }\n    pub fn decode(allocator: std.mem.Allocator, bytes: []const u8) !SearchRequest { ... }\n    pub fn calc_size(self: @This()) usize { ... }\n    pub fn deinit(self: @This(), allocator: std.mem.Allocator) void { ... }\n};\n```\n\n## Field type mapping\n\n| Proto type | Zig type |\n|---|---|\n| `double` / `float` | `f64` / `f32` |\n| `int32` / `sint32` / `sfixed32` | `i32` |\n| `int64` / `sint64` / `sfixed64` | `i64` |\n| `uint32` / `fixed32` | `u32` |\n| `uint64` / `fixed64` | `u64` |\n| `bool` | `bool` |\n| `string` / `bytes` | `[]const u8` |\n| `repeated T` | `[]const T` |\n| `map<K, V>` | `std.StringArrayHashMapUnmanaged(V)` or `std.AutoArrayHashMapUnmanaged(K, V)` |\n| `oneof` | `?union(enum) { ... }` |\n| message field | `?MessageType` |\n\nProto2 optional fields are `?T` (nullable). Proto3 implicit-presence scalars\nuse zero defaults and are omitted from the wire when equal to the default.\n\n## RPC stubs\n\nService definitions generate transport-agnostic interfaces using the standard\nZig vtable pattern (`ptr: *anyopaque` + `vtable: *const VTable`):\n\n```protobuf\nservice RouteGuide {\n    rpc GetFeature(Point) returns (Feature);\n    rpc ListFeatures(Rectangle) returns (stream Feature);\n    rpc RecordRoute(stream Point) returns (RouteSummary);\n    rpc RouteChat(stream RouteNote) returns (stream RouteNote);\n}\n```\n\nGenerates a `RouteGuide` struct containing:\n\n- **`service_descriptor`** -- method metadata (names, paths, streaming flags)\n- **`Server`** -- vtable interface that you implement to handle RPCs\n- **`Client`** -- stub that wraps a `Channel` transport and provides typed methods\n\nAll four streaming modes are supported: unary, server-streaming,\nclient-streaming, and bidirectional. The actual transport (gRPC, Connect,\nin-process mock, etc.) is a separate concern that implements the `Channel`\ninterface.\n\n## Import paths\n\nIf your protos import from other directories, pass additional search paths:\n\n```zig\nconst proto_mod = protobuf.generate(b, proto_dep, .{\n    .proto_sources = b.path(\"proto/\"),\n    .import_paths = &.{\n        b.path(\"third_party/\"),\n    },\n});\n```\n\n## Project structure\n\n```\nsrc/\n  protobuf.zig         Root module\n  encoding.zig         Wire format primitives (varint, zigzag, tags)\n  message.zig          Schema-agnostic message reader/writer\n  rpc.zig              Shared RPC types (StatusCode, streams, Channel)\n  GenerateStep.zig     build.zig integration step\n  proto/\n    lexer.zig          .proto tokenizer\n    parser.zig         Recursive descent parser\n    ast.zig            AST node definitions\n    linker.zig         Type resolution and validation\n  codegen/\n    emitter.zig        Zig source text emitter\n    messages.zig       Message struct generation\n    enums.zig          Enum generation\n    services.zig       RPC stub generation\n```\n\n## Requirements\n\nZig 0.15.2 or later.\n\n## Running tests\n\n```sh\nzig build test\n```\n\n## License\n\nBSD-3-Clause\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/7270159?u=7afc4068ae08a415c57ebd5e2c994f61e04925d4&v=4",
  "releases": [],
  "owner_bio": "Working on embedded systems in Zig. Personal work is now found at https://codeberg.org/mattnite",
  "owner_company": "@zscaler",
  "owner_location": "Coquitlam, BC, Canada",
  "owner_blog": "https://mattnite.net",
  "owner_twitter_username": "embedded_boi",
  "owner_followers": 258,
  "owner_following": 33,
  "owner_created_at": "2014-04-12T05:33:49Z",
  "license": "BSD-3-Clause",
  "category": "library"
}