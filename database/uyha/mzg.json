{
  "name": "mzg",
  "owner": "uyha",
  "repo": "mzg",
  "description": "A MessagePack library for Zig",
  "type": "package",
  "topics": [
    "message-pack",
    "msgpack",
    "zig-package",
    "zig"
  ],
  "stars": 17,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-11-24T17:46:38Z",
  "minimum_zig_version": "0.15.1",
  "readme": "<!-- markdownlint-disable no-inline-html -->\n# mzg\n\n<!--toc:start-->\n- [mzg](#mzg)\n  - [How to use](#how-to-use)\n  - [API](#api)\n    - [High level functions](#high-level-functions)\n    - [Building block functions](#building-block-functions)\n  - [Examples](#examples)\n    - [Simple back and forth](#simple-back-and-forth)\n    - [Default packing and unpacking for custom types](#default-packing-and-unpacking-for-custom-types)\n    - [Adapters for common container types](#adapters-for-common-container-types)\n  - [Mapping](#mapping)\n    - [Default packing from Zig types to MessagePack](#default-packing-from-zig-types-to-messagepack)\n    - [Default unpack from MessagePack to Zig types](#default-unpack-from-messagepack-to-zig-types)\n    - [Customization](#customization)\n      - [Packing](#packing)\n      - [Unpacking](#unpacking)\n<!--toc:end-->\n\n`mzg` is a MessagePack library for Zig with no allocations, and the API favors\nthe streaming usage.\n\n## How to use\n\n1. Run the following command to add this project as a dependency\n\n   ```sh\n   zig fetch --save git+https://github.com/uyha/mzg.git#v0.2.1\n   ```\n\n1. In your `build.zig`, add the following\n\n   ```zig\n   const mzg = b.dependency(\"mzg\", .{\n       .target = target,\n       .optimize = optimize,\n   });\n   // Replace `exe` with your actual library or executable\n   exe.root_module.addImport(\"mzg\", mzg.module(\"mzg\"));\n   ```\n\n## API\n\n### High level functions\n\n### Packing functions\n\n1. `pack` is for packing Zig values using a `writer`\n1. `packAdapted` is like `pack` but it accepts a map that defines how certain\n   types should be packed.\n1. `packWithOptions` is like `pack` but it accepts a `mzg.PackOptions` parameter\n   to control the packing behavior.\n1. `packAdaptedWithOptions` is like `packWithOptions` but it accepts a map that\n   defines how certain types should be packed.\n\n### Unpacking functions\n\n1. `unpack` is for unpacking a MessagePack message into a Zig object and it does\n   not allocate memory.\n1. `unpackAdapted` is like `unpack` but it accepts a map that defines how\n   certain types should be unpacked.\n1. `unpackAllocate` is like `unpack` but it accepts an `Allocator` that allows\n   the unpacking process to allocate memory.\n1. `unpackAdaptedAllocate` is like `unpackAllocate` but it accepts a map that\n   defines how a particular type should be packed.\n\n### Adapters\n\n1. `adapter.packArray` and `adapter.unpackArray` pack and unpack structs like\n   `std.ArrayListUnmanaged`\n1. `adapter.packMap` and `adapter.unpackMap` pack and unpack structs like\n   `std.ArrayHashMapUnmanaged`.\n1. `adapter.packStream` and `adapter.unpackStream` pack and unpack structs in a\n   stream like manner (length is not specified in the beginning).\n\n### Building block functions\n\nThere are a set of `pack*` and `unpack*` functions that translate between a\nprecise set of Zig types and MessagePack. These functions can be used when\nimplementing custom packing and unpacking.\n\n## Examples\n\nAll examples live in [examples](examples) directory.\n\n### Simple back and forth\n\nConverting a byte slice to MessagePack and back\n\n```zig\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var allocWriter: Writer.Allocating = .init(allocator);\n    defer allocWriter.deinit();\n    const writer: *Writer = &allocWriter.writer;\n\n    try mzg.pack(\n        \"a string with some characters for demonstration purpose\",\n        writer,\n    );\n\n    var string: []const u8 = undefined;\n    const size = try mzg.unpack(writer.buffer[0..writer.end], &string);\n    std.debug.print(\"Consumed {} bytes\\n\", .{size});\n    std.debug.print(\"string: {s}\\n\", .{string});\n}\n\nconst std = @import(\"std\");\nconst Writer = std.Io.Writer;\n\nconst mzg = @import(\"mzg\");\n```\n\n### Default packing and unpacking for custom types\n\nCertain types can be packed and unpacked by default (refer to\n[Mapping](#mapping) for more details)\n\n```zig\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var allocWriter: Writer.Allocating = .init(allocator);\n    defer allocWriter.deinit();\n    const writer: *Writer = &allocWriter.writer;\n\n    try mzg.pack(\n        Targets{ .position = .init(2000), .velocity = .init(10) },\n        writer,\n    );\n\n    var targets: Targets = undefined;\n    const size = try mzg.unpack(writer.buffer[0..writer.end], &targets);\n\n    std.debug.print(\"Consumed {} bytes\\n\", .{size});\n    std.debug.print(\"Targets: {}\\n\", .{targets});\n}\n\nconst Position = enum(i32) {\n    _,\n    pub fn init(raw: std.meta.Tag(@This())) @This() {\n        return @enumFromInt(raw);\n    }\n};\nconst Velocity = enum(i32) {\n    _,\n    pub fn init(raw: std.meta.Tag(@This())) @This() {\n        return @enumFromInt(raw);\n    }\n};\nconst Targets = struct {\n    position: Position,\n    velocity: Velocity,\n};\n\nconst std = @import(\"std\");\nconst Writer = std.Io.Writer;\n\nconst mzg = @import(\"mzg\");\nconst adapter = mzg.adapter;\n```\n\n### Adapters for common container types\n\nMany container types in the `std` library cannot be packed or unpacked by\ndefault, but the adapter functions make it easy to work with these types.\n\n```zig\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var allocWriter: Writer.Allocating = .init(allocator);\n    defer allocWriter.deinit();\n    const writer: *Writer = &allocWriter.writer;\n\n    var in: std.ArrayList(u32) = .empty;\n    defer in.deinit(allocator);\n    try in.append(allocator, 42);\n    try in.append(allocator, 75);\n    try mzg.pack(adapter.packArray(&in), writer);\n\n    var out: std.ArrayList(u32) = .empty;\n    defer out.deinit(allocator);\n    const size = try mzg.unpackAllocate(\n        allocator,\n        writer.buffer[0..writer.end],\n        adapter.unpackArray(&out),\n    );\n    std.debug.print(\"Consumed {} bytes\\n\", .{size});\n    std.debug.print(\"out: {any}\\n\", .{out.items});\n}\n\nconst std = @import(\"std\");\nconst Writer = std.Io.Writer;\n\nconst mzg = @import(\"mzg\");\nconst adapter = mzg.adapter;\n```\n\n## Mapping\n\n### Default packing from Zig types to MessagePack\n\n<!-- markdownlint-disable line-length -->\n| Zig Type                                 | MessagePack                                               |\n|------------------------------------------|-----------------------------------------------------------|\n| `void`, `null`                           | `nil`                                                     |\n| `bool`                                   | `bool`                                                    |\n| integers (<=64 bits)                     | `int`                                                     |\n| floats (<=64 bits)                       | `float`                                                   |\n| `?T`                                     | `nil` if value is `null`, pack according to `T` otherwise |\n| enums                                    | `int`                                                     |\n| enum literals                            | `str`                                                     |\n| tagged unions                            | `array` of 2 elements: `int` and the value of the union   |\n| packed structs                           | `int`                                                     |\n| structs and tuples                       | `array` of fields in the order they are declared          |\n| `[N]`, `[]`, `[:X]`, and `@Vec` of `u8`  | `str`                                                     |\n| `[N]`, `[]`, `[:X]`, and `@Vec` of `T`   | `array` of `T`                                            |\n| `Ext`                                    | `ext`                                                     |\n| `Timestamp`                              | `Timestamp`                                               |\n| `*T`                                     | `T`                                                       |\n<!-- markdownlint-enable line-length -->\n\n### Default unpack from MessagePack to Zig types\n\n| MessagePack | Compatible Zig Type                  |\n|-------------|--------------------------------------|\n| `nil`       | `void`, `?T`                         |\n| `bool`      | `bool`                               |\n| `int`       | integers, enums                      |\n| `float`     | floats                               |\n| `str`       | `[]const u8`                         |\n| `bin`       | `[]const u8`                         |\n| `array`     | The length can be read into integers |\n| `map`       | The length can be read into integers |\n| `ext`       | `Ext`                                |\n| `Timestamp` | `Timestamp`                          |\n\n### Customization\n\n#### Packing\n\nWhen an enum/union/struct has an `mzgPack` function that returns\n`mzg.PackError!void` can be called with\n\n```zig\n// Value cares about the options passed by the caller\nvalue.mzgPack(options, map, writer);\n```\n\nWith the arguments being\n\n- `value` is the enum/union/struct being packed.\n- `options` is `mzg.PackOptions`.\n- `map` is a tuple of 2 element tuples whose 1st element being a type and 2nd\n  element being a packing adapter function.\n- `writer` is `std.Io.Writer`.\n\nThe function will be called when the `mzg.pack` function is used.\n\n#### Unpacking\n\nWhen an enum/union/struct has\n\n- `mzgUnpack` function that returns `UnpackError!usize` and can be called with\n\n  ```zig\n  out.mzgUnpack(map, buffer);\n  ```\n\n- `mzgUnpackAllocate` function that returns `UnpackAllocateError!usize` and can\n  be called with\n\n  ```zig\n  out.mzgUnpackAllocate(allocator, map, buffer);\n  ```\n\nWith the arguments being\n\n- `out` is the enum/union/struct being unpacked.\n- `allocator` is an `std.mem.Allocator`.\n- `map` is a tuple of 2 element tuples whose 1st element being a type and 2nd\n  element being an unpacking adapter function.\n- `buffer` is `[]const u8`.\n\nThe `mzgUnpack` function is called when either `mzg.unpack` or\n`mzg.unpackAdapted` is used.\n\nThe `mzgUnpackAllocate` function is called when either `mzg.unpackAllocate` or\n`mzg.unpackAdaptedAllocate` is used.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/8091245?u=cfdcc9a998db848f9a9f0d6481233544845fef31&v=4",
  "releases": [
    {
      "tag_name": "v0.2.1",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2025-10-06T19:17:09Z",
      "html_url": "https://github.com/uyha/mzg/releases/tag/v0.2.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.3",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2025-05-23T18:40:18Z",
      "html_url": "https://github.com/uyha/mzg/releases/tag/v0.1.3",
      "assets": []
    },
    {
      "tag_name": "v0.0.3",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2025-03-29T08:57:28Z",
      "html_url": "https://github.com/uyha/mzg/releases/tag/v0.0.3",
      "assets": []
    },
    {
      "tag_name": "v0.0.2",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2025-03-29T07:56:04Z",
      "html_url": "https://github.com/uyha/mzg/releases/tag/v0.0.2",
      "assets": []
    },
    {
      "tag_name": "v0.0.1",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2025-03-29T07:50:13Z",
      "html_url": "https://github.com/uyha/mzg/releases/tag/v0.0.1",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Helsinki, Finland",
  "owner_blog": null,
  "owner_twitter_username": "hachanuy",
  "owner_followers": 16,
  "owner_following": 8,
  "owner_created_at": "2014-07-07T14:29:34Z",
  "license": "MIT",
  "category": "library"
}