{
  "name": "ziglang-set",
  "owner": "deckarep",
  "repo": "ziglang-set",
  "description": "A generic and general purpose Set implementation for the Zig language",
  "type": "package",
  "topics": [
    "datastructures",
    "generics",
    "set",
    "standard-library",
    "zig",
    "ziglang",
    "zig-package"
  ],
  "stars": 105,
  "forks": 8,
  "watchers": 2,
  "updated_at": "2026-02-22T22:38:08Z",
  "minimum_zig_version": "0.15.1",
  "readme": "### Ziglang Set\n\n![License](https://img.shields.io/github/license/deckarep/ziglang-set) ![Issue](https://img.shields.io/github/issues-raw/deckarep/ziglang-set?style=flat) ![Commit](https://img.shields.io/github/last-commit/deckarep/ziglang-set) ![CI](https://github.com/deckarep/ziglang-set/actions/workflows/test.yml/badge.svg)\n\n<p align=\"center\">\nZiglang-Set: a generic and general-purpose Set implementation for Zig. <br/> ðŸš§ BETA ðŸš§\n</p>\n\n#\n\n<p align=\"center\">\n  <img src=\"assets/ZigSetGraphic.png\" width=\"512\"/>\n</p>\n\n#\n<p align=\"center\">\n  <a href=\"https://deckarep.github.io/ziglang-set/\"><img src=\"https://img.shields.io/badge/api-reference-blue.svg?style=flat-square\" alt=\"API Reference\"></a>\n</p>\n\n#\n\nZig currently [does not have](https://github.com/ziglang/zig/issues/6919) a built-in, general purpose Set data structure at this point in time. Until it does, try this!\n\nRationale: It may be common knowledge that a dictionary, map or hashset can be used as a set with a value of `void`. While this is true, there's a lot to think about in terms of supporting all the common set operations in a performant and correct way and there's no good reason why a common module for this shouldn't exist. After studying the Zig stdlib, I'm hoping this implementation can fill that gap and provide some value.\n\n#\n\nThis module offers a Set implementation built in the same vein and spirit of the other data structures within the Zig standard library. This is my attempt to model one that can get better over time and grow with community interest and support. See a problem, file a bug! Or better yet contribute and let's build the best implementation together.\n\nI am the original author of the popular Go based set package: [golang-set](https://github.com/deckarep/golang-set) that is used by software components built by Docker, 1Password, Ethereum, SendGrid, CrowdStrike and HashiCorp. At just shy of `4.5k stars`, I figured I'd take a crack at building a comprehensive and generic Zig-based set that goes above and beyond the original Go implementation. After using Zig for over 3+ years on personal projects, I thought it was time that Zig had a robust Set implementation for itself.\n\nThis implementation gives credit and acknowledgement to the [Zig language](https://ziglang.org) and powerful [Std Library](https://ziglang.org/documentation/master/std/#std) [HashMap](https://ziglang.org/documentation/master/std/#std.hash_map.HashMap) data structure of which this set implementation is built on top of. Without that, this probably wouldn't exist. Efforts will be made to keep the Ziglang Set code fast and straightforward but this Set's raw speed will largely be bounded by the performance of the Zig HashMap of which it is built on top of.\n\n#\n\n#### Features\n  * Offers idiomatic, generic-based Zig API - allocator support, iterators, capacity hints, clearing, resizing, etc.\n  * A few flavors to choose from\n    * NOTE: Future versions of Zig [will be deprecating the `managed` variants](https://ziglang.org/download/0.14.0/release-notes.html#Embracing-Unmanaged-Style-Containers), and this repo will be following suit.\n    * Hash-based: everyday usecase, optimized for lookups primarily, insertion/removal secondarily - [further reading](https://devlog.hexops.com/2022/zig-hashmaps-explained/)\n      * HashSetManaged - initializes with an allocator and holds it internally (built on top of unmanaged)\n      * HashSetUnmanaged - does not hold an allocator, smaller footprint\n    * Array-based: more specialized, iteration much faster, insertion order preserved, indexing into underylying data - [further reading](https://devlog.hexops.com/2022/zig-hashmaps-explained/)\n      * ArrayHashSetManaged - initializes with an allocator and holds it internally (built on top of unmanaged)\n      * ArrayHashSetUnmanaged - does not hold an allocator, smaller footprint\n  * Common set operations\n    * add, append, appendSlice\n    * remove, removeAll\n    * containsOne, containsAny, containsAll\n    * clone, cloneWithAllocator\n    * equals, isEmpty, cardinality\n    * intersection, intersectionUpdate (in-place variant)\n    * union, unionUpdate (in-place variant)\n    * difference, differenceUpdate (in-place variant)\n    * symmetricDifference, symmetricDifferenceUpdate (in-place variant)\n    * isDisjoint\n    * isSubset\n    * isSuperset\n    * isProperSubset\n    * isProperSuperset\n    * pop\n  * Fully documented and robustly tested\n  * Performance aware to minimize unecessary allocs/iteration internally\n  * Custom hash function support\n  * \"string\" support\n  * Benchmarks\n#\n#### Why use a set?\n  * A set offers a fast way to manipulate data and avoid excessive looping. Look into it as there is already tons of literature on the advantages of having a set in your arsenal of tools.\n#\n#### Example\n```zig\n    // import the namespace.\n    const set = @import(\"ziglangSet\");\n\n    // Create a set of u32s called A\n    var A = set.Set(u32).init(std.testing.allocator);\n    defer A.deinit();\n\n    // Add some data\n    _ = try A.add(5);\n    _ = try A.add(6);\n    _ = try A.add(7);\n\n    // Add more data; single shot, duplicate data is ignored.\n    _ = try A.appendSlice(&.{ 5, 3, 0, 9 });\n\n    // Create another set called B\n    var B = set.Set(u32).init(std.testing.allocator);\n    defer B.deinit();\n\n    // Add data to B\n    _ = try B.appendSlice(&.{ 50, 30, 20 });\n\n    // Get the union of A | B\n    var un = try A.unionOf(B);\n    defer un.deinit();\n\n    // Grab an iterator and dump the contents.\n    var iter = un.iterator();\n    while (iter.next()) |el| {\n        std.log.debug(\"element: {d}\", .{el.*});\n    }\n```\n#\n\nOutput of `A | B` - the union of A and B (order is not guaranteed)\n```sh\n> element: 5\n> element: 6\n> element: 7\n> element: 3\n> element: 0\n> element: 9\n> element: 50\n> element: 30\n> element: 20\n```\n\n#\n\n#### Custom Hash Function\n\nTo use a custom hash function, you can use the following types:\n\n- `HashSetUnmanagedWithContext`\n- `HashSetManagedWithContext`\n\nExample:\n\n```zig\n    const SimpleHasher = struct {\n        const Self = @This();\n        pub fn hash(_: Self, key: u32) u64 {\n            return @as(u64, key) *% 0x517cc1b727220a95;\n        }\n        pub fn eql(_: Self, a: u32, b: u32) bool {\n            return a == b;\n        }\n    };\n\n    const ctx = SimpleHasher{};\n    var set = HashSetUnmanagedWithContext(u32, SimpleHasher, 75).initContext(ctx);\n    defer set.deinit(testing.allocator);\n\n    _ = try set.add(testing.allocator, 123);\n    try expect(set.contains(123));\n    try expect(!set.contains(456));\n```\n\n#\n\n#### Installation of Module\n\nTo add this module, update your applications build.zig.zon file by adding the `.ziglang-set` dependency definition. \n\n```zig\n.{\n    .name = \"your-app\",\n    .version = \"0.1.0\",\n    .dependencies = .{\n        .ziglangSet = .{\n            .url = \"https://github.com/deckarep/ziglang-set/archive/$COMMIT_YOU_WANT_TO_USE.tar.gz\",\n        },\n    },\n}\n```\n\nWhen running zig build now, Zig will tell you you need a hash for the dependency and provide one.\nPut it in your dependency so it looks like:\n\n```zig\n.{\n  .ziglangSet = .{\n      .url = \"https://github.com/deckarep/ziglang-set/archive/$COMMIT_YOU_WANT_TO_USE.tar.gz\",\n      .hash = \"$HASH_ZIG_GAVE_YOU\",\n  },\n}\n```\n\nWith the dependency in place, you can now put the following in your build.zig file:\n\n```zig\n    const ziglangSet = b.dependency(\"ziglangSet\", .{});\n    exe.root_module.addImport(\"ziglangSet\", ziglangSet.module(\"ziglangSet\"));\n```\n\nIn the above change `exe` to whatever CompileStep you are using. For an executable it will\nprobably be exe, but `main_tests` or lib are also common.\n\nWith the build file in order, you can now use the module in your zig source. For example:\n\n```zig\nconst std = @import(\"std\");\nconst set = @import(\"ziglangSet\");\n\npub fn main() void {\n    // 1. This datastructure requires an allocator.\n    //    Setup and choose your respective allocator.\n    // See: https://zig.guide/standard-library/allocators\n\n    // 2. Go to town!\n    var A = set.Set(u32).init(allocator);\n    defer A.deinit();\n\n    // Now do something cool with your set!\n    // ...\n}\n```\n\nCheck the tests for more comprehensive examples on how to use this package.\n\n#### Testing\n\n```sh\nzig build test\n```\n\n#### Docs Generation\n\n```sh\n# With Zig installed:\nzigup build docs && cp -a zig-out/docs/. docs/\n\n# Alternatively, using Zigup:\nzigup run <zig-version> build docs && cp -a zig-out/docs/. docs/\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/200686?v=4",
  "releases": [],
  "owner_bio": "- Love to solve challenging problems with code\r\n- Weapons of choice Go, Python, Zig and sometimes TypeScript.",
  "owner_company": null,
  "owner_location": "Los Angeles, CA",
  "owner_blog": "https://medium.com/@deckarep",
  "owner_twitter_username": "deckarep",
  "owner_followers": 235,
  "owner_following": 189,
  "owner_created_at": "2010-02-10T00:36:20Z",
  "homepage": "https://deckarep.github.io/ziglang-set/",
  "license": "MIT",
  "category": "library"
}