{
  "name": "utils-zig",
  "owner": "GitHamo",
  "repo": "utils-zig",
  "description": "Commonly used utility modules built for ziglang",
  "type": "project",
  "topics": [
    "http",
    "mysql",
    "zig",
    "ziglang",
    "zig-package"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-06-03T16:14:57Z",
  "minimum_zig_version": "0.15.0-dev.621+a63f7875f",
  "readme": "## Setup\n\n**Prerequisites:** MySQL 8.0.1+ installed on the machine that will run the build.\n\n\n## Modules Setup\n\n1. in terminal run the following command:\n\n```bash\nzig fetch https://github.com/GitHamo/utils-zig/archive/refs/heads/main.tar.gz --save\n```\n2. in build.zig add the dependancies you want to include to your project. Example: MySQL driver.\n\n\n```zig\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n    const zig_utils = b.dependency(\"zig_utils\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const exe_mod = b.createModule(.{\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    exe_mod.addImport(\"mysql\", zig_utils.module(\"mysql_mod\"));\n\n    const exe = b.addExecutable(.{\n        .name = \"traffic-controller\",\n        .root_module = exe_mod,\n    });\n\n    exe.linkLibC(); // very important\n\n    b.installArtifact(exe);\n\n```\n\n- It is **IMPORTANT** to add `exe.linkLibC();` to your executable\n\n## MySQL Driver: Install & Usage\n\n```zig\n\n// install in project\n\nconst mysqlib = @import(\"mysql\");\n\nvar driver = mysqlib.MySQLDriver.init(allocator: std.mem.Allocator);\ndefer driver.deinit();\n\ntry driver.connect(.{\n    .host = \"127.0.0.1\",\n    .username = \"root\",\n    .password = \"password\",\n    .database = \"test\",\n    .port = 3306,\n});\n\n// usage\n\n// example: for results without any parameter binding\nvar resultsOne = try driver.execute(\"YOUR QUERY\", null);\n\nif (resultsOne) |*result| {\n    defer result.deinit();\n\n    // option 1: loop through results in case of select\n    for(result.rows, 0..) |row, i| {\n        std.debug.print(\"Row {d}: {s}\\n\", .{i, row});\n    }\n}\n\n\n// example: for results without any parameter binding\nconst query_string = \"SELECT col1, col2 FROM table1 WHERE col3 = ? AND col4 = ? AND col5 = ? LIMIT ?\";\nconst select_params = [_]QueryParameter{\n    QueryParameter.fromString(\"string\"),\n    QueryParameter.fromFloat(45.6),\n    QueryParameter.fromNull(),\n    QueryParameter.fromInt(123),\n};\nvar resultsTwo = try driver.execute(query_string, &select_params);\n\nconst RowModel = struct {\n    propertyOne: type,\n    propertyTwo: type,\n};\n\nif (resultsTwo) |*result| {\n    defer result.deinit();\n\n    // option 2: convert returned results into a struct of desire\n    const rowModels = mysqlib.ResultConverter.convert(RowModel, allocator, result) catch |err| {\n        std.debug.print(\"Conversion failed: {}\\n\", .{err});\n        return;\n    };\n\n    defer mysqlib.ResultConverter.free(Endpoint, allocator, rowModels);\n}\n\n\n```",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/17246505?v=4",
  "releases": [],
  "owner_bio": "PHP & other stuff",
  "owner_company": null,
  "owner_location": "Bremen, Germany",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 1,
  "owner_following": 2,
  "owner_created_at": "2016-02-15T08:12:06Z",
  "category": "library"
}