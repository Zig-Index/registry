{
  "name": "zigft",
  "owner": "chung-leong",
  "repo": "zigft",
  "description": "Zig function transform library",
  "type": "package",
  "topics": [
    "zig",
    "zig-package"
  ],
  "stars": 46,
  "forks": 0,
  "watchers": 2,
  "updated_at": "2025-12-02T21:31:41Z",
  "minimum_zig_version": "0.14.0",
  "readme": "# Zigft\n\nZigft is a small library that lets you perform function transform in Zig. Consisting of just two \nfiles, it's designed to be used in source form. Simply download the file you need from this repo, \nplace it in your `src` directory, and import it into your own code.\n\n[fn-transform.zig](#fn-transformzig) provides the library's core functionality. \n[fn-binding.zig](#fn-bindingzig) meanwhile gives you the ability to bind variables to a function.\n\nThis project's code was developed original for [Zigar](https://github.com/chung-leong/zigar). \nCheck it out of you haven't already learned of its existence.\n\n## fn-transform.zig\n\n`fn-transform.zig` provides a single function: \n[spreadArgs()](https://chung-leong.github.io/zigft/#zigft.fn-transform.spreadArgs). It takes a\nfunction that accepts a tuple as the only argument and returns a new function where the tuple \nelements are spread across the argument list. For example, if the following function is the input:\n\n```zig\nfn hello(args: std.meta.Tuple(&.{ i8, i16, i32, i64 })) bool {\n    // ...;\n}\n```\n\nThen `spreadArgs(hello, null)` will return:\n\n```zig\n*const fn (i8, i16, i32, i64) bool\n```\n\nBecause you have full control over the definition of the tuple at comptime, `spreadArgs()` \nbasically lets you to generate any function you want. The only limitation is that its arguments \ncannot be `comptime` or `anytype`.\n\nIt's easier to see the function's purpose in action. Here're some usage scenarios:\n\n#### Adding debug output to a function:\n\n```zig\nconst std = @import(\"std\");\nconst fn_transform = @import(\"./fn-transform.zig\");\n\nfn attachDebugOutput(comptime func: anytype, comptime name: []const u8) @TypeOf(func) {\n    const FT = @TypeOf(func);\n    const fn_info = @typeInfo(FT).@\"fn\";\n    const ns = struct {\n        inline fn call(args: std.meta.ArgsTuple(FT)) fn_info.return_type.? {\n            std.debug.print(\"{s}: {any}\\n\", .{ name, args });\n            return @call(.auto, func, args);\n        }\n    };\n    return fn_transform.spreadArgs(ns.call, fn_info.calling_convention);\n}\n\npub fn main() void {\n    const ns = struct {\n        fn hello(a: i32, b: i32) void {\n            std.debug.print(\"sum = {d}\\n\", .{a + b});\n        }\n    };\n    const func = attachDebugOutput(ns.hello, \"hello\");\n    func(123, 456);\n}\n```\n```\nhello: { 123, 456 }\nsum = 579\n```\n\n#### \"Uninlining\" an explicitly inline function:\n\n```zig\nconst std = @import(\"std\");\nconst fn_transform = @import(\"./fn-transform.zig\");\n\nfn Uninlined(comptime FT: type) type {\n    const f = @typeInfo(FT).@\"fn\";\n    if (f.calling_convention != .@\"inline\") return FT;\n    return @Type(.{\n        .@\"fn\" = .{\n            .calling_convention = .auto,\n            .is_generic = f.is_generic,\n            .is_var_args = f.is_var_args,\n            .return_type = f.return_type,\n            .params = f.params,\n        },\n    });\n}\n\nfn uninline(func: anytype) Uninlined(@TypeOf(func)) {\n    const FT = @TypeOf(func);\n    const f = @typeInfo(FT).@\"fn\";\n    if (f.calling_convention != .@\"inline\") return func;\n    const ns = struct {\n        inline fn call(args: std.meta.ArgsTuple(FT)) f.return_type.? {\n            return @call(.auto, func, args);\n        }\n    };\n    return fn_transform.spreadArgs(ns.call, .auto);\n}\n\npub fn main() void {\n    const ns = struct {\n        inline fn hello(a: i32, b: i32) void {\n            std.debug.print(\"sum = {d}\\n\", .{a + b});\n        }\n    };\n    const func = uninline(ns.hello);\n    std.debug.print(\"fn address = {x}\\n\", .{@intFromPtr(&func)});\n}\n```\n```\nfn address = 10deb00\n```\n\n#### Converting a function that returns an error code into one that returns an error union:\n\n```zig\nconst std = @import(\"std\");\nconst fn_transform = @import(\"./fn-transform.zig\");\n\nconst OriginalErrorEnum = enum(c_int) {\n    OK,\n    APPLE_IS_ROTTING,\n    BANANA_STINKS,\n    CANTALOUPE_EXPLODED,\n};\n\nfn originalFn() callconv(.c) OriginalErrorEnum {\n    return .CANTALOUPE_EXPLODED;\n}\n\nconst NewErrorSet = error{\n    AppleIsRotting,\n    BananaStink,\n    CantaloupeExploded,\n};\n\nfn Translated(comptime FT: type) type {\n    return @Type(.{\n        .@\"fn\" = .{\n            .calling_convention = .auto,\n            .is_generic = false,\n            .is_var_args = false,\n            .return_type = NewErrorSet!void,\n            .params = @typeInfo(FT).@\"fn\".params,\n        },\n    });\n}\n\nfn translate(comptime func: anytype) Translated(@TypeOf(func)) {\n    const error_list = init: {\n        const es = @typeInfo(NewErrorSet).error_set.?;\n        var list: [es.len]NewErrorSet = undefined;\n        inline for (es, 0..) |e, index| {\n            list[index] = @field(NewErrorSet, e.name);\n        }\n        break :init list;\n    };\n    const FT = @TypeOf(func);\n    const TFT = Translated(FT);\n    const ns = struct {\n        inline fn call(args: std.meta.ArgsTuple(TFT)) NewErrorSet!void {\n            const result = @call(.auto, func, args);\n            if (result != .OK) {\n                const index: usize = @intCast(@intFromEnum(result) - 1);\n                return error_list[index];\n            }\n        }\n    };\n    return fn_transform.spreadArgs(ns.call, .auto);\n}\n\npub fn main() !void {\n    const func = translate(originalFn);\n    try func();\n}\n```\n```\nerror: CantaloupeExploded\n/home/cleong/zigft/fn-transform.zig:97:13: 0x10de01e in call0 (example-enum-to-error)\n            return func(.{});\n            ^\n/home/cleong/zigft/example-enum-to-error.zig:58:5: 0x10ddf53 in main (example-enum-to-error)\n    try func();\n```\n\n## fn-binding.zig\n\n`fn-binding.zig` provides a [set of functions](https://chung-leong.github.io/zigft/#zigft.fn-binding)\nrelated to function binding. [bind()](https://chung-leong.github.io/zigft/#zigft.fn-binding.bind)\nand [unbind()](https://chung-leong.github.io/zigft/#zigft.fn-binding.unbind) are the pair you \nwill most likely use.\n\nThe first argument to `bind()` can be either `fn (...)` or `*const fn (...)`. The second argument \nis a tuple containing arguments for the given function. The function returned by `bind()` depends \non the tuple's content. If it provides a complete set of arguments, then the returned function \nwill have an empty argument list. That is the case for the following example:\n\n```zig\nconst std = @import(\"std\");\nconst fn_binding = @import(\"./fn-binding.zig\");\n\npub fn main() !void {\n    var funcs: [5]*const fn () void = undefined;\n    for (&funcs, 0..) |*ptr, index|\n        ptr.* = try fn_binding.bind(std.debug.print, .{ \"hello: {d}\\n\", .{index + 1} });\n    defer for (funcs) |f| fn_binding.unbind(f);\n    for (funcs) |f| f();\n}\n```\n```\nhello: 1\nhello: 2\nhello: 3\nhello: 4\nhello: 5\n```\n\nIf you wish to bind to arguments in the middle of the argument list while leaving preceding \nones unbound, you can do so with the help of explicit indices:\n\n```zig\nconst std = @import(\"std\");\nconst fn_binding = @import(\"./fn-binding.zig\");\n\npub fn main() !void {\n    const ns = struct {\n        fn hello(a: i8, b: i16, c: i32, d: i64) void {\n            std.debug.print(\"a = {d}, b = {d}, c = {d}, d = {d}\\n\", .{ a, b, c, d });\n        }\n    };\n    const func1 = try fn_binding.bind(ns.hello, .{ .@\"2\" = 300 });\n    defer fn_binding.unbind(func1);\n    func1(1, 2, 4);\n    const func2 = try fn_binding.bind(ns.hello, .{ .@\"-2\" = 301 });\n    defer fn_binding.unbind(func2);\n    func2(1, 2, 4);\n}\n```\n```\na = 1, b = 2, c = 300, d = 4\na = 1, b = 2, c = 301, d = 4\n```\n\nNegative indices mean \"from the end\".\n\nBinding to inline functions is possible:\n\n```zig\nconst std = @import(\"std\");\nconst fn_binding = @import(\"./fn-binding.zig\");\n\npub fn main() !void {\n    const ns = struct {\n        inline fn hello(a: i32, b: i32) void {\n            std.debug.print(\"sum = {d}\\n\", .{a + b});\n        }\n    };\n    const func = try fn_binding.bind(ns.hello, .{ .@\"-1\" = 123 });\n    func(3);\n}\n```\n```\nsum = 126\n```\n\nBinding to inline functions with `comptime` or `anytype` arguments is impossible, however.\n\nAs you've seen already in the example involving \n[std.debug.print()](https://ziglang.org/documentation/0.15.2/std/#std.debug.print), binding to \nfunctions with `comptime` and `anytype` arguments is permitted as long as the resulting function \nwill have no such arguments. \n\nIn a `comptime` context, `bind()` would create a comptime binding. You would basically get a \nregular, not-dynamically-generated function:\n\n```zig\nconst std = @import(\"std\");\nconst fn_binding = @import(\"./fn-binding.zig\");\n\npub fn main() !void {\n    const ns = struct {\n        const dog = fn_binding.bind(std.debug.print, .{ \"Woof!\\n\", .{} }) catch unreachable;\n        const cat = fn_binding.bind(std.debug.print, .{ \"Meow!\\n\", .{} }) catch unreachable;\n        const fox = fn_binding.define(std.debug.print, .{ \"???\\n\", .{} });\n    };\n    ns.dog();\n    ns.cat();\n    ns.fox();\n}\n```\n```\nWoof!\nMeow!\n???\n```\n\nUse [define()](https://chung-leong.github.io/zigft/#zigft.fn-binding.define) instead in this\nscenario if you dislike the appearance of `catch unreachable`.\n\n[closure()](https://chung-leong.github.io/zigft/#zigft.fn-binding.close) lets you conveniently\ncreating a closure with the help of an inline struct type:\n\n```zig\nconst std = @import(\"std\");\nconst fn_binding = @import(\"./fn-binding.zig\");\n\npub fn main() !void {\n    var funcs: [5]*const fn (i32) void = undefined;\n    for (&funcs, 0..) |*ptr, index|\n        ptr.* = try fn_binding.close(struct {\n            number: usize,\n\n            pub fn print(self: @This(), arg: i32) void {\n                std.debug.print(\"Hello: {d}, {d}\\n\", .{ self.number, arg });\n            }\n        }, .{ .number = index });\n    defer for (funcs) |f| fn_binding.unbind(f);\n    for (funcs) |f| f(123);\n}\n```\n```\nHello: 0, 123\nHello: 1, 123\nHello: 2, 123\nHello: 3, 123\nHello: 4, 123\n```\n\nThe function in the struct can have any name. It must be the only public function.\n\n## Limitations\n\nFunction binding requires hardware-specific code. CPU architectures currently supported: \n`x86_64`, `x86`, `aarch64`, `arm`, `riscv64`, `riscv32`, `powerpc64`, `powerpc64le`, \n`powerpc`.\n\n## Support for earlier versions of Zig\n\nThe main branch of Zigft is designed for Zig 0.15.x. Use the code in the v.0.14.1 branch if you're \nstill on the other version of Zig.\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/2793150?u=0978273c5cb88332637e8ebff6d828c567a9eff0&v=4",
  "releases": [],
  "owner_bio": "Chinese-American currently living in Krakow, Poland. I did my undergrad at UC Berkeley, studying Materials Science and Slavic Studies.",
  "owner_company": null,
  "owner_location": "Krak√≥w, Poland",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 54,
  "owner_following": 0,
  "owner_created_at": "2012-11-14T05:26:54Z",
  "homepage": "https://chung-leong.github.io/zigft/",
  "license": "MIT",
  "category": "library"
}