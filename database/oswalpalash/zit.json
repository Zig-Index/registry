{
  "name": "zit",
  "owner": "oswalpalash",
  "repo": "zit",
  "description": "zit - Zig TUI Library",
  "type": "package",
  "topics": [
    "zig",
    "zig-package"
  ],
  "stars": 8,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-01-21T10:32:01Z",
  "readme": "# Zit - A Text User Interface Library for Zig\n\nZit is a TUI (Text User Interface) library for Zig that enables developers to create interactive terminal applications. The library provides tools for terminal manipulation, input handling, rendering, layout management, and widget creation.\n\n## Features\n\n- **Terminal handling**: Cross-platform terminal operations with raw mode support\n- **Text rendering**: Support for colors (named colors), styles (bold, italic, underline), and basic text drawing\n- **Layout system**: Basic layout management with Rect-based positioning, flex/grid containers, and constraint anchoring\n- **Widget library**: Core UI components including:\n  - Labels\n  - Buttons\n  - Checkboxes\n  - Progress bars\n  - Toggles, radio groups, sliders, rating stars, status bars, toolbars, breadcrumbs, pagination, accordions, wizards/steppers, command palette, notification center\n  - Color picker/palettes\n  - Lists\n  - Popups, toasts, menu bars, and canvas primitives\n- **Input handling**: Keyboard and mouse event processing\n- **Typeahead navigation**: Incremental, case-insensitive jumping for lists, tables, and the file browser with configurable timeouts\n- **Event system**: Basic event handling for widgets\n- **Animations**: Reusable animator with easing and yoyo/repeat\n- **Accessibility**: Annotate widgets with roles and focus announcements\n- **Async utilities**: Timer manager plus async application loop helpers\n- **Modern and intuitive API**\n- **Efficient memory management**\n- **Thread-safe components**\n- **Rich widget set**\n- **Cross-platform support**\n- **Zero dependencies**\n\n## Quick start (5 lines)\n\n```zig\nconst zit = @import(\"zit\");\n\npub fn main() !void {\n    try zit.quickstart.renderText(\"Hello, Zit!\", .{});\n}\n```\n\nNeed a widget fast? Fluent builders make configuration readable and type-safe:\n\n```zig\nconst button = try zit.widget.ButtonBuilder.init(allocator)\n    .text(\"Deploy\")\n    .borderStyle(.double)\n    .onPress(myHandler)\n    .build();\n```\n\n## Why Zit over other TUIs?\n\n| Capability | Zit | Typical terminal UI libs |\n| --- | --- | --- |\n| Widgets | 36+ built-ins (gauges, steppers, charts, typeahead lists/tables, palettes, menus) | Often 5-15 primitives; complex widgets assembled manually |\n| Navigation aids | Typeahead on lists/tables/file browser, focus rings, wizard stepper | Usually manual filtering or custom key handlers |\n| Theming | Light/dark/high-contrast palettes + per-widget overrides | Global color constants or app-defined palettes |\n| Motion & feedback | Animator with easing/yoyo, timers, toasts, notification center | Rare or needs external crates |\n| Pointer UX | Mouse + drag-and-drop with payloads, context menus anywhere | Frequently keyboard-only |\n| Accessibility | Focus announcements and annotated roles built in | Typically omitted or ad-hoc |\n\n## Common patterns\n\nSplit panes and quick theming:\n\n```zig\nvar pane = try zit.widget.SplitPane.init(allocator);\npane.setOrientation(.horizontal);\npane.setRatio(0.35);\npane.setFirst(&tree.widget);\npane.setSecond(&table.widget);\n\nconst palette = zit.widget.theme.Theme.highContrast();\ntree.setTheme(palette);\ntable.header_bg = palette.color(.accent);\ntable.header_fg = palette.color(.background);\ntry pane.widget.layout(zit.layout.Rect.init(1, 1, width - 2, height - 2));\ntry pane.widget.draw(&renderer);\n```\n\nTable/list typeahead (works out of the box; just set timeouts to taste):\n\n```zig\nvar services = try zit.widget.Table.init(allocator);\ndefer services.deinit();\ntry services.addColumn(\"Service\", 20, true);\ntry services.addColumn(\"Owner\", 12, true);\ntry services.addRow(&.{ \"gateway\", \"alice\" });\ntry services.addRow(&.{ \"search\", \"carmen\" });\nservices.setTypeaheadTimeout(700); // milliseconds\nservices.widget.focused = true;    // type to jump\n```\n\nContext menus anywhere you can point or right-click:\n\n```zig\nvar ctx = try zit.widget.ContextMenu.init(allocator);\ndefer ctx.deinit();\ntry ctx.addItem(\"Copy\", true, null);\ntry ctx.addItem(\"Delete\", false, null);\nctx.setOnSelect(struct {\n    fn choose(_: usize, item: zit.widget.ContextMenuItem, _: ?*anyopaque) void {\n        std.debug.print(\"picked: {s}\\n\", .{item.label});\n    }\n}.choose, null);\n\n// Open beside the cursor (e.g. on right-click)\nctx.openAt(mouse_x, mouse_y);\nif (ctx.open) try ctx.widget.draw(&renderer);\n```\n\n## Memory Management\n\nZit provides a sophisticated memory management system designed for optimal performance and safety in TUI applications. The system includes:\n\n### MemoryManager\n\nThe core memory management component that coordinates different allocators:\n\n```zig\nvar memory_manager = try memory.MemoryManager.init(allocator, arena_size, widget_pool_size);\ndefer memory_manager.deinit();\n\n// Get the arena allocator for temporary allocations\nconst arena = memory_manager.getArenaAllocator();\n\n// Get the widget pool allocator for widget instances\nconst widget_pool = memory_manager.getWidgetPoolAllocator();\n```\n\n### ArenaAllocator\n\nA fast allocator for temporary allocations with automatic cleanup:\n\n```zig\nvar arena = try memory.ArenaAllocator.init(parent_allocator, size, is_thread_safe);\ndefer arena.deinit();\n\n// Reset the arena to free all allocations\narena.reset();\n```\n\n### PoolAllocator\n\nAn efficient allocator for widget instances with object reuse:\n\n```zig\nvar pool = try memory.PoolAllocator.init(parent_allocator, node_size, initial_capacity);\ndefer pool.deinit();\n\n// Get statistics about pool usage\nconst stats = pool.getStats();\n```\n\n### Memory Safety\n\nBuilt-in safety features to prevent common memory issues:\n\n```zig\nvar safety = try memory.MemorySafety.init(allocator);\ndefer safety.deinit();\n\n// Validate pointer access\nif (safety.validatePointer(ptr, len)) {\n    // Safe to use the pointer\n}\n\n// Check for buffer overflows\ntry safety.checkAllocations();\n```\n\n### Memory Debugging\n\nTools for tracking memory usage and detecting leaks:\n\n```zig\nvar debugger = try memory.MemoryDebugger.init(allocator);\ndefer debugger.deinit();\n\n// Track allocations\nconst ptr = try debugger.allocator().alloc(u8, 100);\ndefer debugger.allocator().free(ptr);\n\n// Dump memory leaks\ntry debugger.dumpLeaks(std.io.getStdErr().writer());\n```\n\n### Memory Optimization\n\nPerformance optimizations for memory-intensive operations:\n\n```zig\nvar optimizer = try memory.MemoryOptimizer.init(allocator);\ndefer optimizer.deinit();\n\n// Pre-allocate cache lines\noptimizer.optimize(256);\n\n// Get optimization statistics\nconst stats = optimizer.getStats();\n```\n\n## Usage Example\n\n```zig\nconst std = @import(\"std\");\nconst zit = @import(\"zit\");\nconst memory = zit.memory;\n\npub fn main() !void {\n    // Initialize memory manager\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\nvar memory_manager = try memory.MemoryManager.init(allocator, 1024 * 1024, 100);\ndefer memory_manager.deinit();\n\n// Initialize terminal with memory manager\nvar term = try zit.terminal.init(memory_manager.getArenaAllocator());\n    defer term.deinit() catch {};\n\n    // Create widgets using the widget pool allocator\n    var button = try zit.widget.Button.init(memory_manager.getWidgetPoolAllocator(), \"Click Me!\");\n    defer button.deinit();\n\n// ... rest of the application code\n}\n```\n\n## Animations and timers\n\nZit ships with a lightweight animation driver (with easing and yoyo/repeat) plus a timer manager that plugs into the application loop:\n\n```zig\nvar app = zit.event.Application.init(allocator);\ntry app.enableAccessibility(); // optional: wire focus announcements\n\n// Animate a progress value for 250ms\nvar gauge = try zit.widget.Gauge.init(allocator);\n_ = try app.addAnimation(.{\n    .duration_ms = 250,\n    .on_update = struct {\n        fn update(progress: f32, ctx: ?*anyopaque) void {\n            const gauge = @as(*zit.widget.Gauge, @ptrCast(@alignCast(ctx.?)));\n            gauge.setValue(progress * 100);\n        }\n    }.update,\n    .context = @ptrCast(gauge),\n});\n\n// Fire a repeating task every second\n_ = try app.scheduleTimer(1000, 1000, struct {\n    fn tick(_: ?*anyopaque) void {\n        std.debug.print(\\\"tick\\\\n\\\", .{});\n    }\n}.tick, null);\n```\n\n## Accessibility\n\nMark widgets with accessible roles and names so focus changes can be announced:\n\n```zig\ntry app.enableAccessibility();\ntry app.registerAccessibleNode(.{\n    .widget_ptr = &button.widget,\n    .role = zit.widget.AccessibilityRole.button,\n    .name = \\\"Submit\\\",\n    .description = \\\"Send the form\\\",\n});\n```\n\n## Examples and benchmarks\n\n- Widget demos in `examples/widget_examples/`:\n  - `zig build notifications-example` – popups, toasts, menu bar, canvas, drag-and-drop payloads.\n  - `zig build dashboard-example` – tree + sparkline + gauge with theme toggles.\n  - `zig build table-example` – typeahead navigation on tables.\n  - `zig build file-browser-example` – explore folders with incremental search.\n  - `zig build file-manager-example` – tree + list + context menu mini file manager.\n  - `zig build form-wizard-example` – multi-step form with validation and toggles.\n  - `zig build system-monitor-example` – gauges, sparkline, live process table.\n- Realistic screens: `zig build htop-clone`, `zig build file-manager`, `zig build text-editor`, `zig build dashboard-demo`.\n- Rendering benchmark: `zig build bench` runs `examples/benchmarks/render_bench.zig` to gauge draw throughput.\n\n### Demo previews\n\n![System monitor dashboard](assets/system_monitor_example.svg)\n![File manager navigation](assets/file_manager_example.svg)\n![Widget showcase](assets/showcase_demo.svg)\n\nTo refresh these assets with real terminal frames, run `python scripts/make_screenshots.py` (requires a PTY/terminal). For a recorder-free refresh that works in sandboxed environments, use the built-in mock layouts with `python scripts/make_screenshots.py --mock`.\n\n## Best Practices\n\n1. Use the `MemoryManager` as the primary interface for memory management\n2. Use the arena allocator for temporary allocations that can be freed together\n3. Use the widget pool allocator for widget instances\n4. Enable memory safety checks in development builds\n5. Use the memory debugger to track down leaks\n6. Consider using the memory optimizer for performance-critical sections\n\n## Thread Safety\n\nAll memory management components are thread-safe by default. The `ArenaAllocator` can be configured for thread safety:\n\n```zig\n// Create a thread-safe arena\nvar arena = try memory.ArenaAllocator.init(allocator, size, true);\n```\n\n## Performance Considerations\n\n- The arena allocator is extremely fast for temporary allocations\n- The pool allocator reduces fragmentation for widget instances\n- The memory optimizer can significantly improve performance for repeated allocations\n- Memory safety checks have minimal overhead in release builds\n\n## Installation\n\nAdd Zit to your project:\n\n```bash\n# Clone the repository\ngit clone https://github.com/oswalpalash/zit.git\n\n# Add as a dependency in your build.zig\n```\n\nIn your `build.zig`:\n\n```zig\nconst zit_dep = b.dependency(\"zit\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nconst zit_module = zit_dep.module(\"zit\");\nexe.addModule(\"zit\", zit_module);\n```\n\n## Quick Start\n\nHere's a simple example to get you started:\n\n```zig\nconst std = @import(\"std\");\nconst zit = @import(\"zit\");\n\npub fn main() !void {\n    // Initialize allocator\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Initialize terminal\n    var term = try zit.terminal.init(allocator);\n    defer term.deinit() catch {};\n\n    // Get terminal size\n    const width = term.width;\n    const height = term.height;\n\n    // Initialize renderer\n    var renderer = try zit.render.Renderer.init(allocator, width, height);\n    defer renderer.deinit();\n\n    // Enable raw mode\n    try term.enableRawMode();\n    defer term.disableRawMode() catch {};\n\n    // Initialize input handler\n    var input_handler = zit.input.InputHandler.init(allocator, &term);\n    try input_handler.enableMouse();\n\n    // Create a label\n    var label = try zit.widget.Label.init(allocator, \"Hello, Zit!\");\n    defer label.deinit();\n    label.setAlignment(.center);\n    label.setColor(\n        zit.render.Color{ .named_color = zit.render.NamedColor.bright_white },\n        zit.render.Color{ .named_color = zit.render.NamedColor.blue }\n    );\n\n    // Main event loop\n    var running = true;\n    while (running) {\n        // Clear the buffer\n        renderer.back.clear();\n        \n        // Draw the label\n        const label_rect = zit.layout.Rect.init(\n            if (width > 20) (width - 20) / 2 else 0,\n            if (height > 1) height / 2 else 0,\n            20,\n            1\n        );\n        try label.widget.layout(label_rect);\n        try label.widget.draw(&renderer);\n        \n        // Render to screen\n        try renderer.render();\n        \n        // Poll for events with a 100ms timeout\n        const event = try input_handler.pollEvent(100);\n        \n        if (event) |e| {\n            switch (e) {\n                .key => |key| {\n                    // Exit on 'q' key\n                    if (key.key == 'q' and !key.modifiers.ctrl and !key.modifiers.alt) {\n                        running = false;\n                    }\n                },\n                .resize => |resize| {\n                    // Resize renderer\n                    try renderer.resize(resize.width, resize.height);\n                },\n                else => {},\n            }\n        }\n    }\n    \n    // Clean up\n    try term.clear();\n    try term.moveCursor(0, 0);\n}\n```\n\n## Core Components\n\n### Terminal Handling\n\nThe terminal module provides basic terminal operations:\n\n```zig\n// Initialize terminal\nvar term = try zit.terminal.init(allocator);\n\n// Enable raw mode for direct input\ntry term.enableRawMode();\n\n// Get terminal dimensions\nconst width = term.width;\nconst height = term.height;\n\n// Move cursor and clear screen\ntry term.moveCursor(x, y);\ntry term.clear();\n```\n\n### Input Handling\n\nThe input module processes keyboard and mouse events:\n\n```zig\n// Initialize input handler\nvar input_handler = zit.input.InputHandler.init(allocator, &term);\ntry input_handler.enableMouse();\n\n// Poll for events with timeout\nconst event = try input_handler.pollEvent(100);\n\n// Handle different event types\nif (event) |e| {\n    switch (e) {\n        .key => |key| {\n            // Handle key press\n            if (key.key == 'q' and !key.modifiers.ctrl and !key.modifiers.alt) {\n                // Exit on 'q'\n            }\n        },\n        .mouse => |mouse| {\n            // Handle mouse event\n        },\n        .resize => |resize| {\n            // Handle terminal resize\n        },\n        else => {},\n    }\n}\n```\n\n### Typeahead navigation\n\nList, Table, and FileBrowser widgets accumulate printable keystrokes while focused to jump to the next matching row or entry. The buffer clears on Escape or after `search_timeout_ms` (900ms by default):\n\n```zig\nlist.setTypeaheadTimeout(1_200);\ntable.setTypeaheadTimeout(800);\nbrowser.resetTypeahead(); // helpful after directory changes\n```\n\n### Rendering\n\nThe render module manages screen drawing:\n\n```zig\n// Initialize renderer\nvar renderer = try zit.render.Renderer.init(allocator, width, height);\n\n// Clear the back buffer\nrenderer.back.clear();\n\n// Draw text with color and style\nrenderer.drawStr(\n    x, y, \"Hello, World!\",\n    zit.render.Color{ .named_color = zit.render.NamedColor.bright_white },\n    zit.render.Color{ .named_color = zit.render.NamedColor.blue },\n    zit.render.Style.init(true, false, false) // bold\n);\n\n// Draw a box\nrenderer.drawBox(\n    x, y, width, height,\n    zit.render.BorderStyle.single,\n    zit.render.Color{ .named_color = zit.render.NamedColor.white },\n    zit.render.Color{ .named_color = zit.render.NamedColor.default },\n    zit.render.Style{}\n);\n\n// Render to screen\ntry renderer.render();\n```\n\n### Widgets\n\nThe widget module provides basic UI components:\n\n```zig\n// Create a label\nvar label = try zit.widget.Label.init(allocator, \"Hello, Zit!\");\nlabel.setAlignment(.center);\nlabel.setColor(fg_color, bg_color);\n\n// Create a button\nvar button = try zit.widget.Button.init(allocator, \"Click Me!\");\nbutton.setColors(normal_fg, normal_bg, hover_fg, hover_bg);\nbutton.setBorder(.rounded);\nbutton.setOnPress(onButtonPress);\n\n// Create a checkbox\nvar checkbox = try zit.widget.Checkbox.init(allocator, \"Enable Feature\");\ncheckbox.setColors(normal_fg, normal_bg, checked_fg, checked_bg);\ncheckbox.setOnChange(onCheckboxChange);\n\n// Create a progress bar\nvar progress_bar = try zit.widget.ProgressBar.init(allocator);\nprogress_bar.setValue(30);\nprogress_bar.setShowPercentage(true);\nprogress_bar.setColors(fg, bg, empty_fg, empty_bg);\nprogress_bar.setBorder(.single);\n\n// Create a list\nvar list = try zit.widget.List.init(allocator);\ntry list.addItem(\"Option 1\");\ntry list.addItem(\"Option 2\");\nlist.setSelectedIndex(0);\nlist.setOnSelect(onListSelect);\nlist.setColors(normal_fg, normal_bg, selected_fg, selected_bg);\nlist.setBorder(.single);\n\n// Autocomplete text input\nvar autocomplete = try zit.widget.AutocompleteInput.init(allocator, 64);\ntry autocomplete.setSuggestions(&[_][]const u8{ \"alpha\", \"beta\", \"gamma\" });\n\n// Drop-in charts (bar, line, area)\nvar chart = try zit.widget.Chart.init(allocator);\nchart.setType(.bar);\ntry chart.addSeries(\"Throughput\", &[_]f32{ 1.0, 2.0, 3.5, 4.0 }, null, null);\n\n// Context menu opened at arbitrary coordinates\nvar ctx = try zit.widget.ContextMenu.init(allocator);\ntry ctx.addItem(\"Copy\", true, null);\ntry ctx.addItem(\"Delete\", false, null);\nctx.openAt(10, 4);\n```\n\n## Development\n\nConfigure Git to use the repo's hooks so the pre-commit `zig build` check runs locally:\n\n```bash\ngit config core.hooksPath .githooks\n```\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6431196?u=ceaa977c3dc79127be38b0b6f14cb0ffbf65c437&v=4",
  "releases": [],
  "owner_bio": "Alumnus @ Carnegie Mellon University  \r\nCTFs @pwning and @mmm-team \r\nChallenge Author and Tester @picoCTF \r\nSecurity Research at @cmu-pasta \r\nWorks @cargurus",
  "owner_company": "https://oswalpalash.com",
  "owner_location": "Boston",
  "owner_blog": "https://oswalpalash.com",
  "owner_twitter_username": "oswalpalash",
  "owner_followers": 62,
  "owner_following": 12,
  "owner_created_at": "2014-01-17T16:33:33Z",
  "license": "MIT",
  "category": "library"
}