{
  "name": "obelizmo",
  "owner": "mnemnion",
  "repo": "obelizmo",
  "description": "Markup and print strings to the terminal",
  "type": "package",
  "topics": [
    "ansi",
    "terminal",
    "vt100",
    "xterm",
    "zig",
    "zig-package"
  ],
  "stars": 11,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-11-05T02:06:26Z",
  "dependencies": [
    {
      "name": "ohsnap",
      "url": "https://github.com/mnemnion/ohsnap/archive/refs/tags/v0.4.1.tar.gz",
      "hash": "ohsnap-0.4.1-iWxzyhicAAA90MEnwxA22VshYmsSH3t0dcqM9yib7ose"
    },
    {
      "name": "mvzr",
      "url": "https://github.com/mnemnion/mvzr/archive/refs/tags/v0.3.7.tar.gz",
      "hash": "mvzr-0.3.7-ZSOky5FtAQB2VrFQPNbXHQCFJxWTMAYEK7ljYEaMR6jt"
    },
    {
      "name": "ezcaper",
      "url": "https://github.com/mnemnion/ezcaper/archive/refs/tags/v0.3.0.tar.gz",
      "hash": "ezcaper-0.3.0-kd9_icCWAAAgzriNtlOgV8G5sBmD9nr8mnmo4zFNQQiq"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# Obeli⚡️mo: A String Marking Library\n\nThis library provides a flexible system for marking up text, a practice referred to in ancient days as [Obelism](https://en.wikipedia.org/wiki/Obelism).  A relic of this use is the [obelus](https://en.wikipedia.org/wiki/Obelus), which you know is an oddball word, since in English, it means `÷` or `†`, depending.\n\nThe goal of `obelizmo` is to provide a performant and output-agnostic way to mark up a string, keeping the metadata and the text separate.  A claim like \"output-agnostic\" always has its limits: `obelizmo` in its present state is a capable obelist of ANSI escape sequences and HTML, and the mechanism provided is, perhaps, general enough to accomodate other formats as well.\n\n## Status\n\nThis library is entirely usable at present for its main focus, which is terminal printing.  I'm reasonably happy with the structure of the marked strings, and the collection of methods for marking them is acceptably featureful.  Printing with ANSI/SGR is fully implemented, with proper handling of nested regions and a color builder.  Printing in HTML is... possible, and might be good enough for your purposes.  I have a long-term goal to come up with a really nice solution there, but it wasn't the primary application of interest.\n\n## Install\n\nUsing the Zig build system:\n\n```sh\nzig fetch --save https://www.github.com/mnemnion/obelizmo/archive/refs/tags/v0.1.2.tar.gz\n```\n\nThe package offers two modules, `obezlimo` itself and [colors](#the-colors-module).  Obelizmo works in two stages: marking strings, and printing them.\n\n## Marking Strings\n\nTo use the library, define an `enum` of all the categories of markup you intend to use.  A simple example:\n\n```zig\nconst Colors = enum(u32) {\n    blue,\n    red,\n    yellow,\n    green,\n    teal, // However many you would like\n};\n```\n\nThis enum can be non-exhaustive, and it is valid to assign any number you like to the enums (although using the default order is optimal).  The enum may be smaller or larger than `u32`, but smaller will not save space because of alignment, and larger will bloat the size of marks.\n\nThe enum is provided to `obelizmo.MarkedString(Enum_T)`, which returns a `MarkedString` specialized to that enum.  This is initialized with the string, and an allocator, like so:\n\n```zig\nconst ColorMarker = obelizmo.MarkedString(Colors);\n\nconst a_string_marker = ColorMarker.init(allocator, a_string);\ndefer a_string_marker.deinit();\n\n// Or you can reserve capacity for some number of marks.\nconst another_string_marker = try ColorMarker.initCapacity(allocator, a_string, 8);\ndefer another_string_marker.deinit();\n```\n\nNow you're ready to provide some marks.\n\n## Marking up a MarkedString\n\nA collection of member functions for marking up strings is provided.  Some of these have return values, which you're free to ignore.  Invalid inputs will return errors, as will failure to allocate.\n\nMarks may be provided in any order. They're stored on a [priority queue](https://ziglang.org/documentation/master/std/#std.priority_queue.PriorityQueue), which has predicable and good algorithmic complexity for this purpose.\n\nUsage note: be aware that marks can overlap each other, and this may give undesired results, depending on how you choose to print the marked string.  No attempt is made to correct for this condition, or compensate for it.  Among other reasons, this is because there are real uses for which overlapping marks are correct.  The terminal printer handles this with aplomb, but if you wish to produce valid HTML, you'll need the marks to properly nest.\n\nAlso worth knowing: if you mark a single region repeatedly, the lower-valued enum will print first on entry, and last on exit.\n\n### Direct Marking\n\nThe simplest option is to specify either slice bounds, or an offset and length, to mark.\n\n```zig\ntry string_marker.markSlice(.red, a, b) catch |e| {\n    switch(err) {\n        error.OutOfMemory => |err| return err,\n        error.InvalidRegion => @panic(\".markSlice provided with invalid data\"),\n    }\n};\n\ntry string_marker.markFrom(.blue, a, 7); // Same error set as markSlice\n```\n\n### Find and Mark\n\nAnother way to mark the string is using the find functions, which work like their equivalents in [std.mem](https://ziglang.org/documentation/master/std/#std.mem.indexOf).  These return the starting index if a mark was applied, or `null` otherwise, and can only fail to allocate.\n\n```zig\nconst first_err: usize = try string_marker.findAndMark(.red, \"ERROR:\").?;\n\n_ = try string_marker.findAndMarkPos(.red, \"ERROR:\", first_err + 7);\n\n_ = try string_marker.findAndMarkLast(.yellow, \"line\");\n```\n\n### Match and Mark\n\nThe last way to apply marks is by using an [mvzr Regex](https://github.com/mnemnion/mvzr), or several.  These functions are actually type-generic, so anything which precisely matches the interface and field names used in `mvzr` would suffice.  But so far as I'm aware, that list only includes `mvzr` at the present time.  The main reason for this is that `mvzr` statically allocates Regexen, so the structs themselves are comptime-generic by size.\n\n```zig\nconst number_regex = mvzr.Regex.compile(\"\\\\d+\").?;\nconst index: ?usize = try string_marker.matchAndMark(.teal, number_regex);\nif (index) |i| {\n   _ = try string_marker.matchAndMarkPos(.yellow, number_regex, index.? + 10);\n}\nconst fizz_regex = mvzr.Regex.compile(\"([Ff]izz([Bb]uzz)?)|[Bbuzz])\").?;\nconst did_match: bool = try string_marker.matchAndMarkAll(.teal, fizz_regex);\nif (!did_match) {\n    std.debug.print(\"definitely not fizzbuzz\\n\", .{});\n}\n```\n\nThat's it for marking methods.  If you have some complex structure, like an abstract or concrete syntax tree, you should find it easy to mark up the string using the direct methods, since one of `[start, end]` or `[offset, length]` is generally used to store the span in those structures.  As a reminder, the order of marking doesn't matter, any order will result in the same printed value and will take more-or-less as long to build as any other.  So any convenient approach to iterating such a tree will suit the purpose.\n\n## Removing Marks\n\nA mark may be removed with `string_marker.removeMark(.kind)`.  This removes the first mark of its kind which it encounters, which may not be the first mark in the order of the string.  Anticipated use cases are removing one unique mark of a given kind, or all unique marks of a kind, which may be accomplished by calling the function until it returns `null`.\n\n```zig\nconst removed_mark: ?Mark = string_marker.removeMark(.yellow);\n\nwhile (string_marker.removeMark(.red)) |_| {}\n```\n\nSince `obelizmo` uses a heap to store marks, the `while` loop above is roughly as efficient as it can be at removing all such marks.  While it's possible to remove the first or last mark of a kind as ordered on the string, with a linear search, this is not currently included as it's unlikely to prove useful.\n\n## Printing\n\nOnce your `MarkedString` is marked, you'll probably want to print it to something, or potentially several somethings.  `obelizmo` provides for a couple of approaches to this.\n\nThe simpler printer uses `marked_string.writeAsTree(writer, markups)`, where the second parameter is a `MarkupStringArray`. This is an [EnumArray](https://ziglang.org/documentation/master/std/#std.enums.EnumArray) where the value type is `[2][]const u8`, for the beginning and end of the region marked with a given enum.  Suitably loaded with the right tags, and given that the `MarkedString` has the right shape, this can produce acceptable HTML.\n\nHTML body text needs to be escaped, for which you can use `HTMLEncodedWriter`, wrapping the underlying Writer of your choice.\n\n### Printing A MarkedString to the Terminal\n\nThis use case was the real motivation for this project, and the fully-supported one, so we'll focus there.\n\nThe marks are just marks: a struct holding the provided enum, as well as the boundaries of the text region in `[offset, length]` form.  To print to the terminal, you'll need to create `Color`s, and a `MarkupColorArray`, this is another `EnumArray` where the value is `Color`.\n\nNext, create an `XtermLinePrinter` specialized to the Writer for the terminal.  Initialize with `init` and call `next`:\n\n```zig\nconst xprint = XtermPrinter.init(&marked_string, markup_array, writer);\ndefer xprint.deinit();\n\nwhile (try xprint.next()) |more| {\n    // `more` is true until the final line\n    // Newlines are not printed, for terminal raw-mode reasons,\n    // So this is where you place the cursor where you want it.\n    // When complete, next() will return null.\n}\n```\nForeground, background, and underline colors, are kept on separate stacks, and will restart automatically at the end of any given marked region.  You can keep the `xprint` around for later, and provide a fresh `MarkedString` with `xprint.newText(&marked_string)`.\n\nIt is also possible to drop some amount of the marked text.  The `XtermLinePrinter` will properly track styles, so that, for instance, if printing picks up in the middle of a red italic foreground section, without printing the beginning, that text will be italic and red.  This may be done with `try x_print.seek(n)`, where `n` is greater than the currently printed text (this number is `x_print.cursor`) and less than the length of the marked string.  Alternately, text up to the next newline can be dropped with `x_print.drop`, or any number of lines with `x_print.dropN`.  It is not required that the indicated number of lines still exist to be printed, however, `xprint.next` must be called at least one more time to guarantee that any applied `Color` styles are properly ended.\n\nAnd what is a `Color`, you might fairly ask?\n\n## The `colors` module\n\nObelizmo includes a standalone module, \"colors\", which primarily features `Color`, a union which allows the full proliferation of SGR-compatible text attributes to be created and wielded in an `obelizmo`-friendly manner.  The preferred way to use this module is via the included builder functions, as documented in the container doc comment at `src/color_marks`.\n\n## Fin\n\nThat's Obeli⚡️mo.  Mark a string, print it.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/231785?u=8a0cdeb97b0a614b0350536ecd6921ee6166c611&v=4",
  "releases": [
    {
      "tag_name": "v0.1.2",
      "name": "Zig 0.15 compatibility",
      "body": "This is technically a breaking change, because the `colors` module is no\r\nlonger `usingnamespace`d into `obelizmo`.  Which was never a great idea.",
      "prerelease": false,
      "published_at": "2025-09-29T17:07:31Z",
      "html_url": "https://github.com/mnemnion/obelizmo/releases/tag/v0.1.2",
      "assets": []
    },
    {
      "tag_name": "v0.1.1",
      "name": "Tests update",
      "body": "This restores the [snapshot tests](https://github.com/mnemnion/ohsnap) to a functional state, and removes the 'eyeball tests', which are now also snapshots.\r\n\r\nNo behavior has changed in the modules, this update is tests only.",
      "prerelease": false,
      "published_at": "2025-04-25T16:42:58Z",
      "html_url": "https://github.com/mnemnion/obelizmo/releases/tag/v0.1.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "Initial Release",
      "body": "Core functionality for string marking and terminal printing written and tested.  Minimal HTML printing also possible.",
      "prerelease": false,
      "published_at": "2025-04-15T00:45:47Z",
      "html_url": "https://github.com/mnemnion/obelizmo/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Eastern Standard Tribe",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 91,
  "owner_following": 24,
  "owner_created_at": "2010-03-27T23:31:39Z",
  "license": "MIT",
  "category": "library"
}