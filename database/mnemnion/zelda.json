{
  "name": "zelda",
  "owner": "mnemnion",
  "repo": "zelda",
  "description": "Type-safe intrusive linked lists for Zig",
  "type": "package",
  "topics": [
    "linked-list",
    "mergesort",
    "nintendo",
    "zig",
    "zig-package"
  ],
  "stars": 9,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-01-05T20:29:49Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# Zelda: Type Safe Intrusive Linked Lists\n\nZelda is a Zig mixin library for intrusive linked lists.  A linked list\nis 'intrusive' when the pointer or pointers which comprise the list\nare fields directly on the data structure, rather than the \"textbook\"\napproach of pairing a pointer to the data with a pointer or pointers\ncomprising the list.  Since intrusive lists take up less memory, and\nneed fewer pointer chases to make use of them, they are nearly always\nwhat you want.\n\nThe Zig standard library already provides [SinglyLinkedList][sll]\nand [DoublyLinkedList][dll], which, since `0.14`, are implemented\nintrusively.  These are implemented as concrete types, meaning every\nlist and every `Node` is of one single type.  User code is expected to\nensure that everything linked into the list is of a common type, and\nuse the `@fieldParentPtr` builtin to retrieve the base address of the\nintruded structs, or at least, what should be the base address.\n\nZelda is an alternative to this: given an appropriately-structured\nstruct type, endow it with a rich collection of list operations,\nand construct a list type unique to that struct.  Originally taking\nadvantage of `usingnamespace`, this is no longer possible, and was\nalways a rather blunt instrument.\n\nNow, we use the zero-width field hack.  Ungainly, perhaps, but\neffective, precise, and at no runtime cost relative to adding methods to\nthe struct directly.\n\nThe lists in the standard library embody a minimalist philosophy, those\nin Zelda a maximalist one.  On top of a kitchen-sink collection of every\nlist operation which seemed plausibly useful, when given an ordering\nfunction, Zelda offers ordered operations on lists as well.\n\n[sll]: https://ziglang.org/documentation/0.15.2/std/#std.SinglyLinkedList\n[dll]: https://ziglang.org/documentation/master/std/#std.DoublyLinkedList\n\n## Link's Awakening\n\nTo use `zelda`, presuming you've added it to the build system, do the\nfollowing:\n\n```zig\n// It's dangerous to go alone! Take this!\nconst zelda = @import(\"zelda\");\n\nconst Monster = struct {\n    kind: MonsterKind,\n    mana: u16,\n    health: u16,\n    // ...\n    next: ?*@This() = null,\n    previous: ?*@This() = null,\n    link: Link = .{}, // What's a Link?\n\n    // This is a Link:\n    pub const Link = zelda.aLinkBetweenWorlds(@This());\n    // This is a (doubly) linked list\n    pub const List = Link.List;\n\n    // That's the magic version, we'll peek behind the curtain forthwith.\n```\n\nThis makes various linked-list operations available by calling, for\ninstance, `monster.link.unlinkForward()`.  The type and field names, of\ncourse, are entirely up to you.  This, too, uses `@fieldParentPtr`, but\nwith type safety: each `Link` is specialized to the type it belongs to,\nand comptime wizardry is used to do the field parent pointer-ing within\ncalls off the zero-width `.link` field.  This is, adequate.  Perhaps not\nelegant, but eloquent enough.  It does simplify the organization of a\nstruct bearing more than one list structure, which does occur from time\nto time.\n\nUsing `aLinkBetweenWorlds`, Zelda will infer the structure and\ncapabilities of your list.  The first `?*T` field encountered will be\nconsidered \"forward\", the second \"backward\".  If it sees a declaration\n`zeldaOrderFn`, it will try to use this as an ordering function to\nprovide numerous facilities, which, if the declaration is appropriate,\nwill succeed.\n\nIf this specific organization is not suitable, or should you find\nyourself in a less than whimsical mood, these may be specified manually\nusing `zelda.doublyLinkedList`.  Currently, any ordering function must\nbe supplied as a string naming a public declaration, I may make it\npossible to provide this as a function (rather than the declared name of\none) at some later point.\n\nThere is nothing stopping you from creating several of these exotic\nzero-width fields, to handle multiple pairs of links or, more likely,\nmore than one sorting regimen.  You could even handle three link fields\nwith two mixins, if you felt the urge to make your own life difficult in\nthat way.\n\nSay you prefer, as indeed you might, a _singly_ linked list?  We have\nthat as well!\n\n> It's yours, my friend, as long as you have enough rupees.\n\n```zig\nconst Chunk64 = struct {\n    data: [64]u8 = undefined;\n    next_free: ?*@This() = null,\n    call_me_whatever: Link = .{}, // zelda don't care\n\n    pub const Link = zelda.aLinkToThePast(@This());\n    pub const List = Link.List;\n\n    // What if you have more than one link though?  For that,\n    // we have zelda.singlyLinkedList.\n};\n```\n\nNow your `Chunk64` will do single-linked node things, and has\n`Chunk64.List` to manage your freelist.\n\nThe first edition of Zelda closely followed the API of the standard\nlibrary, providing a superset of functionality, but with some semantic\ndifferences.  This time we follow our own logic: functions carry the\nsame name when it makes sense (and occasionally when it does not),\nbut by no means always, and we employ our own consistent semantics of\ninvariance which differs from that used by `std`.\n\nBut first, the no-magic approach to Zelda mixins.\n\n### The Shirt and Tie API\n\nFor maximum control, and incrementally less fun, we have\n\n#### zelda.singlyLinkedList(T: type, next: anytype, m_orderFn: ?[]const u8)\n\nThe type, the name of the link field, and a name for an ordering function,\nif you care to provide one.  `aLinkToThePast` figures that stuff out for you,\nbut you have to name your function `zeldaOrderFn`.\n\nIt should return a `zelda.Order`, this is like [`std.math.Order`][smo] but\nit generates good machine code.  Zelda doesn't check this, so you can\nuse the other one, or something even harder to optimize, so long as it\nreturns `.lt`, `.eq`, and `.gt`, in a manner which leaves you happy with\nthe resulting stable ordering.  Oh, and declare it `inline`, every little\nbit helps (this is recommended, not mandatory).\n\n[smo]: https://ziglang.org/documentation/0.15.2/std/#std.math.Order\n\n#### zelda.doublyLinkedList(T: type, next: anytype, prev: anytype, m_orderFn: ?[]const u8)\n\nSame deal.  The `anytypes` let you use an enum literal, which I\nencourage, as there is talk of making `@field` take a \"field enum\",\nwhich should require no changes to code which prefers `.next_free` over\n`\"next_free\"`.\n\nYou are encouraged to peruse the source, or build the docs, in order\nto pick up on what all these lists have built in.  Specifically, the\ninvariants documented in the doc comments of both `List` types are\nimportant for reasoning about Zelda operations, and ensuring that\n'manual' actions from userspace uphold the expectations there listed.\n\n## Order, Lists, and Ordered Lists\n\nA fairly recent modern doctrine emphasizes arrays over anything which\nuses a pointer.  Linked lists are often the target of this sort of\ncritique, and it is indeed true that, in isolation, much of what one can\ndo with a linked list will benchmark faster if something similar is done\nwith an array instead.\n\nWhile an array may be faster, this does not make linked lists slow, and\nthey are unmatched for flexibility.  They also give an often-useful\nproperty of _stability_, in that no operation on a list will ever lose\na reference to an element of that list.  A direct reference, I mean.\nAn indirect reference... that's a different story.\n\nThey should be considered as complementary to arrays, rather than\ncompetitive with them.  Even if your application has gone full\nstruct-of-arrays, there are many tasks which are optimally accomplished\nwith linked lists of indices into your arrays.  Freelists, for example,\nare called that for a reason.\n\nI recently translated the Lemon parser [into Zig][zitron], and let me\ntell you, Lemon uses linked lists for absolutely everything.  It even,\nat several points, uses an `O(n²)` algorithm on these linked lists!\n\nLemon is _astonishingly_ fast, as is (therefore) Zitron.  It parses,\nanalyzes, compresses, and emits a parser of substantial complexity\nin a matter of milliseconds.  While I'm at it, no one seems to have\ntold kernel hackers[^1] that linked lists are busted and slow, since\noperating systems are postively lousy with them.\n\nZelda provides merge sort.  It's a pretty good sort!  It's stable,\nit takes a sliver of constant space on the stack, has the optimal\nworst-case sort time of `Θ(n log n)`, and sorts an already-sorted list\nin `Θ(n)`.  It can't be pessimized with attacker-controlled input\neither.\n\nSo don't be afraid to cons up a list, sort it, maybe sorted-insert a few\nstragglers.  While an amount of data exists where you would feel the\ndifference, it's more than you might think it is.\n\nA notable difference between Zig-standard `SinglyLinkedList` and the\nZelda version, is that the Zelda-provided `List` type retains the tail,\nas well as just the head, of the list.  There's nothing you can do with\na stdlib `SinglyLinkedList` which you can't do just with a node of a\nZelda list, and plenty you can do which the stdlib doesn't.\n\nSo why not provide a data structure which: supports `O(1)` prepend\n_and_ append, concatenation in `O(1)`, which can be `O(1)` loaded onto a\nfreelist, and so on?  Why not indeed.  It costs you an extra pointer, I\nsuppose.  Sometimes that isn't acceptable, in which case, just hold on\nto the head.\n\n[zitron]: https://github.com/mnemnion/zitron/\n[^1]: I'm sure this is not actually true, the Internet being what it is.\nFortunately they don't listen, and you shouldn't either!\n\n### Finding and Filtering\n\nDoubly-linked lists have a `Matcher` type, this is a type erased\n`?*anyopaque` paired with a pointer to a match function, which takes\nyour node type and returns a `bool`.  By creating one of these your code\ngains access to a collection of finding and find-remove operations, the\napotheosis of which is filter.\n\nFilter is a canonical example of what makes linked lists powerful.  In\none pass, we separate what we want from the rest of what we have, with\nno need to allocate scrach space or move anything around.  Pretty nice.\n\nA later release is likely to extend this privilege to singly-linked\nlists as well, but I'm running out of time to spare on buffing linked\nlists.  For now.\n\n### ZELDA_SEEK_LIMIT\n\nIf your type defines a numeric value for `ZELDA_SEEK_LIMIT`, any\niteration which does more cycles than that limit will panic the program.\n\nIt is legal, but discouraged, to use the style-guide-approved form\n`zelda_seek_limit`.  It is the intention of this library that all loops\nused will terminate if a seek limit is declared, after no less than the\nindicated number of iterations[^2].\n\nShould you wish to make this build-configurable, arrange for the seek\nlimit to be of type `@TypeOf(null)` and it will be disabled.  Note that\nthis is subtly different from a `?usize` which happens to have the\n_value_ `null`:\n\n```zig\n    // Not just opts.limit, but:\n    pub const ZELDA_SEEK_LIMIT = if (opts.limit) |l| l else null;\n```\n\n[^2]: When practical and efficient, it will permit no more than the\nindicated number of iterations as well.  Which it usually is, but not\nalways.  Note that user-level iterations, particularly those using\nthe `Taker` iterators, _can_ get trapped in cycles and should use the\niteration limit directly.\n\n## Cool, How'd You Do It?\n\n```sh\n➜  rg -F --count-matches '@field' -- src/zelda.zig\n268\n```\n\nUp from 95 in the last release.\n\n### Alright! Let's Copypasta This Bad Boy!\n\nHave at it:\n```sh\nzig fetch --save https://github.com/mnemnion/zelda/archive/refs/tags/v0.2.0.tar.gz\n```\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/231785?u=8a0cdeb97b0a614b0350536ecd6921ee6166c611&v=4",
  "releases": [
    {
      "tag_name": "v0.2.0",
      "name": "Zelda II: The Adventure of Link",
      "body": "Now Zig 0.15.2 compatible, and much enhanced, with\r\nsorting, filter, and a few other bells and whistles.",
      "prerelease": false,
      "published_at": "2026-01-05T15:47:41Z",
      "html_url": "https://github.com/mnemnion/zelda/releases/tag/v0.2.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Eastern Standard Tribe",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 93,
  "owner_following": 24,
  "owner_created_at": "2010-03-27T23:31:39Z",
  "category": "library"
}