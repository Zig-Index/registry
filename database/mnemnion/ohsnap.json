{
  "name": "ohsnap",
  "owner": "mnemnion",
  "repo": "ohsnap",
  "description": "Oh Snap! Easy Snapshot Testing for Zig",
  "type": "project",
  "topics": [
    "snapshot-testing",
    "test",
    "testing-library",
    "unit-test",
    "zig",
    "zig-package"
  ],
  "stars": 65,
  "forks": 5,
  "watchers": 2,
  "updated_at": "2025-12-04T01:35:59Z",
  "dependencies": [
    {
      "name": "mvzr",
      "url": "https://github.com/mnemnion/mvzr/archive/refs/tags/v0.3.7.tar.gz",
      "hash": "mvzr-0.3.7-ZSOky5FtAQB2VrFQPNbXHQCFJxWTMAYEK7ljYEaMR6jt"
    },
    {
      "name": "pretty",
      "url": "https://github.com/timfayz/pretty/archive/refs/heads/main.tar.gz",
      "hash": "pretty-0.10.4-Tm65r5pKAQDdxCFNtL6huo7lHc_HWn6v4VO5WaTufpRQ"
    },
    {
      "name": "muad_diff",
      "url": "https://github.com/mnemnion/muad-diff/archive/refs/tags/ohsnap-prerelease-02.tar.gz",
      "hash": "muad_diff-0.0.1-p0-XoRGIAwBmN7XLmC4Z6Sj7mqeiUaZvwoisN1hXF81b"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# Oh Snap! Easy Snapshot Testing for Zig\n\nIt's hard to know if a program, or part of one, actually works.  But it's easy to know if it doesn't: if there isn't a test for some part of the program, then that part doesn't work.\n\n[Snapshot testing](https://tigerbeetle.com/blog/2024-05-14-snapshot-testing-for-the-masses) is a great way to get fast coverage for _data invariants_ in a program or library.  The article I just linked to goes into great detail about the advantages of snapshot testing, and you should read it.\n\n`ohsnap` is a Zig library for doing snapshot testing, one which is, in fact, based on the [TigerBeetle library](https://github.com/tigerbeetle/tigerbeetle/blob/main/src/testing/snaptest.zig) used in that post.\n\nIt includes some features not found in the original. TigerBeetle has a no-dependencies policy, and I'm confident that what they have serves their needs just fine.  But a library like this is a dependency by definition, and I didn't mind adding a couple more.\n\nLet me show you its features!\n\n## Installation\n\nThe best way to use `ohsnap` is to install it using the [Zig Build System](https://ziglang.org/learn/build-system/).  From your project repo root, use `zig fetch` like this:\n\n```sh\nzig fetch --save \"https://github.com/mnemnion/ohsnap/archive/refs/tags/v0.4.1.tar.gz\"\n```\n\nThen add it to your test artifact like so:\n\n```zig\n    if (b.lazyDependency(\"ohsnap\", .{\n        .target = target,\n        .optimize = optimize,\n    })) |ohsnap_dep| {\n        lib_unit_tests.root_module.addImport(\"ohsnap\", ohsnap_dep.module(\"ohsnap\"));\n    }\n```\n\nThat should be it!  Now you're ready to write some snaps!\n\n## Using `ohsnap`\n\nThe interface will be familiar if you read the linked blog post, which, really, you should.\n\nOne difference between `ohsnap` and the original, is that `ohsnap` includes [pretty](https://github.com/timfayz/pretty), a clever pretty-printer for arbitrary data structures.  So you don't need to write a custom `.format` method to use `ohsnap`, although if you have one, you can use that instead.  Or both.  Belt and suspenders kinda thing.\n\nWriting a snap is simple, to get started, do something like this:\n\n```zig\nconst OhSnap = @import(\"ohsnap\");\n\ntest \"snap something\" {\n    const oh = OhSnap{};\n    // You can configure `pretty` by using `var oh` and changing settings\n    // in `oh.pretty_options`.\n    const snap_me = someFn();\n    try oh.snap(@src(),\n        \\\\\n        ,\n    ).expectEqual(snap_me);\n}\n```\n\nNote that the call to `@src()` has to be directly above the string, and the string has to be multi-line style, with the double backslashes: `\\\\`.  Both this:\n\n```zig\ntry oh.snap(@src(),\n    \\\\ etc\n    ,).expectEqual(snap_me);\n```\n\nAnd this:\n\n```zig\ntry oh.snap(\n    @src(),\n    \\\\ etc\n  ,).expectEqual(snap_me);\n```\n\nWill work just fine.\n\nThis test will fail, because the snapshot generated by `pretty` won't be equal to the empty string.  `ohsnap` will diff that empty string with what it gets out of `snap_me`, and print what it got in all-green, because that's what happens when you diff an empty string against a string which isn't empty.\n\nIf you like what you see, updating is simple.  Change the file to the following:\n\n```zig\nconst OhSnap = @import(\"ohsnap\");\n\ntest \"snap something\" {\n    const oh = OhSnap{};\n    // You can configure `pretty` by using `var oh` and changing settings\n    // in `oh.pretty_options`.\n    const snap_me = someFn();\n    try oh.snap(@src(),\n    \\\\<!update>\n    ,\n    ).expectEqual(snap_me);\n}\n```\n\nThe snaptest will see the `<!update>`, which must be the beginning of the string, and replace it in your file with the output of the pretty printing.  Easy!\n\nIf your data structure has a `.format` method, and you'd prefer to use that as a basis, simply use `.expectEqualFmt` instead of `.expectEqual`.\n\nIf, down the road, the snapshot doesn't compare to the expected string, `ohsnap` will use [diffz](https://github.com/mnemnion/diffz/tree/more-port)[^1], a Zig port of [diff-match-patch](https://github.com/google/diff-match-patch), to produce a terminal-colored character-level diff of the expected string with the actual string, making it easy to see exactly what's changed.  These changes are either a bug, or a new feature.  If it's the former, fix it, if it's the latter, just add `<!update>` to the head of the string again, and `ohsnap` will oblige.\n\n## Pattern-Matching Snapshots\n\nThis is fine and dandy, if the data structure, exactly as it prints, will always be the same on every test run.  But what if that's only true of some of the data?\n\nConsider this example.  We have a struct which looks like this:\n\n```zig\nconst StampedStruct = struct {\n    message: []const u8,\n    tag: u64,\n    timestamp: isize,\n    pub fn init(msg: []const u8, tag: u64) StampedStruct {\n        return StampedStruct{\n            .message = msg,\n            .tag = tag,\n            .timestamp = std.time.timestamp(),\n        };\n    }\n};\n```\n\nWhich we want to snapshot test, like this:\n\n```zig\ntest \"snap with timestamp\" {\n    const oh = OhSnap{};\n    const with_stamp = StampedStruct.init(\n        \"frobnicate the turbo-encabulator\",\n        31337,\n    );\n    try oh.snap(\n        @src(),\n        \\\\ohsnap.StampedStruct\n        \\\\  .message: []const u8\n        \\\\    \"frobnicate the turbo-encabulator\"\n        \\\\  .tag: u64 = 31337\n        \\\\  .timestamp: isize = 1721501316\n        ,\n    ).expectEqual(with_stamp);\n}\n```\n\nBut of course, the next time we run the test, the timestamp will be different, so the test will fail.  We care about the message and the tag, we care that there _is_ a timestamp, but we don't care what the timestamp is, because we know it will be changing.\n\nFor cases like this, `ohsnap` includes [mvzr](https://github.com/mnemnion/mvzr), the Minimum Viable Zig Regex library, which I wrote specifically for this purpose.\n\nSimply replace the timestamp like so:\n\n```zig\n    try oh.snap(\n        @src(),\n        \\\\ohsnap.StampedStruct\n        \\\\  .message: []const u8\n        \\\\    \"frobnicate the turbo-encabulator\"\n        \\\\  .tag: u64 = 31337\n        \\\\  .timestamp: isize = <^\\d+$>\n        ,\n    ).expectEqual(with_stamp);\n```\n\nThrough the magic of diffing, `ohsnap` will identify the part of the new string which matches `<^\\d+$>`, and try to match the regular expression against that part of the string.  Since this matches, the test now passes.\n\nNote that the regex must be in the form `<^.+?$>` (the exact regex we use is `<\\^[^\\n]+?\\$>`, in fact), the `^` and `$` are essential and are load-bearing parts of the expression.  This prevents partial matches, as well as making the regex portions of a snapshot test easier for `ohsnap` to find.  Note that because this is a multi-line string, you don't have to do double-backslashes: its `<^\\d+$>`, not `<^\\\\d+$>`.  To be very clear, the `<` and `>` demarcate the regex, they aren't part of it.\n\nLet's say you make a change:\n\n```zig\n    const with_stamp = StampedStruct.init(\n        \"thoroughly frobnicate the encabulator\",\n        31337,\n    );\n```\n\nThe test will now fail: the word \"thoroughly\" will be highlighted in green, `turbo-` will be marked in red, and the timestamp will be cyan, indicating that the regex is still matching the pattern string.  If a change in the test data means that the regex no longer matches, then the part of the test string which should match is highlighted in magenta.\n\nSince this was an intentional change, we need to update the snap:\n\n```zig\n    try oh.snap(\n        @src(),\n        \\\\<!update>\n        \\\\ohsnap.StampedStruct\n        \\\\  .message: []const u8\n        \\\\    \"frobnicate the turbo-encabulator\"\n        \\\\  .tag: u64 = 31337\n        \\\\  .timestamp: isize = <^\\d+$>\n        ,\n    ).expectEqual(with_stamp);\n```\n\nOnce again, through the magic of diffing, `ohsnap` will locate the regexen in the old string, and patch them over the new one.\n\n```zig\n    try oh.snap(\n        @src(),\n        \\\\ohsnap.StampedStruct\n        \\\\  .message: []const u8\n        \\\\    \"thoroughly frobnicate the encabulator\"\n        \\\\  .tag: u64 = 31337\n        \\\\  .timestamp: isize = <^\\d+$>\n        ,\n    ).expectEqual(with_stamp);\n```\n\nVoila!\n\nUsage note: in some cases, the changes to the new string will displace the regex, you can tell because some part of the regex itself will be exposed in red.  When that happens, the update may not apply correctly either: the regex will always be moved to the new string intact, but it may or may not be in the correct place (usually, not).  This can generally be fixed by making changes to the expected-value string until whatever part of the regex was sticking out of the diff is no longer exposed.  Sometimes running `<!update>` twice will fix it as well.\n\n## Developing With Snapshots\n\nWhen we're programming, there are always points in the process where a data structure is in flux, and `ohsnap` can help you out with that as well.  Instead of `.expectEqual(var)`, use `.show(var)`, or `.showFmt(var)`.  This will print the snapshot, whether it diffs or not, and it doesn't count as a test.  `<!update>` continues to work in the same way, but an updated `.show` snapshot counts as a failed test.  The update logic is fairly simple, and updating often changes the line numbering of the file, so this helps update one at a time.  Note that you can add the `<!update>` string to any number of snapshots, and just keep recompiling the test suite until they all pass.  Also, if `ohsnap` can't find the snapshot because it moved, nothing untoward will happen, it will just report a failed test, and running it again will fix the problem if it was caused by a previous update.\n\nThis also works as a minimalist way to regress a snapshot test, when you aren't sure what the final value will be.\n\nWhenever you're satisfied with the output, just change `.show` to its `.expect` cousin, and now you've got a test.\n\n## Unusual Directory Structures\n\nZig 0.14 changed some values in `SourceLocation`, which is returned by `@src()`.  In particular, the filenames are now relative to the module root file's directory, not the repository root directory.\n\nThis has required some changes to `ohsnap`.  In the majority of cases, a module is rooted in the `/src` directory, and in those cases, nothing further needs to be done.  The library will make that assumption and updates will proceed on that basis.\n\nHowever, in the event that a test module is rooted in some other directory, or even that there are several test modules rooted in several distinct directories, `ohsnap` must be configured to find those directories given those roots.\n\nThe most satisfactory solution I was able to work out is two options, `module_name` and `root_directory`.  Both have the type `[]const []const u8`.\n\nGiven a test called `\"root\"` in the directory `/test`, `ohsnap` can be passed those values like so:\n\n```sh\n> zig build test -Dmodule_name=root -Droot_directory=test\n```\nIn this case, updating a snapshot will look for files in `root` in the directory `./test`.  If `module_name` doesn't contain the name of the module, this will still fall back to `./src`.\n\nThis can be repeated for as many test modules and associated directories as is needed.  You can find what the build system names a module by adding a test like this to that module:\n\n```zig\ntest \"print module name\" {\n    std.debug.print(\"module name is {s}\\n\", .{@src.module});\n}\n```\n\nThis will only change if certain changes to the build script take place, so there's no need to leave the test running once the name is obtained.\n\nThese values can be provided from the build script as well, like so:\n\n```zig\nif b.lazyDependency(\"ohsnap\", .{\n    .target = target,\n    .optimize = optimize, // etc\n    module_name = .{ \"root\", \"root1\"},\n    root_directory = .{ \"test\", \"src/subdir\"},\n}) |ohsnap_mod| {\n    // Module imported in the usual fashion\n     lib_unit_tests.root_module.addImport(\"ohsnap\", ohsnap_dep.module(\"ohsnap\"));\n     lib_submodule_unit_tests.root_module.addImport(\"ohsnap\", ohsnap_dep.module(\"ohsnap\"));\n}\n```\nThis solution is not perfectly satisfactory, but it retains the generality of the library with a minimum of fussing about.  I hope subsequent work on Zig will restore the ability to reliably open a file, given the return value of `@src()`, in some fashion.\n\n## That's It!\n\nOne of the great advantages of snapshot testing is that it's easy, so `ohsnap`, like the library it's based upon, is intentionally quite simple.  Simple, yet versatile, the latter to a large degree is owed to `pretty`, which can handle anything I've thrown at it, types, unions, you name it.\n\nIt's a new library, but I expect the core interface to remain stable.  It's meant to do one thing, well, and otherwise stay out of the way.  I'm willing to consider suggestions for ways to make `ohsnap` better at what it already does, however.\n\nThat said, the regex library `mvzr` is pretty new, and so is the added code in `diffz`, so version-bumps to fix any bugs in those can be expected over time.  The build system doesn't currently do update checks, so you'll need to check for updates manually, for now.\n\nI hope you enjoy it! Test early, test often, and do it the easy way.\n\n[^1]: The link is to a fork of the library which has the necessary changes for terminal printing.  That branch is in code review, and these things take time. `ohsnap` will be updated to fetch from the [main repo](https://github.com/ziglibs/diffz) when that's possible.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/231785?u=8a0cdeb97b0a614b0350536ecd6921ee6166c611&v=4",
  "releases": [
    {
      "tag_name": "v0.4.1",
      "name": "Zig 0.15 compatibility",
      "body": "No changes to the interface for this release.  You may need to update snaps due to cosmetic changes in `pretty` since the last one.",
      "prerelease": false,
      "published_at": "2025-09-28T15:03:14Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.4.1",
      "assets": []
    },
    {
      "tag_name": "v0.4.0",
      "name": "Zig 0.14 compatibility",
      "body": "This updates `ohsnap` to be compatible with Zig v0.14.  This required adding some options to handle cases where a test module is not rooted in the `/src` directory.",
      "prerelease": false,
      "published_at": "2025-03-28T17:45:15Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.4.0",
      "assets": []
    },
    {
      "tag_name": "v0.3.1",
      "name": "Dependency bump: Pretty v0.10.4",
      "body": "This adds `'c'`haracter-style printing for any `u21` as a default.  As with all [pretty](https://github.com/timfayz/pretty) options, this can be changed by assigning a field in `oh.pretty_options`.",
      "prerelease": false,
      "published_at": "2024-08-23T15:23:06Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.3.1",
      "assets": []
    },
    {
      "tag_name": "v0.3.0",
      "name": "API refactor",
      "body": "This version changes interaction with `ohsnap`.  Now snapshots are only created with `oh.snap`, and the choice of `pretty` or `.fmt` is made by using `.expectEqual` or `.expectEqualFmt`.\r\n\r\nThis also adds `.show` and `.showFmt`, which print the snapshot or diff without treating them as a test.\r\n\r\nFurther API changes are considered unlikely, and no further features are planned.  That leaves dependency updates, which will continue indefinitely. ",
      "prerelease": false,
      "published_at": "2024-08-06T18:15:17Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v0.2.2",
      "name": "Bugfix for stack overflow in diff code",
      "body": "That's it, that's the release.",
      "prerelease": false,
      "published_at": "2024-08-06T00:45:36Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.2.2",
      "assets": []
    },
    {
      "tag_name": "v0.2.1",
      "name": "Dependency update",
      "body": "No changes to `ohsnap` proper.",
      "prerelease": false,
      "published_at": "2024-08-05T16:31:01Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.2.1",
      "assets": []
    },
    {
      "tag_name": "v0.2.0",
      "name": "Usability Improvements",
      "body": "By which I mean, the module build now includes the dependencies, making it er. Usable.",
      "prerelease": false,
      "published_at": "2024-08-04T21:32:20Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.2",
      "name": "Switch to use of splitScalar",
      "body": "This will become necessary in 0.14.0, and is backward compatible as far\r\nas 0.12.0, which is far enough.  It may be further than that, for all I\r\nknow.",
      "prerelease": false,
      "published_at": "2024-08-04T16:27:56Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.1.2",
      "assets": []
    },
    {
      "tag_name": "v0.1.1",
      "name": "Better regex handling",
      "body": "The regex-which-finds-regex now limits its search to a single line of the test string.\r\n\r\nAlso, the use/mention distinction is resolved in the following way: if the regex pattern is already identical to the string, we accept that as a match.  This proved to be useful in `ohsnap`'s test suite, and is clearly correct behavior: the regexen are for excluding differences between the test string and the result string, and if the regex itself is not such a difference, there's nothing to exclude.",
      "prerelease": false,
      "published_at": "2024-07-22T23:01:15Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.1.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "Initial Release",
      "body": "Implements a basic, but featureful, snapshot testing library.  ",
      "prerelease": false,
      "published_at": "2024-07-20T20:32:11Z",
      "html_url": "https://github.com/mnemnion/ohsnap/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Eastern Standard Tribe",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 90,
  "owner_following": 24,
  "owner_created_at": "2010-03-27T23:31:39Z",
  "license": "MIT",
  "category": "library"
}