{
  "name": "http.zig",
  "owner": "karlseguin",
  "repo": "http.zig",
  "description": "An HTTP/1.1 server for zig",
  "type": "package",
  "topics": [
    "http-server",
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 1387,
  "forks": 99,
  "watchers": 13,
  "updated_at": "2026-02-26T10:01:13Z",
  "dependencies": [
    {
      "name": "metrics",
      "url": "https://github.com/karlseguin/metrics.zig/archive/603954879849c331a26529b88254770089acac8b.tar.gz",
      "hash": "metrics-0.0.0-W7G4eP2_AQAdJGKMonHeZFaY4oU4ZXPFFTqFCFXItX3O"
    },
    {
      "name": "websocket",
      "url": "https://github.com/karlseguin/websocket.zig/archive/4deaaef2b4475a63f19c5e2f43e38fd55464b118.tar.gz",
      "hash": "websocket-0.1.0-ZPISdZJxAwAt6Ys_JpoHQQV3NpWCof_N9Jg-Ul2g7OoV"
    },
    {
      "name": "websocket",
      "url": "../websocket.zig"
    }
  ],
  "readme": "# An HTTP/1.1 server for Zig.\n\n```zig\nconst std = @import(\"std\");\nconst httpz = @import(\"httpz\");\n\npub fn main() !void {\n  var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n  const allocator = gpa.allocator();\n\n  // More advance cases will use a custom \"Handler\" instead of \"void\".\n  // The last parameter is our handler instance, since we have a \"void\"\n  // handler, we passed a void ({}) value.\n  var server = try httpz.Server(void).init(allocator, .{.address = .localhost(5882)}, {});\n  defer {\n    // clean shutdown, finishes serving any live request\n    server.stop();\n    server.deinit();\n  }\n\n  var router = try server.router(.{});\n  router.get(\"/api/user/:id\", getUser, .{});\n\n  // blocks\n  try server.listen();\n}\n\nfn getUser(req: *httpz.Request, res: *httpz.Response) !void {\n  res.status = 200;\n  try res.json(.{.id = req.param(\"id\").?, .name = \"Teg\"}, .{});\n}\n```\n\n# Table of Contents\n\n- [Examples](#examples)\n- [Installation](#installation)\n- [Alternatives](#alternatives)\n- [Handler](#handler)\n  - [Custom Dispatch](#custom-dispatch)\n  - [Per-Request Context](#per-request-context)\n  - [Custom Not Found](#not-found)\n  - [Custom Error Handler](#error-handler)\n  - [Dispatch Takeover](#takover)\n- [Memory And Arenas](#memory-and-arenas)\n- [httpz.Request](#httpzrequest)\n- [httpz.Response](#httpzresponse)\n- [Router](#router)\n- [Middlewares](#middlewares)\n- [Configuration](#configuration)\n- [Metrics](#metrics)\n- [Testing](#testing)\n- [HTTP Compliance](#http-compliance)\n- [Server Side Events](#server-side-events)\n- [Websocket](#websocket)\n\n# Versions\n\nThe `master` branch targets the latest stable of Zig (0.15.1). The `dev` branch targets the latest version of Zig. If you're looking for an older version, look for an zig-X.YZ branches.\n\n# Examples\n\nSee the [examples](https://github.com/karlseguin/http.zig/tree/master/examples) folder for examples. If you clone this repository, you can run `zig build example_#` to run a specific example:\n\n```bash\n$ zig build example_1\nlistening http://localhost:8800/\n```\n\n# Installation\n\n1. Add http.zig as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save \"git+https://github.com/karlseguin/http.zig#master\"\n```\n\n2. In your `build.zig`, add the `httpz` module as a dependency to your program:\n\n```zig\nconst httpz = b.dependency(\"httpz\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"httpz\", httpz.module(\"httpz\"));\n```\n\nThe library tracks Zig master. If you're using a specific version of Zig, use the appropriate branch.\n\n# Alternatives\n\nIf you're looking for a higher level web framework with more included functionality, consider [JetZig](https://www.jetzig.dev/) or [Tokamak](https://github.com/cztomsik/tokamak) which are built on top of httpz.\n\n## Why not std.http.Server\n\n`std.http.Server` is very slow and assumes well-behaved clients.\n\nThere are many Zig HTTP server implementations. Most wrap `std.http.Server` and tend to be slow. Benchmark it, you'll see. A few wrap C libraries and are faster (though some of these are slow too!).\n\nhttp.zig is written in Zig, without using `std.http.Server`. On an M2, a basic request can hit 140K requests per seconds.\n\n# Handler\n\nWhen a non-void Handler is used, the value given to `Server(H).init` is passed to every action. This is how application-specific data can be passed into your actions.\n\nFor example, using [pg.zig](https://github.com/karlseguin/pg.zig), we can make a database connection pool available to each action:\n\n```zig\nconst pg = @import(\"pg\");\nconst std = @import(\"std\");\nconst httpz = @import(\"httpz\");\n\npub fn main() !void {\n  var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n  const allocator = gpa.allocator();\n\n  var db = try pg.Pool.init(allocator, .{\n    .connect = .{ .port = 5432, .host = \"localhost\"},\n    .auth = .{.username = \"user\", .database = \"db\", .password = \"pass\"}\n  });\n  defer db.deinit();\n\n  var app = App{\n    .db = db,\n  };\n\n  var server = try httpz.Server(*App).init(allocator, .{.address = .localhost(5882)}, &app);\n  var router = try server.router(.{});\n  router.get(\"/api/user/:id\", getUser, .{});\n  try server.listen();\n}\n\nconst App = struct {\n    db: *pg.Pool,\n};\n\nfn getUser(app: *App, req: *httpz.Request, res: *httpz.Response) !void {\n  const user_id = req.param(\"id\").?;\n\n  var row = try app.db.row(\"select name from users where id = $1\", .{user_id}) orelse {\n    res.status = 404;\n    res.body = \"Not found\";\n    return;\n  };\n  defer row.deinit() catch {};\n\n  try res.json(.{\n    .id = user_id,\n    .name = row.get([]u8, 0),\n  }, .{});\n}\n```\n\n## Custom Dispatch\n\nBeyond sharing state, your custom handler can be used to control how httpz behaves. By defining a public `dispatch` method you can control how (or even **if**) actions are executed. For example, to log timing, you could do:\n\n```zig\nconst App = struct {\n  pub fn dispatch(self: *App, action: httpz.Action(*App), req: *httpz.Request, res: *httpz.Response) !void {\n    var timer = try std.time.Timer.start();\n\n    // your `dispatch` doesn't _have_ to call the action\n    try action(self, req, res);\n\n    const elapsed = timer.lap() / 1000; // ns -> us\n    std.log.info(\"{} {s} {d}\", .{req.method, req.url.path, elapsed});\n  }\n};\n```\n\n### Per-Request Context\n\nThe 2nd parameter, `action`, is of type `httpz.Action(*App)`. This is a function pointer to the function you specified when setting up the routes. As we've seen, this works well to share global data. But, in many cases, you'll want to have request-specific data.\n\nConsider the case where you want your `dispatch` method to conditionally load a user (maybe from the `Authorization` header of the request). How would you pass this `User` to the action? You can't use the `*App` directly, as this is shared concurrently across all requests.\n\nTo achieve this, we'll add another structure called `RequestContext`. You can call this whatever you want, and it can contain any fields of methods you want.\n\n```zig\nconst RequestContext = struct {\n  // You don't have to put a reference to your global data.\n  // But chances are you'll want.\n  app: *App,\n  user: ?User,\n};\n```\n\nWe can now change the definition of our actions and `dispatch` method:\n\n```zig\nfn getUser(ctx: *RequestContext, req: *httpz.Request, res: *httpz.Response) !void {\n   // can check if ctx.user is != null\n}\n\nconst App = struct {\n  pub fn dispatch(self: *App, action: httpz.Action(*RequestContext), req: *httpz.Request, res: *httpz.Response) !void {\n    var ctx = RequestContext{\n      .app = self,\n      .user = self.loadUser(req),\n    }\n    return action(&ctx, req, res);\n  }\n\n  fn loadUser(self: *App, req: *httpz.Request) ?User {\n    // todo, maybe using req.header(\"authorizaation\")\n  }\n};\n\n```\n\nhttpz infers the type of the action based on the 2nd parameter of your handler's `dispatch` method. If you use a `void` handler or your handler doesn't have a `dispatch` method, then you won't interact with `httpz.Action(H)` directly.\n\n## Not Found\n\nIf your handler has a public `notFound` method, it will be called whenever a path doesn't match a found route:\n\n```zig\nconst App = struct {\n  pub fn notFound(_: *App, req: *httpz.Request, res: *httpz.Response) !void {\n    std.log.info(\"404 {} {s}\", .{req.method, req.url.path});\n    res.status = 404;\n    res.body = \"Not Found\";\n  }\n};\n```\n\n## Error Handler\n\nIf your handler has a public `uncaughtError` method, it will be called whenever there's an unhandled error. This could be due to some internal httpz bug, or because your action return an error.\n\n```zig\nconst App = struct {\n  pub fn uncaughtError(_: *App, req: *httpz.Request, res: *httpz.Response, err: anyerror) void {\n    std.log.info(\"500 {} {s} {}\", .{req.method, req.url.path, err});\n    res.status = 500;\n    res.body = \"sorry\";\n  }\n};\n```\n\nNotice that, unlike `notFound` and other normal actions, the `uncaughtError` method cannot return an error itself.\n\n## Takeover\n\nFor the most control, you can define a `handle` method. This circumvents most of Httpz's dispatching, including routing. Frameworks like JetZig hook use `handle` in order to provide their own routing and dispatching. When you define a `handle` method, then any `dispatch`, `notFound` and `uncaughtError` methods are ignored by httpz.\n\n```zig\nconst App = struct {\n  pub fn handle(app: *App, req: *httpz.Request, res: *httpz.Response) void {\n    // todo\n  }\n};\n```\n\nThe behavior `httpz.Server(H)` is controlled by\nThe library supports both simple and complex use cases. A simple use case is shown below. It's initiated by the call to `httpz.Server()`:\n\n```zig\nconst std = @import(\"std\");\nconst httpz = @import(\"httpz\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    var server = try httpz.Server(void).init(allocator, .{.address = .localhost(5882)}, {});\n\n    // overwrite the default notFound handler\n    server.notFound(notFound);\n\n    // overwrite the default error handler\n    server.errorHandler(errorHandler);\n\n    var router = try server.router(.{});\n\n    // use get/post/put/head/patch/options/delete\n    // you can also use \"all\" to attach to all methods\n    router.get(\"/api/user/:id\", getUser, .{});\n\n    // start the server in the current thread, blocking.\n    try server.listen();\n}\n\nfn getUser(req: *httpz.Request, res: *httpz.Response) !void {\n    // status code 200 is implicit.\n\n    // The json helper will automatically set the res.content_type = httpz.ContentType.JSON;\n    // Here we're passing an inferred anonymous structure, but you can pass anytype\n    // (so long as it can be serialized using std.json.stringify)\n\n    try res.json(.{.id = req.param(\"id\").?, .name = \"Teg\"}, .{});\n}\n\nfn notFound(_: *httpz.Request, res: *httpz.Response) !void {\n    res.status = 404;\n\n    // you can set the body directly to a []u8, but note that the memory\n    // must be valid beyond your handler. Use the res.arena if you need to allocate\n    // memory for the body.\n    res.body = \"Not Found\";\n}\n\n// note that the error handler return `void` and not `!void`\nfn errorHandler(req: *httpz.Request, res: *httpz.Response, err: anyerror) void {\n    res.status = 500;\n    res.body = \"Internal Server Error\";\n    std.log.warn(\"httpz: unhandled exception for request: {s}\\nErr: {}\", .{req.url.raw, err});\n}\n```\n\n# Memory and Arenas\n\nAny allocations made for the response, such as the body or a header, must remain valid until **after** the action returns. To achieve this, use `res.arena` or the `res.writer()`:\n\n```zig\nfn arenaExample(req: *httpz.Request, res: *httpz.Response) !void {\n    const query = try req.query();\n    const name = query.get(\"name\") orelse \"stranger\";\n    res.body = try std.fmt.allocPrint(res.arena, \"Hello {s}\", .{name});\n}\n\nfn writerExample(req: *httpz.Request, res: *httpz.Response) !void {\n    const query = try req.query();\n    const name = query.get(\"name\") orelse \"stranger\";\n    try std.fmt.format(res.writer(&.{}), \"Hello {s}\", .{name});\n}\n```\n\nAlternatively, you can explicitly call `res.write()`. Once `res.write()` returns, the response is sent and your action can cleanup/release any resources.\n\n`res.arena` is actually a configurable-sized thread-local buffer that fallsback to an `std.heap.ArenaAllocator`. In other words, it's fast so it should be your first option for data that needs to live only until your action exits.\n\nTo align the `Response.writer()` with the new `*std.Io.Writer` interface (Zig 0.15) , a buffer must be provided. For the most part, you should pass in an empty buffer (`&.{}`) as httpz does its own buffer (as I expect most network applications would do). Still, it appears that some parts of std require a writer buffer. This seems like a really bad design to me, but if you find yourself using code that requires a writer buffer, then, of course, you'll have to provide one when creating the `response.writer(...)`.\n\n# httpz.Request\n\nThe following fields are the most useful:\n\n- `method` - httpz.Method enum\n- `method_string` - Only set if `method == .OTHER`, else empty. Used when using custom methods.\n- `arena` - A fast thread-local buffer that fallsback to an ArenaAllocator, same as `res.arena`.\n- `url.path` - the path of the request (`[]const u8`)\n- `address` - the std.net.Address of the client\n\nIf you give your route a `data` configuration, the value can be retrieved from the optional `route_data` field of the request.\n\n## Path Parameters\n\nThe `param` method of `*Request` returns an `?[]const u8`. For example, given the following path:\n\n```zig\nrouter.get(\"/api/users/:user_id/favorite/:id\", user.getFavorite, .{});\n```\n\nThen we could access the `user_id` and `id` via:\n\n```zig\npub fn getFavorite(req *http.Request, res: *http.Response) !void {\n    const user_id = req.param(\"user_id\").?;\n    const favorite_id = req.param(\"id\").?;\n    ...\n```\n\nIn the above, passing any other value to `param` would return a null object (since the route associated with `getFavorite` only defines these 2 parameters). Given that routes are generally statically defined, it should not be possible for `req.param` to return an unexpected null. However, it _is_ possible to define two routes to the same action:\n\n```zig\nrouter.put(\"/api/users/:user_id/favorite/:id\", user.updateFavorite, .{});\n\n// currently logged in user, maybe?\nrouter.put(\"/api/use/favorite/:id\", user.updateFavorite, .{});\n```\n\nIn which case the optional return value of `param` might be useful.\n\n## Header Values\n\nSimilar to `param`, header values can be fetched via the `header` function, which also returns a `?[]const u8`:\n\n```zig\nif (req.header(\"authorization\")) |auth| {\n\n} else {\n    // not logged in?:\n}\n```\n\nHeader names are lowercase. Values maintain their original casing.\n\nTo iterate over all headers, use:\n\n```zig\nvar it = req.headers.iterator();\nwhile (it.next()) |kv| {\n  // kv.key\n  // kv.value\n}\n```\n\n## QueryString\n\nThe framework does not automatically parse the query string. Therefore, its API is slightly different.\n\n```zig\nconst query = try req.query();\nif (query.get(\"search\")) |search| {\n\n} else {\n    // no search parameter\n};\n```\n\nOn first call, the `query` function attempts to parse the querystring. This requires memory allocations to unescape encoded values. The parsed value is internally cached, so subsequent calls to `query()` are fast and cannot fail.\n\nThe original casing of both the key and the name are preserved.\n\nTo iterate over all query parameters, use:\n\n```zig\nvar it = req.query().iterator();\nwhile (it.next()) |kv| {\n  // kv.key\n  // kv.value\n}\n```\n\n## Body\n\nThe body of the request, if any, can be accessed using `req.body()`. This returns a `?[]const u8`.\n\n### Json Body\n\nThe `req.json(TYPE)` function is a wrapper around the `body()` function which will call `std.json.parse` on the body. This function does not consider the content-type of the request and will try to parse any body.\n\n```zig\nif (try req.json(User)) |user| {\n\n}\n```\n\n### JsonValueTree Body\n\nThe `req.jsonValueTree()` function is a wrapper around the `body()` function which will call `std.json.Parse` on the body, returning a `!?std.jsonValueTree`. This function does not consider the content-type of the request and will try to parse any body.\n\n```zig\nif (try req.jsonValueTree()) |t| {\n    // probably want to be more defensive than this\n    const product_type = r.root.Object.get(\"type\").?.String;\n    //...\n}\n```\n\n### JsonObject Body\n\nThe even more specific `jsonObject()` function will return an `std.json.ObjectMap` provided the body is a map\n\n```zig\nif (try req.jsonObject()) |t| {\n    // probably want to be more defensive than this\n    const product_type = t.get(\"type\").?.String;\n    //...\n}\n```\n\n### Form Data\n\nThe body of the request, if any, can be parsed as a \"x-www-form-urlencoded \"value using `req.formData()`. The `request.max_form_count` configuration value must be set to the maximum number of form fields to support. This defaults to 0.\n\nThis behaves similarly to `query()`.\n\nOn first call, the `formData` function attempts to parse the body. This can require memory allocations to unescape encoded values. The parsed value is internally cached, so subsequent calls to `formData()` are fast and cannot fail.\n\nThe original casing of both the key and the name are preserved.\n\nTo iterate over all fields, use:\n\n```zig\nvar it = (try req.formData()).iterator();\nwhile (it.next()) |kv| {\n  // kv.key\n  // kv.value\n}\n```\n\nOnce this function is called, `req.multiFormData()` will no longer work (because the body is assumed parsed).\n\n### Multi Part Form Data\n\nSimilar to the above, `req.multiFormData()` can be called to parse requests with a \"multipart/form-data\" content type. The `request.max_multiform_count` configuration value must be set to the maximum number of form fields to support. This defaults to 0.\n\nThis is a different API than `formData` because the return type is different. Rather than a simple string=>value type, the multi part form data value consists of a `value: []const u8` and a `filename: ?[]const u8`.\n\nOn first call, the `multiFormData` function attempts to parse the body. The parsed value is internally cached, so subsequent calls to `multiFormData()` are fast and cannot fail.\n\nThe original casing of both the key and the name are preserved.\n\nTo iterate over all fields, use:\n\n```zig\nvar it = req.multiFormData.iterator();\nwhile (it.next()) |kv| {\n  // kv.key\n  // kv.value.value\n  // kv.value.filename (optional)\n}\n```\n\nOnce this function is called, `req.formData()` will no longer work (because the body is assumed parsed).\n\nAdvance warning: This is one of the few methods that can modify the request in-place. For most people this won't be an issue, but if you use `req.body()` and `req.multiFormData()`, say to log the raw body, the content-disposition field names are escaped in-place. It's still safe to use `req.body()` but any content-disposition name that was escaped will be a little off.\n\n### Lazy Loading\n\nBy default, httpz reads the full request body into memory. Depending on httpz configuration and the request size, the body will be stored in the static request buffer, a large buffer pool, or dynamically allocated.\n\nAs an alternative, when `config.request.lazy_read_size` is set, bodies larger than the configured bytes will not be read into memory. Instead, applications can create a `io.Reader` by calling `req.reader(timeout_in_ms)`.\n\n```zig\n// 5000 millisecond read timeout on a per-read basis\nvar reader = try req.reader(5000);\nvar buf: [4096]u8 = undefined;\nwhile (true) {\n    const n = try reader.read(&buf);\n    if (n == 0) break\n   // buf[0..n] is what was read\n}\n```\n\n`req.reader` can safely be used whether or not the full body was already in-memory - the API abstracts reading from already-loaded bytes and bytes still waiting to be received on the socket. You can check `req.unread_body > 0` to know whether lazy loading is in effect.\n\nA few notes about the implementation.\n\nIf if the body is larger than the configured `lazy_read_size`, part of the body might still be read into the request's static buffer. The `io.Reader` returned by `req.reader()` will abstract this detail away and return the full body.\n\nAlso, if the body isn't fully read, but the connection is marked for keepalive (which is generally the default), httpz will still read the full body, but will do so in 4K chunks.\n\nWhile the `io.Reader` can be used for non-lazy loaded bodies, there's overhead to this. It is better to use it only when you know that the body is large (i.e., a file upload).\n\n## Cookies\n\nUse the `req.cookies` method to get a `Request.Cookie` object. Use `get` to get an optional cookie value for a given cookie name. The cookie name is case sensitive.\n\n```zig\nvar cookies = req.cookies();\nif (cookies.get(\"auth\")) |auth| {\n  /// ...\n}\n```\n\n# httpz.Response\n\nThe following fields are the most useful:\n\n- `status` - set the status code, by default, each response starts off with a 200 status code\n- `content_type` - an httpz.ContentType enum value. This is a convenience and optimization over using the `res.header` function.\n- `arena` - A fast thread-local buffer that fallsback to an ArenaAllocator, same as `req.arena`.\n\nThe `status` field is a `u16`. You can alternatively use `res.setStatus(.ok)` if you prefer to use the `std.http.Status` enum.\n\n## Body\n\nThe simplest way to set a body is to set `res.body` to a `[]const u8`. **However** the provided value must remain valid until the body is written, which happens after the function exists or when `res.write()` is explicitly called.\n\n## Dynamic Content\n\nYou can use the `res.arena` allocator to create dynamic content:\n\n```zig\nconst query = try req.query();\nconst name = query.get(\"name\") orelse \"stranger\";\nres.body = try std.fmt.allocPrint(res.arena, \"Hello {s}\", .{name});\n```\n\nMemory allocated with `res.arena` will exist until the response is sent.\n\n## io.Writer\n\n`res.writer()` returns a Writer. Its `interface` field exposes an `std.Io.Writer`. Various types support writing to an io.Writer. For example, the built-in JSON stream writer can use this writer:\n\n```zig\nvar writer = res.writer();\nvar ws = std.json.writeStream(&writer.interface, 4);\ntry ws.beginObject();\ntry ws.objectField(\"name\");\ntry ws.emitString(req.param(\"name\").?);\ntry ws.endObject();\n```\n\n## JSON\n\nThe `res.json` function will set the content_type to `httpz.ContentType.JSON` and serialize the provided value using `std.json.stringify`. The 2nd argument to the json function is the `std.json.StringifyOptions` to pass to the `stringify` function.\n\nThis function uses `res.writer()` explained above.\n\n## Header Value\n\nSet header values using the `res.header(NAME, VALUE)` function:\n\n```zig\nres.header(\"Location\", \"/\");\n```\n\nThe header name and value are sent as provided. Both the name and value must remain valid until the response is sent, which will happen outside of the action. Dynamic names and/or values should be created and or dupe'd with `res.arena`.\n\n`res.headerOpts(NAME, VALUE, OPTS)` can be used to dupe the name and/or value:\n\n```zig\ntry res.headerOpts(\"Location\", location, .{.dupe_value = true});\n```\n\n`HeaderOpts` currently supports `dupe_name: bool` and `dupe_value: bool`, both default to `false`.\n\n## Cookies\n\nYou can use the `res.setCookie(name, value, opts)` to set the \"Set-Cookie\" header.\n\n```zig\ntry res.setCookie(\"cookie_name3\", \"cookie value 3\", .{\n    .path = \"/auth/\",\n    .domain = \"www.openmymind.net\",\n    .max_age = 9001,\n    .secure = true,\n    .http_only = true,\n    .partitioned = true,\n    .same_site = .lax,  // or .none, or .strict (or null to leave out)\n});\n```\n\n`setCookie` does not validate the name, value, path or domain - it assumes you're setting proper values. It _will_ double-quote values which contain spaces or commas (as required).\n\nIf, for whatever reason, `res.setCookie` doesn't work for you, you always have full control over the cookie value via `res.header(\"Set-Cookie\", value)`.\n\n```zig\nvar cookies = req.cookies();\nif (cookies.get(\"auth\")) |auth| {\n  /// ...\n}\n```\n\n## Writing\n\nBy default, httpz will automatically flush your response. In more advance cases, you can use `res.write()` to explicitly flush it. This is useful in cases where you have resources that need to be freed/released only after the response is written. For example, my [LRU cache](https://github.com/karlseguin/cache.zig) uses atomic referencing counting to safely allow concurrent access to cached data. This requires callers to \"release\" the cached entry:\n\n```zig\npub fn info(app: *MyApp, _: *httpz.Request, res: *httpz.Response) !void {\n    const cached = app.cache.get(\"info\") orelse {\n        // load the info\n    };\n    defer cached.release();\n\n    res.body = cached.value;\n    return res.write();\n}\n```\n\n# Router\n\nYou get an instance of the router by calling `server.route(.{})`. Currently, the configuration takes a single parameter:\n\n- `middlewares` - A list of middlewares to apply to each request. These middleware will be executed even for requests with no matching route (i.e. not found). An individual route can opt-out of these middleware, see the `middleware_strategy` route configuration.\n\nYou can use the `get`, `put`, `post`, `head`, `patch`, `trace`, `delete`, `options` or `connect` method of the router to define a router. You can also use the special `all` method to add a route for all methods.\n\nThese functions can all `@panic` as they allocate memory. Each function has an equivalent `tryXYZ` variant which will return an error rather than panicking:\n\n```zig\n// this can panic if it fails to create the route\nrouter.get(\"/\", index, .{});\n\n// this returns a !void (which you can try/catch)\nrouter.tryGet(\"/\", index, .{});\n```\n\nThe 3rd parameter is a route configuration. It allows you to speficy a different `handler` and/or `dispatch` method and/or `middleware`.\n\n```zig\n// this can panic if it fails to create the route\nrouter.get(\"/\", index, .{\n  .dispatcher = Handler.dispathAuth,\n  .handler = &auth_handler,\n  .middlewares = &.{cors_middleware},\n});\n```\n\n## Configuration\n\nThe last parameter to the various `router` methods is a route configuration. In many cases, you'll probably use an empty configuration (`.{}`). The route configuration has three fields:\n\n- `dispatcher` - The dispatch method to use. This overrides the default dispatcher, which is either httpz built-in dispatcher or [your handler's `dispatch` method](#custom-dispatch).\n- `handler` - The handler instance to use. The default handler is the 3rd parameter passed to `Server(H).init` but you can override this on a route-per-route basis.\n- `middlewares` - A list of [middlewares](#middlewares) to run. By default, no middlewares are run. By default, this list of middleware is appended to the list given to `server.route(.{.middlewares = .{....})`.\n- `middleware_strategy` - How the given middleware should be merged with the global middlewares. Defaults to `.append`, can also be `.replace`.\n- `data` - Arbitrary data (`*const anyopaque`) to make available to `req.route_data`. This must be a `const`.\n\nYou can specify a separate configuration for each route. To change the configuration for a group of routes, you have two options. The first, is to directly change the router's `handler`, `dispatcher` and `middlewares` field. Any subsequent routes will use these values:\n\n```zig\nvar server = try httpz.Server(Handler).init(allocator, .{.address = .localhost(5882)}, &handler);\n\nvar router = try server.router(.{});\n\n// Will use Handler.dispatch on the &handler instance passed to init\n// No middleware\nrouter.get(\"/route1\", route1, .{});\n\nrouter.dispatcher = Handler.dispathAuth;\n// uses the new dispatcher\nrouter.get(\"/route2\", route2, .{});\n\nrouter.handler = &Handler{.public = true};\n// uses the new dispatcher + new handler\nrouter.get(\"/route3\", route3, .{.handler = Handler.dispathAuth});\n```\n\nThis approach is error prone though. New routes need to be carefully added in the correct order so that the desired handler, dispatcher and middlewares are used.\n\nA more scalable option is to use route groups.\n\n## Groups\n\nDefining a custom dispatcher or custom global data on each route can be tedious. Instead, consider using a router group:\n\n```zig\nvar admin_routes = router.group(\"/admin\", .{\n  .handler = &auth_handler,\n  .dispatcher = Handler.dispathAuth,\n  .middlewares = &.{cors_middleware},\n});\nadmin_routes.get(\"/users\", listUsers, .{});\nadmin_routs.delete(\"/users/:id\", deleteUsers, .{});\n```\n\nThe first parameter to `group` is a prefix to prepend to each route in the group. An empty prefix is acceptable. Thus, route groups can be used to configure either a common prefix and/or a common configuration across multiple routes.\n\n## Casing\n\nYou **must** use a lowercase route. You can use any casing with parameter names, as long as you use that same casing when getting the parameter.\n\n## Parameters\n\nRouting supports parameters, via `:CAPTURE_NAME`. The captured values are available via `req.params.get(name: []const u8) ?[]const u8`.\n\n## Glob\n\nYou can glob an individual path segment, or the entire path suffix. For a suffix glob, it is important that no trailing slash is present.\n\n```zig\n// prefer using a custom `notFound` handler than a global glob.\nrouter.all(\"/*\", not_found, .{});\nrouter.get(\"/api/*/debug\", .{})\n```\n\nWhen multiple globs are used, the most specific will be selected. E.g., give the following two routes:\n\n```zig\nrouter.get(\"/*\", not_found, .{});\nrouter.get(\"/info/*\", any_info, .{})\n```\n\nA request for \"/info/debug/all\" will be routed to `any_info`, whereas a request for \"/over/9000\" will be routed to `not_found`.\n\n## Custom Methods\n\nYou can use the `method` function to route a custom method:\n\n```zig\nrouter.method(\"TEA\", \"/\", teaList, .{});\n```\n\nIn such cases, `request.method` will be `.OTHER` and you can use the `reqeust.method_string` for the string value. The method name, `TEA` above, is cloned by the router and does not need to exist beyond the function call. The method name should only be uppercase ASCII letters.\n\nThe `router.all` method **does not** route to custom methods.\n\n## Limitations\n\nThe router has several limitations which might not get fixed. These specifically resolve around the interaction of globs, parameters and static path segments.\n\nGiven the following routes:\n\n```zig\nrouter.get(\"/:any/users\", route1, .{});\nrouter.get(\"/hello/users/test\", route2, .{});\n```\n\nYou would expect a request to \"/hello/users\" to be routed to `route1`. However, no route will be found.\n\nGlobs interact similarly poorly with parameters and static path segments.\n\nResolving this issue requires keeping a stack (or visiting the routes recursively), in order to back-out of a dead-end and trying a different path.\nThis seems like an unnecessarily expensive thing to do, on each request, when, in my opinion, such route hierarchies are uncommon.\n\n# Middlewares\n\nIn general, use a [custom dispatch](#custom-dispatch) function to apply custom logic, such as logging, authentication and authorization. If you have complex route-specific logic, middleware can also be leveraged.\n\nA middleware is a struct which exposes a nested `Config` type, a public `init` function and a public `execute` method. It can optionally define a `deinit` method. See the built-in [CORS middleware](https://github.com/karlseguin/http.zig/blob/master/src/middleware/Cors.zig) or the sample [logger middleware](https://github.com/karlseguin/http.zig/blob/master/examples/middleware/Logger.zig) for examples.\n\nA middleware instance is created using `server.middleware()` and can then be used with the router:\n\n```zig\nvar server = try httpz.Server(void).init(allocator, .{.address = .localhost(5882)}, {});\n\n// the middleware method takes the struct name and its configuration\nconst cors = try server.middleware(httpz.middleware.Cors, .{\n  .origin = \"https://www.openmymind.net/\",\n});\n\n// apply this middleware to all routes (unless the route\n// explicitly opts out)\nvar router = try server.router(.{.middlewares = &.{cors}});\n\n// or we could add middleware on a route-per-route bassis\nrouter.get(\"/v1/users\", user, .{.middlewares = &.{cors}});\n\n// by default, middlewares on a route are appended to the global middlewares\n// we can replace them instead by specifying a middleware_strategy\nrouter.get(\"/v1/metrics\", metrics, .{.middlewares = &.{cors}, .middleware_strategy = .replace});\n```\n\n## Cors\n\nhttpz comes with a built-in CORS middleware: `httpz.middleware.Cors`. Its configuration is:\n\n- `origin: []const u8` - The allowed origin(s)\n- `headers: ?[]const u8 = null` - Allowed headers for preflight requests\n- `methods: ?[]const u8 = null` - Allowed methods for preflight requests\n- `max_age: ?[]const u8 = null` - Max age for preflight cache\n- `credentials: ?[]const u8 = null` - Allow credentials (set to \"true\" to enable)\n\nThe `origin` configuration supports three formats:\n\n### Wildcard Origin\n\nAllow all origins with `*`:\n\n```zig\nconst cors = try server.middleware(httpz.middleware.Cors, .{\n    .origin = \"*\",\n    .methods = \"GET,POST\",\n    .headers = \"content-type\",\n});\n```\n\n### Single Origin\n\nAllow a single specific origin:\n\n```zig\nconst cors = try server.middleware(httpz.middleware.Cors, .{\n    .origin = \"https://www.openmymind.net\",\n    .methods = \"GET,POST\",\n    .max_age = \"300\",\n});\n```\n\n### Multiple Origins\n\nAllow multiple specific origins by separating them with commas:\n\n```zig\nconst cors = try server.middleware(httpz.middleware.Cors, .{\n    .origin = \"https://www.openmymind.net, https://api.example.com, https://app.example.com\",\n    .methods = \"GET,POST,DELETE\",\n    .headers = \"authorization,content-type\",\n});\n```\n\n### Credentials\n\nTo allow credentials (cookies, authorization headers, etc.), set the `credentials` field:\n\n```zig\nconst cors = try server.middleware(httpz.middleware.Cors, .{\n    .origin = \"https://www.openmymind.net\",\n    .credentials = \"true\",\n    .methods = \"GET,POST\",\n});\n```\n\nNote that when using credentials, `origin` cannot be `*` (wildcard) - you must specify explicit origin(s).\n\n### Behavior\n\nThe CORS middleware includes an `Access-Control-Allow-Origin` header in responses when:\n\n- The request includes an `Origin` header\n- The origin matches the configured allowed origin(s)\n\nFor wildcard origins (`*`), the middleware returns `Access-Control-Allow-Origin: *`.\nFor specific origins, it echoes back the request's origin if it's in the allowed list.\n\nFor OPTIONS requests where `sec-fetch-mode` is set to `cors` (preflight requests), the middleware will also set:\n\n- `Access-Control-Allow-Headers` (if configured)\n- `Access-Control-Allow-Methods` (if configured)\n- `Access-Control-Max-Age` (if configured)\n- `Access-Control-Allow-Credentials` (if configured)\n\nAnd return a 204 No Content status.\n\nThe origin parsing and validation happens once at middleware initialization, not on every request, ensuring optimal performance.\n\n# Configuration\n\nThe second parameter given to `Server(H).init` is an `httpz.Config`. When running in <a href=#blocking-mode>blocking mode</a> (e.g. on Windows) a few of these behave slightly, but not drastically, different.\n\nThere are many configuration options.\n\n`thread_pool.buffer_size` is the single most important value to tweak. Usage of `req.arena`, `res.arena`, `res.writer()` and `res.json()` all use a fallback allocator which first uses a fast thread-local buffer and then an underlying arena. The total memory this will require is `thread_pool.count * thread_pool.buffer_size`. Since `thread_pool.count` is usually small, a large `buffer_size` is reasonable.\n\n`request.buffer_size` must be large enough to fit the request header. Any extra space might be used to read the body. However, there can be up to `workers.count * workers.max_conn` pending requests, so a large `request.buffer_size` can take up a lot of memory. Instead, consider keeping `request.buffer_size` only large enough for the header (plus a bit of overhead for decoding URL-escape values) and set `workers.large_buffer_size` to a reasonable size for your incoming request bodies. This will take `workers.count * workers.large_buffer_count * workers.large_buffer_size` memory.\n\nBuffers for request bodies larger than `workers.large_buffer_size` but smaller than `request.max_body_size` will be dynamic allocated.\n\nIn addition to a bit of overhead, at a minimum, httpz will use:\n\n```zig\n(thread_pool.count * thread_pool.buffer_size) +\n(workers.count * workers.large_buffer_count * workers.large_buffer_size) +\n(workers.count * workers.min_conn * request.buffer_size)\n```\n\nPossible values, along with their default, are:\n\n```zig\ntry httpz.listen(allocator, &router, .{\n    // Listen on a localhost port.\n    .address = .localhost(5882)\n\n    // Listen on all addresses.\n    // .address = .{ .ip = .{ .host = \"0.0.0.0\", .port = 5882 } },\n\n    // unix socket to listen on (mutually exclusive with host&port)\n    // .address = .{ .unix = \"http.sock\" },\n\n    // Listen on a std.net.Address.\n    // .address = .{ .addr = .initIp4(.{ 0, 0, 0, 0 }, 5882) },\n\n    // configure the workers which are responsible for:\n    // 1 - accepting connections\n    // 2 - reading and parsing requests\n    // 3 - passing requests to the thread pool\n    .workers = .{\n        // Number of worker threads\n        // (blocking mode: handled differently)\n        .count = 1,\n\n        // Maximum number of concurrent connection each worker can handle\n        // (blocking mode: currently ignored)\n        .max_conn = 8_192,\n\n        // Minimum number of connection states each worker should maintain\n        // (blocking mode: currently ignored)\n        .min_conn = 64,\n\n        // A pool of larger buffers that can be used for any data larger than configured\n        // static buffers. For example, if response headers don't fit in in\n        // $response.header_buffer_size, a buffer will be pulled from here.\n        // This is per-worker.\n        .large_buffer_count = 16,\n\n        // The size of each large buffer.\n        .large_buffer_size = 65536,\n\n        // Size of bytes retained for the connection arena between use. This will\n        // result in up to `count * min_conn * retain_allocated_bytes` of memory usage.\n        .retain_allocated_bytes = 4096,\n    },\n\n    // configures the threadpool which processes requests. The threadpool is\n    // where your application code runs.\n    .thread_pool = .{\n        // Number threads. If you're handlers are doing a lot of i/o, a higher\n        // number might provide better throughput\n        // (blocking mode: handled differently)\n        .count = 32,\n\n        // The maximum number of pending requests that the thread pool will accept\n        // This applies back pressure to the above workers and ensures that, under load\n        // pending requests get precedence over processing new requests.\n        .backlog = 500,\n\n        // Size of the static buffer to give each thread. Memory usage will be\n        // `count * buffer_size`. If you're making heavy use of either `req.arena` or\n        // `res.arena`, this is likely the single easiest way to gain performance.\n        .buffer_size = 8192,\n    },\n\n    // options for tweaking request processing\n    .request = .{\n        // Maximum request body size that we'll process. We can allocate up\n        // to this much memory per request for the body. Internally, we might\n        // keep this memory around for a number of requests as an optimization.\n        .max_body_size: usize = 1_048_576,\n\n        // When set, if request body is larger than this value, the body won't be\n        // eagerly read. The application can use `req.reader()` to create a reader\n        // to read the body. Prevents loading large bodies completely in memory.\n        // When set, max_body_size is ignored.\n        .lazy_read_size: ?usize = null,\n\n        // This memory is allocated upfront. The request header _must_ fit into\n        // this space, else the request will be rejected.\n        .buffer_size: usize = 4_096,\n\n        // Maximum number of headers to accept.\n        // Additional headers will be silently ignored.\n        .max_header_count: usize = 32,\n\n        // Maximum number of URL parameters to accept.\n        // Additional parameters will be silently ignored.\n        .max_param_count: usize = 10,\n\n        // Maximum number of query string parameters to accept.\n        // Additional parameters will be silently ignored.\n        .max_query_count: usize = 32,\n\n        // Maximum number of x-www-form-urlencoded fields to support.\n        // Additional parameters will be silently ignored. This must be\n        // set to a value greater than 0 (the default) if you're going\n        // to use the req.formData() method.\n        .max_form_count: usize = 0,\n\n        // Maximum number of multipart/form-data fields to support.\n        // Additional parameters will be silently ignored. This must be\n        // set to a value greater than 0 (the default) if you're going\n        // to use the req.multiFormData() method.\n        .max_multiform_count: usize = 0,\n    },\n\n    // options for tweaking response object\n    .response = .{\n        // The maximum number of headers to accept.\n        // Additional headers will be silently ignored.\n        .max_header_count: usize = 16,\n    },\n\n    .timeout = .{\n        // Time in seconds that keepalive connections will be kept alive while inactive\n        .keepalive = null,\n\n        // Time in seconds that a connection has to send a complete request\n        .request = null\n\n        // Maximum number of a requests allowed on a single keepalive connection\n        .request_count = null,\n    },\n    .websocket = .{\n        // refer to https://github.com/karlseguin/websocket.zig#config\n        max_message_size: ?usize = null,\n        small_buffer_size: ?usize = null,\n        small_buffer_pool: ?usize = null,\n        large_buffer_size: ?usize = null,\n        large_buffer_pool: ?u16 = null,\n        compression: bool = false,\n        compression_retain_writer: bool = true,\n        // if compression is true, and this is null, then\n        // we accept compressed messaged from the client, but never send\n        // compressed messages\n        compression_write_treshold: ?usize = null,\n    },\n});\n```\n\n## Blocking Mode\n\nkqueue (BSD, MacOS) or epoll (Linux) are used on supported platforms. On all other platforms (most notably Windows), a more naive thread-per-connection with blocking sockets is used.\n\nThe comptime-safe, `httpz.blockingMode() bool` function can be called to determine which mode httpz is running in (when it returns `true`, then you're running the simpler blocking mode).\n\nWhile you should always run httpz behind a reverse proxy, it's particularly important to do so in blocking mode due to the ease with which external connections can DOS the server.\n\nIn blocking mode, `config.workers.count` is hard-coded to 1. (This worker does considerably less work than the non-blocking workers). If `config.workers.count` is > 1, than those extra workers will go towards `config.thread_pool.count`. In other words:\n\nIn non-blocking mode, if `config.workers.count = 2` and `config.thread_pool.count = 4`, then you'll have 6 threads: 2 threads that read+parse requests and send replies, and 4 threads to execute application code.\n\nIn blocking mode, the same config will also use 6 threads, but there will only be: 1 thread that accepts connections, and 5 threads to read+parse requests, send replies and execute application code.\n\nThe goal is for the same configuration to result in the same # of threads regardless of the mode, and to have more thread_pool threads in blocking mode since they do more work.\n\nIn blocking mode, `config.workers.large_buffer_count` defaults to the size of the thread pool.\n\nIn blocking mode, `config.workers.max_conn` and `config.workers.min_conn` are ignored. The maximum number of connections is simply the size of the thread_pool.\n\nIf you aren't using a reverse proxy, you should always set the `config.timeout.request`, `config.timeout.keepalive` and `config.timeout.request_count` settings. In blocking mode, consider using conservative values: say 5/5/5 (5 second request timeout, 5 second keepalive timeout, and 5 keepalive count). You can monitor the `httpz_timeout_active` metric to see if the request timeout is too low.\n\n## Timeouts\n\nThe configuration settings under the `timeouts` section are designed to help protect the system against basic DOS attacks (say, by connecting and not sending data). However it is recommended that you leave these null (disabled) and use the appropriate timeout in your reverse proxy (e.g. NGINX).\n\nThe `timeout.request` is the time, in seconds, that a connection has to send a complete request. The `timeout.keepalive` is the time, in second, that a connection can stay connected without sending a request (after the initial request has been sent).\n\nThe connection alternates between these two timeouts. It starts with a timeout of `timeout.request` and after the response is sent and the connection is placed in the \"keepalive list\", switches to the `timeout.keepalive`. When new data is received, it switches back to `timeout.request`. When `null`, both timeouts default to 2_147_483_647 seconds (so not completely disabled, but close enough).\n\nThe `timeout.request_count` is the number of individual requests allowed within a single keepalive session. This protects against a client consuming the connection by sending unlimited meaningless but valid HTTP requests.\n\nWhen the three are combined, it should be difficult for a problematic client to stay connected indefinitely.\n\nIf you're running httpz on Windows (or, more generally, where <code>httpz.blockingMode()</code> returns true), please <a href=\"#blocking-mode\">read the section</a> as this mode of operation is more susceptible to DOS.\n\n# Metrics\n\nA few basic metrics are collected using [metrics.zig](https://github.com/karlseguin/metrics.zig), a prometheus-compatible library. These can be written to an `std.io.Writer` using `try httpz.writeMetrics(writer)`. As an example:\n\n```zig\npub fn metrics(_: *httpz.Request, res: *httpz.Response) !void {\n    const writer = res.writer();\n    try httpz.writeMetrics(writer);\n\n    // if we were also using pg.zig\n    // try pg.writeMetrics(writer);\n}\n```\n\nSince httpz does not provide any authorization, care should be taken before exposing this.\n\nThe metrics are:\n\n- `httpz_connections` - counts each TCP connection\n- `httpz_requests` - counts each request (should be >= httpz_connections due to keepalive)\n- `httpz_timeout_active` - counts each time an \"active\" connection is timed out. An \"active\" connection is one that has (a) just connected or (b) started to send bytes. The timeout is controlled by the `timeout.request` configuration.\n- `httpz_timeout_keepalive` - counts each time an \"keepalive\" connection is timed out. A \"keepalive\" connection has already received at least 1 response and the server is waiting for a new request. The timeout is controlled by the `timeout.keepalive` configuration.\n- `httpz_alloc_buffer_empty` - counts number of bytes allocated due to the large buffer pool being empty. This may indicate that `workers.large_buffer_count` should be larger.\n- `httpz_alloc_buffer_large` - counts number of bytes allocated due to the large buffer pool being too small. This may indicate that `workers.large_buffer_size` should be larger.\n- `httpz_alloc_unescape` - counts number of bytes allocated due to unescaping query or form parameters. This may indicate that `request.buffer_size` should be larger.\n- `httpz_internal_error` - counts number of unexpected errors within httpz. Such errors normally result in the connection being abruptly closed. For example, a failing syscall to epoll/kqueue would increment this counter.\n- `httpz_invalid_request` - counts number of requests which httpz could not parse (where the request is invalid).\n- `httpz_header_too_big` - counts the number of requests which httpz rejects due to a header being too big (does not fit in `request.buffer_size` config).\n- `httpz_body_too_big` - counts the number of requests which httpz rejects due to a body being too big (is larger than `request.max_body_size` config).\n\n# Testing\n\nThe `httpz.testing` namespace exists to help application developers setup an `*httpz.Request` and assert an `*httpz.Response`.\n\nImagine we have the following partial action:\n\n```zig\nfn search(req: *httpz.Request, res: *httpz.Response) !void {\n    const query = try req.query();\n    const search = query.get(\"search\") orelse return missingParameter(res, \"search\");\n\n    // TODO ...\n}\n\nfn missingParameter(res: *httpz.Response, parameter: []const u8) !void {\n    res.status = 400;\n    return res.json(.{.@\"error\" = \"missing parameter\", .parameter = parameter}, .{});\n}\n```\n\nWe can test the above error case like so:\n\n```zig\nconst ht = @import(\"httpz\").testing;\n\ntest \"search: missing parameter\" {\n    // init takes the same Configuration used when creating the real server\n    // but only the config.request and config.response settings have any impact\n    var web_test = ht.init(.{});\n    defer web_test.deinit();\n\n    try search(web_test.req, web_test.res);\n    try web_test.expectStatus(400);\n    try web_test.expectJson(.{.@\"error\" = \"missing parameter\", .parameter = \"search\"});\n}\n```\n\n## Building the test Request\n\nThe testing structure returns from <code>httpz.testing.init</code> exposes helper functions to set param, query and query values as well as the body:\n\n```zig\nvar web_test = ht.init(.{});\ndefer web_test.deinit();\n\nweb_test.param(\"id\", \"99382\");\nweb_test.query(\"search\", \"tea\");\nweb_test.header(\"Authorization\", \"admin\");\n\nweb_test.body(\"over 9000!\");\n// OR\nweb_test.json(.{.over = 9000});\n// OR\n// This requires ht.init(.{.request = .{.max_form_count = 10}})\nweb_test.form(.{.over = \"9000\"});\n\n// at this point, web_test.req has a param value, a query string value, a header value and a body.\n```\n\nAs an alternative to the `query` function, the full URL can also be set. If you use `query` AND `url`, the query parameters of the URL will be ignored:\n\n```zig\nweb_test.url(\"/power?over=9000\");\n```\n\n## Asserting the Response\n\nThere are various methods to assert the response:\n\n```zig\ntry web_test.expectStatus(200);\ntry web_test.expectHeader(\"Location\", \"/\");\ntry web_test.expectHeader(\"Location\", \"/\");\ntry web_test.expectBody(\"{\\\"over\\\":9000}\");\n```\n\nIf the expected body is in JSON, there are two helpers available. First, to assert the entire JSON body, you can use `expectJson`:\n\n```zig\ntry web_test.expectJson(.{.over = 9000});\n```\n\nOr, you can retrieve a `std.json.Value` object by calling `getJson`:\n\n```zig\nconst json = try web_test.getJson();\ntry std.testing.expectEqual(@as(i64, 9000), json.Object.get(\"over\").?.Integer);\n```\n\nFor more advanced validation, use the `parseResponse` function to return a structure representing the parsed response:\n\n```zig\nconst res = try web_test.parseResponse();\ntry std.testing.expectEqual(@as(u16, 200), res.status);\n// use res.body for a []const u8\n// use res.headers for a std.StringHashMap([]const u8)\n// use res.raw for the full raw response\n```\n\n# HTTP Compliance\n\nThis implementation may never be fully HTTP/1.1 compliant, as it is built with the assumption that it will sit behind a reverse proxy that is tolerant of non-compliant upstreams (e.g. nginx). (One example I know of is that the server doesn't include the mandatory Date header in the response.)\n\n# Server Side Events\n\nServer Side Events can be enabled by calling `res.startEventStream()`. This method takes an arbitrary context and a function pointer. The provided function will be executed in a new thread, receiving the provided context and an `std.net.Stream`. Headers can be added (via `res.headers.add`) before calling `startEventStream()`. `res.body` must not be set (directly or indirectly).\n\nCalling `startEventStream()` automatically sets the `Content-Type`, `Cache-Control` and `Connection` header.\n\n```zig\nfn handler(_: *Request, res: *Response) !void {\n    try res.startEventStream(StreamContext{}, StreamContext.handle);\n}\n\nconst StreamContext = struct {\n    fn handle(self: StreamContext, stream: std.net.Stream) void {\n        while (true) {\n            // some event loop\n            stream.writeAll(\"event: ....\") catch return;\n        }\n    }\n}\n```\n\n# Websocket\n\nhttp.zig integrates with [https://github.com/karlseguin/websocket.zig](https://github.com/karlseguin/websocket.zig) by calling `httpz.upgradeWebsocket()`. First, your handler must have a `WebsocketHandler` declaration which is the WebSocket handler type used by `websocket.Server(H)`.\n\n```zig\nconst websocket = httpz.websocket;\n\nconst Handler = struct {\n  // App-specific data you want to pass when initializing\n  // your WebSocketHandler\n  const WebsocketContext = struct {\n\n  };\n\n  // See the websocket.zig documentation. But essentially this is your\n  // Application's wrapper around 1 websocket connection\n  pub const WebsocketHandler = struct {\n    conn: *websocket.Conn,\n\n    // ctx is arbitrary data you passs to httpz.upgradeWebsocket\n    pub fn init(conn: *websocket.Conn, _: WebsocketContext) {\n      return .{\n        .conn =  conn,\n      }\n    }\n\n    // echo back\n    pub fn clientMessage(self: *WebsocketHandler, data: []const u8) !void {\n        try self.conn.write(data);\n    }\n  }\n};\n```\n\nWith this in place, you can call httpz.upgradeWebsocket() within an action:\n\n```zig\nfn ws(req: *httpz.Request, res: *httpz.Response) !void {\n  if (try httpz.upgradeWebsocket(WebsocketHandler, req, res, WebsocketContext{}) == false) {\n  // this was not a valid websocket handshake request\n  // you should probably return with an error\n  res.status = 400;\n  res.body = \"invalid websocket handshake\";\n  return;\n  }\n  // Do not use `res` from this point on\n}\n```\n\nIn websocket.zig, `init` is passed a `websocket.Handshake`. This is not the case with the httpz integration - you are expected to do any necessary validation of the request in the action.\n\nIt is an undefined behavior if `Handler.WebsocketHandler` is not the same type passed to `httpz.upgradeWebsocket`.\n\n# GraphQL\nFor GraphQL support, you might want to consider [yousif-wali/grapzig](https://github.com/yousif-wali/grapzig) which can been integrated with http.zig.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Singapore",
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2348,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}