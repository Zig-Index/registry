{
  "name": "smtp_client.zig",
  "owner": "karlseguin",
  "repo": "smtp_client.zig",
  "description": "SMTP client for Zig",
  "type": "project",
  "topics": [
    "smtp-client",
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 35,
  "forks": 5,
  "watchers": 1,
  "updated_at": "2025-09-15T00:19:24Z",
  "readme": "# SMTP Client for Zig\n\nZig only supports TLS 1.3. Furthermore, the TLS implementation [has known issues](https://github.com/ziglang/zig/issues/14172).\n\nThis library does not work with Amazon SES as Amazon SES does not support TLS 1.3 (Amazon's documentation says that TLS 1.3 is supported with StartTLS but this does not appear to be the case (OpenSSL also reports an error)). \n\nThe library supports the `PLAIN`, `LOGIN` and `CRAM-MD5` mechanisms of the `AUTH` extension.\n\n# Installation\nAdd this to your build.zig.zon\n\n```zig\n.dependencies = .{\n    .smtp_client = .{\n        .url = \"https://github.com/karlseguin/smtp_client.zig/archive/refs/heads/master.tar.gz\",\n        //the correct hash will be suggested by zig\n    }\n}\n\n```\n\nAnd add this to you build.zig\n\n```zig\n    const smtp_client = b.dependency(\"smtp_client\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"smtp_client\", smtp_client.module(\"smtp_client\"));\n```\n\n# Basic Usage\n\n```zig\nconst std = @import(\"std\");\nconst smtp = @import(\"smtp_client\");\n\npub fn main() !void {\n  var gpa: std.heap.DebugAllocator(.{}) = .init;\n  const allocator = gpa.allocator();\n\n  const config = smtp.Config{\n    .port = 25,\n    .encryption = .none,\n    .host = \"localhost\",\n    .allocator = allocator,\n    // .username = \"username\",\n    // .password = \"password\",\n  };\n\n  try smtp.send(.{\n    .from = .{.address = \"admin@localhost\"},\n    .to = &.{.{.address = \"user@localhost\"}},\n    .subject = \"This is the Subject\",\n    .text_body = \"This is the text body\",\n    .html_body = \"<b>This is the html body</b>\",\n  }, config);\n}\n```\n\n## Encryption\nPrefer using `.encryption = .tls` where possible. Most modern email vendors provide SMTP over TLS and support TLS 1.3. \n\n`.encryption = .start_tls` is also supported, but StartTLS is vulnerable to man-in-the-middle attack.\n\n`.encryption = .none` will not use any encryption.  In this mode, authentication via `LOGIN` or `PLAIN` will be rejected.\n\n`.encryption = .insecure` will not use any encryption. In this mode, authentication via `LOGIN` or `PLAIN` will be allowed and passwords will be sent in plain text. \n\nRegardless of the encryption setting, the library will favor authenticating via `CRAM-MD5` if the server supports it.\n\n# Client\nThe `smtp.send` and `smtp.sendAll` functions are wrappers around an `smtp.Client`. Where `send` and `sendAll` open a connection, send one or more messages and then close the connection, an `smtp.Client` keeps the connection open until `deinit` is called. The client is **not** thread safe.\n\n```zig\nvar client = try smtp.connect({\n  .port = 25,\n  .encryption = .none,\n  .host = \"localhost\",\n  .allocator = allocator,\n  // .username = \"username\",\n  // .password = \"password\",\n});\ndefer client.deinit();\n\ntry client.hello();\ntry client.auth();\n\n// Multiple messages can be sent here\ntry client.sendMessage(.{\n    .subject = \"This is the Subject\"\n    .text_body = \"This is the text body\",\n});\n\n// Once this is called, no more messages can be sent\ntry client.quit();\n```\n\n`hello` and `auth` can be called upfront, while `from`, `to` and `sendMessage` can be called repeatedly. To make the Client thread safe, protect the call to `sendMessage` with a mutex.\n\n# Message\nThe `smtp.Message` which is passed to `smtp.send`, `smtp.sendAll` and `client.sendMessage` has the following fields:\n\n* `from: Address` - The address the email is from\n* `to: ?[]const Address` - A list of addresses to send the email to\n* `cc: ?[]const Address` - A list of addresses to cc the email to\n* `bcc: ?[]const Address` - A list of addresses to bcc the email to\n* `subject: ?[]const u8 = null` - The subject\n* `text_body: ?[]const u8 = null` -  The Text body\n* `html_body: ?[]const u8 = null` - The HTML body\n\n\nThe `timestamp: ?i64 = null` field can also be set. This is used when writing the `Date` header. By default `std.time.timestamp`. Only advance usage should set this.\n\nAs an alternative to setting the above fields, the `data: ?[]const u8 = null` field can be set. This is the complete raw data to send following the SMTP `DATA` command. When specified, the rest of the fields are ignored. The `data` must comform to [RFC 2822 - Internet Message Format](https://www.rfc-editor.org/rfc/rfc2822), including a trailing `\\r\\n.\\r\\n`. I realize that a union would normally be used to make `data` and the other fields mutually exclusive. However, the use of `data` is considered an advanced feature, and adding union simply makes the API more complicated for 99% of the cases which would not use it.\n\n## Message.Address\nThe `Message.Address` structure has two fields:\n\n* `name: ?[]const u8 = null` - the optional name\n* `address: []const u8` - the email address \n\n## Performance\n### Tip 1 - sendAll\nThe `sendAll` function takes an array of `smtp.Message`. It is much more efficient than calling `send` in a loop.\n\n```zig\n  var config = smtp.Config{\n   // same configuration as send\n  };\n\n  var sent: usize = 0;\n  const messages = [_]smtp.Message{\n    .{\n      .from = \"...\",\n      .to = &.{\"...\"},\n      .subject = \"...\",\n      .text_body = \"...\",\n    },\n    .{\n      .from = \"...\",\n      .to = &.{\"...\"},\n      .subject = \"...\",\n      .text_body = \"...\",\n    }\n  };\n  try smtp.sendAll(&messages, config, &sent);\n```\n\n`sendAll` can fail part way, resulting in some messages being sent while others are not. `sendAll` stops at the first encountered error. The last parameter to `sendAll` is set to the number of successfully sent messages, thus it's possible for the caller to know which messages were and were not sent (e.g. if `sent == 3`, then messages 1, 2 and 3 were sent, message 4 failed and it, along with all subsequent messages, were not sent). Of course, when we say \"successfully sent\", we only mean from the point of view of this library. SMTP being asynchronous means that this library can successfully send the message to the configured upstream yet the message never reaches the final recipient(s).\n\n### Tip 2 - CA Bundle\nIf you're using TLS encryption (via either `.encryption = .tls` or `.encryption = .start_tls`), you can improve performance by providing your own CA bundle. When `send` or `sendAll` are called without a configured `ca_bundle`, one is created on each call, which involves reading and parsing your OS' root certificates from disk (again, on every call).\n\nYou can create a certificate bundle on app start, using: \n\n```zig\nvar ca_bundle = std.crypto.Certificate.Bundle{}\ntry ca_bundle.rescan(allocator);\ndefer ca_bundle.deinit(allocator);\n```\n\nAnd then pass the bundle to `send` or `sendAll`:\n\n```zig\nvar config = smtp.Config{\n  .port = 25,\n  .host = \"localhost\",\n  .encryption = .tls,\n  .ca_bundle = ca_bundle,\n  // ...\n};\n```\n\n### Tip 3 - Skip DNS Resolution\nEvery call to `send` and `sendAll` requires a DNS lookup on `config.host`. The `sendTo` and `sendAllTo` functions, which take an `std.net.Address`, can be used instead. When using these functions, `config.host` must still be set to the valid host when `.tls` or `.start_tls` is used.\n\nSimilarly, instead of `connect` to create a `Client`, `connectTo` can be used which takes an `std.net.Address`.\n\n### Allocator\n`config.allocator` is required in two cases:\n1. `send`, `sendAll` or `connect` are used, OR\n2. `.tls` or `.start_tls` are used\n\nIf `config.allocator` is required but not specified, the code will return an error.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2252,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}