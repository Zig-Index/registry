{
  "name": "otp.zig",
  "owner": "karlseguin",
  "repo": "otp.zig",
  "description": "An TOTP library for Zig",
  "type": "project",
  "topics": [
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 16,
  "forks": 1,
  "watchers": 2,
  "updated_at": "2025-11-30T00:39:48Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# OTP for Zig\n\nCurrently only supports TOTP with SHA1 or SHA256.\n\n```zig\nconst std = @import(\"std\");\nconst otp = @import(\"otp\");\n\npub fn main() !void {\n    // You would store secret in the DB with the user\n    var secret: [20]u8 = undefined;\n    otp.generateSecret(&secret);\n\n    // base32 encode the secret\n    // (for a 20-byte secret, you need a 32 byte buffer)\n    var code_buf: [32]u8 = undefined;\n    std.debug.print(\"{s}\\n\", .{otp.bufEncodeSecret(&code_buf, &secret)});\n\n    // verify a user-supplied totp\n    const user_topt = \"123456\";\n    if (otp.totp.verify(user_topt, &secret, .{})) {\n        std.debug.print(\"GOOD!\\n\", .{});\n    }\n}\n```\n\n## Install\n1) Add otp.zig as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save git+https://github.com/karlseguin/otp.zig#master\n```\n\n2) In your `build.zig`, add the `otp` module as a dependency you your program:\n\n```zig\nconst otp = b.dependency(\"otp\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"otp\", otp.module(\"otp\"));\n```\n\n## Secrets\nThe first thing to do is to generate a secret:\n\n```zig\nvar secret: [20]u8 = undefined;\notp.generateSecret(&secret);\n```\n\nYou can pick any size, but 20 bytes, as above, is recommended. You should store the secret along with a user.\n\n`generateSecret` fills the supplied slice with raw bytes. You can base32 encode the secret using:\n\n```zig\n// write the base32 encoded secret to the writer\ntry otp.encodeSecret(writer, secret);\n\n// OR\n\n// write the base32 encoded secret into \"encoded_buf\"\nvar encoded_buf: [32]u8 = undefined;\nconst encoded = otp.bufEncodeSecret(&encoded_buf, secret);\n```\n\nWhen using `bufEncodedSecret`, the supplied buffer *must* be large enough to hold the encoded value. You can use `const len = otp.encodeSecretLen(secret.len)` to get the required length.\n\n### TOTP\n\n#### Config\nPassed to various totp functions:\n\n* `interval: u32` - How long a code should be valid for in seconds. Defaults to 30\n* `digits: u8` - Number of digits. Defaults to 6.\n* `algorithm: otp.totp.Algorithm` - The hash algorithm to use. Defaults to `.sha1` (other supported value is `.sha256`)\n\n#### otp.totp.generate(buf: []u8, secret: []const u8, config: Config) ![]u8\nGenerate a new TOTP code for the current time. `buf` must be at least `config.digits`. A slice of `buf[0..config.digits]` is returned.\n\n\n#### otp.totp.generateAt(buf: []u8, secret: []const u8, timestamp: i64, config: Config) ![]u8\nGenerate a new TOTP code for the specified time. `buf` must be at least `config.digits`. A slice of `buf[0..config.digits]` is returned.\n\n#### otp.totp.verify(code: []const u8, secret: []const u8, config: Config) bool\nVerifies that the given code is valid for the current time.\n\n#### otp.totp.verifyAt(code: []const u8, secret: []const u8, timestamp: i64, config: Config) bool\nVerifies that the given code is valid for the given time.\n\n\n#### Example\n```zig\nvar code_buf: [6]u8 = undefined;\nconst code = otp.totp.generate(&code, &secret, .{});\nstd.debug.assert(otp.totp.verify(code, &secret, .{}) == true);\n```\n\nWhich is a shorthand for:\n\n```zig\nvar code_buf: [6]u8 = undefined;\nconst now = std.time.timestamp()\nconst config = otp.TOTP.Config{\n    .digits = 6,\n    .interval = 30,\n    .algorithm = .sha1,\n};\nconst code = try otp.totp.generateAt(&code, &secret, now, config);\nstd.debug.assert(otp.totp.verifyAt(code, &secret, now config) == true);\n```\n\nWhen generating a code, the buffer, `code_buf` above, must be at least `config.digits` long.\n\n#### URL\nYou can generate a URL (which is what would be put in a QR code) using either the `url` or `bufUrl` functions. These functions take their own type of config object:\n\n* `account: []const u8` - The account name. Required\n* `issuer: ?[]const u8` - Optional issuer name. Defaults to `null`\n* `config: Config` - The TOTP configuration. Default to `.{}`\n\n##### bufUrl(buf: []u8, secret: []const u8, uc: URLConfig) ![]u8\nWrites the URL into `buf`. Returns an error if `buf` isn't large enough. Returns the URL on success.\n\n##### url(writer: anytype, secret: []const u8, uc: URLConfig) !void\nWrites the URL using the writer. \n\n```zig\n// min length of buf will largely depend on the account name, issuer name and length of secret.\nvar buf: [200]u8 = undefined;\nconst url = try bufUrl(&buf, secret, .{.account = \"Leto\", .issuer = \"spice.gov\", .config = .{.digits = 8} });\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2252,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}