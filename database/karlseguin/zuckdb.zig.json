{
  "name": "zuckdb.zig",
  "owner": "karlseguin",
  "repo": "zuckdb.zig",
  "description": "A DuckDB driver for Zig",
  "type": "package",
  "topics": [
    "duckdb",
    "zig",
    "zig-library",
    "duckdb-driver",
    "zig-package"
  ],
  "stars": 165,
  "forks": 6,
  "watchers": 4,
  "updated_at": "2026-01-02T00:48:25Z",
  "dependencies": [
    {
      "name": "duckdb",
      "url": "https://github.com/duckdb/duckdb/releases/download/v1.4.3/libduckdb-src.zip",
      "hash": "12207ea388345f0331da4d30395470f99e5403aeddb4e48497315b22c7e3ac0348af"
    }
  ],
  "readme": "# Zig driver for DuckDB.\n\n## Quick Example\n```zig\nconst db = try zuckdb.DB.init(allocator, \"/tmp/db.duck\", .{});\ndefer db.deinit();\n\nvar conn = try db.conn();\ndefer conn.deinit();\n\n// for insert/update/delete returns the # changed rows\n// returns 0 for other statements\n_ = try conn.exec(\"create table users(id int)\", .{});\n\nvar rows = try conn.query(\"select * from users\", .{});\ndefer rows.deinit();\n\nwhile (try rows.next()) |row| {\n    // get the 0th column of the current row\n    const id = row.get(i32, 0);\n    std.debug.print(\"The id is: {d}\", .{id});\n}\n```\n\nAny non-primitive value that you get from the `row` are valid only until the next call to `next` or `deinit`.\n\n## Install\nThis library is tested with DuckDB 1.4.3. You can either link to an existing libduckdb on your system, or have zuckdb download and build DuckDB for you (this will take time.)\n\n1) Add zuckdb as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save git+https://github.com/karlseguin/zuckdb.zig#master\n```\n\n### Link to libduckdb\n\n1) Download the libduckdb from the <a href=\"https://duckdb.org/docs/installation/index.html?version=latest&environment=cplusplus&installer=binary\">DuckDB download page</a>. \n\n2) Place the `duckdb.h` file and the `libduckdb.so` (linux) or `libduckdb.dylib` (mac) in your project's `lib` folder.\n\n3) Add this in `build.zig`:\n\n```zig\nconst zuckdb = b.dependency(\"zuckdb\", .{\n    .target = target,\n    .optimize = optimize,\n}).module(\"zuckdb\");\n\n// Your app's program\nconst exe = b.addExecutable(.{\n    .name = \"run\",\n    .target = target,\n    .optimize = optimize,\n    .root_source_file = b.path(\"src/main.zig\"),\n});\n// include the zuckdb module\nexe.root_module.addImport(\"zuckdb\", zuckdb);\n\n// link to libduckdb\nexe.linkSystemLibrary(\"duckdb\"); \n\n// tell the linker where to find libduckdb.so (linux) or libduckdb.dylib (macos)\nexe.addLibraryPath(b.path(\"lib/\"));\n```\n\n### Automatically fetch and buikd DuckDB\n\n1) Add this in `build.zig`:\n\n```zig\nconst zuckdb = b.dependency(\"zuckdb\", .{\n    .target = target,\n    .optimize = optimize,\n    .system_libduckdb = false,\n    .debug_duckdb = false, // optional, compile DuckDB with DUCKDB_DEBUG_STACKTRACE  or not\n}).module(\"zuckdb\");\n\n// Your app's program\nconst exe = b.addExecutable(.{\n    .name = \"run\",\n    .target = target,\n    .optimize = optimize,\n    .root_source_file = b.path(\"src/main.zig\"),\n});\n// include the zuckdb module\nexe.root_module.addImport(\"zuckdb\", zuckdb);\n```\n\n### Static Linking\nIt's also possible to statically link DuckDB. In order to do this, you must build DuckDB yourself, in order to [compile it using Zig C++](https://github.com/ziglang/zig/issues/9832#issuecomment-926832810) and using the [bundle-library](https://github.com/duckdb/duckdb/issues/9475) target\n\n```\ngit clone -b 1.4.3 --single-branch https://github.com/duckdb/duckdb.git\ncd duckdb\nexport CXX=\"zig c++\"\nDUCKDB_EXTENSIONS='json' make bundle-library\n```\n\nWhen this finished (it will take several minutes), you can copy `build/release/libduckdb_bundle.a` and `src/include/duckdb.h` to your project's `lib` folder. Rename `libduckdb_bundle.a` to `libduckdb.a`.\n\nFinally, Add the following to your `build.zig`:\n\n```zig\nexe.linkSystemLibrary(\"duckdb\");\nexe.linkSystemLibrary(\"stdc++\");\nexe.addLibraryPath(b.path(\"lib/\"));\n```\n\n# DB\nThe `DB` is used to initialize the database, open connections and, optionally, create a connection pool.\n\n## init\nCreates or opens the database.\n\n```zig\n// can use the special path \":memory:\" for an in-memory database\nconst db = try DB.init(allocator, \"/tmp/db.duckdb\", .{});\ndefer db.deinit();\n```\n\nThe 3rd parameter is for options. The available options, with their default, are:\n\n* `access_mode` - Sets the `access_mode` DuckDB configuration. Defaults to `.automatic`. Valid options are: `.automatic`, `.read_only` or `.read_write`.\n* `enable_external_access` - Sets the `enable_external_access` DuckDB configuration. Defaults to `true`.\n\n## initWithErr\nSame as `init`, but takes a 4th output parameter. On open failure, the output parameter will be set to the error message. This parameter must be freed if set.\n\n```zig\nvar open_err: ?[]u8 = null;\nconst db = DB.initWithErr(allocator, \"/does/not/exist\", .{}, &open_err) catch |err| {\n    if (err == error.OpenDB) {\n        defer allocator.free(open_err.?);\n        std.debug.print(\"DB open: {}\", .{open_err.?});\n    }\n    return err;\n};\n```\n\n## deinit\nCloses the database.\n\n## conn\nReturns a new [connection](#conn-1) object. \n\n```zig\nvar conn = try db.conn();\ndefer conn.deinit();\n...\n```\n\n## pool\nInitializes a [pool](#pool-1) of connections to the DB. \n\n```zig\nvar pool = try db.pool(.{.size = 2});\n\n// the pool owns the `db`, so pool.deinit will call `db.deinit`.\ndefer pool.deinit();\n\nvar conn = try pool.acquire();\ndefer pool.release(conn);\n```\n\nThe `pool` method takes an options parameter:\n* `size: usize` - The number of connections to keep in the pool. Defaults to `5`\n* `timeout: u64` - The time, in milliseconds, to wait for a connetion to be available when calling `pool.acquire()`. Defaults to `10_000`.\n* `on_connection: ?*const fn(conn: *Conn) anyerror!void` - The function to call when the pool first establishes the connection. Defaults to `null`.\n* `on_first_connection: ?*const fn(conn: *Conn) anyerror!void` - The function to call on the first connection opened by the pool. Defaults to `null`.\n\n# Conn\n\n## query\nUse `conn.query(sql, args) !Rows` to query the database and return a `zuckdb.Rows` which can be iterated. You must call `deinit` on the returned rows.\n\n```zig\nvar rows = try conn.query(\"select * from users where power > $1\", .{9000});\ndefer rows.deinit();\nwhile (try rows.next()) |row| {\n    // ...\n}\n```\n\n## exec\n`conn.exec(sql, args) !usize` is a wrapper around `query` which returns the number of affected rows for insert, updates or deletes.\n\n## row\n`conn.row(sql, args) !?OwningRow` is a wrapper around `query` which returns a single optional row. You must call `deinit` on the returned row:\n\n```zig\nvar row = (try conn.query(\"select * from users where id = $1\", .{22})) orelse return null;;\ndefer row.deinit();\n// ...\n```\n\n## begin/commit/rollback\nThe `conn.begin()`, `conn.commit()` and `conn.rollback()` calls are wrappers around `exec`, e.g.: `conn.exec(\"begin\", .{})`.\n\n## prepare\n`conn.prepare(sql, opts) !Stmt` prepares the given SQL and returns a `zuckdb.Stmt`. For one-off queries, you should prefer using `query`, `exec` or `row` which wrap `prepare` and then call `stmt.bind(values)` and finally `stmt.execute()`. Getting an explicit [Stmt](#stmt) is useful when executing the same statement multiple times with different values.\n\nValues for opts are:\n\n* `auto_release: bool` - This defaults to and should usually be kept as `false`. When `true`, the statement is automatically discarded (`deinit`) after the result of its first execution is complete. If you're going to set this to `true`, you might as well use `conn.exec`, `conn.query` or `conn.row` instead of getting an explicit statement.\n\n## err\nIf a method of `conn` returns `error.DuckDBError`, `conn.err` will be set:\n\n```zig\nvar rows = conn.query(\"....\", .{}) catch |err| {\n  if (err == error.DuckDBError) {\n    if (conn.err) |derr| {\n      std.log.err(\"DuckDB {s}\\n\", .{derr});\n    }\n  }\n  return err;\n}\n```\n\nIn the above snippet, it's possible to skip the `if (err == error.DuckDBError)`check, but in that case conn.err could be set from some previous command (conn.err is always reset when acquired from the pool).\n\n## release\n`conn.release()` will release the connection back to the pool. This does nothing if the connection did not come from the pool (i.e. `pool.acquire()`). This is the same as calling `pool.release(conn)`.\n\n# Rows\nThe `rows` returned from `conn.query` exposes the following methods:\n\n* `count()` - the number of rows in the result\n* `changed()` - the number of updated/deleted/inserted rows\n* `columnName(i: usize)` - the column name at position `i` in a result\n* `deinit()` - must be called to free resources associated with the result\n* `next() !?Row` - returns the next row\n\nThe most important method on `rows` is `next()` which is used to iterate the results. `next()` is a typical Zig iterator and returns a `?Row` which will be null when no more rows exist to be iterated.\n\n# Row\n\n## get\n`Row` exposes a `get(T, index) T` function. This function trusts you! If you ask for an <code>i32</code> the library will crash if the column is not an <code>int4</code>. Similarly, if the value can be null, you must use the optional type, e.g. <code>?i32</code>.\n\nThe supported types for `get`, are:\n* `[]u8`, \n* `[]const u8`\n* `i8`\n* `i16`\n* `i32`\n* `i64`\n* `i128`\n* `u8`\n* `u16`\n* `u32`\n* `u64`\n* `f32`\n* `f64`\n* `bool`\n* `zuckdb.Date`\n* `zuckdb.Time`\n* `zuckdb.Interval`\n* `zuckdb.UUID`\n* `zudkdb.Enum`\n\nOptional version of the above are all supported **and must be used** if it's possible the value is null.\n\nString values and enums are only valid until the next call to `next()` or `deinit`. You must dupe the values if you want them to outlive the row.\n\n## list\n`Row` exposes a `list` method which behaves similar to `get` but returns a `zuckdb.List(T)`.\n\n```zig\nconst row = (try conn.row(\"select [1, 32, 99, null, -4]::int[]\", .{})) orelse unreachable;\ndefer row.deinit();\n\nconst list = row.list(?i32, 0).?;\ntry t.expectEqual(5, list.len);\ntry t.expectEqual(1, list.get(0).?);\ntry t.expectEqual(32, list.get(1).?);\ntry t.expectEqual(99, list.get(2).?);\ntry t.expectEqual(null, list.get(3));\ntry t.expectEqual(-4, list.get(4).?);\n```\n\n`list()` always returns a nullable, i.e. `?zuckdb.List(T)`. Besides the `len` field, `get` is used on the provided list to return a value at a specific index. `row.list(T, col).get(idx)` works with any of the types supported by `row.get(col)`.\n\na `List(T)` also has a `alloc(allocator: Allocator) ![]T` method. This will allocate a `[]T` and fill it with the list values. It is the caller's responsibility to free the returned slice.\n\nAlternatively, `fill(into: []T) void` can be used used to populate `into` with items from the list. This will fill `@min(into.len, list.len)` values.\n\n# zuckdb.Enum\nThe `zuckdb.Enum` is a special type which exposes two functions: `raw() [*c]const u8` and `rowCache() ![]const u8`.\n\n`raw()` directly returns the DuckDB enum string value. If you want to turn this into a `[]const u8`, you'll need to wrap it in `std.mem.span`. The value returned by `raw()` is only valid until the next iteration.\n\n`rowCache()` takes the result of `raw()`, and dupes it, giving ownership to the Rows. Thus, the string returned by `rowCache()` outlives the current row iteration and is valid until `rows.deinit()` is called. Essentially, it is an interned string representation of the enum value (which DuckDB internally represents as an integer).\n\n# Pool\nThe `zuckdb.Pool` is a thread-safe connection pool:\n\n```zig\nconst db = try zuckdb.DB.init(allocator, \"/tmp/duckdb.zig.test\", .{});\nvar pool = db.pool(.{\n    .size = 2,\n    .on_connection = &connInit,\n    .on_first_connection = &poolInit,\n});\ndefer pool.deinit();\n\nvar conn = try pool.acquire();\ndefer conn.release();\n```\n\nThe Pool takes ownership of the DB object, thus `db.deinit` does not need to be called The `on_connection` and `on_first_connection` are optional callbacks. They both have the same signature:\n\n```zig\n?*const fn(conn: *Conn) anyerror!void\n```\n\nIf both are specific, the first initialized connection will first be passed to `on_first_connection` and then to `on_connection`.\n\n## newConn() !Conn\nBesides using `acquire()` to get a `!*Conn` from the pool, it's possible to create a new connection detached from the pool using `pool.newConn()`.  This is the same as calling `db.conn()` but, on the pool. Again, this connection will not be part of the pool and `release()` should not be called on it (but `deinit()` should).\n\n## exec/query/row\nThe `pool.exec`, `pool.query`, `pool.queryWithState`, `pool.row` and `pool.rowWithState` are convenience functions which behave like their `Conn` counterparts. \n\n`pool.exec` is the same as:\n\n```zig\nvar conn = try pool.acquire();\ndefer conn.release();\nreturn conn.exec(sql, args);\n```\n\n`pool.query`, `pool.queryWithState`, `pool.row` and `pool.rowWithState` are similar, except the connection is automatically released back to the pool when the `rows.deinit()` or `row.deinit()` is called.s\n\n# Stmt\nThe `zuckdb.Stmt` encapsulates a prepared statement. It is generated by calling `conn.prepare([]const u8, opts)`.\n\n## deinit() !void\nDeinitializes the statement.\n\n## clearBindings(stmt: \\*const Stmt) !void\nClears any previous bound values.\n\n## bind(stmt: \\*const Stmt, values: anytype) !void\nBinds the values tuple to the statement. \n\n## bindValue(stmt: \\*const Stmt, value: anytype, index: usize) !void\nBinds the specific value to the specified position.\n\n## exec(stmt: \\*const Stmt) !usize\nLike `conn.exec`, this executes the statement returning the number of affected rows. Should not be used with a query that returns results.\n\n## query(stmt: \\*const Stmt) !Rows\nLike `conn.query`, executes a result and returns the rows.\n\n\n# Query Optimizations\nIn very tight loops, performance might be improved by providing a stack-based state for the query logic to use. The `query` and `row` functions all have a `WithState` alternative, e.g.: `queryWithState`. These functions take 1 additional \"query state\" parameter:\n\n```zig\nvar state = zuckdb.StaticState(2){};\nvar rows = try conn.queryWithState(SQL, .{ARGS}, &state);\n// use rows normally\n```\n\nThe value passed to `zuckdb.StaticState` is the number of columns returned by the query. The `state` must remain valid until `rows.deinit()` is called.\n\n# Appender\nThe fastest way to insert a large amount of data is to use the appender:\n\n```zig\n// the first parameter is the schema, or null to use the default schema\nvar appender = try conn.appender(null, \"my_table\");\ndefer appender.deinit();\n\nfor (...) {\n    try appender.appendRow(.{\"over\", 9001, true});\n}\n// The appender auto-flushes, but it should be called once at the end.\ntry appender.flush();\n```\n\nThe order of the values used in `appendRow` is the order of the columns as they are defined in the table (e.g. the order that `describe $table` returns).\n\n## Appender per-column append\nThe `appender.appendRow` function depends on the fact that you have comptime knowledge of the underlying table. If you are dealing with dynamic (e.g. user-defined) schemas, that won't always be the case. Instead, use the more explicit `beginRow()`, `appendValue()` and `endRow()` methods. \n```zig\nfor (...) {\n    appender.beginRow();\n    try appender.appendValue(\"over\", 0);\n    try appender.appendValue(9001, 1);\n    try appender.appendValue(true, 2);\n    try appender.endRow();\n}\ntry appender.flush();\n```\n\nThe `appendRow()` method internally calls `beginRow(), `appendValue()` and `endRow()`.\n\n## Appender Type Support\nThe appender writes directly to the underlying storage and thus cannot leverage default column values. `appendRow` asserts that the # of values matches the number of columns. However, when using the explicit `beginRow` + `appendValue` + `endRow`, you must make sure to append a value for each column, else the behavior is undefined. \n\nEnums aren't supporting, due to [limitations in the DuckDB C API](https://github.com/duckdb/duckdb/pull/11704).\n\nDecimals are supported, but be careful! When appending a float, the value will truncated to the decimal place specified by the scale of the column (i.e. a decimal(8, 3) will have the float truncated with 3 decimal places). When appending an int, the library assumes that you have already converted the decimal to the DuckDB internal representation. While surprising, this provides callers with precise control.\n\nWhen dealing with ints, floats and decimals, appending a single value tends to be flexible. In other words, you can append an `i64` to a `tinyint` column, so long as the value fits (i.e. there's a runtime check). However, when dealing with lists (e.g. `integer[]`), the exact type is required. Thus, only a `[]u16` can be bound to a `usmallint[]` column. `decimal[]` can bind to a `[]i64`, `[]f32` or `[]f64`.\n\nList columns support null values, and thus can be bound to either a `[]const T` or a `[]const ?T`.\n\n## Appender Error\nIf any of the appender methods return an error, you can see if the optional `appender.err` has an error description. This is a `?[]const u8` field. On error, you **should not** assume that this value is set, there are error cases where DuckDB doesn't provide an error description.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2279,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}