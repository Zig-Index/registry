{
  "name": "zqlite.zig",
  "owner": "karlseguin",
  "repo": "zqlite.zig",
  "description": "A thin SQLite wrapper for Zig",
  "type": "package",
  "topics": [
    "sqlite3",
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 131,
  "forks": 22,
  "watchers": 2,
  "updated_at": "2025-12-21T23:16:05Z",
  "readme": "# A thin SQLite wrapper for Zig\n\n```zig\n// good idea to pass EXResCode to get extended result codes (more detailed error codes)\nconst flags =  zqlite.OpenFlags.Create | zqlite.OpenFlags.EXResCode;\nvar conn = try zqlite.open(\"/tmp/test.sqlite\", flags);\ndefer conn.close();\n\ntry conn.exec(\"create table if not exists test (name text)\", .{});\ntry conn.exec(\"insert into test (name) values (?1), (?2)\", .{\"Leto\", \"Ghanima\"});\n\n{\n    if (try conn.row(\"select * from test order by name limit 1\", .{})) |row| {\n      defer row.deinit();\n      std.debug.print(\"name: {s}\\n\", .{row.text(0)});\n    }\n}\n\n{\n    var rows = try conn.rows(\"select * from test order by name\", .{});\n    defer rows.deinit();\n    while (rows.next()) |row| {\n        std.debug.print(\"name: {s}\\n\", .{row.text(0)});\n    }\n    if (rows.err) |err| return err;\n}\n```\n\nUnless `zqlite.OpenFlags.ReadOnly` is set in the open flags, `zqlite.OpenFlags.ReadWrite` is assumed (in other words, the database opens in read-write by default, and the `ReadOnly` flag must be used to open it in readony mode.)\n\n## Install\nThis library is tested with SQLite3 3.50.4.\n\n1) Add zqlite as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save git+https://github.com/karlseguin/zqlite.zig#master\n```\n\n2)  The library doesn't attempt to link/include SQLite. You're free to do this how you want.\n\nIf you have sqlite3 installed on your system you might get away with just adding this to your build.zig\n\n```zig\nconst zqlite = b.dependency(\"zqlite\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.linkLibC();\nexe.linkSystemLibrary(\"sqlite3\");\nexe.root_module.addImport(\"zqlite\", zqlite.module(\"zqlite\"));\n```\n\nAlternatively, If you download the SQLite amalgamation from [the SQLite download page](https://www.sqlite.org/download.html) and place the `sqlite.c` and `sqlite.h` file in your project's `lib/` folder, you can then:\n\n2) Add this in `build.zig`:\n```zig\nconst zqlite = b.dependency(\"zqlite\", .{\n    .target = target,\n    .optimize = optimize,\n});\nexe.addCSourceFile(.{\n    .file = b.path(\"lib/sqlite3.c\"),\n    .flags = &[_][]const u8{\n        \"-DSQLITE_DQS=0\",\n        \"-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1\",\n        \"-DSQLITE_USE_ALLOCA=1\",\n        \"-DSQLITE_THREADSAFE=1\",\n        \"-DSQLITE_TEMP_STORE=3\",\n        \"-DSQLITE_ENABLE_API_ARMOR=1\",\n        \"-DSQLITE_ENABLE_UNLOCK_NOTIFY\",\n        \"-DSQLITE_DEFAULT_FILE_PERMISSIONS=0600\",\n        \"-DSQLITE_OMIT_DECLTYPE=1\",\n        \"-DSQLITE_OMIT_DEPRECATED=1\",\n        \"-DSQLITE_OMIT_LOAD_EXTENSION=1\",\n        \"-DSQLITE_OMIT_PROGRESS_CALLBACK=1\",\n        \"-DSQLITE_OMIT_SHARED_CACHE\",\n        \"-DSQLITE_OMIT_TRACE=1\",\n        \"-DSQLITE_OMIT_UTF16=1\",\n        \"-DHAVE_USLEEP=0\",\n    },\n});\nexe.linkLibC();\nexe.root_module.addImport(\"zqlite\", zqlite.module(\"zqlite\"));\n```\n\nYou can tweak the SQLite build flags for your own needs/platform.\n\n# Conn\nThe `Conn` type returned by `open` has the following functions:\n\n* `row(sql, args) !?zqlite.Row` - returns an optional row\n* `rows(sql, args) !zqlite.Rows` - returns an iterator that yields rows\n* `exec(sql, args) !void` - executes the statement,\n* `execNoArgs(sql) !void` - micro-optimization if there are no args, `sql` must be a null-terminated string\n* `changes() usize` - the number of rows inserted/updated/deleted by the previous statement\n* `lastInsertedRowId() i64` - the row id of the last inserted row\n* `lastError() [*:0]const u8` - an error string describing the last error\n* `transaction() !void` and `exclusiveTransaction() !void` - begins a transaction\n* `commit() !void` and `rollback() void` - commits and rollback the current transaction\n* `prepare(sql, args) !zqlite.Stmt` - returns a thin wrapper around a `*c.sqlite3_stmt`. `row` and `rows` wrap this type.\n* `close() void` and `tryClose() !void` - closes the database. `close()` silently ignores any error, if you care about the error, use `tryClose()`\n* `busyTimeout(ms)` - Sets the busyHandler for the connection. See https://www.sqlite.org/c3ref/busy_timeout.html\n\n# Row and Rows\nBoth `row` and `rows` wrap an `zqlite.Stmt` which itself is a thin wrapper around an `*c.sqlite3_stmt`.\n\nWhile `zqlite.Row` exposes a `deinit` and `deinitErr` method, it should only be called when the row was fetched directly from `conn.row(...)`:\n\n```zig\nif (try conn.row(\"select 1\", .{})) |row| {\n    defer row.deinit();  // must be called\n    std.debug.print(\"{d}\\n\", .{row.int(0)});\n}\n```\n\nWhen the `row` comes from iterating `rows`, `deinit` or `deinitErr` should not be called on the individual row:\n\n```zig\nvar rows = try conn.rows(\"select 1 union all select 2\", .{})\ndefer rows.deinit();  // must be called\n\nwhile (rows.next()) |row| {\n    // row.deinit() should not be called!\n    ...\n}\n```\n\nNote that `zqlite.Rows` has an `err: ?anyerror` field which can be checked at any point. Calls to `next()` when `err != null` will return null. Thus, `err` need only be checked at the end of the loop:\n\n```zig\nvar rows = try conn.rows(\"select 1 union all select 2\", .{})\ndefer rows.deinit();  // must be called\n\nwhile (rows.next()) |row| {\n    ...\n}\n\nif (rows.err) |err| {\n    // something went wrong\n}\n```\n\n## Row Getters\nThere are two APIs for fetching column data. The first is the generic `get`:\n\n```zig\nget(T, index) T\n```\nWhere `T` can be: `i64`, 'f64', 'bool', '[]const u8', '[:0]const u8' or `zqlite.Blob` or their nullable equivalent (i.e. `?i64`). The return type for `zqlite.Blob` is `[]const u8`.\n\nAlternatively, the following can be used:\n\n* `boolean(index) bool`\n* `nullableBoolean(index) ?bool`\n* `int(index) i64`\n* `nullableInt(index) ?i64`\n* `float(index) f64`\n* `nullableFloat(index) ?f64`\n* `text(index) []const u8`\n* `nullableText(index) ?[]const u8`\n* `cString(index) [:0]const u8`\n* `nullableCString(index) ?[:0]const u8`\n* `blob(index) []const u8`\n* `nullableBlob(index) ?[]const u8`\n\nThe `nullableXYZ` functions can safely be called on a `not null` column. The non-nullable versions avoid a call to `sqlite3_column_type` (which is needed in the nullable versions to determine if the value is null or not).\n\n# Transaction:\nThe `transaction()`, `exclusiveTransaction()`, `commit()` and `rollback()` functions are simply wrappers to `conn.execNoArgs(\"begin\")`, `conn.execNoArgs(\"begin exclusive\")`, `conn.execNoArgs(\"commit\")` and `conn.execNoArgs(\"rollback\")`\n\n```zig\ntry conn.transaction();\nerrdefer conn.rollback();\n\ntry conn.exec(...);\ntry conn.exec(...);\ntry conn.commit();\n```\n\n# Blobs\nWhen binding a `[]const u8`, this library has no way to tell whether the value should be treated as an text or blob. It defaults to text. To have the value bound as a blob use `zqlite.blob(value)`:\n\n```zig\nconn.insert(\"insert into records (image) values (?1)\", .{zqlite.blob(image)})\n```\n\nHowever, this should only be necessary in specific cases where SQLite blob-specific operations are used on the data. Text and blob are practically the same, except they have a different type.\n\n# Pool\n`zqlite.Pool` is a simple thread-safe connection pool. After being created, the `acquire` and `release` functions are used to get a connection from the pool and to release it.\n\n```zig\nvar pool = try zqlite.Pool.init(allocator, .{\n    // The number of connection in the pool. The pool will not grow or\n    // shrink beyond this count\n    .size = 5,   // default 5\n\n    // The path  of the DB connection\n    .path = \"/tmp/zqlite.sqlite\",  // no default, required\n\n    // The zqlite.OpenFlags to use when opening each connection in the pool\n    // Defaults are as shown here:\n    .flags = zqlite.OpenFlags.Create | zqlite.OpenFlags.EXResCode\n\n    // Callback function to execute for each connection in the pool when opened\n    .on_connection = null,\n\n    // Callback function to execute only for the first connection in the pool\n    .on_first_connection = null,\n});\n\nconst c1 = pool.acquire();\ndefer c1.release();\nc1.execNoArgs(...);\n```\n\n## Callbacks\nBoth the `on_connection` and `on_first_connection` have the same signature. For the first connection to be opened by the pool, if both callbacks are provided then both callbacks will be executed, with `on_first_connection` executing first.\n\n```zig\nvar pool = zqlite.Pool.init(allocator, .{\n    .size = 5,\n    .on_first_connection = &initializeDB,\n    .on_connection = &initializeConnection,\n    // other required & optional fields\n});\n...\n\n// Our size is 5, but this will only be executed once, for the first\n// connection in our pool\nfn initializeDB(conn: Conn, _: ?*anyopaque) !void {\n    try conn.execNoArgs(\"create table if not exists testing(id int)\");\n}\n\n// Our size is 5, so this will be executed 5 times, once for each\n// connection. `initializeDB` is guaranteed to be called before this\n// function is called.\nfn initializeConnection(conn: Conn, _: ?*anyopaque) !void {\n    return conn.busyTimeout(1000);\n}\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2271,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}