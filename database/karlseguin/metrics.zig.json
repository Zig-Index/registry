{
  "name": "metrics.zig",
  "owner": "karlseguin",
  "repo": "metrics.zig",
  "description": "Prometheus metrics for library and application developers",
  "type": "package",
  "topics": [
    "metrics",
    "prometheus",
    "prometheus-client",
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 68,
  "forks": 11,
  "watchers": 1,
  "updated_at": "2025-11-27T23:43:16Z",
  "readme": "# Prometheus Metric Library for Zig\nThis library is designed for both library and application developers. I do hope to streamline setup when comptime allocations are allowed.\n\nIt supports, counters, gauges and histograms and the labeled-variant of each.\n\nPlease see the example project. It demonstrates how a <a href=\"https://github.com/karlseguin/metrics.zig/blob/master/example/lib/metrics.zig\">library developer</a>, and how an <a href=\"https://github.com/karlseguin/metrics.zig/blob/master/example/main.zig\">application developer</a> can initialize and output them.</a>\n\n## Metric Setup\nSetup is a bit tedious, and I welcome suggestions for improvement. \n\nLet's start with a basic example. While the metrics within this library can be used directly, I believe that each library/application should create its own `Metrics` struct that encapsulates all metrics. A global instance of this struct can be created and initialized at comptime into a \"noop\" state. \n\n```zig\nconst m = @import(\"metrics\");\n\n// defaults to noop metrics, making this safe to use\n// whether or not initializeMetrics is called\nvar metrics = m.initializeNoop(Metrics);\n\nconst Metrics = struct {\n    // counter can be a unsigned integer or floats\n    hits: m.Counter(u32),\n\n    // gauge can be an integer or float\n    connected: m.Gauge(u16),\n};\n\n// meant to be called within the application\npub fn hit() void {\n    metrics.hits.incr();\n}\n\n// meant to be called within the application\npub fn connected(value: u16) void {\n    metrics.connected.set(value);\n}\n\n// meant to be called once on application startup\npub fn initializeMetrics(comptime opts: m.RegistryOpts) !void {\n    metrics = .{\n        .hits = m.Counter(u32).init(\"hits\", .{}, opts),\n        .connected = m.Gauge(u16).init(\"connected\", .{}, opts),\n    };\n}\n\n// thread safe\npub fn writeMetrics(writer: *std.io.Writer) !void {\n    return m.write(&metrics, writer);\n}\n```\n\nThe call to `m.initializeNoop(Metrics)` creates a `Metrics` and initializes each metric (`hits`, `connected` and `latency`) to a \"noop\" implementation (tagged unions are used). The `initializeMetrics` is called on application startup and sets these metrics to real implementation. \n\nFor library developers, this means their global metrics are always safe to use (all methods call noop). For application developers, it gives them control over which metrics to enable.\n\nAll metrics take a name and **two options**. Why two options? The first is designed for library developers, the second is designed to give application developers additional control.\n\nCurrently the first option has a single field:\n* `help: ?[]const u8 = nulls` - Used to generate the `# HELP $HELP` output line\n\nThe second option should has two fields:\n* `prefix: []const u8 = \"\"` - Appends `prefix` to the start of each metric name.\n* `exclude: ?[]const []const u8 = null` - A list of metric names to exclude (not including the prefix).\n\n`CounterVec`, `GaugeVec`, `Histogram` and `HistogramVec` also require an allocator.\n\n### Note for Library Developers\nLibrary developers are free to change the above as needed. However, having libraries consistently expose an `initializeMetrics` and `writeMetrics` should help application developers.\n\nLibrary developers should ask their users to call `try initializeMetrics(allocator, .{})` on startup and `try writeMetrics(writer)` to generate the metrics.\n\nThe `RegistryOpts` parameter should be supplied by the application and passed to each metric-initializer as-is. \n\n### Labels (vector-metrics)\nEvery metric type supports a vectored variant. This allows labels to be attached to metrics. This metrics require an `std.mem.Allocator` and, as you'll see in the metric API section, most of their methods can fail.\n\n```zig\nvar metrics = m.initializeNoop(Metrics);\n\nconst Metrics = struct {\n    hits: m.CounterVec(u32, struct{status: u16, name: []const u8}),\n};\n\n// All labeled metrics require an allocator\npub fn initializeMetrics(allocator: Allocator, opts: m.RegistryOpts) !void {\n    metrics = .{\n        .hits = try m.CounterVec(u32, struct{status: u16, name: []const u8}).init(allocator, \"hits\", .{}, opts),\n    };\n}\n```\n\nThe labels are strongly types. Valid label types are: `ErrorSet`, `Enum`, `Type`, `Bool`, `Int` and `[]const u8`\n\nThe `CounterVec(u32, ...)` has to be typed twice: once in the definition of `Metrics` and once in `initializeMetrics`. This can be improved slightly.\n\n```zig\nvar metrics = m.initializeNoop(Metrics);\n\nconst Metrics = struct {\n    hits: Hits,\n\n    const Hits = m.CounterVec(u32, struct{status: u16, name: []const u8});\n};\n\npub fn initializeMetrics(allocator: Allocator, opts: m.RegistryOpts) !void {\n    metrics = .{\n        .hits = try Metrics.Hits.init(allocator, \"hits\", .{}, opts),\n    };\n}\n\n// Labels are compile-time checked. Using \"anytype\" here\n// is just lazy so we don't have to declare the label structure\npub fn hit(labels: anytype) !void {    \n    return metrics.hits.incr(labels);\n}\n```\n\nThe above would be called as:\n\n```zig\n// import your metrics file\nconst metrics = @import(\"metrics.zig\");\nmetrics.hit(.{.status = 200, .path = \"/about.txt\"});\n```\n\nInternally, every metric is a union between a \"noop\" and an actual implementation. This allows metrics to be globally initialized as noop and then enabled on startup. The benefit of this approach is that library developers can safely and easily use their metrics whether or not the application has enabled them.\n\n### Histograms\nHistograms are setup like `Counter` and `Gauge`, and have a vectored-variant, but they require a comptime list of buckets:\n\n```zig\nconst Metrics = struct {\n    latency: Latency,\n\n    const Latency = m.Histogram(f32, &.{0.005, 0.01, 0.05, 0.1, 0.25, 1, 5, 10});\n};\n\npub fn initializeMetrics(opts: m.RegistryOpts) !void {\n    metrics = .{\n        .latency = Metrics.Latency.init(\"hits\", .{}, opts),\n    };\n}\n```\n\nThe `HistogramVec` is even more verbose, requiring the label struct and bucket list. And, like all vectored metrics, requires an `std.mem.Allocator` and can fail:\n\n```zig\nvar metrics = m.initializeNoop(Metrics);\n\nconst Metrics = struct {\n    latency: Latency,\n\n    const Latency = m.HistogramVec(\n        u32,\n        struct{path: []const u8},\n        &.{5, 10, 25, 50, 100, 250, 500, 1000}\n    );\n};\n\npub fn initializeMetrics(allocator: Allocator, opts: m.RegistryOpts) !void {\n    metrics = .{\n        .latency = try Metrics.Latency.init(allocator, \"hits\", .{}, opts),\n    };\n}\n\n// Labels are compile-time checked. Using \"anytype\" here\n// is just lazy so we don't have to declare the label structure\n// Would be called as:\n//   @import(\"metrics.zig\").recordLatency(.{.path = \"robots.txt\"}, 2);\npub fn recordLatency(labels: anytype, value: u32) !void {\n    return metrics.latency.observe(labels, value);\n}\n```\n\n## Metrics\n\n### Utility\nThe package exposes the following utility functions.\n\n#### `initializeNoop(T) T`\nCreates an initializes metric `T` with `noop` implementation of every metric field. `T` should contain only metrics (`Counter`, `Gauge`, `Historgram` or their vectored variants) and primitive fields (int, bool, []const u8, enum, float). \n\n`initializeNoop(T)` will set any non-metric field to its default value.\n\nThis method is designed to allow a global \"metrics\" instance to exist and be safe to use within libraries.\n\n#### `write(metrics: anytype, writer: *std.Io.Writer) !void`\nCalls the `write(writer) !void` method on every metric field within `metrics`.\n\nLibrary developers are expected to wrap this method in a `writeMetric(writer: *std.io.Writer) !void` function. This function requires a pointer to your metrics.\n\n### Counter(T)\nA `Counter(T)` is used for incrementing values. `T` can be an unsigned integer or a float. Its two main methods are `incr()` and `incrBy(value: T)`. `incr()` is a short version of `incrBy(1)`.\n\n#### `init(comptime name: []const, comptime opts: Opts, comptime ropts: RegistryOpts) !Counter(T)`\nInitializes the counter. \n\nOpts is:\n* `help: ?[]const` - optional help text to include in the prometheus output\n\n\n#### `incr(self: *Counter(T)) void`\nIncrements the counter by 1.\n\n#### `incrBy(self: *Counter(T), value: T) void`\nIncrements the counter by `value`.\n\n#### `write(self: *const Counter(T), writer: *std.io.Writer) !void`\nWrites the counter to `writer`.\n\n### CounterVec(T, L)\nA `CounterVec(T, L)` is used for incrementing values with labels. `T` can be an unsigned integer or a float. `L` must be a struct where the field names and types will define the lables. Its two main methods are `incr(labels: L)` and `incrBy(labels: L, value: T)`. `incr(L)` is a short version of `incrBy(L, 1)`.\n\n#### `init(allocator: Allocator, comptime name: []const, comptim eopts: Opts, comptime ropts: RegistryOpts) !CounterVec(T, L)`\nInitializes the counter. Name must be given at comptime. \n\nOpts is:\n* `help: ?[]const` - optional help text to include in the prometheus output\n\n#### `deinit(self: *CounterVec(T, L)) void`\nDeallocates the counter\n\n#### `incr(self: *CounterVec(T, L), labels: L) !void`\nIncrements the counter by 1. Vectored metrics can fail.\n\n#### `incrBy(self: *CounterVec(T, L), labels: L, value: T) !void`\nIncrements the counter by `value`. Vectored metrics can fail.\n\n#### `remove(self: *CounterVec(T, L), labels: L) void`\nRemoves the labeled value from the counter. Safe to call if `labels` is not an existing label.\n\n#### `write(self: *CounterVec(T, L), writer: *std.io.Writer) !void`\nWrites the counter to `writer`.\n\n### Gauge(T)\nA `Gauge(T)` is used for setting values. `T` can be an integer or a float. Its main methods are `incr()`, `incrBy(value: T)` and `set(value: T)`. `incr()` is a short version of `incrBy(1)`.\n\n#### `init(comptime name: []const, comptime opts: Opts, comptime ropts: RegistryOpts) !Gauge(T)`\nInitializes the gauge. Name must be given at comptime. \n\nOpts is:\n* `help: ?[]const` - optional help text to include in the prometheus output\n\n#### `incr(self: *Gauge(T)) void`\nIncrements the gauge by 1.\n\n#### `incrBy(self: *Gauge(T), value: T) void`\nIncrements the gauge by `value`.\n\n#### `set(self: *Gauge(T), value: T) void`\nSets the the gauge to `value`.\n\n#### `write(self: *Gauge(T), writer: *std.io.Writer) !void`\nWrites the gauge to `writer`.\n\n### GaugeVec(T, L)\nA `GaugeVec(T, L)` is used for incrementing values with labels. `T` can be an integer or a float. `L` must be a struct where the field names and types will define the lables. Its main methods are `incr(labels: L)`, `incrBy(labels: L, value: T)` and `set(labels: L, value: T)`. `incr(L)` is a short version of `incrBy(L, 1)`.\n\n#### `init(allocator: Allocator, comptime name: []const, comptime opts: Opts, comptime ropts: RegistryOpts) !GaugeVec(T, L)`\nInitializes the gauge. Name must be given at comptime. \n\nOpts is:\n* `help: ?[]const` - optional help text to include in the prometheus output\n\n#### `deinit(self: *GaugeVec(T, L)) void`\nDeallocates the gauge\n\n#### `incr(self: *GaugeVec(T, L), labels: L) !void`\nIncrements the gauge by 1. Vectored metrics can fail.\n\n#### `incrBy(self: *GaugeVec(T, L), labels: L, value: T) !void`\nIncrements the gauge by `value`. Vectored metrics can fail.\n\n#### `set(self: *GaugeVec(T, L), labels: L, value: T) !void`\nSets the gauge to `value`. Vectored metrics can fail.\n\n#### `remove(self: *GaugeVec(T, L), labels: L) void`\nRemoves the labeled value from the gauge. Safe to call if `labels` is not an existing label.\n\n#### `write(self: *GaugeVec(T, L), writer: *std.io.Writer) !void`\nWrites the gauge to `writer`.\n\n### Histogram(T, []T)\nA `Histogram(T, []T)` is used  to track the size and frequency of events. `T` can be an unsigned integer or a float. Its main methods is `observe(T)`.\n\nObserved valued will fall within one of the provided buckets, `[]T`. The buckets must be in ascending order. A final \"infinite\" bucket *should not* be provided.\n\n#### `init(comptime name: []const, comptime opts: Opts, comptime ropts: RegistryOpts) !Histogram(T, []T)`\nInitializes the histogram. Name must be given at comptime. \n\nOpts is:\n* `help: ?[]const` - optional help text to include in the prometheus output\n\n#### `observe(self: *Histogram(T, []T), value: T) void`\nObserves `value`, bucketing it based on the provided comptime buckets.\n\n#### `write(self: *Histogram(T, []T), writer: *std.io.Writer) !void`\nWrites the histogram to `writer`.\n\n### Histogram(T, L, []T)\nA `Histogram(T, L, []T)` is used  to track the size and frequency of events. `T` can be an unsigned integer or a float. `L` must be a struct where the field names and types will define the lables. Its main methods is `observe(T)`.\n\nObserved valued will fall within one of the provided buckets, `[]T`. The buckets must be in ascending order. A final \"infinite\" bucket *should not* be provided.\n\n#### `init(allocator: Allocator, comptime name: []const, comptime opts: Opts, comptime ropts: RegistryOpts) !Histogram(T, L, []T)`\nInitializes the histogram. Name must be given at comptime. \n\nOpts is:\n* `help: ?[]const` - optional help text to include in the prometheus output\n\n#### `deinit(self: *Histogram(T, L, []T)) void`\nDeallocates the histogram\n\n#### `observe(self: Histogram(T, L, []T), value: T) void`\nObserves `value`, bucketing it based on the provided comptime buckets.\n\n#### `remove(self: *Histogram(T, L, []T), labels: L) void`\nRemoves the labeled value from the histogram. Safe to call if `labels` is not an existing label.\n\n#### `write(self: Histogram(T, L, []T), writer: *std.io.Writer) !void`\nWrites the histogram to `writer`.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2253,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}