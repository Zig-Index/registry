{
  "name": "mqttz",
  "owner": "karlseguin",
  "repo": "mqttz",
  "description": "MQTT client for Zig",
  "type": "project",
  "topics": [
    "mqtt-client",
    "zig",
    "zig-library",
    "zig-package"
  ],
  "stars": 47,
  "forks": 3,
  "watchers": 3,
  "updated_at": "2025-11-21T00:40:08Z",
  "readme": "# MQTT Client for Zig\n\nThis is a embedding-friendly MQTT client library for Zig. The library has two client: a platform-agnostic low level MQTT client where you bring your own read/write/close function and a higher level client based on Zig's stdlib.\n\n## Examples\nThese example connect to [test.mosquitto.org](https://test.mosquitto.org/), so please be respectful.\n\nThe `example` folder contains examples of using both clients. The low-level client is implemented using Zig's standard library. This implementation is very basic and not as feature rich as `mqtt.posix.Client5` (i.e. no timeouts) . It is only included to show how to integrate the low-level client within your own platform.\n\nTo run the low-level clients:\nStart the subscriber via: `zig build example_low_level_subscriber`. \nThen start the publisher via: `zig build example_low_level_publisher`. \n\nTo run the posix clients:\nStart the subscriber via: `zig build example_posix_subscriber`. \nThen start the publisher via: `zig build example_posix_publisher`. \n\nIn either case, you should see 3 messages printed in your subscriber, then both programs will exit. \n\n## Overview\nBoth clients are single-threaded and follow the same paradigm. You'll call functions like `connect`, `subscribe` and `publish` to send messages to the server and call `readPacket`, as needed, to receive messages.\n\nThe \"as needed\" part of `readPacket` is where things get interesting. MQTT is bidirectional. If you write a `subscribe` message, you'd reasonably expect to receive a `suback`, but you could also get a `disconnect` AND, if you had previously subscribed to another topic, you could get a `publish`.\n\nThis is why even the higher level client doesn't run a background \"read\" thread nor does it expose a more linear request->response API (e.g. why the return value of `subscribe(...)` isn't a `Packet.Suback`). The message received after \"subscribe\" might not be \"suback\".\n\nIf you're just publishing, the flow is straightforward (especially if you're using the default `at_most_once` QoS). Things are similarly straightforward if you're subscribing (possibly to more than 1 topic, but in a single `subscribe` message) and then receiving.\n\nThis generally means that you need to call `readPacket` in a loop (until you get the expected message) and defensively handle different packet types. If you're subscribed to topics, you'll need to periodically (say, every second) call `readPacket` to check for new messages.\n\nSee the examples in the `example` folder.\n\n## MQTT Version\nThe library supports both MQTT 5 and MQTT 3.1.1. This readme and the examples use the `Mqtt5(T)` generic which is the MQTT 5.0 driver. Use `Mqtt311(T)` instead for MQTT 3.1.1 support.\n\nBy default `Mqtt311(T)` will return an error if a 5.0 option is used which is not supported by 3.1.1. To avoid this runtime check, use `Mqtt311NoCheck(T)` instead. This is a good option if you want forward compatibility with 5.0 or understand the risks [of having parameters silently] ignored and want to avoid the runtime checks.\n\nSimilarly, there's a `Client5`, `Client311` and `ClientNoCheck`.\n\n## mqtt.posix.Client5\n`mqtt.posix.Client5` is a higher level library that uses Zig's standard library and should be the preferred client to use if Zig's standard library is available.\n\nThe client supports timeouts and automatic reconnects. It can optionally be configured without an allocator.\n\n### ReadWriteOpts\nAll methods are thin wrappers around the lower-level `mqtt.Mqtt5(t)`. However, an additional optional parameter has been added (Zig doesn't make composing options easy, so I opted for just adding another parameter - sorry!).\n\nWhere the low-level signature is `publish(opts: SubscribeOpts)` the higher-level signature is: `publish(rw: ReadWriteOpts, opts: SubscribeOpts)`. `ReadWriteOpts` allows overriding the default `retries` and `timeout`.\n\n```zig\nclient.publish(.{\n    .retries 3,\n    .timeout = 10_000,\n}, .{\n    .topic = \"saiyan/goku/power\",\n    .message = \"over 9000!\",\n});\n```\n\nIf a timeout is reached when writing a packet, `error.Timeout` will be returned. If a timeout is reached when `readPacket` is called, `null` will be returned. This allows clients to use a short timeout to periodically check for new packet.\n\nThe client will automatically attempt to reconnect and continue the operation when `retries > 0`. When `retries` reaches 0, the underlying error is returned. At this point, the `client` can still be used as any subsequent write/reads will automatically attempt to reconnect.\n\n### init(opts: Client5.Opts) !Client5\nInitializes the client. This does not open a TCP connection to the server. \n\nOptions are:\n\n* `port: u16` - required\n* `ip: ?[]const u8 = null` - Either `ip` or `host` is required\n* `host: ?[]const u8 = null` -  - Either `ip` or `host` is required\n* `connect_timeout: i32 = 10_000` - Time in milliseconds to try to connect\n* `default_retries: ?u16 = null` - When either reading/writing data from/to the server, the default number of times to automatically reconnect and retry on connection failure. Can be overridden on a per-call basis.\n* `default_timeout: ?i32 = null` - When either reading/writing data from/to the server, the default timeout in milliseconds, to block. Can be overridden on a per-call basis.\n* `allocator: ?Allocator = null` - Optional if `ip` is used instead of `host` and both `read_buf` and `write_buf` are provided.\n* `read_buf: ?[]u8 = null` - The buffer to read messages from the server into. If unspecified, the provided `allocator` will be used to create a buffer of `read_buf_size`. \n* `read_buf_size: u16 = 8192` - See `read_buf`.\n* `write_buf: ?[]u8 = null` - The buffer to write messages to the server into. If unspecified, the provided `allocator` will be used to create a buffer of `write_buf_size`. \n* `write_buf_size: u16 = 8192` - See `write_buf`.\n\nWhen `host` is specified, `std.net.getAddressList` is used to resolve and try each possible address. This happens on each reconnection attempt. This is why an `allocator` must be provided when `host` is used.\n\nTrying to read a message from the server which is larger than `read_buf` (or `read_buf_size` will result in an `error.ReadBufferIsFull`. Similarly, trying to write a message larger than `write_buf` (or `write_buf_size`) will result in an `error.WriteBufferIsFull`.\n\nIf you get an `error.ReadBufferIsFull`, you can try to use `client.lastPartialPacket()` which returns a `?PartialPacket`. This is primarily meant to expose the `packet_identifier` of the message which was too large. (Note that, for a Publish message, the packet_identifier comes _after_ the topic, so a very large topic, or a very small `read_buf` will return a `null` value).\n\n## deinit(self: \\*Client5) void\nCloses the socket (if it's still open) and releases the `read_buf` and `write_buf` if they are owned by the client.\n\nFor a clean shutdown, you might want to call `disconnect` before calling `deinit`.\n\n### lastError(self: \\*Client5) ?mqttz.ErrorDetail\nThe library attempts to make errors easy to manage while still providing some detail. The library typically returns a handful of higher-level errors (which makes it easier) while optionally exposing an error payload. The `lastErorr` method returns the error payload. (See the [errors section](#errors).\n\n### lastReadPacket(self: \\*Client5) []const u8\nThe last read packet. Only meant to be used for debugging. Only valid until the next call to `readPacket`.\n\n### connect(self: \\*Client5, rw: ReadWriteOpts, opts: ConnectOpts) !void\nSends a connect packet.\n\n### publish(self: \\*Client5, rw: ReadWriteOpts, opts: PublishOpts) !?u16\nSends a publish packet. If `opts.qos` was either `at_least_once` or `exactly_once`, then the returned value is the packet identifier, else it is null. The packet identifier is used to pair this publish with `puback`, `pubrec`, `pubrel` or `pubcomp` packets received from `readPacket`.\n\nThe packet identifier is an incrementing integer. It can also be explicitly set via `opts.packet_identifier`.\n\n### subscribe(self: \\*Client5, rw: ReadWriteOpts, opts: SubscribeOpts) !u16\nSends a subscribe packet. The return value is a packet identifier used to pair this message with the corresponding suback message read via `readPacket`. \n\nThe packet identifier is an incrementing integer. It can also be explicitly set via `opts.packet_identifier`.\n\n### unsubscribe(self: \\*Client5, rw: ReadWriteOpts, opts: UnsubscribeOpts) !u16\nSends a unsubscribe packet. The return value is a packet identifier used to pair this message with the corresponding unsuback message read via `readPacket`. \n\nThe packet identifier is an incrementing integer. It can also be explicitly set via `opts.packet_identifier`.\n\n### puback(self: \\*Client5, rw: ReadWriteOpts, opts: PubAckOpts) !void\nSends a puback packet. `opts.packet_identifier` must be set. `opts.reason_code` defaults to `.success`.\n\n### pubrec(self: \\*Client5, rw: ReadWriteOpts, opts: PubRecOpts) !void\nSends a pubrec packet. `opts.packet_identifier` must be set. `opts.reason_code` defaults to `.success`.\n\n### pubrel(self: \\*Client5, rw: ReadWriteOpts, opts: PubRelOpts) !void\nSends a pubrel packet. `opts.packet_identifier` must be set. `opts.reason_code` defaults to `.success`.\n\n### pubcomp(self: \\*Client5, rw: ReadWriteOpts, opts: PubCompOpts) !void\nSends a pubcomb packet. `opts.packet_identifier` must be set. `opts.reason_code` defaults to `.success`.\n\n### ping(self: \\*Client5, rw: ReadWriteOpts) !void\nSends a ping packet.\n\n### disconnect(self: \\*Client5, rw: ReadWriteOpts, opts: DisconnectOpts) !void\nSends a disconnect packet. `opts.reason` must be set. This is a no-op if the socket is known to be disconnected (which isn't always the case).\n\nIf `rw.retries` is not set, `0` will be set, overriding the default (why retry to connect just to disconnect?).\n\n### readPacket(self: \\*Client5, rw: ReadWriteOpts) !?mqttz.Packet\nReads a packet from the server.\n\n## mqtt.Mqtt5(T)\nThe approach of `mqtt.Mqtt5(T)` is to have T provide the `MqttPlatform.read`, `MqttPlatform.write` and `MqttPlatform.close` functions. This decouples the `Mqtt5(T)` library from platform details.\n\nUnlike most generic implementations, `Mqtt5(T)` never references `T`. It merely calls `T.MqttPlatform.read()`, `T.MqttPlatform.write()` and `T.MqttPlatform.close()` with a per-call specific `anytype`. This provides greater flexibility and facilitates composition.\n\nConsider this partial example which wraps `Mqtt5(T)` using `std`:\n\n```zig\nconst Client = struct {\n    mqtt: mqtt.Mqtt5(Client),\n    socket: std.posix.socket_t,\n\n    // wrap mqtt.subscribe\n    pub fn subscribe(self: *Client, opts: mqtt.SubscribeOpts) !usize {\n        // the first parameter is an anytype and will be passed to the\n        // read/write/close function as is\n        return self.mqtt.subscribe(MqttPlatform.Context{\n            .client = self,\n            .timeout = 5000,\n        }, opts);\n    }\n\n    pub const MqttPlatform = struct {\n        const Context = struct {\n            client: *Client,\n            timeout: i32,\n        };\n\n        pub fn write(ctx: *Context, data: []const u8) !void {\n            // todo implement timeout using ctx.timeout\n            // (the real mqtt.posix.Client has timeout support)\n            return std.posix.write(ctx.client.socket, data);\n        }\n\n        pub fn read(ctx: *Context, buf: [] u8) !?usize {\n            // todo implement timeout using ctx.timeout\n            // (the real mqtt.posix.Client has timeout support)\n            return try std.posix.read(ctx.client.socket, buf);\n        }\n\n        pub fn close(ctx: *Context) void {\n            std.posix.close(cts.socket);\n        }\n    };\n}\n```\n\nWhile it's common that the state you pass into the various `Mqtt5(T)` methods will be of type `*T`, as we can see from the above, this is not required. \n\nThe `read`, `write` and `close` functions are wrapped in the `MqttPlatform` container structure only to help avoid conflicts with any `read`, `write` and `close` function you might want on your own type.\n\n## T.MqttPlatform.\nT must expose `MqttPlatform.read`, `MqttPlatform.write` and `MqttPlatform.close` functions.\n\nThe first parameter to these functions is the same `anytype` that was passed into the `Mqtt5(T)` function that triggered it.\n\n### T.MqttPlatform.read(state: anytype, buf: []u8, calls: usize) !?usize\nReads data into `buf` - presumably from a socket referenced directly or indirectly by `state`. Returns the number of bytes read. If `0` is returned, assumes the connection is closed. \n\nIf `null` is returned, then `null` will be returned from `readPacket`. Returning `null` is how timeouts should be implemented, to indicate that there is currently no more data.\n\nOnly `Mqtt5(T).readPacket` can currently trigger a call to `read`. For a single call to `Mqtt5(T).readPacket`, `read` might be called 0 or more times. It would be called 0 times if a previous call to `readPacket` had caused multiple packets to be read. The `calls` parameter indicates the number of times `read` has been called for a single call to `readPacket` (it can be ignored in most cases).\n\n### T.MqttPlatform.write(state: anytype, data: []const u8) !void\nWrites `data` - presumably from a socket referenced directly or indirectly by `state`. `write` must write all of `data`.\n\n### T.MqttPlatform.close(state: anytype) !void\nCalled with `Mqtt5(T).disconnect` is called.\n\nThis can be called internally, via `disconnect`, by the library as required by the specification (e.g. when a `connack` response is received with indicating that a session is present, but `clean_start` was specified).\n\nSince `Mqtt5(T)` is relatively stateless, it's possible for `close` to be called when your implementations' socket is already closed.\n\n## Errors\n`Mqtt5(T)` methods return errors which are meant to be easy(ish) to manage. The `last_error` field is an optional tagged union that can include additional information. The ideas is to provide a manageable number of error values without sacrificing additional details (which might traditionally be handled by having a much larger error set, which is harder to handle).\n\nFor example, the only errors `subscribe` can return are: `error.Usage`, `error.WriteBufferIsFull` or any error your `T.write` method returns. If an error is returned, in most cases the optional `last_error` field will be set. \n\n\n# Mqtt5(T)\nAs a consequence of being a foundation, `Mqtt5(T)` has a simple interface.\n\n## init(read_buf: []u8, write_buf: []u8) Mqtt5(T)\nInitializes an instance. \n\n`read_buf` must remain valid for the lifetime of the returned `Mqtt5(T)` value. `read_buf` must be big enough to handle any message received by the server. If you're only publishing message, than `read_buf` can be relatively small. If you're receiving message, then you'll have to size `read_buf` accordingly. `error.ReadBufferIsFull` is returned from reading functions (i.e. `readPacket`) if `read_buf` is too small to accommodate the packet.\n\n`write_buf` must remain valid for the lifetime of the returned `Mqtt5(T)` value. `write_buf` must be big enough to handle any message sent to the server. If you're only only receiving messages, then `write_buf` can be relatively small. If you're sending message, then you'll have to size `write_buf` accordingly. `error.WriteBufferIsFull` is returned from writing functions (i.e. `connect`, `subscribe`, `publish`, ...) if `write_buf` is too small to accommodate the packet.\n\nMQTT is a compact protocol. To figure out the size you'll need, you can generally add up the length of your longest strings (like the name of the topic + the message) and add a few bytes of overhead.\n\n## connect(state: anytype, opts: ConnectOpts) !void\nNone of the `opts` field are required. \n\nWill call T.write(state, data) exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`, any error returned from your `T.MqttPlatform.write`.\n\n## subscribe(state: anytype, opts: SubscribeOpts) !usize\n`opts` must include at least 1 topic which must contain a filter:\n\n```zig\nmqtt.subscribe(&ctx, .{\n    .topics = &.{\n        .{.filter = \"a/b\"},\n    },\n}\n```\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`, `error.Usage`, any error returned from your `T.MqttPlatform.write`. `error.Usage` happens if no topic is provided.\n\nReturns the `packet_identifier`. The `packet_identifier` can be set explicitly via the `packet_identifier: ?u16 = null` field of the `SubscribeOpts`. Otherwise, an incrementing integer is used. The `packet_identifier` is used to pair the `subscribe` with corresponding `suback` which can be retrieved via `readPacket()`.\n\n## unsubscribe(state: anytype, opts: UnsubscribeOpts) !usize\n`opts` must include at least 1 topic :\n\n```zig\nmqtt.unsubscribe(&ctx, .{\n    .topics = &.{\"a/b\"},\n}\n```\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`, `error.Usage` any error returned from your `T.MqttPlatform.write`. `error.Usage` happens if no topic is provided.\n\nReturns the `packet_identifier`. The `packet_identifier` can be set explicitly via the `packet_identifier: ?u16 = null` field of the `UnsubscribeOpts`. Otherwise, an incrementing integer is used. The `packet_identifier` is used to pair the `unsubscribe` with corresponding `unsuback` which can be retrieved via `readPacket()`.\n\n## publish(state: anytype, opts: PublishOpts) !usize\n`opts` must include at a `topic` and `message`. These can be empty (an empty `topic` is common if `topic_alias` is set.)\n\n```zig\nmqtt.public(&ctx, .{\n    .topics = \"power/goku\",\n    .message = \"over 9000!\"\n}\n```\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`, `error.Usage` any error returned from your `T.MqttPlatform.write`. `error.Usage` happens if the `retain` flag is set, but the server announced (via the `connack` message) that it did not support retained messages.\n\nReturns the `packet_identifier`. The `packet_identifier` can be set explicitly via the `packet_identifier: ?u16 = null` field of the `PublishOpts`. Otherwise, an incrementing integer is used. The `packet_identifier` is used to pair the `publish` with corresponding `pubrec` or `pubrel` assuming the `qos` option is set.\n\n## puback(state: anytype, opts: PubAckOpts) !void\n`opts` must include the `packet_identifer` of the `publish` this message is in response to.\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`,  any error returned from your `T.MqttPlatform.write`.\n\n## pubrec(state: anytype, opts: PubRecOpts) !void\n`opts` must include the `packet_identifer` of the `publish` this message is in response to.\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`, any error returned from your `T.MqttPlatform.write`.\n\n## pubrel(state: anytype, opts: PubRelOpts) !void\n`opts` must include the `packet_identifer` of the `publish` this message is in response to.\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`,  any error returned from your `T.MqttPlatform.write`.\n\n## pubcomp(state: anytype, opts: PubCompOpts) !void\n`opts` must include the `packet_identifer` of the `publish` this message is in response to.\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: `error.WriteBufferIsFull`,  any error returned from your `T.MqttPlatform.write`.\n\n## disconnect(state: anytype. opts: DisconnectOpts) !void\n`opts` must include the `reason` for the disconnect. This is an enum.\n\n```zig\n* `normal`\n* `disconnect_with_will_message`\n* `unspecified`\n* `malformed_packet`\n* `protocol_error`\n* `implementation_specific`\n* `topic_name_invalid`\n* `receive_maximum_exceeded`\n* `topic_alias_invalid`\n* `packet_too_large`\n* `message_rate_too_high`\n* `quota_exceeded`\n* `administrative_action`\n* `payload_format_invalid`\n```\n\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: any error returned from your `T.MqttPlatform.write`.\n\n## ping(state: anytype) !void\nThis will call `T.write(state, data)` exactly once.\n\nPossible errors are: any error returned from your `T.MqttPlatform.write`.\n\n## readPacket(state: anytype) !void\nAttempts to read a packet from the server.\n\nThis may call `T.read(state, buf, calls)` 0 or more times. It will call it 0 times if there is already a packet in `read_buf` (from a previous call to `T.read` which read more than 1 packet). `calls` is the number of times (starting at 1) that `T.read` has been called in this single invocation of `readPacket`. This could be used, for example, to control a timeout (in most cases, you'll probably just ignore `calls`).\n\nPossible errors are: \n- `error.Closed` - `T.read` returned 0\n- `error.ReadBufferIsFull` - The packet was too large to fit in `read_buf`\n- `error.Protocol` - A valid packet was received but, from this libraries point of view, the packet didn't make sense. For example, the packet might have had a `reason_code` which was not valid (not one of the allowed u8 values). If you're using a robust server implementation, this is likely a bug/oversight in this library\n- `error.MalformedPacket` - An invalid packet was received which could not be parsed. If you're using a robust server implementation, this is likely a bug/oversight in this library.\n\nPlus any error returned by your `T.read`.\n\nOn success, `readPacket` returns a tagged union. This union has the following tags:\n\n* `connack: mqtt.Packet.ConnAck`\n* `suback: mqtt.Packet.SubAck`\n* `unsuback: mqtt.Packet.UnsubAck`\n* `publish: mqtt.Packet.Publish`\n* `puback: mqtt.Packet.PubAck`\n* `pubrec: mqtt.Packet.PubRec`\n* `pubrel: mqtt.Packet.PubRel`\n* `pubcomp: mqtt.Packet.PubComp`\n* `disconnect: mqtt.Packet.Disconnect`\n* `pong: void` - called `pingresp` in the spec, but why?\n\n`[]const u8` values in the above structures are only valid until the next call to `readPacket`.\n\nSee the [Flow](#flow) for more information.\n\n### Packet.SubAck\nThe `subscribe` method allows multiple topics to be specified. The corresponding `suback` contains 1 reason code per topic. If you subscribed to 3 topics, the corresponding `suback.results.len` should equal 3. However, `suback.results` is a `[]const u8`, representing the numeric reason code. Use `suback.result(idx) ?mqtt.QoS` to get a more meaningful result.\n\nWhen the subscription is success, you'll get a `mqtt.Qos` enum value indicating the QoS level of the subscription. Else you'll get one of these errors:\n\n* `error.Protocol`\n* `error.Unspecified`\n* `error.ImplementationSpecific`\n* `error.NotAuthorized`\n* `error.TopicFilterInvalid`\n* `error.PacketIdentifierInUse`\n* `error.QuotaExceeded`\n* `error.SharedSubscriptionsNotSupported`\n* `error.SubscriptionIdentifierNotSupported`\n* `error.WildcardSubscriptionsNotSupported`\n\n### Packet.UnsubAck\nLike `subscribe` and `suback`, `unsubscribe` and `unsuback` also allow multiple topics to be specified. Again, `unsuback.results` is a `[]const u8` representing the underlying integer code for each unsubscribed topic. Use `unsuback.result(idx)` to get a meaningful error. On success, this returns nothing. Else you'll get an error:\n\n* `error.Protocol`\n* `error.NoSubscriptionExisted`\n* `error.Unspecified`\n* `error.ImplementationSpecific`\n* `error.NotAuthorized`\n* `error.TopicFilterInvalid`\n* `error.PacketIdentifierInUse`\n\n### User Properties\nAll of these packets, except `pong` might have user properties. These are exposes as an iterator:\n\n```zig\nvar it = suback.userPropertis();\nwhile (it.next()) |up| {\n    // up.key\n    // up.value\n}\n```\n\nThe key and value are only valid as long as the packet is valid (which is only valid until the next call to readPacket).\n\n## lastReadPacket() []const u8\nReturns the full raw packet from the last call to `readPacket`. Might be useful when debugging.\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/206480?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://www.openmymind.net/",
  "owner_twitter_username": "karlseguin",
  "owner_followers": 2252,
  "owner_following": 3,
  "owner_created_at": "2010-02-19T04:01:58Z",
  "license": "MIT",
  "category": "library"
}