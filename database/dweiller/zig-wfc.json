{
  "name": "zig-wfc",
  "owner": "dweiller",
  "repo": "zig-wfc",
  "description": "An implementation of the wave function collapse algorithm in Zig",
  "type": "project",
  "topics": [
    "zig-package"
  ],
  "stars": 6,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-03-18T05:22:46Z",
  "dependencies": [
    {
      "name": "zubench",
      "url": "https://github.com/dweiller/zubench/archive/53140a07a6ee27e28549c46209d900ba92f61ceb.tar.gz",
      "hash": "zubench-0.0.0-kIvtMziVAABBkFpJIF0hfbKvx04ZEE9P_G9Xu_xQvb7n"
    }
  ],
  "readme": "# zig-wfc\nAn implementation of the wave function collapse algorithm in Zig\n\nA generic library implementing the *wave function collapse* algorithm. This library exposes a generic core algorithm which produces tilings given a collection of tiles and associated adjacency constraints, as well a tile generator for implementing the _overlapping_ mode. See the [original implementation](https://github.com/mxgmn/WaveFunctionCollapse) for an overview of the algorithm and links to other resources.\n\n## Using zig-wfc\n\nYou can use `zig-wfc` in a Zig project with the Zig build system. Include a dependency in your `build.zig.zon`, e.g.:\n```\n.dependencies = .{\n    .zig_wfc = .{\n        .url = \"https://github.com/dweiller/zig-wfc/archive/[[COMMIT_HASH]].tar.gz\",\n        .hash = \"[[ZIG_PACKAGE_HASH]]\",\n    },\n}\n```\n\nThen retrieve the `wfc` module from the dependency in your `build.zig`:\n```\npub fn build(b: *std.Build) !void {\n\n    // -- snip --\n\n    const wfc = b.dependency(\"zig_wfc\", .{}).module(\"wfc\");\n\n    // assuming you have a `std.Build.Step.Compile` called 'exe' that wants to do WFC\n    exe.addModule(\"zig-wfc\", wfc);\n}\n```\n\nYou can ascertain the correct value for `[[ZIG_PACKAGE_HASH]]` by leaving that field out initially; this make Zig report the correct hash value.\n\n## WFC Core\n\nWFC is sometimes considered as having two different modes: overlapping and tiled. I think is description is a little misleading: I would rather say the WFC is a tiling generator (or maybe even more generally a graph colouring algorithm) and the overlapping mode merely one of several processing pipelines that can be used to achieve various effects. A good explanation how the core tiling algorithm relates to the overlapping mode can be found [here](https://www.gridbugs.org/wave-function-collapse/). Another processing pipeline of particular interest I haven't yet seen talked about is what could be called the 'iterative mode' (if we want to keep the nomenclature of modes), which allows for generating [large-scale structure](#large-scale-structure), which are usually considered outside the scope of WFC.\n\nThe most common situation is generating a 2D or 3D cubic tiling and this library is currently restricted to 2-dimensional rectangular tilings.\n\n## Features (and todos)\n\n  - [x] generic core algorithm you can use with any set of (2D) tiles/edge constraints forming a rectangular grid\n  - [x] generate tiles from image (overlapping mode)\n  - [x] seeded generation\n  - generation constraints\n    - [x] maximum tile count (i.e. max number of times a tile can be used)\n    - [ ] minimum tile count (i.e. min number of times a tile can be used)\n    - [ ] connectivity constraints (i.e. forces tiles to be part of the same region/path)\n    - [ ] distance constraints (distance between particular tiles and of paths)\n  - [ ] tile symmetry groups\n  - [ ] iterative pipeline\n  - [ ] _n_-dimensional rectangular tilings\n  - [ ] hexagonal grid\n\n## Iterative pipeline\n\nHelper utilities for the iterative pipeline is not yet implemented, but are planned for the future. This pipeline is a fairly general idea that produces intermediate tilings that are used to seed the next stage.\n\n### Large-scale structure\n\nWFC does not generally produce large-scale structures as the constraints it considers are all local. However, the core tiling algorithm can be used to generate large-scale structure fairly easily using an iterative strategy. The basic idea is to first generate a low resolution tiling which is used to seed subsequent tile generation. The increase in resolution naturally leads to the initial tiling producing large-scale structure.\n\nFor example, say you wanted to generate a 2D tiling with some larger-scale structure that includes houses, roads and grass, including more specialised tiles for the boundary regions between the road and a front lawn (like a footpath). You could start by generating a 'seed' tiling at a lower resolution that has the tiles 'property' and 'road'. You then expand this tiling into a higher resolution one initially seeded with 'house', 'footpath' and 'grass' tiles in the regions associated to 'property' tiles and 'road' tiles seeded where the 'road' tiles were. The adjacency constraints for 'footpath' can then require that they border 'road' tiles and 'grass' tiles surround 'house' tiles. This guarantees a minimum size for each large-scale 'property' which are grassy regions (possibly) with house tiles inside them. More passes/sub-tile types could be added for improved internal structure of a 'property' (e.g. to make 'house' tiles form a connected region or to add a driveway).\n\n\n## Contributing\n\nContributions are welcome, as are issues requesting/suggesting better documentation or API and new features; feel free to open issues and send PRs.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/4678790?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 15,
  "owner_following": 0,
  "owner_created_at": "2013-06-12T11:36:02Z",
  "license": "MIT",
  "category": "library"
}