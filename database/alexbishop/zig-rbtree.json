{
  "name": "zig-rbtree",
  "owner": "alexbishop",
  "repo": "zig-rbtree",
  "description": "An implementation of an augmented red-black tree in Zig with 3 layers of abstraction",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 12,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-12-08T17:33:08Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# Zig Red-Black Trees\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\nAn extensible implementation of augmented red-black trees in the Zig programming language.\n\n**Note:** This package is written for zig version 0.15.1.\n\nThis library is released under the MIT license (you should have a copy of the LICENSE file with this source code).\n\n## Quickstart\n\nFor instructions on how to use this package in your code, see the [Releases page](https://github.com/alexbishop/zig-rbtree/releases).\n\n## Documentation\n\nFor full documentation with some examples, see https://alexbishop.github.io/zig-rbtree\n\n## Features\n\n  1. Multiple layers of abstraction for different use cases\n  2. Non-recursive implementation of search, insert and delete\n  3. Create a red-black tree from a sorted list in O(n) time without the need for rotates, recolours or swaps.\n     This implementation does not use recursion.\n  4. Takes order functions which take a context parameter so you can change order behaviour at runtime\n     *(this feature is useful if your order depends on some user input)*\n  5. Possibility to make an augmented red-black tree with arbitrary additional data\n     in nodes\n  6. Optional: maintain subtree sizes\n     *(turned off by default but easy to enable in the `Options` passed\n     to `RBTreeImplementation`, `RBTreeUnmanaged` or `RBTree`)*\n      - these subtree counts don't need to be of type `usize`, in fact, they can be of any\n        unsigned integer type with at least 8 bits and at most as many bits as `usize`\n      - for such trees, we also have additional function available under the `index_functions` namespace\n  7. Optional: save space by keeping the colour of the nodes in the lowest order bit of the parent pointer\n     *(turned on by default but easy to disable in the `Options` passed\n     to `RBTreeImplementation`, `RBTreeUnmanaged` or `RBTree`)*\n  8. Optional: cache the first and last node in the tree\n     *(turned off by default but easy to enable in the `Options` passed\n     to `RBTreeImplementation`, `RBTreeUnmanaged` or `RBTree`)*\n        - this then allows `findMin` and `findMax` to run in time O(1)\n\n## Alternatives\n\nIf you don't like this implementation, here are some alternatives which either solve the same problem or a similar problem:\n\n  - [Haeryu/rbtree](https://github.com/Haeryu/rbtree): stores a red-black tree in an array\n  - [Zig standard library](https://github.com/ziglang/std-lib-orphanage/blob/master/std/rb.zig):\n        the now orphaned implementation which used to appear in the zig standard library\n  - [JamesErrington/zig-rbtree](https://github.com/JamesErrington/zig-rbtree)\n  - [avdva/zigavl](https://github.com/avdva/zigavl):\n        an implementation of an AVL tree\n  - [pmkap/zig-btreemap](https://github.com/pmkap/zig-btreemap):\n        an implementation of B-trees which is another balanced tree data structure\n  - [judofyr/rgb-tree](https://github.com/judofyr/rgb-tree):\n        an implementation of rgb trees with arbitrarily many colours\n  - [Linux Kernel](https://github.com/torvalds/linux/blob/master/lib/rbtree.c):\n        since you can use C code in Zig, you could use the red-black tree implementation in the Linux kernel\n  - [C++ std::map](https://cplusplus.com/reference/map/map/):\n       You could write a C wrapper around the C++ library and use it in Zig \n\nThe above list is non-exhaustive. There are likely many other alternatives out there.\n\n## Tests\n\nTo run all the tests with a summary, execute the following command\n\n```bash\nzig build test --summary all\n```\n\nNote that the tests under `test/tests.zig` were translation of the tests in [stanislavkozlovski/Red-Black-Tree](https://github.com/stanislavkozlovski/Red-Black-Tree/tree/cb3cefb420bfa6c1d1fc703cefad54e209c7438c).\nThis translation was performed using the awk script given in `scripts/tests.gawk` in this repository, followed by a small amount of manual editing. (We note here that the tests in [stanislavkozlovski/Red-Black-Tree](https://github.com/stanislavkozlovski/Red-Black-Tree/tree/cb3cefb420bfa6c1d1fc703cefad54e209c7438c) contained a few typos which were found after the translation.)\nAs the name suggests this script was written to be run with [gawk](https://www.gnu.org/software/gawk/manual/gawk.html).\n(At this point, there are still 6 small tests left to be translated.)\n\n## 1. Examples\n\n```zig\nconst std = @import(\"std\");\nconst rbtreelib = @import(\"rbtree\");\n\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n\n    const Tree = DefaultRBTree(i32, f32);\n\n    var tree = Tree.init(allocator, void{});\n    defer tree.deinit();\n\n    // insert some stuff into the tree\n    var index: i32 = -19;\n    while (index < 20) : (index += 1) {\n        const value = std.math.pow(\n            f32,\n            0.5,\n            @floatFromInt(index),\n        );\n        try tree.put(index, value);\n    }\n\n    // print the contents of the tree\n    {\n        std.debug.print(\"First print\\n\", .{});\n        var current: ?*Tree.Node = tree.findMin();\n        while (current) |c| : (current = c.next()) {\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\n        }\n    }\n\n    // remove some entries from the tree\n    _ = tree.remove(7);\n    _ = tree.remove(3);\n    _ = tree.remove(5);\n\n    // print it again\n    {\n        std.debug.print(\"\\nSecond print\\n\", .{});\n        var current: ?*Tree.Node = tree.findMin();\n        while (current) |c| : (current = c.next()) {\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\n        }\n    }\n}\n\n```\n\n## 2. Layers of abstraction\n\nThe red-black trees in this library come in 3 layers of abstraction as decribed in the follows subsections.\n\nWe note here that we also provide the following helper functions for accessing these abstractions.\n\n```zig\npub fn DefaultRBTreeImplementation(comptime K: type, comptime V: type) type {\n    return RBTreeImplementation(K, V, void, defaultOrder(K), .{}, .{});\n}\n\npub fn DefaultRBTreeUnmanaged(comptime K: type, comptime V: type) type {\n    return RBTreeUnmanaged(K, V, void, defaultOrder(K), .{}, .{});\n}\n\npub fn DefaultRBTree(comptime K: type, comptime V: type) type {\n    return RBTree(K, V, void, defaultOrder(K), .{}, .{});\n}\n```\n\n### 2.1. Layer 1: RBTreeImplementation\n\nYou can construct an object of this type using the following function.\n\n```zig\npub fn RBTreeImplementation(\n    /// The type used for the keys of the red-black tree\n    comptime K: type,\n    /// The type used for the values of the red-black tree\n    comptime V: type,\n    /// The type used for the context which is passed to the order function\n    comptime Context: type,\n    /// The order by which to sort the keys\n    ///\n    /// Note that if your desired order function does not support a context,\n    /// then you can fix this with the `addVoidContextToOrder` function.\n    comptime order: fn (ctx: Context, lhs: K, rhs: K) Order,\n    /// Additional options used to construct the tree\n    comptime options: Options,\n    /// The callback functions which implement any augmentation\n    comptime augmented_callbacks: Callbacks(\n        K,\n        V,\n        Context,\n        options.getNodeOptions(),\n    ),\n) type\n```\n\nThis layer of abstraction, the supports the following functionality.\n\n#### 2.1.1. Search\n\n```zig\npub const Location = struct {\n    parent: *Node,\n    direction: Direction,\n};\npub const NodeOrLocationResultTag = enum {\n    node,\n    location,\n};\npub const FindNodeOrLocationResult = union(NodeOrLocationResultTag) {\n    node: *Node,\n    location: Location,\n};\n/// Either finds the given key in the tree, or finds the location where the\n/// given key should be inserted for order to be preserved\npub fn findNodeOrLocation(\n    root: *Node,\n    ctx: Context,\n    key: K,\n) FindNodeOrLocationResult {\n```\n\n#### 2.1.2 Insert as root\n\n```zig\n/// Makes the given node the root of the tree\n/// It is assumed that `root_ref.* == null` before calling this function\npub fn makeRoot(\n    root_ref: *?*Node,\n    ctx: Context,\n    new_node: *Node,\n) void {\n```\n\n#### 2.1.3 Insert as an internal node\n\nInsert into a non-empty tree.\n\n```zig\npub fn insertNode(\n    root_ref: **Node,\n    ctx: Context,\n    new_node: *Node,\n    location: Location,\n) void {\n```\n\nNotice here that `root_ref` must be of type `**Node` and not `*?*Node`. Example of its usage is as follows.\n\n```zig\n// suppose\n//      `root` is of type `?*Node`\n//      `node` is of type `*Node`\n//      `implementation` is of a type created by `RBTreeImplementation`\n//      `location` is of type `Location`\nif (root) |*root_ref| {\n    // the tree node is not null\n    // here `root_ref` is of type `**Node`\n    implementation.insertNode(root_ref, ctx, new_node, location);\n}\n```\n\n#### 2.1.4. Deleting a node\n\n```zig\npub fn removeNode(\n    root_ref_opt: *?*Node,\n    ctx: Context,\n    node: *Node,\n) void {\n```\n\n### 2.2. Layer 2: RBTreeUnmanaged\n\nThis layer adds on some functions to make inserting and deleting from the tree easier.\nMoreover, this layer also keeps track of the size of the tree.\n\n```zig\npub fn RBTreeUnmanaged(\n    // the type of the key\n    comptime K: type,\n    // the type of the value being stored\n    comptime V: type,\n    // the type of the conext which can be passed to the comparison function\n    // and to any augmented callbacks\n    comptime Context: type,\n    // the function used to compare keys in the tree\n    comptime order: fn (ctx: Context, lhs: K, rhs: K) Order,\n    // some additional options,\n    // see the \"Augmentation and options\" section of this readme\n    comptime options: Options,\n    // functions used to augment the functionality of the tree,\n    // see the \"Augmentation and options\" section of this readme\n    comptime augmented_callbacks: Callbacks(\n        K,\n        V,\n        Context,\n        options.getNodeOptions(),\n    ),\n) type {\n```\n\n### 2.3. Layer 3: RBTree\n\nThis is an abstraction on top of `RBTreeUnmanaged` which holds a copy of the allocator and context.\n\n```zig\npub fn RBTree(\n    // the type of the key\n    comptime K: type,\n    // the type of the value being stored\n    comptime V: type,\n    // the type of the conext which can be passed to the comparison function\n    // and to any augmented callbacks\n    comptime Context: type,\n    // the function used to compare keys in the tree\n    comptime order: fn (ctx: Context, lhs: K, rhs: K) Order,\n    // some additional options,\n    // see the \"Augmentation and options\" section of this readme\n    comptime options: Options,\n    // functions used to augment the functionality of the tree,\n    // see the \"Augmentation and options\" section of this readme\n    comptime augmented_callbacks: Callbacks(\n        K,\n        V,\n        Context,\n        options.getNodeOptions(),\n    ),\n) type {\n```\n\n## 3. Helper functions\n\nNotice that all of the comparison functions used here are three parameter with the first agument beng of type `Context`.\nWe provide the following helper function which adds a void context to any two parameter comparison function.\n\n```zig\npub fn addVoidContextToOrder(\n    comptime K: type,\n    comptime order: fn (lhs: K, rhs: K) std.math.Order,\n) fn (_: void, lhs: K, rhs: K) std.math.Order {\n    const tmp = struct {\n        pub fn do(_: void, lhs: K, rhs: K) std.math.Order {\n            return order(lhs, rhs);\n        }\n    };\n    return tmp.do;\n}\n```\n\nMoreover, if you wish for a default comparison operator, then try the following.\n\n```zig\npub fn defaultOrder(comptime K: type) fn (_: void, lhs: K, rhs: K) std.math.Order {\n    const tmp = struct {\n        pub fn do(_: void, lhs: K, rhs: K) std.math.Order {\n            switch (@typeInfo(K)) {\n                .Int, .Float, .Pointer, .ComptimeInt, .ComptimeFloat => return std.math.order(lhs, rhs),\n                .Array, .Vector => return std.mem.order(K, lhs, rhs),\n                else => @compileError(\"Unsupported type\"),\n            }\n        }\n    };\n    return tmp.do;\n}\n```\n\n## 4. Augmentation and options\n\nNotice that each of our layers of abstraction allow for options which augment the node.\n\n```zig\npub const Options = struct {\n    /// Indicates if each node of the tree should maintain a count of the\n    /// number of elements in its associated subtree\n    SubtreeSize: type = void,\n    /// Indicates if the color of a red-black tree node should be stored\n    /// as the least-significant bit of the parent pointer\n    store_color_in_parent_pointer: bool = true,\n    /// Gives any additional data which should be stored as part of each node.\n    /// This type is used in augmented red-black trees.\n    AdditionalNodeData: type = void,\n    /// Indicates if the implemenation should cache the first and/or last node\n    /// in the tree.\n    cache_nodes: ?struct {\n        /// cache the first node of the tree\n        first: bool = false,\n        /// cache the last node of the tree\n        last: bool = false,\n    } = null,\n};\n```\n\nMoreover, you can also specify some callbacks whihc can be run at relevant times during the update of the tree.\n\nFor an example of this see `./example/augmented_example.zig`.\n\n```zig\npub fn Callbacks(\n    comptime K: type,\n    comptime V: type,\n    comptime Context: type,\n    comptime options: NodeOptions,\n) type {\n    return struct {\n        const Node = RBNode.Node(\n            K,\n            V,\n            options,\n        );\n        /// This function will be run after every rotation of any subtree\n        afterRotate: ?fn (\n            ctx: Context,\n            old_subtree_root: *Node,\n            new_subtree_root: *Node,\n            dir: RBNode.Direction,\n        ) void = null,\n        /// This function will be run after the positions of two\n        /// nodes are swapped in the tree\n        ///\n        /// Note that swaps will only take place when one node\n        /// is an ancestor of another. After the swap,\n        ///\n        ///     `deep_unordered_node`\n        ///         will be the node farther away from the root.\n        ///         Note that this node may not be in its correct order\n        ///\n        ///     `shallow_node`\n        ///         will be the node closer to the root.\n        ///         This node is always in its correct order\n        ///\n        afterSwap: ?fn (\n            ctx: Context,\n            deep_unordered_node: *Node,\n            shallow_node: *Node,\n        ) void = null,\n        /// This function will be run after a new node has been\n        /// added as a leaf of the tree. Note that the tree may not be\n        /// correctly balanced at this point\n        afterLink: ?fn (\n            ctx: Context,\n            new_node: *Node,\n        ) void = null,\n        /// called after the color of a node is overwritten.\n        /// Node this is NOT called the affected node\n        /// is already covered by a call to `afterLink`\n        afterRecolor: ?fn (\n            ctx: Context,\n            nodes: []*Node,\n        ) void = null,\n        /// This function is called immediatly before a node is removed from the tree\n        beforeUnlink: ?fn (\n            ctx: Context,\n            node: *Node,\n        ) void = null,\n        /// This function is called after a node is removed from the tree\n        afterUnlink: ?fn (\n            ctx: Context,\n            node: *Node,\n        ) void = null,\n    };\n}\n```\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/14539473?v=4",
  "releases": [
    {
      "tag_name": "v1.1.1",
      "name": "v1.1.1",
      "body": "# Changes\r\n\r\nNow supports Zig version 0.15.1 as a minimum version.\r\n\r\n# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v1.1.1.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\n**(Note: the following code has changed from the previous release so that it matches Zig v0.15.1)**\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_module = b.createModule(.{\r\n            .root_source_file = b.path(\"src/main.zig\"),\r\n            .target = target,\r\n            .optimize = optimize,\r\n        }),\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-08-27T03:31:45Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v1.1.1",
      "assets": []
    },
    {
      "tag_name": "v1.1.0",
      "name": "v1.1.0",
      "body": "# Changes\r\n\r\nAdds the functions `advanceNext` and `advancePrev` to the `index_functions` namespace. These functions are also tested.\r\n\r\n# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v1.1.0.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-05-09T05:36:10Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v1.1.0",
      "assets": []
    },
    {
      "tag_name": "v1.0.2",
      "name": "v1.0.2",
      "body": "# Changes\r\n\r\nFixes issues with `clone` methods and adds tests to ensure that they work.\r\n\r\n# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v1.0.2.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-05-02T17:07:03Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v1.0.2",
      "assets": []
    },
    {
      "tag_name": "v1.0.1",
      "name": "v1.0.1",
      "body": "> [!WARNING]  \r\n> You should use version 1.0.2 instead of this version.\r\n\r\n# Changes\r\n\r\nThis release fixes issues with the functions `postfixPrev`, `prefixNext`, and `prefixPrev`; and issues with cached nodes.\r\nThis version all adds new tests to confirm that these new versions of the functions are correctly implemented.\r\n\r\n# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v1.0.1.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-05-02T15:06:31Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v1.0.1",
      "assets": []
    },
    {
      "tag_name": "v1.0.0",
      "name": "v1.0.0",
      "body": "> [!WARNING]  \r\n> You should use version 1.0.2 instead of this version.\r\n\r\n# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v1.0.0.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-05-02T06:16:00Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v1.0.0",
      "assets": []
    },
    {
      "tag_name": "v0.3.0",
      "name": "v0.3.0",
      "body": "# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.3.0.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-04-28T03:33:25Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v0.2.0",
      "name": "v0.2.0",
      "body": "# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.2.0.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `src/main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n```",
      "prerelease": false,
      "published_at": "2025-04-17T12:47:53Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "v0.1.0",
      "body": "# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.1.0.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const lib = b.addStaticLibrary(.{\r\n        .name = \"example-lib\",\r\n        .root_source_file = b.path(\"src/root.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    lib.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(lib);\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```",
      "prerelease": false,
      "published_at": "2025-02-15T11:09:20Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.1.0",
      "assets": []
    },
    {
      "tag_name": "v0.0.5",
      "name": "v0.0.5",
      "body": "# How to Use\r\n\r\nTo use this package, add it as a dependency by running the following command.\r\n\r\n```\r\nzig fetch --save https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.0.5.zip\r\n```\r\n\r\nThis will update your `build.zig.zon` file with the correct url and hash for the package.\r\n\r\nYou can then import this package as a module by adding the following to the main function of you `build.zig` file\r\n\r\n```zig\r\nconst rbtree = b.dependency(\"rbtree\", .{\r\n    .target = target,\r\n    .optimize = optimize,\r\n});\r\nconst rbtree_module = rbtree.module(\"rbtree\");\r\n```\r\n\r\nFor each dependency, you may then ads this module as follows:\r\n\r\n```zig\r\ndep.root_module.addImport(\"rbtree\", rbtree_module);\r\n```\r\n\r\n\r\n## Example\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const lib = b.addStaticLibrary(.{\r\n        .name = \"example-lib\",\r\n        .root_source_file = b.path(\"src/root.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    lib.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(lib);\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```",
      "prerelease": false,
      "published_at": "2024-10-02T19:33:48Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.0.5",
      "assets": []
    },
    {
      "tag_name": "v0.0.3",
      "name": "v0.0.3",
      "body": "To use this package:\r\n\r\nAdd it as a dependency in the `build.zig.zon` file for your project. For example:\r\n\r\n```zig\r\n.{\r\n    .name = \"your-package-name\",\r\n    .version = \"0.0.0\", // your package version\r\n    .dependencies = .{\r\n        .rbtree = .{\r\n            .url = \"https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.0.3.zip\",\r\n            .hash = \"1220b6c3f7e48c52969eb4537d3152b9e1221001c20f7bdbb6678949899a3b88973c\",\r\n        },\r\n    },\r\n    .paths = .{\"\"}, // your paths\r\n}\r\n```\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const lib = b.addStaticLibrary(.{\r\n        .name = \"example-lib\",\r\n        .root_source_file = b.path(\"src/root.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    lib.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(lib);\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```",
      "prerelease": false,
      "published_at": "2024-08-19T23:02:36Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.0.3",
      "assets": []
    },
    {
      "tag_name": "v0.0.2",
      "name": "v0.0.2",
      "body": "To use this package:\r\n\r\nAdd it as a dependency in the `build.zig.zon` file for your project. For example:\r\n\r\n```zig\r\n.{\r\n    .name = \"your-package-name\",\r\n    .version = \"0.0.0\", // your package version\r\n    .dependencies = .{\r\n        .rbtree = .{\r\n            .url = \"https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.0.2.zip\",\r\n            .hash = \"1220b8c6ec3374af5f8621fc2bcff76726065f53092137c66e172b0f5037dd7b6932\",\r\n        },\r\n    },\r\n    .paths = .{\"\"}, // your paths\r\n}\r\n```\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const lib = b.addStaticLibrary(.{\r\n        .name = \"example-lib\",\r\n        .root_source_file = b.path(\"src/root.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    lib.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(lib);\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```",
      "prerelease": false,
      "published_at": "2024-08-19T22:01:35Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.0.2",
      "assets": []
    },
    {
      "tag_name": "v0.0.1",
      "name": "v0.0.1",
      "body": "To use this package:\r\n\r\nAdd it as a dependency in the `build.zig.zon` file for your project. For example:\r\n\r\n```zig\r\n.{\r\n    .name = \"your-package-name\",\r\n    .version = \"0.0.0\", // your package version\r\n    .dependencies = .{\r\n        .rbtree = .{\r\n            .url = \"https://github.com/alexbishop/zig-rbtree/archive/refs/tags/v0.0.1.zip\",\r\n            .hash = \"122083a3e42c859bd0346d804a210de590d6fea362bbd57460a91a8904d573002db5\",\r\n        },\r\n    },\r\n    .paths = .{\"\"}, // your paths\r\n}\r\n```\r\n\r\nAdd the module to the appropriate libraries and executables in `build.zig`. For example:\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\n\r\npub fn build(b: *std.Build) void {\r\n    const target = b.standardTargetOptions(.{});\r\n    const optimize = b.standardOptimizeOption(.{});\r\n\r\n    // get the module for red-black trees\r\n    const rbtree = b.dependency(\"rbtree\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    const rbtree_module = rbtree.module(\"rbtree\");\r\n\r\n    const lib = b.addStaticLibrary(.{\r\n        .name = \"example-lib\",\r\n        .root_source_file = b.path(\"src/root.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    lib.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(lib);\r\n\r\n    const exe = b.addExecutable(.{\r\n        .name = \"example-exe\",\r\n        .root_source_file = b.path(\"src/main.zig\"),\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    // add the module\r\n    exe.root_module.addImport(\"rbtree\", rbtree_module);\r\n    b.installArtifact(exe);\r\n}\r\n```\r\n\r\nYou can now import it as `rbtree`: For example, the contents of `main.zig` could be\r\n\r\n```zig\r\nconst std = @import(\"std\");\r\nconst rbtreelib = @import(\"rbtree\");\r\n\r\npub const DefaultRBTree = rbtreelib.DefaultRBTree;\r\n\r\npub fn main() !void {\r\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\r\n    const allocator = gpa.allocator();\r\n\r\n    const Tree = DefaultRBTree(i32, f32);\r\n\r\n    var tree = Tree.init(allocator, void{});\r\n    defer tree.deinit();\r\n\r\n    // insert some stuff into the tree\r\n    var index: i32 = -19;\r\n    while (index < 20) : (index += 1) {\r\n        const value = std.math.pow(\r\n            f32,\r\n            0.5,\r\n            @floatFromInt(index),\r\n        );\r\n        try tree.put(index, value);\r\n    }\r\n\r\n    // print the contents of the tree\r\n    {\r\n        std.debug.print(\"First print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n\r\n    // remove some entries from the tree\r\n    _ = tree.remove(7);\r\n    _ = tree.remove(3);\r\n    _ = tree.remove(5);\r\n\r\n    // print it again\r\n    {\r\n        std.debug.print(\"\\nSecond print\\n\", .{});\r\n        var current: ?*Tree.Node = tree.findMin();\r\n        while (current) |c| : (current = c.next()) {\r\n            std.debug.print(\"Node {} -> {}\\n\", .{ c.key, c.value });\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```",
      "prerelease": false,
      "published_at": "2024-08-17T17:15:40Z",
      "html_url": "https://github.com/alexbishop/zig-rbtree/releases/tag/v0.0.1",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://alexbishop.github.io",
  "owner_twitter_username": null,
  "owner_followers": 1,
  "owner_following": 0,
  "owner_created_at": "2015-09-21T05:44:19Z",
  "license": "MIT",
  "category": "library"
}