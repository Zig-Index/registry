{
  "name": "zoop",
  "owner": "zhuyadong",
  "repo": "zoop",
  "description": "A Zig OOP solution",
  "type": "package",
  "topics": [
    "oop",
    "zig",
    "class",
    "interface",
    "zig-package"
  ],
  "stars": 34,
  "forks": 4,
  "watchers": 2,
  "updated_at": "2025-12-10T14:59:39Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.11.0",
  "readme": "# [中文](README.CN.md) | [English](README.md)\n# Zoop is an OOP solution for Zig\n\n## Install\nIn the project root directory:\n```shell\nzig fetch \"git+https://github.com/zhuyadong/zoop.git\" --save=zoop\n```\nIf you want to install a specific version:\n```shell\nzig fetch \"git+https://github.com/zhuyadong/zoop.git#<ref id>\" --save=zoop\n```\n\n## Define the class\n```zig\n// Define a class Human\npub const Human = struct {\n    // The first field of the zoop class must be aligned to `zoop.alignment`\n    name: []const u8 align(zoop.alignment),\n    age: u8 = 30,\n\n    // If there is no cleanup work, can skip define `deinit`\n    pub fn deinit(self: *Human) void {\n        self.name = \"\";\n    }\n\n    pub fn getName(self: *const Human) []const u8 {\n        return self.name;\n    }\n\n    pub fn setName(self: *Human, name: []const u8) void {\n        self.name = name;\n    }\n};\n```\n\n## Creating and destroying class objects\n```zig\nconst t = std.testing;\n\n// Create a `Human` on the heap\nvar phuman = try zoop.new(t.allocator, Human, null);\n// If the class field has a default value, the object field will be initialized to the default value\ntry t.expect(phuman.age == 30);\n// Destroy the object and release the memory.\n// If the class defines `deinit`, it will be called first and then release the memory.\nzoop.destroy(phuman);\n\n// Create a `Human` on the stack\nvar human = zoop.make(Human, null);\n// Access object fields through `ptr()`\ntry t.expect(human.ptr().age == 30);\n// Clean up the object (call `deinit` if any).\n// If there is no work to clean up, you don't need to call `zoop.destroy`\nzoop.destroy(human.ptr());\n\n// Both `zoop.new` and `zoop.make` support creation-time initialization\nphuman = try zoop.new(t.allocator, Human, .{.name = \"HeapObj\", .age = 1});\nhuman = zoop.make(Human, .{.name = \"StackObj\", .age = 2});\ntry t.expect(phuman.age == 1);\ntry t.expect(human.ptr().age == 2);\n```\nNote about `deinit`:\n`zoop.destroy` will sequentially call the `deinit` method of the class and all its parent classes\n\n## Inheritance\n```zig\n// Define `SuperMan`, inherit from `Human`, \n// the parent class must be the first field and the alignment is `zoop.alignment`,\n// The field name is arbitrary and does not have to be `super`, but it is recommended to use `super`\npub const SuperMan = struct {\n    super: Human align(zoop.alignment),\n    // SuperMan can live a long time, u8 can't satisfy it, we use u16\n    age: u16 = 9999,\n\n    pub fn getAge(self: *SuperMan) u16 {\n        return self.age;\n    }\n\n    pub fn setAge(self: *SuperMan, age: u16) void {\n        self.age = age;\n    }\n};\n\n// First create a `SuperMan` object\nvar psuperman = try zoop.new(t.allocator, SuperMan, null);\n//Call parent class method\npsuperman.super.setName(\"super\");\n// Or call the parent class method like this. This method is suitable for situations where the\n// inheritance hierarchy is too deep and you don't know which parent class implements the `setName` method.\n// In addition, since it is called `upcall`, it means that even if `SuperMan` implements `setName`,\n// The following call will still call the `setName` method of the nearest parent class\nzoop.upcall(psuperman, .setName, .{\"super\"});\n// You can also flexibly access all fields in the class inheritance tree. For example,\n// if you want to access the `Human.age` field, you can do this:\nvar phuman_age = zoop.getField(psuperman, \"age\", u8);\ntry t.expect(phuman_age.* == 30);\n// Access `SuperMan.age`, you can do this:\nvar psuper_age = zoop.getField(psuperman, \"age\", u16);\ntry t.expect(psuper_age.* == 9999);\n// Note that if two `age` are of the same type and both are called \"age\",\n// The above `zoop.getField` call will cause a compilation error to avoid bugs\n```\n\n## Class type conversion\n```zig\n// First create a Human and a SuperMan\nvar phuman = try zoop.new(t.allocator, Human, null);\nvar psuper = try zoop.new(t.allocator, SuperMan, null);\n\n// Subclasses can be converted to parent classes\nt.expect(zoop.as(psuper, Human) != null);\nt.expect(zoop.cast(psuper, Human).age == 30);\n// The parent class cannot be converted to a subclass (if `zoop.cast` is used, a compilation error will occur)\nt.expect(zoop.as(phuman, SuperMan) == null);\n// A parent class pointer to a subclass can be converted to a subclass\nphuman = zoop.cast(psuper, Human);\ntry t.expect(zoop.as(phuman, SuperMan) != null);\n```\n\n## Define the interface\n```zig\n// Define an interface `IName` for accessing names\npub const IName = struct {\n    // The interface can only define two fields, `ptr` and `vptr`,\n    // and the names and types must be the same as below\n    ptr: *anyopaque,\n    vptr: *anyopaque,\n\n    // Define the `getName` interface method\n    pub fn getName(self: IHuman) []const u8 {\n        return zoop.icall(self, .getName, .{});\n    }\n    // Define the `setName` interface method\n    pub fn setName(self: IHuman, name: []const u8) void {\n        zoop.icall(self, .setName, .{name});\n    }\n    // Don't worry about what `zoop.icall` is, just follow it\n};\n\n// Define another interface `IAge` for accessing age\npub const IAge = struct {\n    ptr: *anyopaque,\n    vptr: *anyopaque,\n\n    pub fn getAge(self: IHuman) u16 {\n        return zoop.icall(self, .getAge, .{});\n    }\n    pub fn setAge(self: IHuman, age: u16) void {\n        zoop.icall(self, .setAge, .{age});\n    }\n}\n\n// Interfaces can also be inherited\npub const INameAndAge struct {\n    pub const extends = .{IName, IAge};\n\n    ptr: *anyopaque,\n    vptr: *anyopaque,\n}\n\n// can specify exclude APIs.\n// Only methods defined in this interface can be specified,\n// and inherited methods will not be affected.\npub const INameAndAge struct {\n    pub const extends = .{IName, IAge};\n    // exclude “eql\" method\n    pub const excludes = .{\"eql\"};\n\n    ptr: *anyopaque,\n    vptr: *anyopaque,\n\n    pub fn eql(self: INameAndAge, other: INameAndAge) bool {\n        return self.ptr == other.ptr;\n    }\n}\n\n// Interfaces can also provide default implementations of methods,\n// so that classes that declare to implement interfaces can still\n// compile and work correctly without implementing these methods\n// (the interface becomes an abstract class)\npub const IName = struct {\n    ...// Same as above code\n\n    pub fn Default(comptime Class: type) type {\n        return struct {\n            pub fn getName(_: *Class) []const u8 {\n                return \"default name\";\n            }\n        }\n    }\n}\n```\n\n## Implementing the interface\n```zig\n// We let `Human` implement the `IName` interface\npub const Human = struct {\n    pub const extends = .{IName};\n    ...// Same as above code\n};\n\n// Let `SuperMan` implement the `IAge` interface\npub const SuperMan = struct {\n    pub const extends = .{IAge};\n    ...//Same as above code\n}\n// The interface implemented by the parent class is automatically implemented by the class,\n// so `SuperMan` also implements `IName`, although it only declares that it implements `IAge`.\n// A subclass can repeatedly declare that it implements an interface that has already been implemented \n// by its parent class. This will not cause any problems and will not affect the results.\n// For example, the following code is equivalent to the above:\npub const SuperMan = struct {\n    pub const extends = .{IAge, IName};\n    ...\n}\n```\n\n## Converting between classes and interfaces\n```zig\n// First create a Human and a SuperMan\nvar phuman = try zoop.new(t.allocator, Human, .{.name = \"human\"});\nvar psuper = try zoop.new(t.allocator, SuperMan, .{.super = .{.name = \"super\"}});\n\n// Human implements IName, so it can be converted\nvar iname = zoop.cast(phuman, IName);\n// SuperMan implements IAge, so it can be transferred\nvar iage = zoop.cast(psuper, IAge);\ntry t.expect(iage.getAge() == psuper.age);\ntry t.expectEqualStrings(iname.getName(), phuman.name);\n// Human does not implement IAge, so the conversion will fail.\n// (Note that now `iname` points to `phuman`, and `iage` points to `psuper`)\ntry t.expect(zoop.as(phuman, IAge) == null);\ntry t.expect(zoop.as(iname, IAge) == null);\n// Now let iname point to psuper\niname = zoop.cast(psuper, IName);\n// Or you can write it like this, but the performance is a little affected\n// (`cast` is O(1), while `as` is O(n) in the worst case n=the number of interfaces implemented by SuperMan)\niname = zoop.as(psuper, IName).?;\n// Now iname can be converted to IAge\ntry t.expect(zoop.as(iname, IAge) != null);\ntry t.expectEqualStrings(iname.getName(), \"super\");\n// Everything can be converted to zoop.IObject\ntry t.expect(zoop.as(phuman, zoop.IObject) != null);\ntry t.expect(zoop.as(psuper, zoop.IObject) != null);\n// Can also be converted back from IObject\nvar iobj = zoop.cast(psuper, zoop.IObject);\ntry t.expect(zoop.as(iobj, SuperMan).? == psuper);\n```\nTo summarize `cast` and `as`:\n- `cast` is applicable\n    - Subclass -> Parent class\n    - Sub-interface -> Parent interface\n    - Class -> Interfaces implemented by the class and its parent class\n- `as` is applicable\n    - All the cases where `cast` is applicable and not applicable (everything can be `as`)\n\n## Method overriding and virtual method calls\n```zig\n// If SuperMan overrides the getName method\npub const SuperMan = struct {\n    ...//Same as above\n\n    pub fn getName(_: *SuperMan) []const u8 {\n        return \"override\";\n    }\n}\n\n// Now IName.getName will call SuperMan.getName instead of Human.getName\nvar psuper = try zoop.new(t.allocator, SuperMan, .{.super = .{.name = \"human\"}});\nvar iname = zoop.cast(psuper, IName);\ntry t.expectEqualStrings(iname.getName(), \"override\");\n// Another style of calling interface methods\ntry t.expectEqualStrings(zoop.vcall(psuper, IName.getName, .{}), \"override\");\n// Virtual method calls are also useful for converted classes\nvar phuman = zoop.cast(psuper, Human);\niname = zoop.cast(phuman, IName);\ntry t.expectEqualStrings(iname.getName(), \"override\");\ntry t.expectEqualStrings(zoop.vcall(phuman, IName.getName, .{}), \"override\");\n```\nPerformance notes for `vcall`:\n`vcall` will use `cast` when possible, and `as` otherwise\n\n## `zoop.IObject.formatAny` for print\n`zoop.IObject` can conveniently output the string content of the object through the `format(...)` mechanism of `std.fmt`.\n```zig\n// define a class that implemented `zoop.IObject.formatAny`\npub const SomeClass = struct {\n    name:[]const u8 align(zoop.alignment) = \"some\";\n\n    pub fn formatAny(self: *SomeClass, writer: std.io.AnyWriter) anyerror!void {\n        try writer.print(\"SomeClass.name = {s}\", .{self.name});\n    }\n}\n\n// print string from `SomeClass.formatAny` \nconst psome = try zoop.new(t.allocator, SomeClass, null);\nstd.debug.print(\"{}\\n\", .{zoop.cast(psome, zoop.IObject)});\n// output: SomeClass.name = some\n```",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/910428?v=4",
  "releases": [
    {
      "tag_name": "0.2.4",
      "name": "0.2.4",
      "body": "update to zig 0.15.1",
      "prerelease": false,
      "published_at": "2025-09-01T12:53:52Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.2.4",
      "assets": []
    },
    {
      "tag_name": "0.2.3",
      "name": "0.2.3",
      "body": "update to zig 0.14",
      "prerelease": false,
      "published_at": "2025-03-08T11:54:31Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.2.3",
      "assets": []
    },
    {
      "tag_name": "0.2.2",
      "name": "0.2.2",
      "body": "make all function which return bool inline, otherwise if call without `comptime` will get wrong result.",
      "prerelease": false,
      "published_at": "2024-10-12T03:35:20Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.2.2",
      "assets": []
    },
    {
      "tag_name": "0.2.1",
      "name": "0.2.1",
      "body": "- interface support default implementing of method through: fn Default(comptime Class:type) type\r\n- bug fix",
      "prerelease": false,
      "published_at": "2024-09-27T00:05:11Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.2.1",
      "assets": []
    },
    {
      "tag_name": "0.2.0",
      "name": "0.2.0",
      "body": "no longer relies on usingnamespace and not compatible with 0.1.x",
      "prerelease": false,
      "published_at": "2024-09-18T07:38:04Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.2.0",
      "assets": []
    },
    {
      "tag_name": "0.1.9",
      "name": "0.1.9",
      "body": "fix bug that super class field not inited",
      "prerelease": false,
      "published_at": "2024-08-31T04:25:25Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.9",
      "assets": []
    },
    {
      "tag_name": "0.1.8",
      "name": "0.1.8",
      "body": "save binary space",
      "prerelease": false,
      "published_at": "2024-08-19T01:58:13Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.8",
      "assets": []
    },
    {
      "tag_name": "0.1.7",
      "name": "0.1.7",
      "body": "change implementation of zoop.makeTypeId()",
      "prerelease": false,
      "published_at": "2024-08-18T16:45:38Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.7",
      "assets": []
    },
    {
      "tag_name": "0.1.6",
      "name": "0.1.6",
      "body": "add zoop.type_id",
      "prerelease": false,
      "published_at": "2024-08-18T15:34:31Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.6",
      "assets": []
    },
    {
      "tag_name": "0.1.5",
      "name": "0.1.5",
      "body": "Support for non-rootptr objects to call destroy()",
      "prerelease": false,
      "published_at": "2024-08-17T09:43:35Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.5",
      "assets": []
    },
    {
      "tag_name": "0.1.4",
      "name": "0.1.4",
      "body": "update Class.format()",
      "prerelease": false,
      "published_at": "2024-08-14T17:48:46Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.4",
      "assets": []
    },
    {
      "tag_name": "0.1.3",
      "name": "0.1.3",
      "body": "add IObject.formatAny()",
      "prerelease": false,
      "published_at": "2024-08-14T17:36:44Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.3",
      "assets": []
    },
    {
      "tag_name": "0.1.2",
      "name": "0.1.2",
      "body": "add zoop.typeId()",
      "prerelease": false,
      "published_at": "2024-08-14T04:13:44Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.2",
      "assets": []
    },
    {
      "tag_name": "0.1.1",
      "name": "0.1.1",
      "body": "fix a bug in zoop.DefVtable",
      "prerelease": false,
      "published_at": "2024-08-09T09:00:21Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.1",
      "assets": []
    },
    {
      "tag_name": "0.1.0",
      "name": "0.1.0",
      "body": "First release",
      "prerelease": false,
      "published_at": "2024-08-08T12:57:21Z",
      "html_url": "https://github.com/zhuyadong/zoop/releases/tag/0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 14,
  "owner_following": 10,
  "owner_created_at": "2011-07-12T14:44:51Z",
  "license": "MIT",
  "category": "library"
}