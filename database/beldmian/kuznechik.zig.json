{
  "name": "kuznechik.zig",
  "owner": "beldmian",
  "repo": "kuznechik.zig",
  "description": "Kuznechik cipher implementation in pure zig",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-01-21T23:54:42Z",
  "readme": "# kuznechik.zig\n\nA fast implementation of the Kuznechik (GOST R 34.12-2015) block cipher in Zig. Kuznechik is a symmetric block cipher with a block size of 128 bits and a key length of 256 bits, standardized as GOST R 34.12-2015.\n\n## Features\n\n- Pure Zig implementation\n- Optimized using precomputed lookup tables\n- Includes both encryption and decryption\n- Performance benchmarks\n\n## Usage\n\n### Basic Example\n\n```zig\nconst kuznechik = @import(\"kuznechik\");\n\n// Initialize cipher with 256-bit key\nvar key = kuznechik.key{\n    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,\n    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,\n    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,\n    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,\n};\n\nvar cipher = kuznechik.Cipher.init(key);\n\n// Create a 128-bit block\nvar block = kuznechik.block{\n    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00,\n    0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,\n};\n\n// Encrypt\ncipher.encrypt(&block);\n\n// Decrypt\ncipher.decrypt(&block);\n```\n\n### Building\n\n```bash\nzig build\n```\n\n*To achieve better performance, compile with `-Doptimize=ReleaseFast`*\n\n### Running Tests\n\n```bash\nzig build test\n```\n\n### Running Benchmarks\n\n```bash\nzig build bench\n```\n\n### Fuzzing\n\nThis project includes fuzzing infrastructure using AFL++ to continuously test cipher properties and discover edge cases.\n\n**Quick Links:**\n- [Comprehensive Fuzzing Guide](docs/FUZZING.md) - Detailed documentation on AFL++ usage\n- [Helper Scripts](#helper-scripts) - Convenient scripts for common fuzzing workflows\n\n#### Available Fuzzers\n\n1. **roundtrip** - Tests encryption/decryption round-trip property\n2. **key_schedule** - Tests key schedule generation and validation\n3. **ls_roundtrip** - Tests LS (Linear Substitution) transformation round-trip property\n\n#### Installation\n\n**macOS:**\n```bash\nbrew install afl++\n```\n\n**Linux (Debian/Ubuntu):**\n```bash\nsudo apt-get install afl++\n```\n\n**Linux (Fedora/RHEL):**\n```bash\nsudo dnf install afl++\n```\n\nVerify your installation:\n```bash\nafl-fuzz --version\n```\n\n#### Building Fuzzers\n\nBuild a specific fuzzer:\n```bash\nzig build fuzz-ls-roundtrip\n```\n\nBuild all fuzzers:\n```bash\nzig build fuzz-build\n```\n\n#### Helper Scripts\n\nConvenience scripts are provided in the `scripts/` directory for common fuzzing workflows:\n\n**Quick Start (Dumb Mode - Works Everywhere):**\n```bash\n./scripts/fuzz-dumb.sh ls_roundtrip\n```\n\n**QEMU Mode (Binary Instrumentation - Recommended):**\n```bash\n./scripts/fuzz-qemu.sh ls_roundtrip\n```\n\n**Parallel Fuzzing (Multiple Instances):**\n```bash\n./scripts/fuzz-parallel.sh ls_roundtrip dumb 4  # 4 parallel instances\n./scripts/fuzz-parallel.sh ls_roundtrip qemu 4  # with QEMU mode\n```\n\n**View Statistics:**\n```bash\n./scripts/fuzz-stats.sh\n```\n\n**Reproduce a Crash:**\n```bash\n./scripts/fuzz-reproduce.sh ls_roundtrip test/fuzz/output/ls_roundtrip_dumb/default/crashes/id:000000,...\n```\n\n**Clean Output Directories:**\n```bash\n./scripts/fuzz-clean.sh\n```\n\n**All Scripts:**\n- `fuzz-dumb.sh` - Run AFL++ in dumb mode (no instrumentation)\n- `fuzz-qemu.sh` - Run AFL++ in QEMU mode (binary instrumentation)\n- `fuzz-parallel.sh` - Run multiple AFL++ instances in parallel\n- `fuzz-stats.sh` - Display statistics for all fuzzing sessions\n- `fuzz-reproduce.sh` - Reproduce crashes found by AFL++\n- `fuzz-clean.sh` - Clean up fuzzing output directories\n\n#### Running Fuzzers\n\n**Quick Start with Helper Scripts:**\n\nThe easiest way to start fuzzing is using the provided helper scripts:\n\n```bash\n# Dumb mode (works everywhere, no setup required)\n./scripts/fuzz-dumb.sh ls_roundtrip\n\n# QEMU mode (recommended, requires AFL++ built with QEMU support)\n./scripts/fuzz-qemu.sh ls_roundtrip\n\n# Parallel fuzzing (4 instances for better coverage)\n./scripts/fuzz-parallel.sh ls_roundtrip dumb 4\n```\n\n**Manual AFL++ Usage:**\n\nIf you prefer to use AFL++ directly:\n\n**Important Note:** Zig uses its own compiler backend which does not support AFL++'s compile-time instrumentation. To use AFL++ with Zig binaries, you must use one of the following modes:\n\n**Option 1: Dumb Mode (No instrumentation, simplest)**\n```bash\n# Build the fuzzer first\nzig build fuzz-ls-roundtrip\n\n# Run AFL++ in dumb mode (-n flag)\n# This mode doesn't use coverage guidance but still provides mutation and crash detection\nafl-fuzz -n -i test/fuzz/corpus/ls_roundtrip -o test/fuzz/output/ls_roundtrip -- ./zig-out/bin/ls_roundtrip\n```\n\n**Option 2: QEMU Mode (Binary instrumentation, recommended for Zig)**\n```bash\n# Install AFL++ with QEMU mode (requires building from source)\n# See: https://github.com/AFLplusplus/AFLplusplus#qemu-mode\n\n# Run AFL++ with QEMU mode (-Q flag)\nafl-fuzz -Q -i test/fuzz/corpus/ls_roundtrip -o test/fuzz/output/ls_roundtrip -- ./zig-out/bin/ls_roundtrip\n```\n\n**Option 3: FRIDA Mode (Dynamic instrumentation)**\n```bash\n# Install FRIDA and AFL++ FRIDA mode\n# See: https://github.com/AFLplusplus/AFLplusplus#frida-mode\n\n# Run AFL++ with FRIDA mode (-O flag)\nafl-fuzz -O -i test/fuzz/corpus/ls_roundtrip -o test/fuzz/output/ls_roundtrip -- ./zig-out/bin/ls_roundtrip\n```\n\n**For more detailed information, see [FUZZING.md](docs/FUZZING.md)**\n\n#### Understanding Results\n\nAFL++ creates an output directory with the following structure:\n\n```\ntest/fuzz/output/ls_roundtrip/\n├── default/\n│   ├── crashes/          # Inputs that triggered crashes\n│   ├── hangs/            # Inputs that caused timeouts\n│   ├── queue/            # Interesting inputs discovered\n│   └── fuzzer_stats      # Statistics and progress\n```\n\n**Crashes:**\n- Check `default/crashes/` for files that triggered assertion failures or panics\n- Each crash file contains the input that reproduces the issue\n- Run the fuzzer directly with a crash file to reproduce: `./zig-out/bin/ls_roundtrip < default/crashes/id:000000...`\n\n**Hangs:**\n- Inputs in `default/hangs/` exceeded the timeout threshold (default: 1 second)\n- May indicate infinite loops or performance issues\n- Adjust timeout with AFL++'s `-t` option\n\n**Statistics:**\n- Monitor `default/fuzzer_stats` for execution speed, coverage, and discovered paths\n- `execs_per_sec`: Executions per second (higher is better)\n- `unique_crashes`: Total unique crashes found\n- `saved_crashes`: Crashes saved to disk\n\n#### Testing Fuzzers Standalone\n\nValidate that fuzz harnesses work correctly without AFL++:\n```bash\nzig build fuzz-test\n```\n\n## Performance\n\nThe implementation is optimized using precomputed lookup tables for the S-box, inverse S-box, and linear transformations. Benchmark results on Apple M2:\n\n```\nRunning benchmark: Encrypt Benchmark (65535 iterations)\nEncrypt Benchmark:\n  Iterations: 65535\n  Total time: 5056195 ns\n  Average time: 77 ns\n  Min time: 0 ns\n  Max time: 18375 ns\n\nRunning benchmark: Decrypt Benchmark (65535 iterations)\nDecrypt Benchmark:\n  Iterations: 65535\n  Total time: 5698981 ns\n  Average time: 86 ns\n  Min time: 0 ns\n  Max time: 10167 ns\n```\n\n\n## Algorithm Details\n\nKuznechik is a symmetric block cipher that operates on 128-bit blocks using a 256-bit key. The encryption process consists of:\n- 10 rounds of transformations\n- Key schedule generating 10 round keys\n- Each round applies:\n  - Key addition (XOR)\n  - Substitution layer (S-box)\n  - Linear transformation (L)\n\n## References\n\n- [RFC 7801 - GOST R 34.12-2015](https://www.rfc-editor.org/rfc/rfc7801.html)\n- [Implementation of «Kuznyechik» cipher using vector instructions](https://www.researchgate.net/publication/346964920_Implementation_of_Kuznyechik_cipher_using_vector_instructions)\n## License\n\nMIT License - see the [LICENSE](LICENSE) file for details.\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## Future Plans\n\n- [x] Add fuzzing harnesses (encryption/decryption round-trip, key schedule, LS transformation)\n- [ ] Improve performance further\n- [ ] Add cipher operation modes (CTR, CBC, GCM, etc.)\n\n## Author\n\n[beldmian](https://github.com/beldmian)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/33232961?u=a7e828bbad6383fa16d30a8ab95ceb73a1d0ff04&v=4",
  "releases": [
    {
      "tag_name": "v0.2.0",
      "name": "v0.2.0 Small performance and code improvements",
      "body": "## What's Changed\r\n* Refactoring by @beldmian in https://github.com/beldmian/kuznechik.zig/pull/1\r\n\r\n## New Contributors\r\n* @beldmian made their first contribution in https://github.com/beldmian/kuznechik.zig/pull/1\r\n\r\n**Full Changelog**: https://github.com/beldmian/kuznechik.zig/compare/v0.1.0...v0.2.0",
      "prerelease": false,
      "published_at": "2025-04-24T15:54:15Z",
      "html_url": "https://github.com/beldmian/kuznechik.zig/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "v0.1.0 Initial release ",
      "body": "**Full Changelog**: https://github.com/beldmian/kuznechik.zig/commits/v0.1.0",
      "prerelease": false,
      "published_at": "2025-02-09T10:23:59Z",
      "html_url": "https://github.com/beldmian/kuznechik.zig/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_company": "go dev @ozontech",
  "owner_location": "Moscow, Russian Federation",
  "owner_blog": "beldmian.ru",
  "owner_twitter_username": null,
  "owner_followers": 13,
  "owner_following": 16,
  "owner_created_at": "2017-10-30T18:27:38Z",
  "license": "MIT",
  "category": "library"
}