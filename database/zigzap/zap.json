{
  "name": "zap",
  "owner": "zigzap",
  "repo": "zap",
  "description": "blazingly fast backends in zig",
  "type": "package",
  "topics": [
    "http",
    "zig",
    "blazingly",
    "fast",
    "rest",
    "api",
    "zig-package"
  ],
  "stars": 3152,
  "forks": 103,
  "watchers": 30,
  "updated_at": "2025-12-08T06:00:04Z",
  "readme": "# ‚ö°zap‚ö° - blazingly fast backends in zig\n\n![](https://github.com/zigzap/zap/actions/workflows/build-current-zig.yml/badge.svg) ![](https://github.com/zigzap/zap/actions/workflows/mastercheck.yml/badge.svg) [![Discord](https://img.shields.io/discord/1107835896356675706?label=chat&logo=discord&style=plastic)](https://discord.gg/jQAAN6Ubyj)\n\nZap is the [zig](https://ziglang.org) replacement for the REST APIs I used to\nwrite in [python](https://python.org) with\n[Flask](https://flask.palletsprojects.com) and\n[mongodb](https://www.mongodb.com), etc. It can be considered to be a\nmicroframework for web applications.\n\nWhat I needed as a replacement was a blazingly fast and robust HTTP server that\nI could use with Zig, and I chose to wrap the superb evented networking C\nlibrary [facil.io](https://facil.io). Zap wraps and patches [facil.io - the C\nweb application framework](https://facil.io).\n\n## **‚ö°ZAP‚ö° IS FAST, ROBUST, AND STABLE**\n\n\nAfter having used ZAP in production for years, I can confidently assert that it\nproved to be:\n\n- ‚ö° **blazingly fast** ‚ö°\n- üí™ **extremely robust** üí™\n\n## FAQ:\n\n- Q: **What version of Zig does Zap support?**\n    - Zap uses the latest stable zig release (0.15.1), so you don't have to keep\n      up with frequent breaking changes. It's an \"LTS feature\".\n- Q: **Can Zap build with Zig's master branch?**\n    - See the `zig-master` branch. Please note that the zig-master branch is not\n      the official master branch of ZAP. Be aware that I don't provide tagged\n      releases for it. If you know what you are doing, that shouldn't stop you\n      from using it with zig master though.\n- Q: **Where is the API documentation?**\n    - Docs are a work in progress. You can check them out\n      [here](https://zigzap.org/zap).\n    - Run `zig build run-docserver` to serve them locally.\n- Q: **Does ZAP work on Windows?**\n    - No. This is due to the underlying facil.io C library. Future versions\n      of facil.io might support Windows but there is no timeline yet. Your best\n      options on Windows are **WSL2 or a docker container**.\n- Q: **Does ZAP support TLS / HTTPS?**\n    - Yes, ZAP supports using the system's openssl. See the\n      [https](./examples/https/https.zig) example and make sure to build with\n      the `-Dopenssl` flag or the environment variable `ZAP_USE_OPENSSL=true`:\n      - `.openssl = true,` (in dependent projects' build.zig,\n        `b.dependency(\"zap\" .{...})`)\n      - `ZAP_USE_OPENSSL=true zig build https`\n      - `zig build -Dopenssl=true https`\n\n## Here's what works\n\nI recommend checking out **the new App-based** or the Endpoint-based\nexamples, as they reflect how I intended Zap to be used.\n\nMost of the examples are super stripped down to only include what's necessary to\nshow a feature.\n\n**To see API docs, run `zig build run-docserver`.** To specify a custom\nport and docs dir: `zig build docserver && zig-out/bin/docserver --port=8989\n--docs=path/to/docs`.\n\n### New App-Based Examples\n\n- **[app_basic](examples/app/basic.zig)**: Shows how to use zap.App with a\nsimple Endpoint.\n- **[app_auth](examples/app/auth.zig)**: Shows how to use zap.App with an\nEndpoint using an Authenticator.\n\nSee the other examples for specific uses of Zap.\n\nBenefits of using `zap.App`:\n\n- Provides a global, user-defined \"Application Context\" to all endpoints.\n- Made to work with \"Endpoints\": an endpoint is a struct that covers a `/slug`\n  of the requested URL and provides a callback for each supported request method\n  (get, put, delete, options, post, head, patch).\n- Each request callback receives:\n  - a per-thread arena allocator you can use for throwaway allocations without\n    worrying about freeing them.\n  - the global \"Application Context\" of your app's choice\n- Endpoint request callbacks are allowed to return errors:\n  - you can use `try`.\n  - the endpoint's ErrorStrategy defines if runtime errors should be reported to\n    the console, to the response (=browser for debugging), or if the error\n    should be returned.\n\n### Legacy Endpoint-based examples\n\n- **[endpoint](examples/endpoint/)**: a simple JSON REST API example featuring a\n  `/users` endpoint for performing PUT/DELETE/GET/POST operations and listing\n  users, together with a simple frontend to play with. **It also introduces a\n  `/stop` endpoint** that shuts down Zap, so **memory leak detection** can be\n  performed in main().\n    - Check out how [main.zig](examples/endpoint/main.zig) uses ZIG's awesome\n      `GeneralPurposeAllocator` to report memory leaks when ZAP is shut down.\n      The [StopEndpoint](examples/endpoint/stopendpoint.zig) just stops ZAP when\n      receiving a request on the `/stop` route.\n- **[endpoint authentication](examples/endpoint_auth/endpoint_auth.zig)**: a\n  simple authenticated endpoint. Read more about authentication\n  [here](./doc/authentication.md).\n\n\n### Legacy Middleware-Style examples\n\n- **[MIDDLEWARE support](examples/middleware/middleware.zig)**: chain together\n  request handlers in middleware style. Provide custom context structs, totally\n  type-safe. If you come from GO this might appeal to you.\n- **[MIDDLEWARE with endpoint\n  support](examples/middleware_with_endpoint/middleware_with_endpoint.zig)**:\n  Same as the example above, but this time we use an endpoint at the end of the\n  chain, by wrapping it via `zap.Middleware.EndpointHandler`. Mixing endpoints\n  in your middleware chain allows for usage of Zap's authenticated endpoints and\n  your custom endpoints. Since Endpoints use a simpler API, you have to use\n  `r.setUserContext()` and `r.getUserContext()` with the request if you want to\n  access the middleware context from a wrapped endpoint. Since this mechanism\n  uses an `*anyopaque` pointer underneath (to not break the Endpoint API), it is\n  less type-safe than `zap.Middleware`'s use of contexts.\n- [**Per Request Contexts**](./src/zap.zig#L102) : With the introduction of\n  `setUserContext()` and `getUserContext()`, you can, of course use those two in\n  projects that don't use `zap.Endpoint` or `zap.Middleware`, too, if you\n  really, really, absolutely don't find another way to solve your context\n  problem. **We recommend using a `zap.Endpoint`** inside of a struct that\n  can provide all the context you need **instead**. You get access to your\n  struct in the callbacks via the `@fieldParentPtr()` trick that is used\n  extensively in Zap's examples, like the [endpoint\n  example](examples/endpoint/endpoint.zig).\n\n### Specific and Very Basic Examples\n\n- **[hello](examples/hello/hello.zig)**: welcomes you with some static HTML\n- **[routes](examples/routes/routes.zig)**: a super easy example dispatching on\n  the HTTP path. **NOTE**: The dispatch in the example is a super-basic\n  DIY-style dispatch. See endpoint-based examples for more realistic use cases.\n- [**simple_router**](examples/simple_router/simple_router.zig): See how you\n  can use `zap.Router` to dispatch to handlers by HTTP path.\n- **[serve](examples/serve/serve.zig)**: the traditional static web server with\n  optional dynamic request handling\n- **[sendfile](examples/sendfile/sendfile.zig)**: simple example of how to send\n  a file, honoring compression headers, etc.\n- **[bindataformpost](examples/bindataformpost/bindataformpost.zig)**: example\n  to receive binary files via form post.\n- **[hello_json](examples/hello_json/hello_json.zig)**: serves you json\n  dependent on HTTP path\n- **[mustache](examples/mustache/mustache.zig)**: a simple example using\n  [mustache](https://mustache.github.io/) templating.\n- **[http parameters](examples/http_params/http_params.zig)**: a simple example\n  sending itself query parameters of all supported types.\n- **[cookies](examples/cookies/cookies.zig)**: a simple example sending itself a\n  cookie and responding with a session cookie.\n- **[websockets](examples/websockets/)**: a simple websockets chat for the\n  browser.\n- **[Username/Password Session\n  Authentication](./examples/userpass_session_auth/)**: A convenience\n  authenticator that redirects un-authenticated requests to a login page and\n  sends cookies containing session tokens based on username/password pairs\n  received via POST request.\n- [**Error Trace Responses**](./examples/senderror/senderror.zig): You can now\n  call `r.sendError(err, status_code)` when you catch an error and a stack trace\n  will be returned to the client / browser.\n- [**HTTPS**](examples/https/https.zig): Shows how easy it is to use facil.io's\n  openssl support. Must be compiled with `-Dopenssl=true` or the environment\n  variable `ZAP_USE_OPENSSL` set to `true` and requires openssl dev dependencies\n  (headers, lib) to be installed on the system.\n  - run it like this: `ZAP_USE_OPENSSL=true zig build run-https`\n    OR like this: `zig build -Dopenssl=true run-https`\n  - it will tell you how to generate certificates\n\n\n## ‚ö°blazingly fast‚ö°\n\nClaiming to be blazingly fast is the new black. At least, Zap doesn't slow you\ndown and if your server performs poorly, it's probably not exactly Zap's fault.\nZap relies on the [facil.io](https://facil.io) framework and so it can't really\nclaim any performance fame for itself. In this initial implementation of Zap,\nI didn't care about optimizations at all.\n\nBut, how fast is it? Being blazingly fast is relative. When compared with a\nsimple GO HTTP server, a simple Zig Zap HTTP server performed really well on my\nmachine (x86_64-linux):\n\n- Zig Zap was nearly 30% faster than GO\n- Zig Zap had over 50% more throughput than GO\n- **YMMV!!!**\n\nSo, being somewhere in the ballpark of basic GO performance, zig zap seems to be\n... of reasonable performance üòé.\n\nI can rest my case that developing ZAP was a good idea because it's faster than\nboth alternatives: a) staying with Python, and b) creating a GO + Zig hybrid.\n\n### On (now missing) Micro-Benchmarks\n\nI used to have some micro-benchmarks in this repo, showing that Zap beat all the\nother things I tried, and eventually got tired of the meaningless discussions\nthey provoked, the endless issues and PRs that followed, wanting me to add and\nmaintain even more contestants, do more justice to beloved other frameworks,\netc.\n\nCase in point, even for me the micro-benchmarks became meaningless. They were\njust some rough indicator to me confirming that I didn't do anything terribly\nwrong to facil.io, and that facil.io proved to be a reasonable choice, also from\na performance perspective.\n\nHowever, none of the projects I use Zap for, ever even remotely resembled\nanything close to a static HTTP response micro-benchmark.\n\nFor my more CPU-heavy than IO-heavy use-cases, a thread-based microframework\nthat's super robust is still my preferred choice, to this day.\n\nHaving said that, I would **still love** for other, pure-zig HTTP frameworks to\neventually make Zap obsolete. Now, in 2025, the list of candidates is looking\nreally promising.\n\n### üì£ Shout-Outs\n\n- [http.zig](https://github.com/karlseguin/http.zig) : Pure Zig! Close to Zap's\n  model. Performance = good!\n- [jetzig](https://github.com/jetzig-framework/jetzig) : Comfortably develop\n  modern web applications quickly, using http.zig under the hood\n- [zzz](https://github.com/tardy-org/zzz) : Super promising, super-fast,\n  especially for IO-heavy tasks, io_uring support - need I say more?\n\n\n## üí™ Robust\n\nZAP is **very robust**. In fact, it is so robust that I was confidently able to\nonly work with in-memory data (RAM) in all my ZAP projects so far: over 5 large\nonline research experiments. No database, no file persistence, until I hit\n\"save\" at the end üòä.\n\nSo I was able to postpone my cunning data persistence strategy that's similar to\na mark-and-sweep garbage collector and would only persist \"dirty\" data when\ntraffic is low, in favor of getting stuff online more quickly. But even if\nimplemented, such a persistence strategy is risky because when traffic is not\nlow, it means the system is under (heavy) load. Would you confidently NOT save\ndata when load is high and the data changes most frequently -> the potential\ndata loss is maximized?\n\nTo answer that question, I just skipped it. I skipped saving any data until\nreceiving a \"save\" signal via API. And it worked. ZAP just kept on zapping. When\ntraffic calmed down or all experiment participants had finished, I hit \"save\"\nand went on analyzing the data.\n\nHandling all errors does pay off after all. No hidden control flow, no hidden\nerrors or exceptions is one of Zig's strengths.\n\nTo be honest: There are still pitfalls. E.g. if you request large stack sizes\nfor worker threads, Zig won't like that and panic. So make sure you don't have\nlocal variables that require tens of megabytes of stack space.\n\n\n### üõ°Ô∏è Memory-safe\n\nSee the [StopEndpoint](examples/endpoint/stopendpoint.zig) in the\n[endpoint](examples/endpoint) example. The `StopEndpoint` just stops ZAP when\nreceiving a request on the `/stop` route. That example uses ZIG's awesome\n`GeneralPurposeAllocator` in [main.zig](examples/endpoint/main.zig) to report\nmemory leaks when ZAP is shut down.\n\nYou can use the same strategy in your debug builds and tests to check if your\ncode leaks memory.\n\n\n\n## Getting started\n\nMake sure you have **zig 0.15.1** installed. Fetch it from\n[here](https://ziglang.org/download).\n\n```shell\n$ git clone https://github.com/zigzap/zap.git\n$ cd zap\n$ zig build run-hello\n$ # open http://localhost:3000 in your browser\n```\n... and open [http://localhost:3000](http://localhost:3000) in your browser.\n\n## Using ‚ö°zap‚ö° in your own projects\n\nMake sure you have **the latest zig release (0.15.1)** installed. Fetch it from\n[here](https://ziglang.org/download).\n\nIf you don't have an existing zig project, create one like this:\n\n```shell\n$ mkdir zaptest && cd zaptest\n$ zig init\n```\n\nWith an existing Zig project, adding Zap to it is easy:\n\n1. Zig fetch zap\n2. Add zap to your `build.zig`\n\nIn your zig project folder (where `build.zig` is located), run:\n\n<!-- INSERT_DEP_BEGIN -->\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.11.0\"\n```\n<!-- INSERT_DEP_END -->\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n\nFrom then on, you can use the Zap package in your project via `const zap =\n@import(\"zap\");`. Check out the examples to see how to use Zap.\n\n\n## Contribute to ‚ö°zap‚ö° - blazingly fast\n\nAt the current time, I can only add to zap what I need for my personal and\nprofessional projects. While this happens **blazingly fast**, some if not all\nnice-to-have additions will have to wait. You are very welcome to help make the\nworld a blazingly fast place by providing patches or pull requests, add\ndocumentation or examples, or interesting issues and bug reports - you'll know\nwhat to do when you receive your calling üëº.\n\n**We have our own [ZAP discord](https://discord.gg/jQAAN6Ubyj) server!!!**\n\n## Support ‚ö°zap‚ö°\n\nBeing blazingly fast requires a constant feed of caffeine. I usually manage to\nprovide that to myself for myself. However, to support keeping the juices\nflowing and putting a smile on my face and that warm and cozy feeling into my\nheart, you can always [buy me a coffee](https://buymeacoffee.com/renerocksai)\n‚òï. All donations are welcomed üôè blazingly fast! That being said, just saying\n\"hi\" also works wonders with the smiles, warmth, and coziness üòä.\n\n## Examples\n\nYou build and run the examples via:\n\n```shell\n$ zig build [EXAMPLE]\n$ ./zig-out/bin/[EXAMPLE]\n```\n\n... where `[EXAMPLE]` is one of `hello`, `routes`, `serve`, ... see the [list of\nexamples above](#heres-what-works).\n\nExample: building and running the hello example:\n\n```shell\n$ zig build hello\n$ ./zig-out/bin/hello\n```\n\nTo just run an example, like `routes`, without generating an executable, run:\n\n```shell\n$ zig build run-[EXAMPLE]\n```\n\nExample: building and running the routes example:\n\n```shell\n$ zig build run-routes\n```\n\n### [hello](examples/hello/hello.zig)\n\n```zig\nconst std = @import(\"std\");\nconst zap = @import(\"zap\");\n\nfn on_request(r: zap.Request) !void {\n    if (r.path) |the_path| {\n        std.debug.print(\"PATH: {s}\\n\", .{the_path});\n    }\n\n    if (r.query) |the_query| {\n        std.debug.print(\"QUERY: {s}\\n\", .{the_query});\n    }\n    r.sendBody(\"<html><body><h1>Hello from ZAP!!!</h1></body></html>\") catch return;\n}\n\npub fn main() !void {\n    var listener = zap.HttpListener.init(.{\n        .port = 3000,\n        .on_request = on_request,\n        .log = true,\n    });\n    try listener.listen();\n\n    std.debug.print(\"Listening on 0.0.0.0:3000\\n\", .{});\n\n    // start worker threads\n    zap.start(.{\n        .threads = 2,\n        .workers = 2,\n    });\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/125233599?v=4",
  "releases": [
    {
      "tag_name": "v0.11.0",
      "name": "Release v0.11.0",
      "body": "# ZAP Release v0.11.0\n\n## Updates\n\nUpdate to Zig 0.15.1\n\nThis release introduces breaking changes that basically come from\n\"unmanaged\" containers being the default in Zig's std library now. The\nrest of Zap hasn't really changed much.\n\nAll examples and tests have been updated.\n\nAlso, the following contributions made it into the release:\n\n* 3c22e9d - chore: update to latest zig version <Tesseract22>\n* 512c630 - feat: tweak support for additional cookie fields <Michael Pollind>\n* 6174c3e - feat: add parition support for cookies in facil.io  <Michael Pollind>\n\nThanks Tesseract22 who kicked off the 0.15 work and Michael!\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.11.0\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": false,
      "published_at": "2025-08-28T21:39:50Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.11.0",
      "assets": []
    },
    {
      "tag_name": "v0.10.6",
      "name": "Release v0.10.6",
      "body": "# ZAP Release v0.10.6\n\n## Updates\n\nBugfix release:\n\nThe latest changes to parsing the mimetype of uploaded files required a\ntype check, as, apparently, they _can_ also be arrays instead of\nstrings.\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.6\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": false,
      "published_at": "2025-07-25T00:00:51Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.6",
      "assets": []
    },
    {
      "tag_name": "v0.10.5",
      "name": "Release v0.10.5",
      "body": "# ZAP Release v0.10.5\n\n## Updates\n\nA quick one. I was so fascinated by @TesseractCat's PR that I implemented\nthe same logic for all other forms of endpoints: regular endpoints,\nauthenticating endpoints, and middleware endpoints.\n\n- see #171 from Tesseract22 : provide defaults to unprovided method\n  handlers in zap.App\n- the default handlers now return 405 - method not allowed, and also log\n  a message\n\nI also fixed port numbers in tests so they don't cross-talk to each\nother when run in parallel by the zig test runner.\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.5\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": false,
      "published_at": "2025-07-23T18:32:57Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.5",
      "assets": []
    },
    {
      "tag_name": "v0.10.4",
      "name": "Release v0.10.4",
      "body": "# ZAP Release v0.10.4\n\n## Updates\n\nFor some reason, the zon version hadn't come through before creating the\ntag.\n\nThis time it will work üòÑ\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.4\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": false,
      "published_at": "2025-07-23T00:26:07Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.4",
      "assets": []
    },
    {
      "tag_name": "v0.10.3",
      "name": "Release v0.10.3",
      "body": "# ZAP Release v0.10.3\n\n## Updates\n\nSorry I (again) forgot to bump the version in build.zig.zon\n\nTo avoid confusion, I created this release. It's identical to v0.10.2,\nbut with the zon version fixed, so it will show up with the correct\nversion in your zon files after a zig fetch.\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.3\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": false,
      "published_at": "2025-07-23T00:10:44Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.3",
      "assets": []
    },
    {
      "tag_name": "v0.10.2",
      "name": "Release v0.10.2",
      "body": "# ZAP Release v0.10.2\n\n## Updates\n\nHi, it's been a while, and I've almost had no time for zap. However, ...\n\n..., eventually I got to merge the following amazing PRs:\n\n- #171 from Tesseract22 : provide defaults to unprovided method handlers in\n  zap.App\n- the default handlers now return 405 - method not allowed, and also log a\n  message\n\n- #167 from yanis-fourel : file-uploads with missing content-type will default\n  to application/octet-stream\n\n- #164 fwfurtado : added handlers for HEAD requests in Endpoints\n\n- #161 from unorsk : fixed example in the README\n\n- support for unhandledError() in zap.App's Context\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.2\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": false,
      "published_at": "2025-07-23T00:06:38Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.2",
      "assets": []
    },
    {
      "tag_name": "v0.10.1",
      "name": "Release v0.10.1",
      "body": "# ZAP Release v0.10.1\r\n\r\n## Updates\r\n\r\n__Rebased Zap's logging on Zig's std.log__\r\n\r\nZap's logging is now based on zig's `std.log`.\r\n\r\nYou can set a custom log level just for Zap in your Zig projects like\r\nthis:\r\n\r\n```ts\r\npub const std_options: std.Options = .{\r\n    // general log level\r\n    .log_level = .info,\r\n    .log_scope_levels = &[_]std.log.ScopeLevel{\r\n        // log level specific to zap\r\n        .{ .scope = .zap, .level = .debug },\r\n    },\r\n};\r\n```\r\n\r\nLow-level access to facil.io's logging facilities is provided by\r\n`zap.Logging`.\r\n\r\n\r\n\r\n## Using it\r\n\r\nIn your zig project folder (where `build.zig` is located), run:\r\n\r\n```\r\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.1\"\r\n```\r\n\r\nThen, in your `build.zig`'s `build` function, add the following before\r\n`b.installArtifact(exe)`:\r\n\r\n```zig\r\n    const zap = b.dependency(\"zap\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n        .openssl = false, // set to true to enable TLS support\r\n    });\r\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\r\n```\r\n",
      "prerelease": false,
      "published_at": "2025-04-01T14:41:52Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.1",
      "assets": []
    },
    {
      "tag_name": "v0.10.0",
      "name": "Release v0.10.0",
      "body": "# ZAP Release v0.10.0\r\n\r\n## Updates\r\n\r\n**What's new in ZAP?**\r\n\r\n- Upgraded to Zig 0.14!\r\n- Breaking Changes for `zap.Endpoint`\r\n- New `zap.App`!\r\n- Updated README\r\n- Contributions!\r\n\r\nAfter a break, I'm about to work a lot more with Zap, and in preparation made a few improvements which might also work in favor of newcomers.\r\n\r\nBTW newcomers: please, also check out these other, pure-zig (which Zap is not) HTTP server projects:\r\n\r\n- [http.zig](https://github.com/karlseguin/http.zig) : Pure Zig! Close to Zap's model. Performance = good!\r\n- [jetzig](https://github.com/jetzig-framework/jetzig) : Comfortably develop modern web applications quickly, using http.zig under the hood\r\n- [zzz](https://github.com/tardy-org/zzz) : Super promising, super-fast, especially for IO-heavy tasks, io_uring support - need I say more?\r\n\r\nI can't wait for the day that Zap becomes obsolete. It would be a very good sign for the Zig HTTP server space!\r\n\r\n**Breaking Changes for zap.Endpoint**\r\n\r\nThese breaking changes are meant to be improvements.\r\n\r\n- no `@fieldParentPtr`: Endpoints now directly get their `@This()` pointer passed into their methods\r\n- request handlers are allowed to return errors!\r\n- the `.error_strategy` decides if errors are logged to console or reported as HTML to the client (for debugging in the browser)\r\n- no \"Settings\":\r\n    - `path` and `error_strategy` are required for Endpoints\r\n    - all http method handlers must be present, but of course may be empty\r\n    - all of the above are checked at comptime, with meaningful compile error messages\r\n- you register your custom Endpoint instances directly with the\r\n  `zap.Endpoint.Listener`, no need to provide an `.endpoint()` method.\r\n\r\nIt's best illustrated by example of `error.zig` (of the updated `endpoints` example) which creates the `ErrorEndpoint`:\r\n\r\n```zig\r\n//!\r\n//! An ErrorEndpoint\r\n//!\r\nconst std = @import(\"std\");\r\nconst zap = @import(\"zap\");\r\n\r\n/// A simple endpoint listening on the /error route that causes an error on GET\r\n/// requests, which gets logged to the response (=browser) by default\r\npub const ErrorEndpoint = @This();\r\n\r\npath: []const u8 = \"/error\",\r\nerror_strategy: zap.Endpoint.ErrorStrategy = .log_to_response,\r\n\r\npub fn get(_: *ErrorEndpoint, _: zap.Request) !void {\r\n    return error.@\"Oh-no!\";\r\n}\r\n\r\n// unused:\r\npub fn post(_: *ErrorEndpoint, _: zap.Request) !void {}\r\npub fn put(_: *ErrorEndpoint, _: zap.Request) !void {}\r\npub fn delete(_: *ErrorEndpoint, _: zap.Request) !void {}\r\npub fn patch(_: *ErrorEndpoint, _: zap.Request) !void {}\r\npub fn options(_: *ErrorEndpoint, _: zap.Request) !void {}\r\n```\r\n\r\nAll relevant examples have been updated accordingly.\r\n\r\n**The New `zap.App`**\r\n\r\nIn a way, `zap.App` takes the `zap.Endpoint` concept one step further: instead of having only per-endpoint instance data (fields of your Endpoint struct), endpoints in a `zap.App` easily share a global 'App Context'.\r\n\r\nIn addition to the global App Context, all Endpoint request handlers also receive an arena allocator for easy, care-free allocations. There is one arena allocator per thread, and arenas are reset after each request.\r\n\r\nJust like regular / legacy `zap.Endpoints`, returning errors from request handlers is OK. It's decided on a per-endpoint basis how errors are dealt with, via the `ErrorStrategy` enum field.\r\n\r\nHere is a complete `zap.App` example:\r\n\r\n```zig\r\n//!\r\n//! Part of the Zap examples.\r\n//!\r\n//! Build me with `zig build     app_basic`.\r\n//! Run   me with `zig build run-app_basic`.\r\n//!\r\nconst std = @import(\"std\");\r\nconst Allocator = std.mem.Allocator;\r\n\r\nconst zap = @import(\"zap\");\r\n\r\n// The global Application Context\r\nconst MyContext = struct {\r\n    db_connection: []const u8,\r\n\r\n    pub fn init(connection: []const u8) MyContext {\r\n        return .{\r\n            .db_connection = connection,\r\n        };\r\n    }\r\n};\r\n\r\n// A very simple endpoint handling only GET requests\r\nconst SimpleEndpoint = struct {\r\n\r\n    // zap.App.Endpoint Interface part\r\n    path: []const u8,\r\n    error_strategy: zap.Endpoint.ErrorStrategy = .log_to_response,\r\n\r\n    // data specific for this endpoint\r\n    some_data: []const u8,\r\n\r\n    pub fn init(path: []const u8, data: []const u8) SimpleEndpoint {\r\n        return .{\r\n            .path = path,\r\n            .some_data = data,\r\n        };\r\n    }\r\n\r\n    // handle GET requests\r\n    pub fn get(e: *SimpleEndpoint, arena: Allocator, context: *MyContext, r: zap.Request) !void {\r\n        const thread_id = std.Thread.getCurrentId();\r\n\r\n        r.setStatus(.ok);\r\n\r\n        // look, we use the arena allocator here -> no need to free the response_text later!\r\n        // and we also just `try` it, not worrying about errors\r\n        const response_text = try std.fmt.allocPrint(\r\n            arena,\r\n            \\\\Hello!\r\n            \\\\context.db_connection: {s}\r\n            \\\\endpoint.data: {s}\r\n            \\\\arena: {}\r\n            \\\\thread_id: {}\r\n            \\\\\r\n        ,\r\n            .{ context.db_connection, e.some_data, arena.ptr, thread_id },\r\n        );\r\n        try r.sendBody(response_text);\r\n        std.time.sleep(std.time.ns_per_ms * 300);\r\n    }\r\n\r\n    // empty stubs for all other request methods\r\n    pub fn post(_: *SimpleEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn put(_: *SimpleEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn delete(_: *SimpleEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn patch(_: *SimpleEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn options(_: *SimpleEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n};\r\n\r\nconst StopEndpoint = struct {\r\n    path: []const u8,\r\n    error_strategy: zap.Endpoint.ErrorStrategy = .log_to_response,\r\n\r\n    pub fn get(_: *StopEndpoint, _: Allocator, context: *MyContext, _: zap.Request) !void {\r\n        std.debug.print(\r\n            \\\\Before I stop, let me dump the app context:\r\n            \\\\db_connection='{s}'\r\n            \\\\\r\n            \\\\\r\n        , .{context.*.db_connection});\r\n        zap.stop();\r\n    }\r\n\r\n    pub fn post(_: *StopEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn put(_: *StopEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn delete(_: *StopEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn patch(_: *StopEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n    pub fn options(_: *StopEndpoint, _: Allocator, _: *MyContext, _: zap.Request) !void {}\r\n};\r\n\r\npub fn main() !void {\r\n    // setup allocations\r\n    var gpa: std.heap.GeneralPurposeAllocator(.{\r\n        // just to be explicit\r\n        .thread_safe = true,\r\n    }) = .{};\r\n    defer std.debug.print(\"\\n\\nLeaks detected: {}\\n\\n\", .{gpa.deinit() != .ok});\r\n    const allocator = gpa.allocator();\r\n\r\n    // create an app context\r\n    var my_context = MyContext.init(\"db connection established!\");\r\n\r\n    // create an App instance\r\n    const App = zap.App.Create(MyContext);\r\n    var app = try App.init(allocator, &my_context, .{});\r\n    defer app.deinit();\r\n\r\n    // create the endpoints\r\n    var my_endpoint = SimpleEndpoint.init(\"/test\", \"some endpoint specific data\");\r\n    var stop_endpoint: StopEndpoint = .{ .path = \"/stop\" };\r\n    //\r\n    // register the endpoints with the app\r\n    try app.register(&my_endpoint);\r\n    try app.register(&stop_endpoint);\r\n\r\n    // listen on the network\r\n    try app.listen(.{\r\n        .interface = \"0.0.0.0\",\r\n        .port = 3000,\r\n    });\r\n    std.debug.print(\"Listening on 0.0.0.0:3000\\n\", .{});\r\n\r\n    std.debug.print(\r\n        \\\\ Try me via:\r\n        \\\\ curl http://localhost:3000/test\r\n        \\\\ Stop me via:\r\n        \\\\ curl http://localhost:3000/stop\r\n        \\\\\r\n    , .{});\r\n\r\n    // start worker threads -- only 1 process!!!\r\n    zap.start(.{\r\n        .threads = 2,\r\n        .workers = 1,\r\n    });\r\n}\r\n```\r\n\r\n**Updated README**\r\n\r\n- restructured the examples section a bit\r\n- got rid of all the microbenchmark stuff\r\n- shout-outs to great Zap alternatives (http.zig, Jetzig, zzz)\r\n\r\n**Contributions!**\r\n\r\nSpecial thanks to:\r\n\r\n- Victor Moin (vctrmn): Fix deprecated warning in facil.io #154\r\n- Joshua B. (OsakiTsukiko): updated .gitignore, Endpoint improvements\r\n- Thom Dickson (cosmicboots): Add type checking to simple_router's handle_func #125\r\n\r\n**What's coming up...?**\r\n\r\nI am contemplating upgrading the underlying facil.io library to the new and improved version 0.8!\r\n\r\nThanks for reading and helping out üòä!\r\n\r\n\r\n\r\n## Using it\r\n\r\nIn your zig project folder (where `build.zig` is located), run:\r\n\r\n```\r\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.10.0\"\r\n```\r\n\r\nThen, in your `build.zig`'s `build` function, add the following before\r\n`b.installArtifact(exe)`:\r\n\r\n```zig\r\n    const zap = b.dependency(\"zap\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n        .openssl = false, // set to true to enable TLS support\r\n    });\r\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\r\n```\r\n",
      "prerelease": false,
      "published_at": "2025-03-30T19:15:53Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.10.0",
      "assets": []
    },
    {
      "tag_name": "v0.9.1",
      "name": "Release v0.9.1",
      "body": "# ZAP Release v0.9.1\n\n## Updates\n\n__**Bugfix for Middleware.EnpointHandler checkPath logic**__\n\nI introduced a bug by wrongly trying to de-morgan the logic.\n\nThx @andr3h3nriqu3s11 for submitting issue #136 <https://github.com/zigzap/zap/issues/136>\n\nI reverted the commit.\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.9.1\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-10-20T21:36:11Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.9.1",
      "assets": []
    },
    {
      "tag_name": "v0.9.0",
      "name": "Release v0.9.0",
      "body": "# ZAP Release v0.9.0\n\n## Updates\n\n__**Small API Refactors**__\n\nThis is a small update from recent PRs with little breaking changes in\n`zap.Mustache` and `zap.Middleware.EndpointHandler`. Thanks for the\ngreat contributions! See the changelog below.\n\n**Also: we now use zig fetch!**\n\nThis greatly simplifies the instructions in the README and release\nnotes.\n\n__**Breaking Changes:**__\n\nMustache:\n- renamed `zap.Mustache.MustacheLoadArgs` to `zap.Mustache.LoadArgs`\n- `zap.Mustache.BuildResult` is a public type now\n\nMiddleware:\n- `zap.Middleware.EndpointHandler` now takes more than one option:\n\n```ts\n/// Options used to change the behavior of an `EndpointHandler`\npub const EndpointHandlerOptions = struct {\n    /// If `true`, the handler will stop handing requests down the chain if the\n    /// endpoint processed the request.\n    breakOnFinish: bool = true,\n\n    /// If `true`, the handler will only execute against requests that match\n    /// the endpoint's `path` setting.\n    checkPath: bool = false,\n};\n```\n\nI updated the docs and zig-master branch, too.\n\n__**Changelog:**__\n\nRene Schallner (5):\n      Merge pull request #117 from cosmicboots/mustache-build\n      doc: getHeader need lowercase keys\n      Merge pull request #120 from cosmicboots/endpoint-middleware\n      Merge pull request #127 from iacore/patch-1\n      docs, announceybot: switch to using zig fetch\n\nThom Dickson (4):\n      include BuildResult in public Mustache API\n      rename MustacheLoadArgs to LoadArgs\n      Create options for EndpointHandler\n      update docs and examples for endpoint middleware\n\niacore (1):\n      update docs for zap.start\n\n\n\n## Using it\n\nIn your zig project folder (where `build.zig` is located), run:\n\n```\nzig fetch --save \"git+https://github.com/zigzap/zap#v0.9.0\"\n```\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-10-14T23:04:18Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.9.0",
      "assets": []
    },
    {
      "tag_name": "v0.8.0",
      "name": "Release v0.8.0",
      "body": "# ZAP Release v0.8.0\r\n\r\n## Updates\r\n\r\n__Update to Zig 0.13__\r\n\r\nWith the help of our awesome contributers, we have a new release:\r\n\r\n- Zap is now officially based on Zig 0.13.0!\r\n- Thx to Lois Pearson, we now have `mimetypeRegister` and `mimetypeClear`\r\n- Thx to geemili, we don't need to link facil.io in our build.zigs anymore\r\n- Thx to S√∂ren Michaels, `methodAsEnum` supports the `HEAD` method.\r\n- ... and more, see the changelog below\r\n\r\n**Note:** there now is a `zig-master` branch that gets updated with breaking changes of Zig master on a somewhat regular basis. Please feel free to send PRs.\r\n\r\nMany thanks again to everyone who helped out:\r\n\r\nGiuseppe Cesarano (1):\r\n      fix: _debug typo in startWithLogging\r\n\r\nJoe Koop (1):\r\n      update http.zig to rfc9110 using MDN as a reference\r\n\r\nLord Asdi (1):\r\n      fix: use std.process.getEnvVarOwned instead of std.posix.getenv\r\n\r\nLouis Pearson (8):\r\n      fix: last_modifed -> last_modified\r\n      fix: docserver: server wasm with correct mimetype\r\n      feat: Wrap mimetypeRegister and mimetypeClear\r\n      fix: move getHeaderCommon to zap.zig\r\n      feat: add parseAccept\r\n      feat: make example for parseAccept\r\n      fix: simplify accept header api somewhat\r\n      feat: pre-allocate enough space for accept items\r\n\r\nMichael Wendt (1):\r\n      feat: remove deprecated path\r\n\r\nRene Schallner (18):\r\n      Update hello_json.zig\r\n      fix docserver invocation from build.zig\r\n      proposed change to parseAccept API\r\n      make zap master build with zig master\r\n      update zig version\r\n      updated zig-master check in CI\r\n      update badge in README\r\n      corrected release templates\r\n\r\nS√∂ren Michaels (1):\r\n      feat: add HEAD Method to `methodAsEnum`\r\n\r\ngeemili (1):\r\n      feat: streamline depending on zap by linking facil.io to module\r\n\r\n\r\n\r\n## Using it\r\n\r\nTo use in your own projects, put this dependency into your `build.zig.zon`:\r\n\r\n```zig\r\n        // zap v0.8.0\r\n        .zap = .{\r\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.8.0.tar.gz\",\r\n            .hash = \"12209936c3333b53b53edcf453b1670babb9ae8c2197b1ca627c01e72670e20c1a21\",\r\n        }\r\n```\r\n\r\nHere is a complete `build.zig.zon` example:\r\n\r\n```zig\r\n.{\r\n    .name = \"My example project\",\r\n    .version = \"0.0.1\",\r\n\r\n    .dependencies = .{\r\n        // zap v0.8.0\r\n        .zap = .{\r\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.8.0.tar.gz\",\r\n            .hash = \"12209936c3333b53b53edcf453b1670babb9ae8c2197b1ca627c01e72670e20c1a21\",\r\n        },\r\n    },\r\n    .paths = .{\r\n        \"\",\r\n    },\r\n}\r\n\r\n```\r\n\r\nThen, in your `build.zig`'s `build` function, add the following before\r\n`b.installArtifact(exe)`:\r\n\r\n```zig \r\n    const zap = b.dependency(\"zap\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n        .openssl = false, // set to true to enable TLS support\r\n    });\r\n    exe.root_module.addImport(\"zap\", zap.module(\"zap\"));\r\n```\r\n",
      "prerelease": true,
      "published_at": "2024-06-28T10:22:01Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.8.0",
      "assets": []
    },
    {
      "tag_name": "v0.7.0",
      "name": "Release v0.7.0",
      "body": "# ZAP Release v0.7.0\r\n\r\n## Updates\r\n\r\n__Update to Zig 0.12__\r\n\r\nWith the help of our awesome contributers, we have a new release:\r\n\r\n- zap is now officially based on Zig 0.12.0!\r\n- tests have been updated to use the latest `std.http` client\r\n- @desttinghim added `getHeaderCommon` to `zap.Request`\r\n- @leroycep improved error return traces in `zap.Request.sendError()`\r\n- @dasimmet and @dweiller fixed the use of @fieldParentPtr to the new style\r\n- @xflow-systems improved the write function of websockets\r\n\r\nUsers of `sendError()`: the API has changed! The doc comment has been updated. The new way of using it is:\r\n\r\n```ts\r\nr.sendError(err, if (@errorReturnTrace()) |t| t.* else null, 505);\r\n```\r\n\r\nThe new version outputs much nicer error traces.\r\n\r\n**Note:** there will likely be a `zig-master` branch in the future that gets updated with breaking changes of Zig master. For sanity reasons, it will not be called `zig-0.13.0` but `zig-master`. I'll update the README accordingly then.\r\n\r\n**Note 2:** I merged PRs and fixed the tests while waiting for my plane to board, then finished on the plane. If I might have rushed it and oopsied something up, I'll apologize and follow up with a bugfix release.\r\n\r\nOne open issue is using openssl on macOS, especially with openssl in custom locations, like homebrew-installed versions. If anyone wants to look into that: PRs are welcome üòä!\r\n\r\nMany thanks again to everyone who helped out!\r\n\r\n\r\n\r\n## Using it\r\n\r\nTo use in your own projects, put this dependency into your `build.zig.zon`:\r\n\r\n```zig\r\n        // zap v0.7.0\r\n        .zap = .{\r\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.7.0.tar.gz\",\r\n            .hash = \"1220a1cb1822ea77083045d246db5d7a6f07a8ddafa69c98dee367560f9ce667fd8d\",\r\n        }\r\n```\r\n\r\nHere is a complete `build.zig.zon` example:\r\n\r\n```zig\r\n.{\r\n    .name = \"My example project\",\r\n    .version = \"0.0.1\",\r\n\r\n    .dependencies = .{\r\n        // zap v0.7.0\r\n        .zap = .{\r\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.7.0.tar.gz\",\r\n            .hash = \"1220a1cb1822ea77083045d246db5d7a6f07a8ddafa69c98dee367560f9ce667fd8d\",\r\n        },\r\n    },\r\n    .paths = .{\r\n        \"\",\r\n    },\r\n}\r\n\r\n```\r\n\r\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\r\n\r\n```zig \r\n    const zap = b.dependency(\"zap\", .{\r\n        .target = target,\r\n        .optimize = optimize,\r\n    });\r\n    exe.addModule(\"zap\", zap.module(\"zap\"));\r\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\r\n```\r\n",
      "prerelease": true,
      "published_at": "2024-04-21T18:29:32Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.7.0",
      "assets": []
    },
    {
      "tag_name": "v0.6.0",
      "name": "Release v0.6.0",
      "body": "# ZAP Release v0.6.0\n\n## Updates\n\n__Breaking change in zap.Router__\n\nLatest zig master does not allow for multiple copies of the same anonymous type anymore. This broke zap.RequestHandler used by zap.Router.\n\nSo I rewrote zap.Router and zap.RequestHandler is gone.\n\nTo keep the APIs identical for both zig versions, I applied the rewrite patch also to the zig 0.11.0 (master) branch.\n\n- [simple_router example](https://github.com/zigzap/zap/blob/master/examples/simple_router/simple_router.zig)\n- [zap.Router documentation](https://zigzap.org/zap/#zap.router)\n\nFrom a user perspective not much changed:\n\n- for unbound route handlers, use `zap.Router.handle_route_unbound`.\n- use `zap.Router.on_request_handler()` to get the request function to pass to a Listener.\n\n**Note:** the 0.12.0 branch is currently broken with regard to tests due to changes in `std.http`.\n\n__**Changelog**__ in alphabetical order:\n\nGitHub Action (1):\n      Update README\n\nRene Schallner (2):\n      trying to add mastercheck badge to README\n      re-write of zap.Router, fix #83\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.6.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.6.0.tar.gz\",\n            .hash = \"1220a5a1e6b18fa384d8a98e5d5a25720ddadbcfed01da2e4ca55c7cfb3dc1caa62a\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.6.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.6.0.tar.gz\",\n            .hash = \"1220a5a1e6b18fa384d8a98e5d5a25720ddadbcfed01da2e4ca55c7cfb3dc1caa62a\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-03-23T23:47:03Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.6.0",
      "assets": []
    },
    {
      "tag_name": "v0.5.1",
      "name": "Release v0.5.1",
      "body": "# ZAP Release v0.5.1\n\n## Updates\n\n__Request.methodAsEnum() and Windows build error message__\n\nThis is a small update of recent PRs. Thanks for the great contributions!\n\nSee the changelog below for individual contributions.\n\n- `zap.Request.methodAsEnum()` returns HTTP method as enum or .UNKNOWN\n    - the reason the method is not an enum by default is to avoid the\n      string comparisons on every request when we might not need them\n- build attempts on Windows now produce a meaningful error message\n- `zap.Request` now supports `getParamSlice()` and `getParamSlices()`\n    which return optional string slices of the raw query string.\n    - PRO: no allocation\n    - CON: no decoding: \"hello+zap\" will not be decoded into \"hello zap\"\n    - if you need decoding, you can still use `getParamStr()`.\n\nI updated the docs and zig-0.12.0 branch, too, as with all recent and future releases.\n\n__**Changelog**__ in alphabetical order:\n\nFroxcey (4):\n      Use std.http.Method for Request.method\n      Use custom method enum\n      Provide Windows error message\n      Use debug.err and exit 1 for windows fail message\n\nJoe Liotta (1):\n      fixed unneeded optional unwrap in hello_json\n\nRene Schallner (8):\n      Update README.md to point out even more prominently the zig master situation\n      Merge pull request #72 from Chiissu/master\n      Merge pull request #75 from Chiissu/windows-errmsg\n      access raw query params w/o allocator, close #40\n      cosmetics\n      Merge pull request #79 from joeypas/master\n      fix workflow to detect failing builds of individual samples\n      in http.methodToEnum use std.meta.stringToEnum\n      performance: revert r.method enum back to ?[]const u8\n          (new http.Method enum is available via r.methodAsEnum())\n      use methodAsEnum() in Endpoint, and in json example\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.5.1\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.5.1.tar.gz\",\n            .hash = \"1220d4802fb09d4e99c0e7265f90d6f3cfdc3e5e31c1b05f0924ee2dd26d9d6dbbf4\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.5.1\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.5.1.tar.gz\",\n            .hash = \"1220d4802fb09d4e99c0e7265f90d6f3cfdc3e5e31c1b05f0924ee2dd26d9d6dbbf4\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-02-24T15:15:27Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.5.1",
      "assets": []
    },
    {
      "tag_name": "v0.5.0",
      "name": "Release v0.5.0",
      "body": "# ZAP Release v0.5.0\n\n## Updates\n\n__Introducing: zap.Router__\n\nThanks to StringNick, we now have `zap.Router` with handler closures support!\n\nSee the `simple_router` example. `zap.Router` is missing doc comments, so if anyone wants to step up, please feel free to send a PR against the `zig-0.12.0` my way.\n\nBTW: Documentation (built on zig-0.12.0 branch) is now live at: <https://zigzap.org/zap>\n\nDoc update PRs are welcome. I am especially excited about the _guides_ feature: <https://zigzap.org/zap/#G;>\n\n__**Introduced:**__\n\n- `zap.Router`: the router itself\n- `zap.RequestHandler : a nice way to capture \"self\" pointers of containers of request functions.\n- `simple_router`: example demonstrating the above\n\nThanks again to StringNick!\n\nI updated the zig-0.12.0 branch, too, as with all recent and future releases.\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.5.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.5.0.tar.gz\",\n            .hash = \"1220aabff84ad1d800f5657d6a49cb90dab3799765811ada27faf527be45dd315a4d\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.5.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.5.0.tar.gz\",\n            .hash = \"1220aabff84ad1d800f5657d6a49cb90dab3799765811ada27faf527be45dd315a4d\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-01-24T22:05:39Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.5.0",
      "assets": []
    },
    {
      "tag_name": "v0.4.0",
      "name": "Release v0.4.0",
      "body": "# ZAP Release v0.4.0\n\n## Updates\n\n__Breaking API Cleanup__\n\n**Documentation (built on zig-0.12.0 branch) is now live at: <https://zigzap.org/zap>**\n\nDoc update PRs are welcome. I am especially excited about the _guides_ feature: <https://zigzap.org/zap/#G;>\n\nSo, I spent a few days with a first pass of cleaning up Zap's API, informed by using it in production for over half a year now.\n\n**__Refactored:__**\n\n- no more type names starting with `Simple`.\n    - zap.SimpleEndpoint -> zap.Endpoint\n    - zap.SimpleRequest -> zap.Request\n    - zap.SimpleHttpListener -> zap.HttpListener\n    - ...\n- zap.Endpoint : zap.Endpoint, zap.Endpoint.Authenticating\n    - zap.Endpoint.Listener.register() // was: zap.EndpointListener.addEndpoint\n- zap.Auth : zap.Auth.Basic, zap.Auth.BearerSingle, ...\n- zap.Mustache : stayed the same\n- zap.Request : refactored into its own file, along with supporting types and functions (e.g. http params related)\n    - added setContentTypeFromFilename thx @hauleth.\n- zap.Middleware: no more MixContexts\n    - (zig structs are fine)\n    - check example\n- zap.fio : facilio C FFI stuff does not pollute zap namespace anymore\n    - it is still available via `zap.fio`.\n- allocators are always first-ish param: either first or after self\n- more docstrings\n\nAll examples and tests have been updated. Also, check out the documentation (work in progress).\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.4.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.4.0.tar.gz\",\n            .hash = \"1220a20e883195793cff0f298d647d35f675ad25e6556fe75b9ccabc98a349cbf082\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.4.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.4.0.tar.gz\",\n            .hash = \"1220a20e883195793cff0f298d647d35f675ad25e6556fe75b9ccabc98a349cbf082\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-01-10T14:37:38Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.4.0",
      "assets": []
    },
    {
      "tag_name": "v0.3.0",
      "name": "Release v0.3.0",
      "body": "# ZAP Release v0.3.0\n\n## Updates\n\n__-Dopenssl is back && breaking mustache changes__\n\nThanks to @Vemahk, `-Dopenssl=true` is back! Apparently, while trying to pass user-defined options from a dependent project to zap, I typoed the working solution, and several people pointed out to me that it's as simple as:\n\n```zig\n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n        .openssl = false, // set to true to enable TLS support\n    });\n```\n\nAs a result, we re-introduced `-Dopenssl`, use it if present, and fall back to the `ZAP_USE_OPENSSL` env var (set to `true` to enable) if not.\n\nAaand: thanks to @Chooky (BrookJeynes on GH), we have a new, clean, zig-iomatic, documented Mustache API in Zap now:\n\n```zig\n    var mustache = try Mustache.fromData(\"{{some_item}} {{& nested.item }}\");\n    defer mustache.deinit();\n\n    const b = mustache.build(.{\n        .some_item = 42,\n        .nested = .{\n            .item = 69,\n        },\n    });\n    defer b.deinit();\n\n    if(b.str()) |s| {\n        std.debug.print(\"{s}\", .{s});\n    };\n```\n\nCheckout mustache.zig and the mustache example to learn more.\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.3.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.3.0.tar.gz\",\n            .hash = \"1220697520f1fc8c511db31bb99d3adae035b83abbc9752de59c3a5ac4f22e7a90fa\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.3.0\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.3.0.tar.gz\",\n            .hash = \"1220697520f1fc8c511db31bb99d3adae035b83abbc9752de59c3a5ac4f22e7a90fa\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-01-07T22:04:56Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v0.2.6",
      "name": "Release v0.2.6",
      "body": "# ZAP Release v0.2.6\n\n## Updates\n\n__TLS / HTTPS / openssl build change!!!__\n\nPreviously, zap required `-Dopenssl=true` to build openssl support. Turns out, for projects using zap, it's insanely hard if not impossible to pass the user provided option `openssl=true` down to the zap dependency.\n\nAs a workaround, I changed the build so that it now expects an environment variable `ZAP_USE_OPENSSL` be set to `true`.\n\nSo, to build the _https_ example, run:\n\n`ZAP_USE_OPENSSL=true zig build run-https`\n\n*The Example*\n\nCreate the certificate and key file:\n\n```console\n$ openssl req -x509 -nodes -days 365 -sha256 -newkey rsa:2048 -keyout mykey.pem -out mycert.pem\n```\n\nBuild / run the example\n\n```console\n$ ZAP_USE_OPENSSL=true zig build https\n$ ZAP_USE_OPENSSL=true zig build -Dopenssl=true run-https\n```\n\nIssue an HTTPS request:\n\n```console\n$ curl -v -k https://localhost:4443/build.zig\n```\n\nUsing openssl in your code is super simple:\n\n```zig\n    const tls = zap.fio_tls_new(\n        \"localhost:4443\",\n        CERT_FILE,\n        KEY_FILE,\n        null, // key file is not password-protected\n    );\n    defer tls.deinit();\n```\n\nThat `tls` data is then passed to the `SimpleHttpListener`:\n\n```zig\n    var listener = zap.SimpleHttpListener.init(.{\n        .port = 4443,\n        .on_request = on_request_verbose,\n        .log = true,\n        .max_clients = 100000,\n        .tls = tls,   //   <----- h e r e\n    });\n    try listener.listen();\n```\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.2.6\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.2.6.tar.gz\",\n            .hash = \"1220140b2cdb01223ebd9c8d9f978df8a4b5c50b75f2170ed6af4cb477374511b8eb\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.2.6\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.2.6.tar.gz\",\n            .hash = \"1220140b2cdb01223ebd9c8d9f978df8a4b5c50b75f2170ed6af4cb477374511b8eb\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2024-01-05T13:11:33Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.2.6",
      "assets": []
    },
    {
      "tag_name": "v0.2.5",
      "name": "Release v0.2.5",
      "body": "# ZAP Release v0.2.5\n\n## Updates\n\n__Community PR update: HTTP options support!__\n\nHey, things are moving rapidly in ZAP land these days. StringNick (on GitHub) provided a PR adding HTTP options support!\n\nMany thanks for the great PR!\n\nBTW: New stuff is cooking in the 0.12.0 branch. Check out @Chooky 's new mustache ;-). Maybe even in the API docs?\n(`zig build run-docserver` is your friend)\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.2.5\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.2.5.tar.gz\",\n            .hash = \"1220c33e0ecc01b862ff6d929a948f5a8b5526a66f8d883a6d10eaff1620b8d4d605\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.2.5\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.2.5.tar.gz\",\n            .hash = \"1220c33e0ecc01b862ff6d929a948f5a8b5526a66f8d883a6d10eaff1620b8d4d605\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2023-12-31T00:42:44Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.2.5",
      "assets": []
    },
    {
      "tag_name": "v0.2.4",
      "name": "Release v0.2.4",
      "body": "# ZAP Release v0.2.4\n\n## Updates\n\n__FIX tls.zig__\n\nIn the heat of the action, I forgot to add tls.zig in 0.2.3. Ooops.\n\nIt's present in 0.2.4\n\n\n\n## Using it\n\nTo use in your own projects, put this dependency into your `build.zig.zon`:\n\n```zig\n        // zap v0.2.4\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.2.4.tar.gz\",\n            .hash = \"1220b22285fd80b8e027bf877a1f66833934b8639cc4fc38c84fbbbcee5b2d6f6a8f\",\n        }\n```\n\nHere is a complete `build.zig.zon` example:\n\n```zig\n.{\n    .name = \"My example project\",\n    .version = \"0.0.1\",\n\n    .dependencies = .{\n        // zap v0.2.4\n        .zap = .{\n            .url = \"https://github.com/zigzap/zap/archive/refs/tags/v0.2.4.tar.gz\",\n            .hash = \"1220b22285fd80b8e027bf877a1f66833934b8639cc4fc38c84fbbbcee5b2d6f6a8f\",\n        }\n    }\n}\n\n```\n\nThen, in your `build.zig`'s `build` function, add the following before `exe.install()`:\n\n```zig \n    const zap = b.dependency(\"zap\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe.addModule(\"zap\", zap.module(\"zap\"));\n    exe.linkLibrary(zap.artifact(\"facil.io\"));\n```\n",
      "prerelease": true,
      "published_at": "2023-12-30T12:17:01Z",
      "html_url": "https://github.com/zigzap/zap/releases/tag/v0.2.4",
      "assets": []
    }
  ],
  "owner_bio": "Blazingly fast backends in Zig",
  "owner_location": "Austria",
  "owner_blog": "https://zigzap.org",
  "owner_twitter_username": null,
  "owner_created_at": "2023-02-13T03:01:43Z",
  "license": "MIT",
  "category": "library"
}