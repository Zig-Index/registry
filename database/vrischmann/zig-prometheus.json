{
  "name": "zig-prometheus",
  "owner": "vrischmann",
  "repo": "zig-prometheus",
  "description": "Prometheus/VictoriaMetrics client library for Zig",
  "type": "package",
  "topics": [
    "zig",
    "prometheus",
    "victoriametrics",
    "zig-package"
  ],
  "stars": 56,
  "forks": 2,
  "watchers": 2,
  "updated_at": "2025-07-24T22:35:50Z",
  "minimum_zig_version": "0.14.0",
  "readme": "# zig-prometheus\n\nThis is a [Zig](https://ziglang.org/) library to add [Prometheus](https://prometheus.io/docs/concepts/data_model/)-inspired metrics to a library or application.\n\n\"Inspired\" because it is not strictly compatible with Prometheus, the `Histogram` type is tailored for [VictoriaMetrics](https://github.com/VictoriaMetrics/VictoriaMetrics).\nSee [this blog post](https://valyala.medium.com/improving-histogram-usability-for-prometheus-and-grafana-bc7e5df0e350) from the creator of `VictoriaMetrics` for details.\n\n# Requirements\n\n[Zig master](https://ziglang.org/download/) is the only required dependency.\n\n# Introduction\n\nThis library only provides the following types:\n* A `Registry` holding a number of metrics\n* A `Counter` metric type\n* A `Gauge` metric type\n* A `Histogram` metric type\n\n# Examples\n\nIf you want a quick overview of how to use this library check the [basic example program](examples/basic/main.zig). It showcases everything.\n\n# Reference\n\n## Registry\n\nThe `Registry` is the entry point to obtain a metric type, as well as the type capable of serializing the metrics to a writer.\n\nIn an application it might be useful to have a default, global registry; in a library you probably should take one as a parameter.\n\n### Creation\n\nHere is how to get a registry:\n```zig\nvar registry = try prometheus.Registry(.{}).create(allocator);\ndefer registry.destroy();\n...\n```\n\nYou can also configure some options for the registry:\n```zig\nvar registry = try prometheus.Registry(.{ .max_metrics = 40, .max_name_len = 300 }).create(allocator);\ndefer registry.destroy();\n...\n```\n\nIf you want to store the registry in a variable you probably want to do something like this:\n```zig\nconst Registry = prometheus.Registry(.{ .max_metrics = 40, .max_name_len = 300 });\nvar registry = Registry.create(allocator);\ndefer registry.destroy();\n...\n```\n\nNow you can get metric objects which we will describe later.\n\n### Serializing the metrics\n\nOnce you have a registry you can serialize its metrics to a writer:\n```zig\nvar registry = try prometheus.Registry(.{}).create(allocator);\ndefer registry.destroy();\n\n...\n\nvar file = try std.fs.cwd().createFile(\"metrics.txt\", .{});\ndefer file.close();\n\ntry registry.write(allocator, file.writer());\n```\n\nThe `write` method is thread safe.\n\n## Counter\n\nThe `Counter` type is an atomic integer counter.\n\nHere is an example of how to use a counter:\n\n```zig\nvar registry = try prometheus.Registry(.{}).create(allocator);\ndefer registry.destroy();\n\nvar total_counter = try registry.getOrCreateCounter(\"http_requests_total\");\nvar api_users_counter = try registry.getOrCreateCounter(\n    \\\\http_requests{route=\"/api/v1/users\"}\n);\nvar api_articles_counter = try registry.getOrCreateCounter(\n    \\\\http_requests{route=\"/api/v1/articles\"}\n);\n\ntotal_counter.inc();\ntotal_counter.dec();\ntotal_counter.add(200);\ntotal_counter.set(2400);\nconst counter_value = total_counter.get();\n```\n\nAll methods on a `Counter` are thread safe.\n\n## Gauge\n\nThe `Gauge` type represents a numerical value that is provided by calling a user-supplied function.\n\nA `Gauge` is created with a _state_ and a _function_ which is given that state every time it is called.\n\nFor example, you can imagine a gauge returning the number of connections in a connection pool, the amount of memory allocated, etc.\nBasically anytime the value is instantly queryable it could be a gauge.\n\nOf course, nothing stops you from using a counter to simulate a gauge and calling `set` on it; it's up to you.\n\nHere is an example gauge:\n```zig\nvar registry = try prometheus.Registry(.{}).create(allocator);\ndefer registry.destroy();\n\nconst Conn = struct {};\nconst ConnPool = struct {\n    conns: std.ArrayList(Conn),\n};\nvar pool = ConnPool{ .conns = std.ArrayList.init(allocator) };\n\n_ = try registry.getOrCreateGauge(\n    \"http_conn_pool_size\",\n    &pool,\n    struct {\n        fn get(p: *Pool) f64 {\n            return @intToFloat(f64, p.conns.items.len);\n        }\n    }.get,\n);\n```\n\n## Histogram\n\nThe `Histogram` type samples observations and counts them in automatically created buckets.\n\nIt can be used to observe things like request duration, request size, etc.\n\nHere is a (contrived) example on how to use an histogram:\n```zig\nvar registry = try prometheus.Registry(.{}).create(allocator);\ndefer registry.destroy();\n\nvar request_duration_histogram = try registry.getOrCreateHistogram(\"http_request_duration\");\n\n// Make 100 observations of some expensive operation.\nvar i: usize = 0;\nwhile (i < 100) : (i += 1) {\n    const start = std.time.milliTimestamp();\n\n    var j: usize = 0;\n    var sum: usize = 0;\n    while (j < 2000000) : (j += 1) {\n        sum *= j;\n    }\n\n    request_duration_histogram.update(@intToFloat(f64, std.time.milliTimestamp() - start));\n}\n```\n\n## Using labels\n\nIf you're read the [Prometheus data model](https://prometheus.io/docs/concepts/data_model/#notation), you've seen that a metric can have labels.\n\nOther Prometheus clients provide helpers for this, but not this library: you need to build the proper name yourself.\n\nIf you have static labels then it's easy, just write the label directly like this:\n```zig\nvar http_requests_route_home = try registry.getOrCreateCounter(\n    \\\\http_requests{route=\"/home\"}\n);\nvar http_requests_route_login = try registry.getOrCreateCounter(\n    \\\\http_requests{route=\"/login\"}\n);\nvar http_requests_route_logout = try registry.getOrCreateCounter(\n    \\\\http_requests{route=\"/logout\"}\n);\n...\n```\n\nIf you have dynamic labels you could write a helper function like this:\n```zig\nfn getHTTPRequestsCounter(\n    allocator: *mem.Allocator,\n    registry: *Registry,\n    route: []const u8,\n) !*prometheus.Counter {\n    const name = try std.fmt.allocPrint(allocator, \"http_requests{{route=\\\"{s}\\\"}}\", .{\n        route,\n    });\n    return try registry.getOrCreateCounter(name);\n}\n\nfn handler(route: []const u8) void {\n    var counter = getHTTPRequestsCounter(allocator, registry, route);\n    counter.inc();\n}\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/1916079?u=7084654a44817cac4a2f0cd57b5fedfbd3df4da0&v=4",
  "releases": [],
  "owner_bio": "Still learning",
  "owner_company": "@BatchLabs ",
  "owner_location": "France",
  "owner_blog": "https://rischmann.fr",
  "owner_twitter_username": "vrischmann",
  "owner_followers": 116,
  "owner_following": 47,
  "owner_created_at": "2012-07-02T23:09:35Z",
  "license": "MIT",
  "category": "library"
}