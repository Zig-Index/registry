{
  "name": "zunvox",
  "owner": "Logickin-Lambda",
  "repo": "zunvox",
  "description": "SunVox Lib, but in Zig!",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-03-02T14:35:03Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# ZunVox, A More Intuitive SunVox Library Written In zig\r\n\r\n### Todo:\r\n- [x] Address the random segmentation fault during the first build to the project (Fixed, missing sv_deinit() should be the original cause)\r\n- [ ] An async controller queue to ensure the controller parameter being update before project save. (zig 0.16.0 features required)\r\n- [ ] More os support (currently windows, mac, and x86_64 Linux)\r\n- [ ] Enable the Audio Callback and any other missing functions\r\n- [ ] Replace function parameters and return type more idiomatic to zig.\r\n\r\n### Story\r\nI have a couple of sunvox project on hand, including the VOXCOM 1610 assembler and the Preset bank generator which these projects are based on the [SunVox Library](https://warmplace.ru/soft/sunvox/sunvox_lib.php).The original library is not hard to use, as you can see, you can just load the dynamic/share library like shown, which is surprisingly simple for zig:\r\n\r\n``` zig\r\npub fn main(){\r\n    dll = try std.DynLib.open(\"sunvox\");\r\n    const audio_callback = dll.lookup(tsv_audio_callback, \"sv_audio_callback\");\r\n    const audio_callback2 = dll.lookup(tsv_audio_callback2, \"sv_audio_callback2\");\r\n    const open_slot = dll.lookup(tsv_open_slot, \"sv_open_slot\");\r\n    const init = dll.lookup(tsv_init, \"sv_init\");\r\n    // ... and ~80 more functions to go\r\n\r\n    _ = init.?(0, 44100, 2, 0);\r\n}\r\n\r\n```\r\n\r\nhowever, the design of the original library is a bit low level since you need to manually manage the slot and module IDs and keep track on the event change, while the negative error number can be thrown unexpectedly in any point of the function call if you used a wrong id or forget to lock the slot.\r\n\r\nThus, since my use of the SunVox library is to generate and manipulate modules, I decided to build a level of abstraction such that the library will be easier to use for simple application and ensure the reliability setting certain components of the modules and projects. If you need maximal performance, this **might not be** the library for you since this has a lot more overhead than the original library.\r\n\r\nSimilar to the original library, this library is **not thread safe**, so be aware if you use the library with multiple threads.\r\n\r\n### Basics\r\nTo build the library, you need to import the dependency as shown:\r\n\r\n``` zig\r\nconst zunvox = b.dependency(\"zunvox\", .{});\r\nexe.root_module.addImport(\"zunvox\", zunvox.module(\"zunvox\"));\r\n\r\n// install the original dynamic library into your project\r\n@import(\"zunvox\").installSunVoxBinary(&exe.step, zunvox, .bin);\r\n```\r\n\r\nWith the set up above, when you compile the library, the share library (.so/.dll) will be installed into the destination binary folder. To use the library, simply import zunvox like shown to initialize the library:\r\n\r\n``` zig\r\nconst std = @import(\"std\");\r\nconst zunvox = @import(\"zunvox\");\r\n\r\npub fn main() !void {\r\n    _ = try zunvox.init(null, 44100, 2, 0);\r\n    defer zunvox.deinit();\r\n\r\n    // your code...\r\n}\r\n```\r\n\r\nTo load a project, you need to create a slot, and since ZunVox have automatically manage the slot id, you don't need to remember the id when calling the function, as long as you have kept a reference to the slot:\r\n``` zig\r\nvar arena = std.heap.ArenaAllocator.init(std.heap.smp_allocator);\r\narena.deinit();\r\n\r\nvar slot = try zunvox.Slot.create(arena.allocator());\r\ndefer slot.destroy() catch @panic(\"failed to destroy slot\");\r\n\r\ntry slot.Project.load(\"demo_track.sunvox\");\r\ntry slot.Project.playFromBeginning();\r\n\r\nstd.Thread.sleep(20e9);\r\n```\r\n\r\nCreating a module is also easy, and all you need to do is to create a module object by calling Module.new(), you may connect to any modules existed from the project which \r\nyou need to fetch the module type with a module ID like shown:\r\n\r\n``` zig\r\nconst multi = try Module.new(slot, .MultiSynth, \">> Input\", 0, 0, 1);\r\nconst square = try Module.new(slot, .@\"Analog generator\", \"Square\", 96, 0, 1);\r\nconst saw = try Module.new(slot, .@\"Analog generator\", \"Saw\", 96, 96, 1);\r\nconst sine = try Module.new(slot, .@\"Analog generator\", \"Sine\", 96, 96 * 2, 1);\r\nconst filter = try Module.new(slot, .@\"Filter Pro\", null, 96 * 2, 0, 1);\r\nconst output = Module.fetchFromSlotByID(slot, 0).?; // getting the reference of the output module\r\n\r\n// make connections, you many also use module.disconnect(module) for disconnection\r\ntry multi.connect(square);\r\ntry multi.connect(saw);\r\ntry multi.connect(sine);\r\n\r\ntry square.connect(filter);\r\ntry saw.connect(filter);\r\ntry sine.connect(filter);\r\n\r\ntry filter.connect(output);\r\n```\r\n\r\nAs you can see, in the exception of fetching the existing modules from the loaded project, you no longer need to manually handle the id of various instance.\r\n\r\nHowever, there are some conventions keeps in mind:\r\n\r\nIf the member functions contains an allocator, you must manually destroy the instance. This is because those objects are not frequently used, and there is no way to determine the array size at compile time. For example:\r\n``` zig\r\nconst curve_new = try drawn.getCurve(allocator, null);\r\ndefer allocator.free(curve_new);\r\n```\r\n\r\nSome of the type are encapsulated in pack unions, and the reason behind the design is that it provides a handly way to convert type between a raw bit field and a separated; thus, if you encounter function with returning a union type, make sure are you use the flags/detail of the union instead of raw which is used for the library internally:\r\n\r\n``` zig\r\n\r\n// instead of doing this:\r\nconst flags = self.getFlags().raw;\r\n\r\n// it is more preferred to do get the specific flags instead:\r\nconst is_muted = self.getFlags().details.is_muted;\r\n```",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/118601127?u=b7cb9f26ba45acdf8d30d4c56bdfef587813d9c4&v=4",
  "releases": [
    {
      "tag_name": "Initial-Release",
      "name": "v0.1.0",
      "body": "After a project using this library, most of the functionality is now working; thus, I decided to mark this as a release because the next update contains some breaking changes including modifying the input parameters to make it more idiomatic to zig, and potentially update the library into 0.16.0 to explore around the async functions for the set control event queue prototype. ",
      "prerelease": true,
      "published_at": "2025-12-20T08:46:24Z",
      "html_url": "https://github.com/Logickin-Lambda/zunvox/releases/tag/Initial-Release",
      "assets": []
    }
  ],
  "owner_bio": "Just a birb here, nothing special.",
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://logickin.net/",
  "owner_twitter_username": null,
  "owner_followers": 7,
  "owner_following": 10,
  "owner_created_at": "2022-11-19T10:15:05Z",
  "category": "library"
}