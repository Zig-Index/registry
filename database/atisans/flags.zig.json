{
  "name": "flags.zig",
  "owner": "atisans",
  "repo": "flags.zig",
  "description": "A type-safe command-line argument parser for Zig",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-02-22T08:37:07Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# flags.zig\n\nA type-safe command-line argument parser for Zig. Taking inspiration from **Rust clap**, **Python argparse**, and **TigerBeetle's flags** implementation, it lets you define flags using a struct or union(enum) and parses command-line arguments into it.\n\n---\n\n## Table of Contents\n\n- [Overview](#overview)\n- [Features](#features)\n- [Installation](#installation)\n- [Quick Start](#quick-start)\n- [Usage Examples](#usage-examples)\n- [Advanced Features](#advanced-features)\n- [Supported Types](#supported-types)\n- [Error Handling](#error-handling)\n- [Documentation](#documentation)\n- [Credits](#credits)\n\n---\n\n## Overview\n\n**flags.zig** provides a declarative, type-safe approach to command-line parsing by leveraging Zig's powerful comptime capabilities. Define your CLI interface as a struct with defaults and types, and let the library handle the rest.\n\n### Why flags.zig?\n\n- Zero runtime overhead—parsing happens at comptime where possible\n- Type safety—catch errors at compile time, not runtime\n- Idiomatic Zig—works with the grain of the language\n- Zero external dependencies\n\n---\n\n## Features\n\n- [x] Multiple flag types (bool, string, int, float, enum)\n- [x] Struct-based argument definition\n- [x] Default values via struct fields\n- [x] Automatic help generation (`--help`)\n- [x] Error handling for invalid/unknown flags\n- [x] Positional arguments support\n- [x] Subcommands via `union(enum)`\n- [x] Short flag names (`-v`)\n- [x] Long flag names (`--verbose`)\n- [x] Slice support (multiple values per flag)\n- [x] Two parsing patterns: repeated, comma-separated\n\n---\n\n## Installation\n\n### 1. Fetch the library\n\n```bash\nzig fetch --save git+https://github.com/atisans/flags.zig\n```\n\n### 2. Add to your `build.zig`\n\n```zig\nconst flags = b.dependency(\"flags\", .{});\nexe.root_module.addImport(\"flags\", flags.module(\"flags\"));\n```\n\n---\n\n## Quick Start\n\n```zig\nconst std = @import(\"std\");\nconst flags = @import(\"flags\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Define flags as a struct with slice support\n    const Args = struct {\n        name: []const u8 = \"world\",\n        age: u32 = 25,\n        active: bool = false,\n        \n        // Multiple values supported\n        files: []const []const u8 = &[_][]const u8{},\n        ports: []u16 = &[_]u16{8080},\n    };\n\n    // Parse and use\n    const args = try std.process.argsAlloc(allocator);\n    defer std.process.argsFree(allocator, args);\n\n    const parsed = try flags.parse(args, Args);\n\n    std.debug.print(\"Hello {s}! Age: {d}, Active: {}\\n\", .{\n        parsed.name, parsed.age, parsed.active\n    });\n}\n```\n\n---\n\n## Usage Examples\n\n### Basic Flags\n\n```bash\n./program --name=alice --age=30 --active\n```\n\n### Individual Flag Types\n\n```bash\n# String flag\n./program --name=bob\n\n# Integer flag\n./program --age=40\n\n# Boolean flag (presence = true)\n./program --active\n```\n\n### Getting Help\n\n```bash\n./program --help\n```\n\n### Mixed Flags\n\n```bash\n./program --name=charlie --age=35 --active\n```\n\n### Short Flags\n\nDefine single-character flag names for shorter invocations:\n\n```zig\nconst Args = struct {\n    v: bool = false,  // Short flag: -v\n    q: bool = false,  // Short flag: -q\n};\n```\n\n```bash\n./program -v -q     # Multiple short flags\n./program -v        # Only verbose\n```\n\n### Slice (Multiple Values) Support\n\n```zig\nconst Args = struct {\n    files: []const []const u8 = &[_][]const u8{},\n    ports: []u16 = &[_]u16{8080},\n    tags: []const []const u8 = &[_][]const u8{},\n};\n```\n\n#### Two Syntax Patterns:\n\n```bash\n# Repeated flags (default)\n./program --files=a.txt --files=b.txt --files=c.txt\n\n# Comma-separated values  \n./program --files=a.txt,b.txt,c.txt\n```\n\n---\n\n## Advanced Features\n\n### Type-Safe Arguments\n\nLeverage Zig's type system for compile-time guarantees:\n\n```zig\nconst Args = struct {\n    // u16 enforces valid port range (0-65535)\n    port: u16 = 8080,\n    \n    // Optional types for nullable values\n    config: ?[]const u8 = null,\n    \n    // Enums for valid choices\n    format: enum { json, yaml, toml } = .json,\n};\n```\n\n### Help Documentation\n\nHelp is **auto-generated by default** from your struct fields:\n\n```zig\nconst Args = struct {\n    verbose: bool = false,\n    port: u16 = 8080,\n};\n\n// Running with --help automatically shows:\n// Options:\n//   --verbose            bool (default: false)\n//   --port               u16 (default: 8080)\n```\n\nFor custom help text, define `pub const help`:\n\n```zig\nconst Args = struct {\n    verbose: bool = false,\n    port: u16 = 8080,\n    \n    pub const help = \n        \\\\Options:\n        \\\\  --verbose    Enable verbose output (default: false)\n        \\\\  --port       Port to listen on (default: 8080)\n    ;\n};\n```\n\n**Why this approach?**\n- Auto-generated by default (zero config)\n- Custom help when you want fine-grained control\n- Accessible at compile time via `@hasDecl()`\n- Type-safe (struct literal validation)\n- Zero runtime cost (can be optimized away)\n\n### Subcommands\n\nGit-style subcommands using `union(enum)`:\n\n```zig\nconst CLI = union(enum) {\n    start: struct {\n        host: []const u8 = \"localhost\",\n        port: u16 = 8080,\n    },\n    stop: struct {\n        force: bool = false,\n    },\n    \n    pub const help = \n        \\\\ Server management CLI\n        \\\\ commands:\n        \\\\  start       Start the server\n        \\\\      --host     Hostname to bind to (default: localhost)\n        \\\\      --port     Port to listen on (default: 8080)\n        \\\\  stop        Stop the server\n        \\\\      --force    Force stop (default: false)\n    ;\n};\n\nconst cli = try flags.parse(args, CLI);\nswitch (cli) {\n    .start => |s| startServer(s.host, s.port),\n    .stop => |s| stopServer(s.force),\n}\n```\n\n### Positional Arguments\n\nUse the `@\"--\"` marker to separate flags from positional arguments:\n\n```zig\nconst Args = struct {\n    verbose: bool = false,\n    @\"--\": void,\n    input: []const u8,\n    output: []const u8 = \"output.txt\",\n};\n\n// Usage: program --verbose input.txt --output=result.txt\n```\n\n---\n\n## Supported Types\n\n| Type | Example | Notes |\n|------|---------|-------|\n| `bool` | `--verbose` or `--verbose=true/false` | Presence = true |\n| Integers | `--port=8080` | `u8`-`u64`, `i8`-`i64` |\n| Floats | `--rate=0.5` | `f32`, `f64` |\n| Strings | `--name=value` | `[]const u8` only |\n| Enums | `--format=json` | Validates against variants |\n| Optionals | `--config=path` or omit | `?T` for nullable values |\n\n---\n\n## Error Handling\n\nThe parser returns descriptive errors:\n\n```zig\npub const Error = error{\n    DuplicateFlag,              // --port=8080 --port=9090\n    InvalidArgument,            // No args provided\n    InvalidValue,               // --port=not_a_number\n    MissingRequiredFlag,        // Required field with no default\n    MissingRequiredPositional,  // Positional arg not provided\n    MissingSubcommand,          // No subcommand for union\n    MissingValue,               // --name (no value after =)\n    UnknownFlag,                // --unknown-flag\n    UnknownSubcommand,          // prog unknown-cmd\n    UnexpectedArgument,         // Extra positional arg\n};\n```\n\nExample usage:\n\n```zig\nconst parsed = flags.parse(args, Args) catch |err| {\n    std.log.err(\"Parse error: {s}\", .{@errorName(err)});\n    return;\n};\n```\n\n---\n\n## Documentation\n\nSee [docs/](docs/) for detailed documentation:\n\n| Document | Description |\n|----------|-------------|\n| [docs/README.md](docs/README.md) | Usage guide and API reference |\n| [docs/DESIGN.md](docs/DESIGN.md) | Architecture and design decisions |\n\n---\n\n## Limitations\n\n- **No short flags** - Use long flags (`--verbose` not `-v`)\n- **Equals syntax only** - Use `--name=value` not `--name value`\n- **No custom types** - Only built-in types and enums\n- **No slices** - Single values only\n\n---\n\n## Credits\n\nThis library draws significant inspiration from two exceptional projects:\n\n### TigerBeetle\n\nThe design philosophy of struct-based flag definitions and zero-cost abstractions is heavily inspired by [TigerBeetle's flags implementation](https://github.com/tigerbeetle/tigerbeetle). Their approach to type-safe, performant CLI parsing in Zig demonstrates the power of leveraging Zig's comptime capabilities.\n\n### Rust clap\n\nThe declarative API design and developer experience patterns are influenced by [Rust's clap crate](https://github.com/clap-rs/clap). Clap's ergonomic structopt-style derive patterns informed our approach to making CLI parsing intuitive while maintaining compile-time safety.\n\n---\n\n<div align=\"center\">\n\nMade with  for the Zig community\n\n</div>\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/197046972?v=4",
  "releases": [],
  "owner_bio": "In the shadow of God - move fast, break things",
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_created_at": "2025-01-30T07:24:18Z",
  "license": "MIT",
  "category": "library"
}