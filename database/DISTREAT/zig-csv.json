{
  "name": "zig-csv",
  "owner": "DISTREAT",
  "repo": "zig-csv",
  "description": "A library for parsing, creating, and manipulating CSV data.",
  "type": "package",
  "topics": [
    "csv",
    "zig",
    "zig-lib",
    "zig-library",
    "zig-package"
  ],
  "stars": 12,
  "forks": 4,
  "watchers": 2,
  "updated_at": "2026-01-18T02:37:20Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# zig-csv\n\nA library for parsing, creating, and manipulating CSV data in Zig.\n\n## Features\n\n- Data integrity: modifications are explicit and predictable.\n- Fail-fast: ambiguous or malformed input results in immediate failure.\n- Low-level access: exposes internals for flexibility and control.\n- Real-world compatibility: handles edge cases and non-standard CSV formats.\n\n## Philosophy\n\nThe design of this library is guided by the principles outlined in the [CSV Parser Philosophy](PHILOSOPHY.md) document,\nwhich emphasizes data integrity, fail-fast behavior, and low-level access to parsed data.\nThis design approach ensures the library is compatible with real-world CSV data while avoiding ambiguity in parsing.\n\n## Installation\n\nFirst, add the dependency to your `build.zig.zon`:\n\n```sh\nzig fetch --save git+https://github.com/DISTREAT/zig-csv\n```\n\nThen, add the package to your `build.zig`:\n\n```zig\nconst zig_csv = b.dependency(\"zig_csv\", .{});\nexe.root_module.addImport(\"zig_csv\", zig_csv.module(\"zig_csv\"));\n```\n\n## Usage\n\nThe library provides two primary types for working with CSV data:\n`StructuredTable` and `Table`.\n\nThe differences between them are as follows:\n- `StructuredTable` requires a predefined schema,\n  allowing for type-safe parsing and manipulation of CSV data.\n- `Table` offers a more flexible approach, enabling dynamic\n  handling of CSV data without a predefined schema.\n\n### StructuredTable\n\nThe `StructuredTable` allows you to define a schema for your CSV data,\nenabling type-safe parsing and manipulation.\n\n```zig\nconst std = @import(\"std\");\nconst csv = @import(\"zig_csv\");\nconst allocator = std.heap.page_allocator;\n\n// Define a schema for the CSV data\nconst Animal = struct {\n    id: i32,\n    name: []const u8,\n    happy: ?bool,\n};\n\n// Parse CSV data into a StructuredTable\nvar table = csv.StructuredTable(Animal).init(\n    allocator,\n    csv.Settings.default()\n);\ndefer table.deinit();\ntry table.parse(\n    \\\\id,name,happy\n    \\\\1,dog,\n    \\\\2,cat,\n    \\\\3,bird,\n);\n\n// Modify the name of the animal with id 2\nfor (0..table.getRowCount()) |index| {\n    // Retrieve the row at the current index.\n    const row = try table.getRow(index);\n    if (row == .@\"error\") {\n        // If the row structure doesn't match the schema, handle the error.\n        break;\n    }\n    // Access the parsed Animal struct from the row.\n    var animal = row.ok.value;\n    // Look for the animal with id == 2.\n    if (animal.id != 2) continue;\n\n    // Change the animal's name to \"mouse\".\n    animal.name = \"mouse\";\n    // Attempt to write the modified struct back to the table.\n    const result = try table.editRow(index, animal);\n    if (result == .@\"error\") {\n        // If the new struct doesn't match the schema, handle the error.\n    }\n    // Stop after editing the first matching row.\n    break;\n}\n\n// Export the table back to CSV\nconst exported_csv = try table.exportCSV(allocator);\ndefer allocator.free(exported_csv);\nstd.debug.print(\"Exported CSV:\\n{s}\\n\", .{exported_csv});\n// id,name,happy\n// 1,dog,\n// 2,mouse,\n// 3,bird,\n\n```\n\n### Table\n\nThe `Table` type provides a flexible way to work with CSV data without a predefined schema.\n\n```zig\nconst std = @import(\"std\");\nconst csv = @import(\"zig_csv\");\nconst allocator = std.heap.page_allocator;\n\n// Parse CSV data\nvar table = csv.Table.init(allocator, csv.Settings.default());\ndefer table.deinit();\ntry table.parse(\n    \\\\id,animal,color\n    \\\\1,cat,black\n    \\\\2,dog,brown\n    \\\\3,bird,blue\n);\n\n// Change the color of the dog to \"white\"\nconst animal_col = (try table.findColumnIndexesByValue(allocator, 0, \"animal\"))[0];\nconst dog_row = (try table.findRowIndexesByValue(allocator, animal_col, \"dog\"))[0];\nconst color_col = (try table.findColumnIndexesByValue(allocator, 0, \"color\"))[0];\ntry table.replaceValue(dog_row, color_col, \"white\");\n\n// Add a new animal\nconst new_row = try table.insertEmptyRow(null);\ntry table.replaceValue(new_row, animal_col, \"fish\");\ntry table.replaceValue(new_row, color_col, \"gold\");\n\n// Export the table back to CSV\nconst exported = try table.exportCSV(allocator);\ndefer allocator.free(exported);\n\nstd.debug.print(\"Exported CSV:\\n{s}\\n\", .{exported});\n// id,animal,color\n// 1,cat,black\n// 2,dog,white\n// 3,bird,blue\n// ,fish,gold\n```\n\n_More examples can be found in `src/tests.zig`._\n\n## Documentation\n\nThe documentation is available [online](https://distreat.github.io/zig-csv/),\nor can be built locally using `zig build docs`.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/99132213?u=b22d9f1e69659b314f27c10b8fbae707d3676eac&v=4",
  "releases": [],
  "owner_bio": "email address: github[at]distreat.anonaddy.com",
  "owner_company": null,
  "owner_location": "Central Europe",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 2,
  "owner_following": 2,
  "owner_created_at": "2022-02-06T15:06:59Z",
  "homepage": "https://distreat.github.io/zig-csv",
  "license": "LGPL-3.0",
  "category": "library"
}