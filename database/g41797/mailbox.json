{
  "name": "mailbox",
  "owner": "g41797",
  "repo": "mailbox",
  "description": "Zig Mailbox  is convenient  inter-thread communication mechanizm.",
  "type": "package",
  "topics": [
    "actor-model",
    "inter-thread-communication",
    "mailbox",
    "zig",
    "zig-library",
    "zig-package",
    "thread-safe",
    "fan-in",
    "fan-out",
    "channel-on-steroids"
  ],
  "stars": 88,
  "forks": 7,
  "watchers": 2,
  "updated_at": "2025-12-21T07:29:36Z",
  "minimum_zig_version": "0.15.2",
  "readme": "![](_logo/mailboxes.png)\n\n\n# Mailbox - old new way of inter-thread communication.          \n\n[![CI](https://github.com/g41797/yazq/actions/workflows/ci.yml/badge.svg)](https://github.com/g41797/yazq/actions/workflows/ci.yml)\n<img src=\"https://img.shields.io/badge/Linux-FCC624?style=flat&logo=linux&logoColor=black\" width=\"48\" height=\"24\">&nbsp;\n<img src=\"https://img.shields.io/badge/macOS-000000?style=flat&logo=apple&logoColor=white\" width=\"48\" height=\"24\">&nbsp;\n<img src=\"https://img.shields.io/badge/Windows-0078D6?style=flat&logo=windows&logoColor=white\" width=\"48\" height=\"24\">&nbsp;\n\n## A bit of history, a bit of theory\n\nMailboxes are one of the fundamental parts of the [actor model originated in **1973**](https://en.wikipedia.org/wiki/Actor_model): \n> An actor is an object that carries out its actions in response to communications it receives.\n> Through the mailbox mechanism, actors can decouple the reception of a message from its elaboration.\n> A mailbox is nothing more than the data structure (FIFO) that holds messages.\n\nI first encountered MailBox in the late 80s while working on a real-time system: \n> \"A **mailbox** is object that can be used for inter-task\ncommunication. When task A wants to send an object to task B, task A\nmust send the object to the mailbox, and task B must visit the mailbox,\nwhere, if an object isn't there, it has the option of *waiting for any\ndesired length of time*...\" \n> **iRMX 86â„¢ NUCLEUS REFERENCE MANUAL** _Copyright @ 1980, 1981 Intel Corporation.\n\nSince then, I have used it in:\n\n|     OS      | Language(s) |\n|:-----------:|:-----------:|\n|    iRMX     |  *PL/M-86*  |\n|     AIX     |     *C*     |\n|   Windows   |  *C++/C#*   |\n|    Linux    |    *Go*     |\n\n**Now it's Zig time!!!**\n\n## Why?\nIf your thread runs in \"Fire and Forget\" mode, you don't need Mailbox.\n \nBut in real multithreaded applications, threads communicate with each other as\nmembers of a work team.\n\n**Mailbox** provides a convenient and simple inter-thread communication:\n- thread safe\n- asynchronous\n- cancelable\n- no own allocations\n- unbounded\n- fan-out/fan-in\n  \n\n## Example of usage - 'Echo' \n```zig\n    // Mbx is Mailbox with usize letter(data)\n    const Mbx = mailbox.MailBox(usize);\n\n    // Echo - runs on own thread\n    // It has two mailboxes\n    // \"TO\" and \"FROM\" - from the client point of the view\n    // Receives letter via 'TO' mailbox\n    // Replies letter without change (echo) to \"FROM\" mailbox\n    const Echo = struct {\n        const Self = @This();\n\n        to: Mbx = undefined,\n        from: Mbx = undefined,\n        thread: Thread = undefined,\n\n        // Mailboxes creation and start of the thread\n        // Pay attention, that client code does not use\n        // any thread \"API\" - all embedded within Echo\n        pub fn start(echo: *Self) void {\n            echo.to = .{};\n            echo.from = .{};\n            echo.thread = std.Thread.spawn(.{}, run, .{echo}) catch unreachable;\n        }\n\n        // Echo thread function\n        fn run(echo: *Self) void {\n            // Main loop:\n            while (true) {\n                // Receive - exit from the thread if mailbox was closed\n                const envelope = echo.to.receive(100000000) catch break;\n                // Reply to the client\n                // Exit from the thread if mailbox was closed\n                _ = echo.from.send(envelope) catch break;\n            }\n        }\n\n        // Wait exit from the thread\n        pub fn waitFinish(echo: *Self) void {\n            echo.thread.join();\n        }\n\n        // Close mailboxes\n        // As result Echo should stop processing\n        // and exit from the thread.\n        pub fn stop(echo: *Self) !void {\n            _ = echo.to.close();\n            _ = echo.from.close();\n        }\n    };\n\n    var echo = try std.testing.allocator.create(Echo);\n\n    // Start Echo(on own thread)\n    echo.start();\n    defer echo.stop();\n\n    defer {\n        // Wait finish of Echo\n        echo.waitFinish();\n        std.testing.allocator.destroy(echo);\n    }\n\n    // because nothing was send to 'TO' mailbox, nothing should be received\n    // from 'FROM' mailbox\n    try testing.expectError(error.Timeout, echo.from.receive(100));\n\n    // Create wrapper for the data\n    const envl = try std.testing.allocator.create(Mbx.Envelope);\n    defer std.testing.allocator.destroy(envl);\n\n    // Send/Receive loop\n    for (0..6) |indx| {\n        // Set value for send [0-5]\n        envl.letter = indx;\n\n        // Send to 'TO' mailbox\n        try echo.to.send(envl);\n\n        // Wait received data from OUT mailbox\n        const back = echo.from.receive(1000000);\n\n        if (back) |val| {\n            // Expected value == index [0-5]\n            try testing.expect(val.letter == indx);\n        } else |_| {\n            try testing.expect(false);\n        }\n    }\n```\n\n## Boring details\n\nMailbox of *[]const u8* 'Letters':\n```zig\nconst Rumors = mailbox.MailBox([]const u8);\nconst rmrsMbx : Rumors = .{};\n```\n\n**Envelope** is a wrapper of actual user defined type **Letter**.\n```zig\n        pub const Envelope = struct {\n            prev: ?*Envelope = null,\n            next: ?*Envelope = null,\n            letter: Letter,\n        };\n```\nIn fact Mailbox is a queue(FIFO) of Envelope(s).\n\n## APIs\n\nMailBox supports following operations:\n- **send** *Envelope* to MailBox (*enqueue*) and wakeup waiting receiver(s)\n- **receive** *Envelope* from Mailbox (*dequeue*) with time-out\n- **interrupt** - wake-up receiver thread\n- **close** Mailbox:\n  - disables further operations\n  - _first_ close returns List of non-processed *Envelope(s)* for free/reuse etc.\n\n## Intrusive mailbox\n\nIn order to be intrusive, Envelope should look like\n\n```zig\n  pub const T = struct {\n       prev: ?*T = null,\n       next: ?*T = null,\n       additional stuff\n  };\n```\nDumb example:\n```zig\n  const MsgU32 = struct {\n      prev: ?*MsgU32 = null,\n      next: ?*MsgU32 = null,\n      stuff: u32 = undefined,\n  };\n```\n\n_MailBoxIntrusive_ has exactly the same functionality as former _MailBox_.\n\nFor curious:\n  - [What does it mean for a data structure to be \"intrusive\"?](https://stackoverflow.com/questions/5004162/what-does-it-mean-for-a-data-structure-to-be-intrusive)\n  - [libxev intrusive queue](https://github.com/mitchellh/libxev/blob/main/src/queue.zig#L4)\n\n## TypeErased Mailbox\n\n**TypeErased Mailbox** is an _intrusive_ mailbox that does **not know the message type**.\n\nThis implementation relies on [De-Genericify Linked Lists](https://ziglang.org/download/0.15.1/release-notes.html#De-Genericify-Linked-Lists) introduced in Zig 0.15.1.  \n\nIn order to work with **_TypeErased Mailbox_** each message must embed a linked list node:\n```zig\nconst Msg = struct {\n  <your data>\n  node: std.DoublyLinkedList.Node,\n};\n```\n\nExample:\n```zig\n    const Node = std.DoublyLinkedList.Node;\n    const Mbx = mailbox.TypeErasedMailbox;\n\n    // Message envelope (intrusive)\n    const Msg = struct {\n        value: usize = 0,\n        node: Node = .{},\n    };\n\n    var mbox: Mbx = .{};\n\n    var msg: Msg = .{\n        .value = 1,\n    };\n\n    _ = try mbox.send(&msg.node);\n\n    const node: *Node = try mbox.receive(1000);\n    const rcvdMsg: *Msg = @fieldParentPtr(\"node\", node);\n    var shouldBeOne: usize = rcvdMsg.*.value;\n```\n_TypeErasedMailbox_ has exactly the same functionality as former _MailBox_.\n\n## Eat your own dog food  \n\nI am using _MailBox_ in own projects:\n- [multithreaded tests](https://github.com/g41797/syslog/blob/main/src/syslog_tests.zig)\n- [message pool](https://github.com/g41797/nats/blob/main/src/messages.zig#L222)\n\n\n## Installation\nYou finally got to installation!\n\nWith an existing Zig project, adding Mailbox to it is easy:\n\n1. Add mailbox to your `build.zig.zon`\n2. Add mailbox to your `build.zig`\n\nTo add mailbox to `build.zig.zon` simply run the following from your project root:\n\n```sh\nzig fetch --save=mailbox git+https://github.com/g41797/mailbox\n```\n\nand in your `build.zig.zon` you should find a new dependency like:\n\n```zig\n.{\n    .dependencies = .{\n        .mailbox = .{\n            .url = \"git+https://github.com/g41797/mailbox#3f794f34f5d859e7090c608da998f3b8856f8329\",\n            .hash = \"122068e7811ec1bfc2a81c9250078dd5dafa9dca4eb3f1910191ba060585526f03fe\",\n        },\n    },\n    .paths = .{\n        \"\",\n    },\n}\n```\n\n**NOTE**: If you still need version for zig 0.14.1 , run\n```sh\nzig fetch --save https://github.com/g41797/mailbox/archive/refs/tags/v0.0.12.tar.gz\n```\n\n\nThen, in your `build.zig`'s `build` function, add the following before\n`b.installArtifact(exe)`:\n\n```zig\n    const mailbox = b.dependency(\"mailbox\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    exe.root_module.addImport(\"mailbox\", mailbox.module(\"mailbox\"));\n```\nFrom then on, you can use the Mailbox package in your code:\n```zig\n    const mailbox = @import(\"mailbox\");\n```\n\n\n## License\n[MIT](LICENSE)\n\n## Last warning\nFirst rule of multithreading:\n>**If you can do without multithreading - do without.**\n<br>    \n\n*Powered by*  [![clion](_logo/CLion_icon.png)][refclion]\n\n[refclion]: https://www.jetbrains.com/clion/\n\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/9116281?u=2db219a6136b07d51afe2002b80a7e47b3b37427&v=4",
  "releases": [
    {
      "tag_name": "v0.0.13",
      "name": "zig 0.15.2",
      "body": "Migration to zig 0.15.2.\r\nAdded TypeErased Mailbox.",
      "prerelease": true,
      "published_at": "2025-12-20T11:51:14Z",
      "html_url": "https://github.com/g41797/mailbox/releases/tag/v0.0.13",
      "assets": []
    },
    {
      "tag_name": "v0.0.12",
      "name": "zig 0.14.1",
      "body": "mailbox based on zig 0.14.1",
      "prerelease": false,
      "published_at": "2025-12-20T07:26:12Z",
      "html_url": "https://github.com/g41797/mailbox/releases/tag/v0.0.12",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 12,
  "owner_following": 8,
  "owner_created_at": "2014-10-09T16:33:35Z",
  "license": "MIT",
  "category": "library"
}