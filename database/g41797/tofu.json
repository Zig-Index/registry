{
  "name": "tofu",
  "owner": "g41797",
  "repo": "tofu",
  "description": "Tofu - Async messaging for Zig",
  "type": "package",
  "topics": [
    "async",
    "messaging",
    "protocol",
    "zig-library",
    "zig-package"
  ],
  "stars": 8,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-12-15T14:15:05Z",
  "dependencies": [
    {
      "name": "nats",
      "url": "git+https://github.com/g41797/nats#5028b8772a15b84a9c7ff959db93ac74ac2c754b",
      "hash": "nats-0.0.3-MWKeg18aAgBOji2Yb_PlNYb0zyN6SvcCP0ULh8m3Qewp"
    },
    {
      "name": "mailbox",
      "url": "git+https://github.com/g41797/mailbox#5e2a00e7af3d27be9f40dc03aeca204bb8973fce",
      "hash": "mailbox-0.0.0-eJsHsMBEAACjbrEiAWogXHrTTXjUheNjxm-PLKTUQWCz"
    },
    {
      "name": "temp",
      "url": "git+https://github.com/abhinav/temp.zig#382a711f253d54a88f222650e6c03b62411373c6",
      "hash": "temp-0.3.0-Ogl1FSSBAAB2WXv3QbTYO3NYfVFoYTBkZsVK3MYvbxFE"
    },
    {
      "name": "datetime",
      "url": "git+https://github.com/frmdstryr/zig-datetime?ref=master#3a39a21e6e34dcb0ade0ff828d0914d40ba535f3",
      "hash": "datetime-0.8.0-cJNXzP_YAQBxQ5hkNNP6ScnG5XsqciJmeP5RVV4xwCBA"
    }
  ],
  "minimum_zig_version": "0.14.0",
  "readme": "![](_logo/Ziggy_And_Zero_Are_Cooking_Tofu.png)\n# tofu - _Async messaging for Zig._\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Linux](https://github.com/g41797/yaaamp/actions/workflows/linux.yml/badge.svg)](https://github.com/g41797/yaaamp/actions/workflows/linux.yml)\n<!-- [![MacOS](https://github.com/g41797/yaaamp/actions/workflows/mac.yml/badge.svg)](https://github.com/g41797/yaaamp/actions/workflows/mac.yml) -->\n\n---\n\n##\n\nWhat does **tofu** have to do with a library for \n_asynchronous message communication_?\n\nI spent a long time breaking my head trying to explain the _point_ of this project.\n\nThere are already tons of networking libraries out there. \n\nWell, let’s say at least several kilograms for Zig. \n\nAnd then it hit me — **tofu**!\n\nTofu is a simple product with almost no flavor. You can\n\n- eat it plain \n- add a little spice and make something slightly better\n- or go all the way and create culinary masterpieces.\n\nAnd what I especially like:\n>[tofu is as good as you are a cook](https://www.reddit.com/r/vegan/comments/hguwpc/tofu_is_as_good_as_you_are_a_cook/)\n\nYou'll use the tofu library in a similar way:\n\n- from minimal setups \n- to more complex flows\n- and eventually distributed applications.\n\n---\n\n\n## Features\n \n- **Message-Based**: Uses discrete messages for communication.\n- **Asynchronous**: Enables non-blocking message exchanges.\n- **Duplex**: Supports two-way communication.\n- **Peer-to-Peer**: Allows equal roles after connection establishment.\n- **Stream oriented transport** - TCP/IP and **U**nix **D**omain **S**ockets\n- **Multithread-friendly** - All APIs are safe for concurrent access.\n- **Memory management for messages** - internal message pool\n- **Backpressure management** - allows to control receive of messages\n- **Customizable application flows** - allows to build various application flows not restricted to request/response or pub/sub\n- **Simplest API** - you don't have to bother with or know the \"guts\" of socket interfaces\n\n\n---\n\n\n\n## A bit of history\n\n**tofu** wasn’t just \"pulled out of thin air.\"\n\nI started developing a similar system back in 2008, maintained it, and kept it running for years.\n\nThat system powered all data transfer in a serious distributed environment\n\n- from basic IPC \n- to communication in a proprietary distributed file system.\n\nWe parted ways a few years ago, but I haven't heard any complaints yet.\n\nCorporate lawyers can relax — from that system I only took the _smell_\n([precedent case about paying for smell](http://fable1001.blogspot.com/2009/11/nasreddin-hodja-smell-of-soup-and-sound.html))\n\nBy '_smell_' I mean the idea itself:\n\n- message as the _**data**_ and _**API**_\n- the philosophy of _**gradual evolution**_ \n  - starting from something simple \n  - and steadily growing into more advanced and powerful systems.\n\n---\n\n\n## API\n\n**_Stripped Interface Definitions_**:\n\n```zig\n/// Defines the async message passing engine interface.\n/// \"Ampe\" and \"engine\" mean the same thing.\n///\n/// Provides methods to:\n/// - Get/return messages from the internal pool.\n/// - Create/destroy ChannelGroups.\n/// - Access the shared allocator for memory management.\npub const Ampe = struct {\n\n    /// Gets a message from the internal pool.\n    ///\n    /// Uses the given `strategy` to decide how to allocate.\n    /// Returns `null` if pool is empty and `strategy` is `poolOnly`.\n    ///\n    /// Returns error if engine is shutting down or allocation fails.\n    ///\n    /// Thread-safe.\n    pub fn get(\n        ampe: Ampe,\n        strategy: AllocationStrategy,\n    ) status.AmpeError!?*message.Message {...}\n\n    /// Returns a message to the internal pool.\n    /// If pool is closed, destroys the message instead.\n    ///\n    /// Always sets `msg.*` to `null` to prevent reuse.\n    ///\n    /// Thread-safe.\n    pub fn put(\n        ampe: Ampe,\n        msg: *?*message.Message,\n    ) void {...}\n\n    /// Creates a new `ChannelGroup`.\n    ///\n    /// Call `destroy` on result to stop communication and free memory.\n    ///\n    /// Thread-safe.\n    pub fn create(\n        ampe: Ampe,\n    ) status.AmpeError!ChannelGroup {...}\n\n    /// Destroys `ChannelGroup`, stops communication, frees memory.\n    ///\n    /// Thread-safe.\n    pub fn destroy(\n        ampe: Ampe,\n        chnls: ChannelGroup,\n    ) status.AmpeError!void {...}\n\n    /// Returns the allocator used by the engine for all memory.\n    ///\n    /// Thread-safe.\n    pub fn getAllocator(\n        ampe: Ampe,\n    ) Allocator {...}\n};\n\n/// Defines how messages are allocated from the pool.\npub const AllocationStrategy = enum {\n    /// Tries to get a message from the pool. Returns null if the pool is empty.\n    poolOnly,\n    /// Gets a message from the pool or creates a new one if the pool is empty.\n    always,\n};\n\n//////////////////////////////////////////////////////////////////////////\n// Client and server terms are used only during the initial handshake.\n// After the handshake, both sides are equal. We call them **peers**.\n// They send and receive messages based on application logic.\n//////////////////////////////////////////////////////////////////////////\n\n/// Defines the ChannelGroup interface for async message passing.\n/// Supports two-way message exchange between peers.\npub const ChannelGroup = struct {\n\n    /// Submits a message for async processing:\n    /// - most cases: send to peer\n    /// - others: internal network related processing\n    ///\n    /// On success:\n    /// - Sets `msg.*` to null (prevents reuse).\n    /// - Returns `BinaryHeader` for tracking.\n    ///\n    /// On error:\n    /// - Returns an error.\n    /// - If the engine cannot use the message (internal failure),\n    ///   also sets `msg.*` to null.\n    ///\n    /// Thread-safe.\n    pub fn enqueueToPeer(\n        chnls: ChannelGroup,\n        msg: *?*message.Message,\n    ) status.AmpeError!message.BinaryHeader {...}\n\n    /// Waits for the next message from the internal queue.\n    ///\n    /// Timeout is in nanoseconds. Returns `null` if no message arrives in time.\n    ///\n    /// Message sources:\n    /// - Remote peer (via `enqueueToPeer` on their side).\n    /// - Application (via `updateWaiter` on this ChannelGroup).\n    /// - Ampe (status/control messages).\n    ///\n    /// Check `BinaryHeader` to identify the source.\n    ///\n    /// On error: stop using this ChannelGroup and call `ampe.destroy` on it.\n    ///\n    /// Call in a loop from **one thread only**.\n    pub fn waitReceive(\n        chnls: ChannelGroup,\n        timeout_ns: u64,\n    ) status.AmpeError!?*message.Message {...}\n\n    /// Adds a message to the internal queue for `waitReceive`.\n    ///\n    /// If `msg.*` is not null:\n    /// - Engine sets status to `'waiter_update'`.\n    /// - Sets `msg.*` to null after success.\n    /// - No need for `channel_number` or similar fields.\n    ///\n    /// If `msg.*` is null:\n    /// - Creates a `'waiter_update'` Signal and adds it.\n    ///\n    /// Returns error if shutting down.\n    ///\n    /// Use from another thread to:\n    /// - Wake the waiter (`msg.*` = null).\n    /// - Send info/commands/notifications.\n    ///\n    /// FIFO order only. No priority queues.\n    ///\n    /// Thread-safe.\n    pub fn updateWaiter(\n        chnls: ChannelGroup,\n        update: *?*message.Message,\n    ) status.AmpeError!void {...}\n};\n```\n\nDocumentation and examples are available on the [Tofu documentation site](https://g41797.github.io/tofu/) (**_work in progress_**).\n\n---\n\n\n## NAQ or **N**ever **A**sked **Q**uestions\n\n<details><summary><i>Why not use another library?</i></summary>\n  Why not? Go ahead and use it.\n</details>\n\n\n---\n\n\n## Credits\n- [Karl Seguin](https://github.com/karlseguin) — for introducing me to [Zig networking](https://www.openmymind.net/TCP-Server-In-Zig-Part-1-Single-Threaded/)\n- [tardy](https://github.com/tardy-org/tardy) — I peeked into 2 files of the project (the author will guess which ones)\n- [temp.zig](https://github.com/abhinav/temp.zig) — helped me (and will help you) work with temporary files\n- [Gemini AI image generator](https://gemini.google.com/app) — the only one out of six I managed to convince to seat Ziggy and Zero at the same table\n- Zig Community Forums (in order of my registration) - for your help and patience with my posts\n  - [Zig on Reddit](https://www.reddit.com/r/Zig/)\n  - [Zig on Discord](https://discord.com/invite/zig)\n  - [Zig on Discourse](https://ziggit.dev/)\n\n---\n\n\n## Last but not least\n⭐️ Like, share, and don’t forget to [subscribe to the channel](https://github.com/g41797/tofu) !\n\n\n\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/9116281?u=2db219a6136b07d51afe2002b80a7e47b3b37427&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 12,
  "owner_following": 7,
  "owner_created_at": "2014-10-09T16:33:35Z",
  "homepage": "https://g41797.github.io/tofu/",
  "license": "MIT",
  "category": "library"
}