{
  "name": "keylib",
  "owner": "Zig-Sec",
  "repo": "keylib",
  "description": "FIDO2/ PassKey compatible authentication library",
  "type": "project",
  "topics": [
    "authentication",
    "authenticator",
    "ctap",
    "ctap2",
    "fido2",
    "webauthn",
    "zig",
    "ziglang",
    "passkey",
    "passkeys"
  ],
  "stars": 68,
  "forks": 3,
  "watchers": 2,
  "updated_at": "2025-12-06T14:56:19Z",
  "dependencies": [
    {
      "name": "zbor",
      "url": "https://github.com/r4gus/zbor/archive/refs/tags/0.20.1.tar.gz",
      "hash": "zbor-0.20.0-kr-CoK1kAwDtdlkCAsc43I4FkS-G2GJ0buELN1gCVfLN"
    },
    {
      "name": "hidapi",
      "url": "https://github.com/r4gus/hidapi/archive/refs/tags/0.16.0.tar.gz",
      "hash": "hidapi-0.16.0-470BSmniGwCMJlhcDUFoW8Lw80CRGWngB876THiu8Ryf"
    },
    {
      "name": "uuid",
      "url": "https://github.com/r4gus/uuid-zig/archive/refs/tags/0.4.0.tar.gz",
      "hash": "uuid-0.4.0-oOieIR2AAAChAUVBY4ABjYI1XN0EbVALmiN0JIlggC3i"
    }
  ],
  "readme": "# keylib\n\n![GitHub](https://img.shields.io/github/license/r4gus/keylib?style=flat-square)\n![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/r4gus/keylib/main.yml?style=flat-square)\n![GitHub all releases](https://img.shields.io/github/downloads/r4gus/keylib/total?style=flat-square)\n<noscript><a href=\"https://liberapay.com/r4gus/donate\"><img alt=\"Donate using Liberapay\" src=\"https://liberapay.com/assets/widgets/donate.svg\"></a></noscript>\n\nFIDO2 compatible authenticator and client library written in [Zig](https://ziglang.org/). The authenticator part requires __zero dynamic allocations__.\n\n> We track the latest stable release of Zig (`0.12.0`)\n\nIf you want to see an example on how the library could be used, check out [PassKeeZ](https://github.com/r4gus/keypass).\n\n| Zig version | keylib version |\n|:-----------:|:--------------:|\n| 0.13.0      | 0.5.0, 0.5.1, 0.5.2, 0.5.3 |\n| 0.14.x      | 0.6.0, 0.6.1 |\n| 0.15.x      | 0.7.0 |\n\n## QA\n\n<details>\n<summary><ins>What is FIDO2?</ins></summary>\n\nFIDO2 is a protocol designed for authentication purposes. It can be used as single factor (e.g., as a replacement for password based authentication) or as a second factor (e.g., instead of OTPs).\n\n</details>\n\n<details>\n<summary><ins>I've heard the term Passkey but what is that?</ins></summary>\n\nPasskey is a marketing term which is used to refer to a specific FIDO2 authenticator configuration. A authenticator can be configured to use so called discoverable credentials (also referred to as resident keys). Those credentials are stored somewhere on your device, e.g. in a encrypted database. Devices can also be protected by some form of user verification. This can be a PIN or a built in user verification method like a finger print scanner. Passkey refers to FIDO2 using discoverable credentials and some form of user verification. \n\nPlease note that this is only one interpretation of what PassKey means as the term itself is nowhere defined (see also [Passkeys's: A Shattered Dream](https://fy.blackhats.net.au/blog/2024-04-26-passkeys-a-shattered-dream/)).\n\n</details>\n\n<details>\n<summary><ins>How does it work?</ins></summary>\n\nFIDO2 uses asymmetric cryptography to ensure the authenticity of the user. A unique credential (key-pair) is created for each relying party (typically a web server) and bound to the relying party id (e.g., google.com). The private key stays on the authenticator and the public key is stored by the relying party. When a user wants to authenticate herself, the relying party sends a nonce (a random byte string meant to be only used once) and some other data, over the client (typically your web browser), to the authenticator. The authenticator looks up the required private key and signs the data with it. The generated signature can then be verified by the relying party using the corresponding public key.\n\n</details>\n\n<details>\n<summary><ins>What is the difference between FIDO2, PassKey and WebAuthn?</ins></summary>\n\nYou might have noticed that FIDO2, PassKey and even WebAuthn are often used interchangeably by some articles and people which can be confusing, especially for people new to the protocol. Here is a short overview:\n\n* `FIDO2` Protocol consisting of two sub-protocols: Client to Authenticator Protocol 2 (`CTAP2`) and Web Authentication (`WebAuthn`)\n* `CTAP2` Specification that governs how a authenticator (e.g. YubiKey) should behave and how a authenticator and a client (e.g. web-browser) can communicate with each other.\n* `WebAuthn` Specification that defines how web applications can use a authenticator for authentication. This includes the declaration of data structures and Java Script APIs.\n* `PassKey`: A authenticator with a specific configuration (see above).\n\n</details>\n\n\n<details>\n<summary><ins>Why should I use FIDO2?</ins></summary>\n\nFIDO2 has a lot of advantages compared to passwords:\n\n1. No secret information is shared, i.e. the private key stays on the authenticator or is protected, e.g. using key wrapping.\n2. Each credential is bound to a relying party id (e.g. google.com), which makes social engineering attacks, like phishing websites, quite difficult (as long as the client verifies the relying party id properly).\n3. Users don't have to be concerned with problems like password complexity.\n4. If well implemented, FIDO2 provides a better user experience (e.g., faster logins).\n5. A recent paper showed that with some adoptions, FIDO2 is ready for a post quantum world under certain conditions ([FIDO2, CTAP 2.1, and WebAuthn 2: Provable Security and Post-Quantum Instantiation, Cryptology ePrint Archive, Paper 2022/1029](https://eprint.iacr.org/2022/1029.pdf)).\n\n</details>\n\n<details>\n<summary><ins>Are there problems with FIDO2?</ins></summary>\n\nYes, there are:\n\n1. The two FIDO2 subprotocols (CTAP2 and WebAuthn) are way more difficult to implement, compared to password authentication. \n2. There are more points of failure because you have three parties that are involved in the authentication process (authenticator, client, relying party).\n3. Currently not all browsers support the CTAP2 protocol well (especially on Linux).\n4. There is no way to verify that a client is trustworthy:\n    * Rogue clients may communicate with a authenticator without your consent\n    * Clients may display wrong information\n5. The 4th layer introduced for Android, IOS, and Windows to connect authenticators and clients internally could be used as a man in the middle.\n\n</details>\n\n<details>\n<summary><ins>Does this library work with all browsers?</ins></summary>\n\nAnswering this question isn't straightforward. The library, by its nature, is designed to be independent of any particular platform, meaning that you have the responsibility of supplying it with data for processing. To put it differently, you're in charge of creating a functional interface for communicating with a client, typically a web browser. On Linux, we offer a wrapper for the uhid interface, simplifying the process of presenting an application as a USB HID device with a Usage Page of F1D0 on the bus.\n\n**There are known issues with older browsers (including Firefox)**. Newer browser versions should work fine. Tested with:\n\n| Browser | Supported? | Tested version| Notes |\n|:-------:|:----------:|:-------------:|:-----:|\n| Cromium   | &#9989;    | 119.0.6045.159 (Official Build) Arch Linux (64-bit) | |\n| Brave | &#9989; | Version 1.62.153 Chromium: 121.0.6167.85 (Official Build) (64-bit) | |\n| Firefox | &#9989; | 122.0 (64-bit) |  |\n| Opera | &#9989; | version: 105.0.4970.16 chromium: 119.0.6045.159 | |\n\n**Please let me know if you run into issues!**\n\n</details>\n\n<details>\n<summary><ins>Does this library implement the whole CTAP2 sepc?</ins></summary>\n\nNo, we do not fully implement the entire [CTAP2](https://fidoalliance.org/specs/fido-v2.2-rd-20230321/fido-client-to-authenticator-protocol-v2.2-rd-20230321.html#intro) specification. In the initial version of this library, which can be found on GitHub, our aim was to remain completely platform-agnostic and cover most of the CTAP2 specification. However, this approach introduced complexities for both users and developers. The current version of this library strikes a balance between usability and feature completeness.\n\nWe offer support for operations like __authenticatorMakeCredential__, __authenticatorGetAssertion__, __authenticatorGetInfo__, and __authenticatorClientPin__, with built-in support for __user verification__ and the __pinUvAuth protocol__ (versions 1 and 2). You are responsible for handling data management tasks (such as secure storage, updates, and deletions), verifying user presence, and conducting user verification. These responsibilities are fulfilled by implementing the necessary callbacks used to instantiate an authenticator (refer to the \"Getting Started\" section for details).\n\n</details>\n\n<details>\n<summary><ins>Zero dynamic allocations?</ins></summary>\n\nThe authenticator part of this library doesn't allocate any memory dynamically. This has some draw backs like a fixed\nsize for strings (e.g., rpId, user name, etc.) but also reduces the complexity of the code.\n\nThe authenticator example uses `88655` bytes of stack space when compiled with `-Doptimize=ReleaseSmall` on Linux (x86\\_64).\n\n> The authenticator example has been profiled using valgrind. \n> * `zig build auth-example -Doptimize=ReleaseSmall` \n> * `valgrind --tool=drd --show-stack-usage=yes ./zig-out/bin/authenticator`\n> * Test page: [webauthn.io](https://webauthn.io/) - Register + Authentication\n> `thread 1 finished and used 88655 bytes out of 8388608 on its stack.`\n> `ThinkPad-X1-Yoga-3rd 6.5.0-35-generic #35~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC x86_64 GNU/Linux`\n\n</details>\n\n## Design\n\n![keylib design](static/design.png)\n\n## Getting Started\n\nWe maintain two examples on how to use the library:\n\n* `authenticator` - [https://github.com/r4gus/keylib/blob/master/example/authenticator.zig](https://github.com/r4gus/keylib/blob/master/example/authenticator.zig)\n    * **Please read the description at the top of the source code for instructions on how to setup uhid correctly**\n* `client` - [https://github.com/r4gus/keylib/blob/master/example/client.zig](https://github.com/r4gus/keylib/blob/master/example/client.zig)\n\n## Resources\n\n- [CTAP2](https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#intro) - FIDO Alliance\n- [WebAuthn](https://www.w3.org/TR/webauthn-3/) - W3C\n- [CBOR RFC8949](https://www.rfc-editor.org/rfc/rfc8949.html) - C. Bormann and P. Hoffman\n\n---\n\n__FIDO2/Passkey test sites__:\n- [passkey.org](https://passkey.org/)\n- [webauthn.io](https://webauthn.io/)\n\n## Random Ideas\n\n<details>\n<summary><ins>Protecting secrets using a PIN</ins></summary>\n\nMicrocontrollers like the rp2040 allow the creation of cheap authenticators but they provide no means to somehow protect\nsecrets like master passwords, PINs, or credentials. One way one could securely store sensitive data is by making PIN\nprotection mandatory. Note that this is a tradeof and will render some counters (like the pin retry counter) useless if\nan attacker has physical access to the chip, as one can not protect the counters from manipulation.\n\n1. Your authenticator has PIN protection enabled by default, i.e. on first boot a default password is set. You should also\nset the _force pin change_ flag to \"encourge\" the user to change his password.\n2. Also on first boot, you create a master password which will encrypt all sensitive data using a AEAD cipher. The master\npassword itself is encrypted using a secret derived from the PIN.\n3. Metadata like retry counters are not encrypted (make sure you __DONT__ store the PIN unencrypted!). This still allows\nthe blocking of a authenticator (in fact you should automatically reset the authenticator if the retry counter hits zero)\nbut an attack with physical access could potentially reset the counters giving him unlimited retries.\n4. Make sure you disallow any operations on sensitive data without prior authentication (__alwaysUv__).\n5. Make sure you only use PIN authentication.\n6. During authentication you intercept the PIN hash (after decryption) and derive a deterministic secret from it\nusing a key derivation function of you choice (e.g. HKDF; but it must always be the same). This secret must have\nthe same lifetime as the pinUvAuthToken! \n7. When the application requires a credential (or other sensitive data) you decrypt the master secret using the\nderived secret and the decrypt the actual data with the master secret. If the application wants to overwrite data,\nyou decrypt the data, update it and the encrypt it using the master secret.\n8. After you're done, make sure to overwrite any plain text information no longer required.\n9. On pin change, just decrypt the master secret and then re-encrypt it using the secret derived\nfrom the new PIN hash.\n\n</details>\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/175068426?v=4",
  "releases": [
    {
      "tag_name": "0.7.0",
      "name": "0.7.0",
      "body": "- Updated package to Zig v0.15.1\r\n- The following builds pass successfully:\r\n    - `zig build test` - all tests pass\r\n    - `zig build`\r\n    - `zig build auth-example`\r\n    - `zig build client-example`\r\n\r\nThe authenticator example has been tested using passkey.org. It allows the creation and selection of multiple credentials. This and the passing tests indicate that the update didn't break any functionality.\r\n\r\nNo changes to the actual API.\r\n\r\nIf you run into problems please open an issue.",
      "prerelease": false,
      "published_at": "2025-09-15T21:54:54Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.7.0",
      "assets": []
    },
    {
      "tag_name": "0.6.1",
      "name": "0.6.1",
      "body": "",
      "prerelease": false,
      "published_at": "2025-03-30T22:11:13Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.6.1",
      "assets": []
    },
    {
      "tag_name": "0.6.0",
      "name": "0.6.0",
      "body": "**Full Changelog**: https://github.com/r4gus/keylib/compare/0.5.3...0.6.0",
      "prerelease": false,
      "published_at": "2025-03-15T14:05:06Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.6.0",
      "assets": []
    },
    {
      "tag_name": "0.5.3",
      "name": "0.5.3",
      "body": "",
      "prerelease": false,
      "published_at": "2024-10-17T14:24:49Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.5.3",
      "assets": []
    },
    {
      "tag_name": "0.5.2",
      "name": "0.5.2",
      "body": "**Full Changelog**: https://github.com/r4gus/keylib/compare/0.5.1...0.5.2\r\n\r\n**Full Changelog**: https://github.com/r4gus/keylib/compare/0.5.1...0.5.2",
      "prerelease": false,
      "published_at": "2024-08-23T19:46:28Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.5.2",
      "assets": []
    },
    {
      "tag_name": "0.5.1",
      "name": "0.5.1",
      "body": "UUIDs as IDs for credentials",
      "prerelease": false,
      "published_at": "2024-07-22T20:46:33Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.5.1",
      "assets": []
    },
    {
      "tag_name": "0.5.0",
      "name": "0.5.0",
      "body": "",
      "prerelease": false,
      "published_at": "2024-07-15T21:15:37Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.5.0",
      "assets": []
    },
    {
      "tag_name": "0.4.0",
      "name": "",
      "body": "* authenticator: zero dynamic allocations",
      "prerelease": false,
      "published_at": "2024-06-13T22:43:56Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.4.0",
      "assets": []
    },
    {
      "tag_name": "0.3.5",
      "name": "0.3.5",
      "body": "* AttestationStatement bug fix",
      "prerelease": false,
      "published_at": "2024-02-04T20:20:55Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.3.5",
      "assets": []
    },
    {
      "tag_name": "0.3.4",
      "name": "0.3.4",
      "body": "**Full Changelog**: https://github.com/r4gus/keylib/compare/0.3.3...0.3.4",
      "prerelease": false,
      "published_at": "2024-01-30T13:26:09Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.3.4",
      "assets": []
    },
    {
      "tag_name": "0.3.3",
      "name": "0.3.3",
      "body": "dependency updated",
      "prerelease": false,
      "published_at": "2024-01-20T18:44:07Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.3.3",
      "assets": []
    },
    {
      "tag_name": "0.3.2",
      "name": "0.3.2",
      "body": "bug fix",
      "prerelease": false,
      "published_at": "2024-01-12T23:47:01Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.3.2",
      "assets": []
    },
    {
      "tag_name": "0.3.1",
      "name": "0.3.1",
      "body": "",
      "prerelease": false,
      "published_at": "2024-01-04T10:41:52Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.3.1",
      "assets": []
    },
    {
      "tag_name": "0.3.0",
      "name": "0.3.0",
      "body": "# Changes\r\n\r\n* `CtapHid.handle` doesn't accept a reference to a `Auth` struct anymore and now either returns nil or a struct `{ cmd: Cmd, cid: Cid, data: []const u8 }` where cmd is the received command, cid is the channel id, and data is the data related to the command (e.g. cbor encoded CTAP2 command). This allows you to act on specific CTAPHID commands. You can call `iterator()` on the returned struct.\r\n* `Auth.handle` now expects two arguments. The first is a pointer to a array of 7609 bytes (the max msg size of CTAPHID); this will probably change in the future. The second argument is the CBOR command. The `Auth.handle` function will write its response to the struct and then return a slice with the message. The slice references the array.\r\n\r\nFor an overview on how to use the new API, see README.md.",
      "prerelease": false,
      "published_at": "2024-01-04T10:38:05Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.3.0",
      "assets": []
    },
    {
      "tag_name": "0.2.1",
      "name": "0.2.1",
      "body": "All commands now share the same function signature. This allows users to swap out the default callbacks with their own ones.",
      "prerelease": false,
      "published_at": "2024-01-02T21:36:42Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.2.1",
      "assets": []
    },
    {
      "tag_name": "0.2.0",
      "name": "",
      "body": "# Changes\r\n\r\n* Users can now choose the `std.rand.Random` impl the authenticator should use. The default is `std.crypto.random`.\r\n* Users can now choose the timestamp function the authenticator should use (`fn () i64`). The default is `std.time.milliTimestamp`\r\n* Users now have to specify what `Random` impl should be used for `CtapHid`. This is a breaking change! If you upgrade to this version you have to pass the RNG to `CtapHid.init()` as second argument. \r\n\r\n__Hash:__ `1220641561f120bf75991cecbe314fd2ffaa7c3d8dcc7db98b493f1666759ac62779`",
      "prerelease": false,
      "published_at": "2023-12-21T23:04:35Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.2.0",
      "assets": []
    },
    {
      "tag_name": "0.1.0",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2023-12-03T16:59:45Z",
      "html_url": "https://github.com/Zig-Sec/keylib/releases/tag/0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "ZigSec - Because we jump from bytes to bytes. ",
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_created_at": "2024-07-08T23:35:57Z",
  "license": "MIT",
  "category": "library"
}