{
  "name": "concurrent_skip_list",
  "owner": "bridgeQiao",
  "repo": "concurrent_skip_list",
  "description": "Concurrent skip list written in zig.",
  "type": "package",
  "topics": [
    "zig-package",
    "skiplist"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-01-21T02:00:04Z",
  "minimum_zig_version": "0.16.0-dev.2255+d417441f4",
  "readme": "# concurrent_skip_list\n\nFolly-inspired, Zig-powered.\n\nThis project provides a high-performance **concurrent skip list** (lock-free / fine-grained locking variants are available) designed for multi-threaded key-value workloads. BenchMark origin: [greensky00/skiplist](https://github.com/greensky00/skiplist.git). Thanks!\n\n## Performance Recommendations\n\nThis implementation compared different concurrency strategies. Choose the most suitable one based on your workload and hardware:\n\n- **Skiplist** (prioritize write performance)\n\n  The **skiplist-based** concurrent map is optimized to prioritize write performance. However, you **must benchmark it first** in your actual deployment environment to ensure it performs as expected. Be aware that performance can be significantly affected by Docker containers, third-party memory allocators (e.g., mimalloc), and other environmental factors.\n\n- **Mutex + hash_map** (fallback if skiplist doesn't perform as expected)\n\n  For **general-purpose** use cases, the **mutex + hash_map** implementation often delivers the most balanced performance — good throughput for both reads and writes.\n\n- **RWLock + hash_map** (prioritize read performance)\n\n  The **reader-writer lock + hash_map** variant is optimized to prioritize read performance and can provide significantly better throughput under concurrent reads.\n  However, write performance will be noticeably worse than the mutex-based version — only choose this when reads clearly dominate.\n\nQuick summary:\n\n| Scenario                          | Recommended Choice       | When to prefer it                              |\n|-----------------------------------|---------------------------|------------------------------------------------|\n| Prioritize write performance      | Skiplist                 | Optimized for write throughput, must benchmark first |\n| General / balanced workload       | Mutex + hash_map         | Most consistent & predictable performance      |\n| Prioritize read performance       | RWLock + hash_map        | Optimized for read throughput, accept slower writes |\n\nFeel free to run your own benchmarks with your specific workload, key distribution, and hardware — the best choice can vary depending on actual access patterns.\n\n## use it\n\n### 1. add the repo\n\nexecute:\n\n```bash\nzig fetch --save git+https://github.com/bridgeQiao/concurrent_skip_list.git\n```\n\nIn `build.zig` add import:\n\n```zig\nconst con_skiplist_dep = b.dependency(\"concurrent_skip_list\", .{\n    .target = target,\n    .optimize = optimize,\n});\nconst con_skiplist = con_skiplist_dep.module(\"concurrent_skip_list\");\n\n// ...\nexe.root_module.addImport(\"concurrent_skip_list\", con_skiplist);\n```\n\n### 2. import\n\n```zig\nconst skip_list = @import(\"concurrent_skip_list\");\n\n// define data type\nconst NodeType = struct {\n    const Self = @This();\n    first: i32 = 0,\n    second: i32 = 0,\n\n    fn less(lhs: *const Self, rhs: *const Self) bool {\n        return lhs.first < rhs.first;\n    }\n};\nconst SkipListType = skip_list.ConcurrentSkipList(NodeType, &NodeType.less, 16);\n\n// main\npub fn main(init: std.process.Init) !void {\n    const gpa = init.gpa;\n    const data: NodeType = .{ .first = 30, .second = 30 };\n    var sl = SkipListType.init(gpa);\n    defer sl.deinit();\n\n    var access = SkipListType.Accessor.init(&sl);\n    defer access.deinit();\n    _ = access.add(&data);\n    if (access.contains(&data)) {\n        std.debug.print(\"data: {}\\n\", .{access.find(&data).?.data().*});\n    }\n    std.debug.print(\"{*}\\n\", .{access.first()});\n}\n```\n\n## BenchMark\n\nMy computer is `Mac mini m2`, 8G memory. Use `-Doptimize=ReleaseSafe`.\n\nW8 R1:\n\n```bash\nconcurrent test: .SKIPLIST\nread: 651899.4 ops/sec\nwrite: 2228922.6 ops/sec\ntotal: 2880822.0 ops/sec\nconcurrent test: .MAP_MUTEX\nread: 5443653.0 ops/sec\nwrite: 169249.2 ops/sec\ntotal: 5612902.2 ops/sec\n```\n\nW1 R8:\n\n```bash\nconcurrent test: .SKIPLIST\nread: 9461286.0 ops/sec\nwrite: 431863.2 ops/sec\ntotal: 9893149.2 ops/sec\nconcurrent test: .MAP_MUTEX\nread: 13446618.6 ops/sec\nwrite: 57112.0 ops/sec\ntotal: 13503730.6 ops/sec\n```\n\nW4 R4:\n\n```bash\nconcurrent test: .SKIPLIST\nread: 3441819.6 ops/sec\nwrite: 1377360.8 ops/sec\ntotal: 4819180.4 ops/sec\nconcurrent test: .MAP_MUTEX\nread: 7980547.2 ops/sec\nwrite: 111181.2 ops/sec\ntotal: 8091728.4 ops/sec\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/19978130?v=4",
  "releases": [
    {
      "tag_name": "v1.0",
      "name": "zig-0.15",
      "body": "Release for 0.15, no more here.",
      "prerelease": false,
      "published_at": "2025-12-31T01:20:14Z",
      "html_url": "https://github.com/bridgeQiao/concurrent_skip_list/releases/tag/v1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 1,
  "owner_following": 0,
  "owner_created_at": "2016-06-16T15:16:57Z",
  "category": "library"
}