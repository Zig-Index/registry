{
  "name": "gremlin.zig",
  "owner": "norma-core",
  "repo": "gremlin.zig",
  "description": "A zero-dependency Google Protocol Buffers implementation in pure Zig. Single allocation encode and lazy decode",
  "type": "package",
  "topics": [
    "zig-package",
    "zig"
  ],
  "stars": 232,
  "forks": 18,
  "watchers": 4,
  "updated_at": "2026-01-23T16:57:19Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# gremlin\n\nA zero-dependency, zero-allocation Google Protocol Buffers implementation in pure Zig (no protoc required)\n\n## Installation & Setup\n\nSingle command setup:\n```bash\nzig fetch --save https://github.com/norma-core/gremlin.zig/archive/refs/heads/master.zip\n```\n\nThis command will:\n1. Download gremlin\n2. Add it to your `build.zig.zon`\n3. Generate the correct dependency hash\n\nIn your `build.zig`:\n```zig\nconst std = @import(\"std\");\nconst ProtoGenStep = @import(\"gremlin\").ProtoGenStep;\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Get the gremlin dependency\n    const gremlin_dep = b.dependency(\"gremlin\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Get the gremlin module for imports\n    const gremlin_module = gremlin_dep.module(\"gremlin\");\n\n    // Generate Zig code from .proto files\n    // This will process all .proto files in the proto/ directory\n    // and output generated Zig code to src/gen/\n    const protobuf = ProtoGenStep.create(\n        b,\n        .{\n            .name = \"protobuf\",                  // Name for the build step\n            .proto_sources = b.path(\"proto\"),    // Directory containing .proto files\n            .target = b.path(\"src/gen\"),         // Output directory for generated Zig code\n        },\n    );\n\n    // Create binary\n    const exe = b.addExecutable(.{\n        .name = \"example\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    // Add the gremlin module\n    exe.root_module.addImport(\"gremlin\", gremlin_module);\n    exe.step.dependOn(&protobuf.step);\n\n    b.installArtifact(exe);\n}\n```\n\n## Features\n\n- Zero dependencies\n- Pure Zig implementation (no protoc required)\n- Compatible with Protocol Buffers version 2 and 3\n- Simple integration with Zig build system\n- Single allocation for serialization (including complex recursive messages)\n- Zero-allocation readers with lazy parsing - parses only required complex fields\n- Tested with Zig 0.15.2\n\n## Generated code\n\nSee the complete working example in the [`example`](./example) folder.\n\nGiven a protobuf definition:\n```protobuf\nsyntax = \"proto3\";\n\nmessage User {\n  string name = 1;\n  uint64 id   = 2;\n  repeated string tags = 10;\n}\n```\n\nGremlin will generate equivalent Zig code (see [example.proto.zig](./example/src/gen/example.proto.zig)):\n```zig\nconst std = @import(\"std\");\nconst gremlin = @import(\"gremlin\");\n\n// Wire numbers for fields\nconst UserWire = struct {\n    const NAME_WIRE: gremlin.ProtoWireNumber = 1;\n    const ID_WIRE: gremlin.ProtoWireNumber = 2;\n    const TAGS_WIRE: gremlin.ProtoWireNumber = 10;\n};\n\n// Message struct\npub const User = struct {\n    name: ?[]const u8 = null,\n    id: u64 = 0,\n    tags: ?[]const ?[]const u8 = null,\n    \n    // Calculate size for allocation\n    pub fn calcProtobufSize(self: *const User) usize { ... }\n    \n    // Encode to new buffer\n    pub fn encode(self: *const User, allocator: std.mem.Allocator) gremlin.Error![]const u8 { ... }\n    \n    // Encode to existing buffer\n    pub fn encodeTo(self: *const User, target: *gremlin.Writer) void { ... }\n};\n\n// Reader for lazy parsing (zero allocations)\npub const UserReader = struct {\n    buf: gremlin.Reader,\n    _name: ?[]const u8 = null,\n    _id: u64 = 0,\n    ...\n\n    pub fn init(src: []const u8) gremlin.Error!UserReader { ... }\n    \n    // Accessor methods\n    pub inline fn getName(self: *const UserReader) []const u8 { ... }\n    pub inline fn getId(self: *const UserReader) u64 { ... }\n    \n};\n```\n\n## Usage Example\n\n```zig\nconst std = @import(\"std\");\nconst proto = @import(\"gen/example.proto.zig\");\n\npub fn main() !void {\n    // Encoding\n    const user = proto.User{\n        .name = \"Alice\",\n        .id = 12345,\n        .tags = &[_]?[]const u8{ \"admin\", \"verified\" },\n    };\n    \n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const encoded = try user.encode(allocator);\n    defer allocator.free(encoded);\n    \n    // Decoding with zero-allocation reader\n    var reader = try proto.UserReader.init(encoded);\n    \n    std.debug.print(\"Name: {s}\\n\", .{reader.getName()});\n    std.debug.print(\"ID: {}\\n\", .{reader.getId()});\n    \n    // Iterate over repeated fields\n    while (reader.tagsNext()) |tag| {\n        std.debug.print(\"Tag: {s}\\n\", .{tag});\n    }\n}\n```\n\n### Reader API for Repeated Fields\n\nThe generated readers provide `next()` methods for iterating over repeated fields without allocations:\n\n```zig\n// For repeated string field 'tags'\npub fn tagsNext(self: *UserReader) ?[]const u8 {\n    // Returns next value or null when done\n}\n\n// For repeated scalar fields (e.g., repeated int32 values)\npub fn valuesNext(self: *UserReader) gremlin.Error!?i32 {\n    // Returns next value or null when done\n}\n\n// For repeated message fields\npub fn messagesNext(self: *UserReader) ?MessageReader {\n    // Returns next message reader or null when done\n}\n\n// Optional: get count of repeated items\npub fn tagsCount(self: *const UserReader) usize {\n    // Returns total count\n}\n```\n\nThis pattern applies to all repeated field types:\n- Repeated scalars: `fieldNameNext()` returns `gremlin.Error!?T` where T is the scalar type\n- Repeated messages: `fieldNameNext()` returns `?MessageReader`\n- Repeated strings/bytes: `fieldNameNext()` returns `?[]const u8`\n\nThe readers maintain internal state for iteration, so you can call `next()` repeatedly to traverse all values. No allocations are required as the readers work directly with the underlying protobuf buffer.",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/250746960?v=4",
  "releases": [
    {
      "tag_name": "0.1.0",
      "name": "0.1.0",
      "body": "- zig 0.15.2 support\r\n- zero-allocation reading\r\n- zig fmt-compatible generated code",
      "prerelease": false,
      "published_at": "2025-12-30T23:18:23Z",
      "html_url": "https://github.com/norma-core/gremlin.zig/releases/tag/0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "",
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": "norma_core_dev",
  "owner_created_at": "2025-12-20T20:29:42Z",
  "license": "MIT",
  "category": "library"
}