{
  "name": "gremlin.zig",
  "owner": "norma-core",
  "repo": "gremlin.zig",
  "description": "A zero-dependency Google Protocol Buffers implementation in pure Zig. Single allocation encode and lazy decode",
  "type": "package",
  "topics": [
    "zig-package",
    "zig"
  ],
  "stars": 249,
  "forks": 21,
  "watchers": 5,
  "updated_at": "2026-02-13T14:40:30Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# gremlin\n\nA zero-dependency, zero-allocation Google Protocol Buffers implementation in pure Zig (no protoc required)\n\n[![X (Twitter)](https://img.shields.io/badge/X-@batsuev__es-black?logo=x)](https://x.com/batsuev_es) [![X (Twitter)](https://img.shields.io/badge/X-@norma__core__dev-black?logo=x)](https://x.com/norma_core_dev)\n\nPart of [NormaCore](https://github.com/norma-core/norma-core/) project.\n\n**[‚ö° See Performance Benchmarks](#performance)** - 2x-5.7x faster than our Go implementation\n\n## Installation & Setup\n\nSingle command setup:\n```bash\nzig fetch --save https://github.com/norma-core/gremlin.zig/archive/refs/heads/master.zip\n```\n\nThis command will:\n1. Download gremlin\n2. Add it to your `build.zig.zon`\n3. Generate the correct dependency hash\n\nIn your `build.zig`:\n```zig\nconst std = @import(\"std\");\nconst ProtoGenStep = @import(\"gremlin\").ProtoGenStep;\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Get the gremlin dependency\n    const gremlin_dep = b.dependency(\"gremlin\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Get the gremlin module for imports\n    const gremlin_module = gremlin_dep.module(\"gremlin\");\n\n    // Generate Zig code from .proto files\n    // This will process all .proto files in the proto/ directory\n    // and output generated Zig code to src/gen/\n    const protobuf = ProtoGenStep.create(\n        b,\n        .{\n            .name = \"protobuf\",                  // Name for the build step\n            .proto_sources = b.path(\"proto\"),    // Directory containing .proto files\n            .target = b.path(\"src/gen\"),         // Output directory for generated Zig code\n            .ignore_masks = &[_][]const u8{      // Optional: patterns to ignore\n                \"vendor/*\",\n                \"*/node_modules/*\",\n                \".git/*\",\n            },\n        },\n    );\n\n    // Create binary\n    const exe = b.addExecutable(.{\n        .name = \"example\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/main.zig\"),\n            .target = target,\n            .optimize = optimize,\n        }),\n    });\n\n    // Add the gremlin module\n    exe.root_module.addImport(\"gremlin\", gremlin_module);\n    exe.step.dependOn(&protobuf.step);\n\n    b.installArtifact(exe);\n}\n```\n\n## Features\n\n- Zero dependencies\n- Pure Zig implementation (no protoc required)\n- Compatible with Protocol Buffers version 2 and 3\n- Simple integration with Zig build system\n- Single allocation for serialization (including complex recursive messages)\n- Zero-allocation readers with lazy parsing - parses only required complex fields\n- Tested with Zig 0.15.2\n\n## Performance\n\n### Benchmark: gremlin.zig vs gremlin_go\n\nDeep nested message benchmarks (1409 bytes, 4+ levels deep) comparing gremlin.zig against [gremlin_go](https://github.com/norma-core/norma-core/tree/main/shared/gremlin_go) across multiple platforms with 10 million iterations:\n\n**üçé Apple M3 Max** (16 cores, 10M iterations):\n\n| Operation | gremlin_go | gremlin.zig ‚ö° | Speedup |\n|-----------|------------|----------------|---------|\n| üî® **Marshal** | 1,749 ns/op | 891 ns/op | **2.0x** |\n| ‚ö° **Unmarshal** | 253 ns/op | 112 ns/op | **2.3x** |\n| üéØ **Lazy Read** | 269 ns/op | 112 ns/op | **2.4x** |\n| üîç **Deep Access** | 833 ns/op | 266 ns/op | **3.1x** |\n\n**üòà FreeBSD** - AMD Ryzen 5 7600X (12 cores, 10M iterations):\n\n| Operation | gremlin_go | gremlin.zig ‚ö° | Speedup |\n|-----------|------------|----------------|---------|\n| üî® **Marshal** | 1,554 ns/op | 649 ns/op | **2.4x** |\n| ‚ö° **Unmarshal** | 234 ns/op | 66 ns/op | **3.5x** |\n| üéØ **Lazy Read** | 254 ns/op | 66 ns/op | **3.8x** |\n| üîç **Deep Access** | 776 ns/op | 180 ns/op | **4.3x** |\n\n**üíª Framework 16 with Ubuntu** - AMD Ryzen AI 9 HX 370 (24 cores, 10M iterations):\n\n| Operation | gremlin_go | gremlin.zig ‚ö° | Speedup |\n|-----------|------------|----------------|---------|\n| üî® **Marshal** | 1,436 ns/op | 558 ns/op | **2.6x** |\n| ‚ö° **Unmarshal** | 207 ns/op | 45 ns/op | **4.6x** |\n| üéØ **Lazy Read** | 229 ns/op | 45 ns/op | **5.1x** |\n| üîç **Deep Access** | 692 ns/op | 156 ns/op | **4.4x** |\n\n**ü•ß Raspberry Pi 5** - Gentoo Linux (ARM64, 4 cores, 10M iterations):\n\n| Operation | gremlin_go | gremlin.zig ‚ö° | Speedup |\n|-----------|------------|----------------|---------|\n| üî® **Marshal** | 6,520 ns/op | 2,225 ns/op | **2.9x** |\n| ‚ö° **Unmarshal** | 1,080 ns/op | 264 ns/op | **4.1x** |\n| üéØ **Lazy Read** | 1,078 ns/op | 264 ns/op | **4.1x** |\n| üîç **Deep Access** | 3,924 ns/op | 688 ns/op | **5.7x** |\n\n**Memory Efficiency:**\n- Marshal: **1 allocation** (vs 1 allocation in gremlin_go)\n- Unmarshal: **0 allocations** (vs 9 allocations in gremlin_go)\n- Lazy Read: **0 allocations** (vs 9 allocations in gremlin_go)\n- Deep Access: **0 allocations** (vs 29 allocations in gremlin_go)\n\n*Benchmarks run with `--release=fast` with 10,000,000 iterations. Run `zig build run-benchmark -- 10000000` to reproduce.*\n\n## Ignore Patterns\n\nThe `ignore_masks` option allows you to exclude directories from proto file discovery using glob patterns with `*` wildcards:\n\n```zig\nconst protobuf = ProtoGenStep.create(\n    b,\n    .{\n        .name = \"protobuf\",\n        .proto_sources = b.path(\"proto\"),\n        .target = b.path(\"src/gen\"),\n        .ignore_masks = &[_][]const u8{\n            \"vendor/*\",           // Ignore vendor directory\n            \"*/node_modules/*\",   // Ignore node_modules anywhere\n            \".git/*\",             // Ignore .git directory\n            \"*_test/*\",           // Ignore test directories\n        },\n    },\n);\n```\n\nPattern matching:\n- `vendor/*` matches `vendor/any/path`\n- `*/vendor/*` matches `any/vendor/path`\n- `*suffix` matches anything ending with \"suffix\"\n- `prefix*` matches anything starting with \"prefix\"\n\n## Generated code\n\nSee the complete working example in the [`example`](./example) folder.\n\nGiven a protobuf definition:\n```protobuf\nsyntax = \"proto3\";\n\nmessage User {\n  string name = 1;\n  uint64 id   = 2;\n  repeated string tags = 10;\n}\n```\n\nGremlin will generate equivalent Zig code (see [example.proto.zig](./example/src/gen/example.proto.zig)):\n```zig\nconst std = @import(\"std\");\nconst gremlin = @import(\"gremlin\");\n\n// Wire numbers for fields\nconst UserWire = struct {\n    const NAME_WIRE: gremlin.ProtoWireNumber = 1;\n    const ID_WIRE: gremlin.ProtoWireNumber = 2;\n    const TAGS_WIRE: gremlin.ProtoWireNumber = 10;\n};\n\n// Message struct\npub const User = struct {\n    name: ?[]const u8 = null,\n    id: u64 = 0,\n    tags: ?[]const ?[]const u8 = null,\n    \n    // Calculate size for allocation\n    pub fn calcProtobufSize(self: *const User) usize { ... }\n    \n    // Encode to new buffer\n    pub fn encode(self: *const User, allocator: std.mem.Allocator) gremlin.Error![]const u8 { ... }\n    \n    // Encode to existing buffer\n    pub fn encodeTo(self: *const User, target: *gremlin.Writer) void { ... }\n};\n\n// Reader for lazy parsing (zero allocations)\npub const UserReader = struct {\n    buf: gremlin.Reader,\n    _name: ?[]const u8 = null,\n    _id: u64 = 0,\n    ...\n\n    pub fn init(src: []const u8) gremlin.Error!UserReader { ... }\n    \n    // Accessor methods\n    pub inline fn getName(self: *const UserReader) []const u8 { ... }\n    pub inline fn getId(self: *const UserReader) u64 { ... }\n    \n};\n```\n\n## Usage Example\n\n```zig\nconst std = @import(\"std\");\nconst proto = @import(\"gen/example.proto.zig\");\n\npub fn main() !void {\n    // Encoding\n    const user = proto.User{\n        .name = \"Alice\",\n        .id = 12345,\n        .tags = &[_]?[]const u8{ \"admin\", \"verified\" },\n    };\n    \n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const encoded = try user.encode(allocator);\n    defer allocator.free(encoded);\n    \n    // Decoding with zero-allocation reader\n    var reader = try proto.UserReader.init(encoded);\n    \n    std.debug.print(\"Name: {s}\\n\", .{reader.getName()});\n    std.debug.print(\"ID: {}\\n\", .{reader.getId()});\n    \n    // Iterate over repeated fields\n    while (reader.tagsNext()) |tag| {\n        std.debug.print(\"Tag: {s}\\n\", .{tag});\n    }\n}\n```\n\n### Reader API for Repeated Fields\n\nThe generated readers provide `next()` methods for iterating over repeated fields without allocations:\n\n```zig\n// For repeated string field 'tags'\npub fn tagsNext(self: *UserReader) ?[]const u8 {\n    // Returns next value or null when done\n}\n\n// For repeated scalar fields (e.g., repeated int32 values)\npub fn valuesNext(self: *UserReader) gremlin.Error!?i32 {\n    // Returns next value or null when done\n}\n\n// For repeated message fields\npub fn messagesNext(self: *UserReader) ?MessageReader {\n    // Returns next message reader or null when done\n}\n\n// Optional: get count of repeated items\npub fn tagsCount(self: *const UserReader) usize {\n    // Returns total count\n}\n```\n\nThis pattern applies to all repeated field types:\n- Repeated scalars: `fieldNameNext()` returns `gremlin.Error!?T` where T is the scalar type\n- Repeated messages: `fieldNameNext()` returns `?MessageReader`\n- Repeated strings/bytes: `fieldNameNext()` returns `?[]const u8`\n\nThe readers maintain internal state for iteration, so you can call `next()` repeatedly to traverse all values. No allocations are required as the readers work directly with the underlying protobuf buffer.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/250746960?v=4",
  "releases": [
    {
      "tag_name": "0.1.0",
      "name": "0.1.0",
      "body": "- zig 0.15.2 support\r\n- zero-allocation reading\r\n- zig fmt-compatible generated code",
      "prerelease": false,
      "published_at": "2025-12-30T23:18:23Z",
      "html_url": "https://github.com/norma-core/gremlin.zig/releases/tag/0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "Physical Operations Platform",
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": "norma_core_dev",
  "owner_created_at": "2025-12-20T20:29:42Z",
  "license": "MIT",
  "category": "library"
}