{
  "name": "OpenMP-zig",
  "owner": "sbancuz",
  "repo": "OpenMP-zig",
  "description": "An implementation of the OpenMP directives for Zig",
  "type": "project",
  "topics": [
    "openmp",
    "openmp-parallelization",
    "zig",
    "zig-package"
  ],
  "stars": 42,
  "forks": 1,
  "watchers": 1,
  "updated_at": "2025-09-29T22:28:42Z",
  "readme": "# OpenMP-zig\n\nThis wrapper implements (almost all) the OpenMP directives up-to version 3.1 and some newer stuff.\nAll of this is (mostly, see below) without any allocation from the zig part.\n\nThis is implemented using the `libomp' library of LLVM. (Gomp support is not planned) **Disclaimer** This project is not affiliated with LLVM in any capacity.\n\n```zig\nconst std = @import(\"std\");\nconst omp = @import(\"omp\");\n\nfn main() void {\n    omp.parallel(.{})\n        .run(.{}, struct {\n        fn f() void {\n            std.debug.print(\"Hello world {}!\", .{omp.get_thread_num()});\n        }\n    }.f);\n}\n```\n\n## Build\n\n```sh\nzig fetch --save git+https://github.com/sbancuz/OpenMP-zig\n```\n\n```zig\n// build.zig\nconst OpenMP_zig_dep = b.dependency(\"OpenMP-zig\", .{\n      .target = target,\n      .optimize = optimize,\n});\nexe.root_module.addImport(\"omp\", OpenMP_zig_dep.module(\"omp\"));\n```\n\n## Features\n- [x] `#pragma omp parallel`\n- [x] `All reductions`\n- [x] `#pragma omp for`\n- [x] `#pragma omp sections`\n- [x] `#pragma omp single`\n- [x] `#pragma omp master/masked`\n- [x] `#pragma omp critical`\n- [x] `#pragma omp barrier`\n- [x] `#pragma omp task`\n- [ ] `#pragma omp atomic` NOT POSSIBLE TO IMPLEMENT\n- [ ] `#pragma omp simd` NOT POSSIBLE TO IMPLEMENT\n\nTo see some other examples of the library check the tests folder.\n\n## Extensions\n\n```zig\nfn test_omp_task_error() !bool {\n    // The ret reduction parameter tells the directive how it should reduce the return value\n    const result = omp.parallel(.{ .ret_reduction = .plus })\n        .run(.{}, struct {\n        // You can return whatever you want!\n        fn f() !usize {\n            const maybe = omp.single()\n                .run(.{}, struct {\n                // Only for tasks, you have to put the explicit error type in the promise,\n                // otherwise it won't be able to infer the type\n                fn f() *omp.promise(error{WompWomp}!usize) {\n                    return omp.task(.{})\n                        .run(.{}, struct {\n                        // Same deal here\n                        fn f() error{WompWomp}!usize {\n                            return error.WompWomp;\n                        }\n                    }.f);\n                }\n            }.f);\n            if (maybe) |pro| {\n                defer pro.deinit();\n                return pro.get();\n            }\n            return 0;\n        }\n    }.f) catch |err| switch (err) {\n        error.WompWomp => std.debug.print(\"Caught an error :^(\", .{});\n    };\n\n    std.debug.print(\"No errors here!\". /{});\n}\n```\n\n### Return\n\nAll of the directives can return values. To return something you may need to specify the `ret_reduction` parameter.\n\n> [!WARNING]\n> The promises that are returned from the `task` directive will be heap allocated. So make sure to deinit() them!\n\n### Errors\n\nAll of the directive can return error types.\n> [!WARNING]\n> Returning more than one type of error from a directive it's clearly a race condition!\n\n## Goal\n\nThe goal of this library is to provide at least OpenMP 4.5 to zig and be production ready, along with the mentioned extensions.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/43883450?u=ff08a844f38d004c5152edbc7709931c9cd34f66&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 3,
  "owner_following": 4,
  "owner_created_at": "2018-10-05T13:10:35Z",
  "license": "MIT",
  "category": "library"
}