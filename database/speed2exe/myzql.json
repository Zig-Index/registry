{
  "name": "myzql",
  "owner": "speed2exe",
  "repo": "myzql",
  "description": "MySQL and MariaDB  driver in native Zig",
  "type": "package",
  "topics": [
    "driver",
    "mariadb",
    "mysql",
    "sql",
    "zig",
    "zig-package",
    "zig-library"
  ],
  "stars": 67,
  "forks": 6,
  "watchers": 5,
  "updated_at": "2026-01-08T09:43:02Z",
  "readme": "# MyZql\n- MySQL and MariaDB driver in native zig\n\n## Status\n- Beta\n\n## Version Compatibility\n| MyZQL       | Zig                       |\n|-------------|---------------------------|\n| 0.0.9.1     | 0.12.0                    |\n| 0.13.2      | 0.13.0                    |\n| 0.14.0      | 0.14.0                    |\n| 0.15.1      | 0.15.1                    |\n| main        | 0.15.1                    |\n\n## Features\n- Native Zig code, no external dependencies\n- TCP protocol\n- Prepared Statement\n- Structs from query result\n- Data insertion\n- MySQL DateTime and Time support\n\n## Requirements\n- MySQL/MariaDB 5.7.5 and up\n\n## TODOs\n- Config from URL\n- Connection Pooling\n- TLS support\n\n## Add as dependency to your Zig project\n### Fetch dependency\n```bash\nzig fetch --save git+https://github.com/speed2exe/myzql#0.15.1\n```\nor\n- `build.zig.zon`\n```zon\n    // ...\n    .dependencies = .{\n      .myzql = .{\n        // choose a tag according to \"Version Compatibility\" table\n        .url = \"https://github.com/speed2exe/myzql/archive/refs/tags/0.13.2.tar.gz\",\n        .hash = \"1220582ea45580eec6b16aa93d2a9404467db8bc1d911806d367513aa40f3817f84c\",\n      }\n    },\n    // ...\n```\n\n### Import in your project\n- `build.zig`\n```zig\n    //...\n    const myzql_dep = b.dependency(\"myzql\", .{});\n    const myzql = myzql_dep.module(\"myzql\");\n    exe.addModule(\"myzql\", myzql);\n    //...\n```\n\n## Usage\n- Project integration example: [Usage](https://github.com/speed2exe/myzql-example)\n\n### Connection\n```zig\nconst myzql = @import(\"myzql\");\nconst Conn = myzql.conn.Conn;\n\npub fn main() !void {\n    // Setting up client\n    var client = try Conn.init(\n        allocator,\n        &.{\n            .username = \"some-user\",   // default: \"root\"\n            .password = \"password123\", // default: \"\"\n            .database = \"customers\",   // default: \"\"\n\n            // Current default value.\n            // Use std.net.getAddressList if you need to look up ip based on hostname\n            .address =  std.net.Address.initIp4(.{ 127, 0, 0, 1 }, 3306),\n            // ...\n        },\n    );\n    defer client.deinit();\n\n    // Connection and Authentication\n    try client.ping();\n}\n```\n\n## Querying\n```zig\n\nconst OkPacket = protocol.generic_response.OkPacket;\n\npub fn main() !void {\n    // ...\n    // You can do a text query (text protocol) by using `query` method on `Conn`\n    const result = try c.query(\"CREATE DATABASE testdb\");\n\n    // Query results can have a few variant:\n    // - ok:   OkPacket     => query is ok\n    // - err:  ErrorPacket  => error occurred\n    // In this example, res will either be `ok` or `err`.\n    // We are using the convenient method `expect` for simplified error handling.\n    // If the result variant does not match the kind of result you have specified,\n    // a message will be printed and you will get an error instead.\n    const ok: OkPacket = try result.expect(.ok);\n\n    // Alternatively, you can also handle results manually for more control.\n    // Here, we do a switch statement to handle all possible variant or results.\n    switch (result.value) {\n        .ok => |ok| {},\n\n        // `asError` is also another convenient method to print message and return as zig error.\n        // You may also choose to inspect individual fields for more control.\n        .err => |err| return err.asError(),\n    }\n}\n```\n\n## Querying returning rows (Text Results)\n- If you want to have query results to be represented by custom created structs,\nthis is not the section, scroll down to \"Executing prepared statements returning results\" instead.\n```zig\nconst myzql = @import(\"myzql\");\nconst QueryResult = myzql.result.QueryResult;\nconst ResultSet = myzql.result.ResultSet;\nconst ResultRow = myzql.result.ResultRow;\nconst TextResultRow = myzql.result.TextResultData;\nconst ResultSetIter = myzql.result.ResultSetIter;\nconst TableTexts = myzql.result.TableTexts;\nconst TextElemIter = myzql.result.TextElemIter;\n\npub fn main() !void {\n    const result = try c.queryRows(\"SELECT * FROM customers.purchases\");\n\n    // This is a query that returns rows, you have to collect the result.\n    // you can use `expect(.rows)` to try interpret query result as ResultSet(TextResultRow)\n    const rows: ResultSet(TextResultRow) = try query_res.expect(.rows);\n\n    // Allocation free interators\n    const rows_iter: ResultRowIter(TextResultRow) = rows.iter();\n    { // Option 1: Iterate through every row and elem\n        while (try rows_iter.next()) |row| { // ResultRow(TextResultRow)\n            var elems_iter: TextElemIter = row.iter();\n            while (elems_iter.next()) |elem| { // ?[] const u8\n                std.debug.print(\"{?s} \", .{elem});\n            }\n        }\n    }\n    { // Option 2: Iterating over rows, collecting elements into []const ?[]const u8\n        while (try rows_iter.next()) |row| {\n            const text_elems: TextElems = try row.textElems(allocator);\n            defer text_elems.deinit(allocator); // elems are valid until deinit is called\n            const elems: []const ?[]const u8 = text_elems.elems;\n            std.debug.print(\"elems: {any}\\n\", .{elems});\n        }\n    }\n\n    // You can also use `collectTexts` method to collect all rows.\n    // Under the hood, it does network call and allocations, until EOF or error\n    // Results are valid until `deinit` is called on TableTexts.\n    const rows: ResultSet(TextResultRow) = try query_res.expect(.rows);\n    const table = try rows.tableTexts(allocator);\n    defer table.deinit(allocator); // table is valid until deinit is called\n    std.debug.print(\"table: {any}\\n\", .{table.table});\n}\n\n```\n\n### Data Insertion\n- Let's assume that you have a table of this structure:\n```sql\nCREATE TABLE test.person (\n    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    age INT\n)\n```\n\n```zig\nconst myzql = @import(\"myzql\");\nconst QueryResult = myzql.result.QueryResult;\nconst PreparedStatement = myzql.result.PreparedStatement;\nconst OkPacket = myzql.protocol.generic_response.OkPacket;\n\npub fn main() void {\n    // In order to do a insertion, you would first need to do a prepared statement.\n    // Allocation is required as we need to store metadata of parameters and return type\n    const prep_res = try c.prepare(allocator, \"INSERT INTO test.person (name, age) VALUES (?, ?)\");\n    defer prep_res.deinit(allocator);\n    const prep_stmt: PreparedStatement = try prep_res.expect(.stmt);\n\n    // Data to be inserted\n    const params = .{\n        .{ \"John\", 42 },\n        .{ \"Sam\", 24 },\n    };\n    inline for (params) |param| {\n        const exe_res = try c.execute(&prep_stmt, param);\n        const ok: OkPacket = try exe_res.expect(.ok); // expecting ok here because there's no rows returned\n        const last_insert_id: u64 = ok.last_insert_id;\n        std.debug.print(\"last_insert_id: {any}\\n\", .{last_insert_id});\n    }\n\n    // Currently only tuples are supported as an argument for insertion.\n    // There are plans to include named structs in the future.\n}\n```\n\n### Executing prepared statements returning results as structs\n```zig\nconst ResultSetIter = myzql.result.ResultSetIter;\nconst QueryResult = myzql.result.QueryResult;\nconst BinaryResultRow = myzql.result.BinaryResultRow;\nconst TableStructs = myzql.result.TableStructs;\nconst ResultSet = myzql.result.ResultSet;\n\nfn main() !void {\n    const prep_res = try c.prepare(allocator, \"SELECT name, age FROM test.person\");\n    defer prep_res.deinit(allocator);\n    const prep_stmt: PreparedStatement = try prep_res.expect(.stmt);\n\n    // This is the struct that represents the columns of a single row.\n    const Person = struct {\n        name: []const u8,\n        age: u8,\n    };\n\n    // Execute query and get an iterator from results\n    const res: QueryResult(BinaryResultRow) = try c.executeRows(&prep_stmt, .{});\n    const rows: ResultSet(BinaryResultRow) = try res.expect(.rows);\n    const iter: ResultSetIter(BinaryResultRow) = rows.iter();\n\n    { // Iterating over rows, scanning into struct or creating struct\n        const query_res = try c.executeRows(&prep_stmt, .{}); // no parameters because there's no ? in the query\n        const rows: ResultSet(BinaryResultRow) = try query_res.expect(.rows);\n        const rows_iter = rows.iter();\n        while (try rows_iter.next()) |row| {\n            { // Option 1: scanning into preallocated person\n                var person: Person = undefined;\n                try row.scan(&person);\n                person.greet();\n                // Important: if any field is a string, it will be valid until the next row is scanned\n                // or next query. If your rows return have strings and you want to keep the data longer,\n                // use the method below instead.\n            }\n            { // Option 2: passing in allocator to create person\n                const person_ptr = try row.structCreate(Person, allocator);\n\n                // Important: please use BinaryResultRow.structDestroy\n                // to destroy the struct created by BinaryResultRow.structCreate\n                // if your struct contains strings.\n                // person is valid until BinaryResultRow.structDestroy is called.\n                defer BinaryResultRow.structDestroy(person_ptr, allocator);\n                person_ptr.greet();\n            }\n        }\n    }\n\n    { // collect all rows into a table ([]const Person)\n        const query_res = try c.executeRows(&prep_stmt, .{}); // no parameters because there's no ? in the query\n        const rows: ResultSet(BinaryResultRow) = try query_res.expect(.rows);\n        const rows_iter = rows.iter();\n        const person_structs = try rows_iter.tableStructs(Person, allocator);\n        defer person_structs.deinit(allocator); // data is valid until deinit is called\n        std.debug.print(\"person_structs: {any}\\n\", .{person_structs.struct_list.items});\n    }\n}\n```\n\n### Temporal Types Support (DateTime, Time)\n- Example of using DateTime and Time MySQL column types.\n- Let's assume you already got this table set up:\n```sql\nCREATE TABLE test.temporal_types_example (\n    event_time DATETIME(6) NOT NULL,\n    duration TIME(6) NOT NULL\n)\n```\n\n\n```zig\n\nconst DateTime = myzql.temporal.DateTime;\nconst Duration = myzql.temporal.Duration;\n\nfn main() !void {\n    { // Insert\n        const prep_res = try c.prepare(allocator, \"INSERT INTO test.temporal_types_example VALUES (?, ?)\");\n        defer prep_res.deinit(allocator);\n        const prep_stmt: PreparedStatement = try prep_res.expect(.stmt);\n\n        const my_time: DateTime = .{\n            .year = 2023,\n            .month = 11,\n            .day = 30,\n            .hour = 6,\n            .minute = 50,\n            .second = 58,\n            .microsecond = 123456,\n        };\n        const my_duration: Duration = .{\n            .days = 1,\n            .hours = 23,\n            .minutes = 59,\n            .seconds = 59,\n            .microseconds = 123456,\n        };\n        const params = .{.{ my_time, my_duration }};\n        inline for (params) |param| {\n            const exe_res = try c.execute(&prep_stmt, param);\n            _ = try exe_res.expect(.ok);\n        }\n    }\n\n    { // Select\n        const DateTimeDuration = struct {\n            event_time: DateTime,\n            duration: Duration,\n        };\n        const prep_res = try c.prepare(allocator, \"SELECT * FROM test.temporal_types_example\");\n        defer prep_res.deinit(allocator);\n        const prep_stmt: PreparedStatement = try prep_res.expect(.stmt);\n        const res = try c.executeRows(&prep_stmt, .{});\n        const rows: ResultSet(BinaryResultRow) = try res.expect(.rows);\n        const rows_iter = rows.iter();\n\n        const structs = try rows_iter.tableStructs(DateTimeDuration, allocator);\n        defer structs.deinit(allocator);\n        std.debug.print(\"structs: {any}\\n\", .{structs.struct_list.items}); // structs.rows: []const DateTimeDuration\n        // Do something with structs\n    }\n}\n```\n\n### Arrays Support\n- Assume that you have the SQL table:\n```sql\nCREATE TABLE test.array_types_example (\n    name VARCHAR(16) NOT NULL,\n    mac_addr BINARY(6)\n)\n```\n\n```zig\nfn main() !void {\n    { // Insert\n        const prep_res = try c.prepare(allocator, \"INSERT INTO test.array_types_example VALUES (?, ?)\");\n        defer prep_res.deinit(allocator);\n        const prep_stmt: PreparedStatement = try prep_res.expect(.stmt);\n\n        const params = .{\n            .{ \"John\", &[_]u8 { 0xFE } ** 6 },\n            .{ \"Alice\", null }\n        };\n        inline for (params) |param| {\n            const exe_res = try c.execute(&prep_stmt, param);\n            _ = try exe_res.expect(.ok);\n        }\n    }\n\n    { // Select\n        const Client = struct {\n            name: [16:1]u8,\n            mac_addr: ?[6]u8,\n        };\n        const prep_res = try c.prepare(allocator, \"SELECT * FROM test.array_types_example\");\n        defer prep_res.deinit(allocator);\n        const prep_stmt: PreparedStatement = try prep_res.expect(.stmt);\n        const res = try c.executeRows(&prep_stmt, .{});\n        const rows: ResultSet(BinaryResultRow) = try res.expect(.rows);\n        const rows_iter = rows.iter();\n\n        const structs = try rows_iter.tableStructs(DateTimeDuration, allocator);\n        defer structs.deinit(allocator);\n        std.debug.print(\"structs: {any}\\n\", .{structs.struct_list.items}); // structs.rows: []const Client\n        // Do something with structs\n    }\n}\n```\n- Arrays will be initialized by their sentinel value. In this example, the value of the `name` field corresponding to `John`'s row will be `[16:1]u8 { 'J', 'o', 'h', 'n', 1, 1, 1, ... }`\n- If the array doesn't have a sentinel value, it will be zero-initialized.\n- Insufficiently sized arrays will silently truncate excess data\n\n## Unit Tests\n- `zig test src/myzql.zig`\n\n## Integration Tests\n- Start up mysql/mariadb in docker:\n```bash\n# MySQL\ndocker run --name some-mysql --env MYSQL_ROOT_PASSWORD=password -p 3306:3306 -d mysql\n```bash\n# MariaDB\ndocker run --name some-mariadb --env MARIADB_ROOT_PASSWORD=password -p 3306:3306 -d mariadb\n```\n- Run all the test: In root directory of project:\n```bash\nzig build -Dtest-filer='...' integration_test\n```\n\n## Philosophy\n### Correctness\nFocused on correct representation of server client protocol.\n### Low-level and High-level APIs\nLow-level apis should contain all functionality you need.\nHigh-level apis are built on top of low-level ones for convenience and developer ergonomics.\n\n### Binary Column Types support\n- MySQL Colums Types to Zig Values\n```\n- Null -> ?T\n- Int -> u64, u32, u16, u8\n- Float -> f32, f64\n- String -> []u8, []const u8, enum\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/33050391?u=23f863c9f21567a56ea583c66e4c8b3e0e746d29&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 12,
  "owner_following": 2,
  "owner_created_at": "2017-10-24T06:09:18Z",
  "license": "MIT",
  "category": "library"
}