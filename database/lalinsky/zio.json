{
  "name": "zio",
  "owner": "lalinsky",
  "repo": "zio",
  "description": "Async I/O framework for Zig",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 315,
  "forks": 9,
  "watchers": 0,
  "updated_at": "2025-12-19T18:49:09Z",
  "dependencies": [
    {
      "name": "aio",
      "url": "git+https://github.com/lalinsky/aio.zig?ref=v0.1.0#5e2db8aadd14ee141084922c49d4e8952edaa969",
      "hash": "aio-0.4.0-k5779gHcBgDaPq8pM2EnhXXL-GhLNLEI740wtNZgGUzt"
    },
    {
      "name": "coro",
      "url": "git+https://github.com/lalinsky/coro.zig#c2f6ee86f08f09dc636bd7e2fada4ac7041f1bf8",
      "hash": "coro-0.4.0-PlYYwB5LAQC74z-2I1aFodebvqTCgDtWK3B9FtoWO110"
    }
  ],
  "minimum_zig_version": "0.15.2",
  "readme": "# ZIO - Async I/O framework for Zig\n\n[![CI](https://github.com/lalinsky/zio/actions/workflows/test.yml/badge.svg)](https://github.com/lalinsky/zio/actions/workflows/test.yml)\n[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)\n[![Zig](https://img.shields.io/badge/zig-0.15.1-orange.svg)](https://ziglang.org/download/)\n[![Documentation](https://img.shields.io/badge/docs-online-green.svg)](https://lalinsky.github.io/zio/)\n\nThere are two ways of doing asynchronous I/O, either you use callbacks and have the I/O operation call you when it's done, or you have some sort of continuation system and suspend your code while waiting for I/O. Callback-based APIs are easier to implement, they don't need any special runtime or language support. However, they are much harder to use, you need to manage state yourself and most likely need many more allocations to do so.\n\nThis project started out of my frustration with the state of networking in Zig. I've tried to write a nice wrapper for libuv in Zig, but it just doesn't work, you have to allocate memory all the time, you need to depend on reference counted pointers. Then it occurred to me that I could do Go-style stackful coroutines and use the stack for storing the state. The resulting code feels much more idiomatic. So I did an experiment with custom assembly for switching contexts, used libuv as my event loop, created a translation layer from libuv callbacks to coroutines, later switched libuv for libxev, and then worked more on the scheduler, especially making it run in multi-threaded mode.\n\nThe project consists of a runtime for executing many stackful coroutines (fibers, green threads) on one or more CPU threads, synchronization primitives that work with this runtime and an asynchronous I/O layer that makes it look like I/O calls are blocking, allowing surrounding state to be stored directly on the stack. This makes it possible for you to handle thousands of network connections on a single CPU thread. And if you use multiple executors, you can spread the load across multiple CPU threads. When using the multi-threaded runtime, coroutines migrate from one thread to another, both for reduced latency in message passing applications, but also for load balancing.\n\nStreams implement the standard `std.Io.Reader` and `std.Io.Writer` interfaces, so you can use external libraries, that were never written with asynchronous I/O in mind and they will just work. Additionally, when Zig 0.16 is released with the `std.Io` interface, I will implement that as well, allowing you to use the entire standard library with this runtime.\n\nYou can see this as an alternative to the Go runtime, the Tokio project for Rust, or Python's asyncio. In a single-threaded mode, Zio outperforms any of these. In multi-threaded mode, it has comparable performance to Go and Tokio, but those are more mature projects and they have invested a lot of effort to ensuring fairness and load balancing of their schedulers.\n\n## Features\n\n- Supports Linux (x86_64, aarch64, riscv64), Windows (x86_64, aarch64), macOS (aarch64), should also work on BSDs, but not tested\n- Single-threaded or multi-threaded runtime with one I/O event loop per executor thread\n- Spawning coroutines, one small allocation per spawn, stack memory is reused\n- Spawning blocking tasks in an auxiliary thread pool\n- Fully asynchronous network I/O, supports TCP/UDP sockets, Unix sockets, DNS resolution currently via thread pool\n- Asynchronous file I/O, Linux and Windows are truly asynchronous, other platforms are simulated using a thread pool\n- Cancellation support for all I/O operations on Linux and Windows, on other platforms we just stop polling, but can't cancel an active operation\n- Full `std.Io.Reader` and `std.Io.Writer` support for files and streaming sockets (TCP, Unix)\n- Synchronization primitives matching `std.Thread` API (`Mutex`, `Condition`, `Semaphore`, `ResetEvent`, `Notify`, `Barrier`)\n- `Channel(T)` and `BroadcastChannel(T)` for producer-consumer patterns across coroutines\n- Signal handling\n\n## Installation\n\n1) Add zio as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save \"git+https://github.com/lalinsky/zio\"\n```\n\n2) In your `build.zig`, add the `zio` module as a dependency to your program:\n\n```zig\nconst zio = b.dependency(\"zio\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"zio\", zio.module(\"zio\"));\n```\n\n## Usage\n\nBasic TCP echo server:\n\n```zig\nconst std = @import(\"std\");\nconst zio = @import(\"zio\");\n\nfn handleClient(rt: *zio.Runtime, stream: zio.net.Stream) !void {\n    defer stream.close(rt);\n\n    var read_buffer: [1024]u8 = undefined;\n    var reader = stream.reader(rt, &read_buffer);\n\n    var write_buffer: [1024]u8 = undefined;\n    var writer = stream.writer(rt, &write_buffer);\n\n    while (true) {\n        const line = reader.interface.takeDelimiterInclusive('\\n') catch |err| switch (err) {\n            error.EndOfStream => break,\n            else => return err,\n        };\n        try writer.interface.writeAll(line);\n        try writer.interface.flush();\n    }\n}\n\nfn serverTask(rt: *zio.Runtime) !void {\n    const addr = try zio.net.IpAddress.parseIp4(\"127.0.0.1\", 8080);\n\n    const server = try addr.listen(rt, .{});\n    defer server.close(rt);\n\n    std.log.info(\"Listening on 127.0.0.1:8080\", .{});\n\n    while (true) {\n        const stream = try server.accept(rt);\n        errdefer stream.close(rt);\n\n        var task = try rt.spawn(handleClient, .{ rt, stream }, .{});\n        task.detach(rt);\n    }\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n\n    const rt = try zio.Runtime.init(gpa.allocator(), .{});\n    defer rt.deinit();\n\n    var handle = try rt.spawn(serverTask, .{rt}, .{});\n    try handle.join(rt);\n}\n```\n\nSee `examples/*.zig` and [mini-redis](https://github.com/lalinsky/zio-mini-redis) for more examples.\n\nYou can also have a look at [Dusty](https://github.com/lalinsky/dusty), a HTTP server library that uses Zio.\n\n## Building\n\n```bash\n# Build the library and examples\nzig build\n\n# Run tests\nzig build test\n```\n## Sub-projects\n\nTo make CI testing easier, I've extracted platform-specific code to separate packages:\n\n* [aio.zig](https://github.com/lalinsky/aio.zig) - callback-based asynchronous file/network library for Linux, Windows, macOS and most BSDs\n* [coro.zig](https://github.com/lalinsky/coro.zig) - stackful coroutine library for x86_64, aarch64 and riscv64 architectures\n\n## FAQ\n\n### How is this different from other Zig async I/O projects?\n\nThere are many projects implementing stackful coroutines for Zig, unfortunately they are all missing something. The closest one to complete is [Tardy](https://github.com/tardy-org/tardy). Unfortunately, I didn't know about it when I started this project. However, even Tardy is missing many things that I wanted, like spawning non-cooperative tasks in a separate thread pool and being able to wait on their results from coroutines, more advanced synchronization primitives and Windows support. I wanted to start from an existing cross-platform event loop, originally [libuv](https://libuv.org/), later switched to [libxev](https://github.com/mitchellh/libxev), and just add coroutine runtime on top of that.\n\n### How is this different from the future `std.Io` interface in Zig?\n\nIn the `zig-0.16` branch, I actually have an implementation of the `std.Io` interface, so you can use this library for any I/O code in Zig 0.16. It's essentially just another frontend API for the same runtime.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/220839?u=76f817358cb458727e81dd4ec11188d343becc9e&v=4",
  "releases": [
    {
      "tag_name": "v0.4.0",
      "name": "v0.4.0",
      "body": "### Added\n\n- Extended runtime to support multiple threads/executors (not full work-stealing yet)\n- Added `Signal` for listening to OS signals\n- Added `Notify` and `Future(T)` synchronization primitives\n- Added `select()` for waiting on multiple tasks\n\n### Changed\n\n- Added `zio.net.IpAddress` and `zio.net.UnixAddress`, matching the future `std.net` API\n- Renamed `zio.TcpListener` to `zio.net.Server`\n- Renamed `zio.TcpStream` to `zio.net.Stream`\n- Renamed `zio.UdpSocket` to `zio.net.Socket` (`Socket` can be also as a low-level primitive)\n- `join()` is now uncancelable, it will cancel the task if the parent task is cancelled\n- `sleep()` now correctly propagates `error.Canceled`\n- Internal refactoring to allow more objects (e.g. `ResetEvent`) to participate in `select()`\n\n### Fixed\n\n- IPv6 address truncatation in network operations",
      "prerelease": false,
      "published_at": "2025-10-25T07:06:12Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.4.0",
      "assets": []
    },
    {
      "tag_name": "v0.3.0",
      "name": "v0.3.0",
      "body": "### Added\n\n- `Runtime.now()` for getting the current monotonic time in milliseconds\n- `JoinHandle.cast()` for converting between compatible error sets\n- Exported `Barrier` and `RefCounter` synchronization primitives\n\n### Changed\n\n- **BREAKING**: Renamed `Queue` to `Channel` with channel-style API\n- **BREAKING**: `JoinHandle(T)` type parameter `T` now represents the full error union type, not just the success payload\n- Updated to use `std.net.Address` directly\n- Internal refactoring to prepare for future multi-threaded runtime support (executor separation, unified waiter lists, improved cancellation-safety)\n\n### Fixed\n\n- macOS crash in event loop (updated libxev with kqueue fixes)",
      "prerelease": false,
      "published_at": "2025-10-16T21:47:31Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v0.2.0",
      "name": "v0.2.0",
      "body": "## Added\n\n- Cancellation support for all task types with proper cleanup and error handling\n- `Barrier` and `BroadcastChannel` synchronization primitives\n- `Future(T)` object for task-less async operations\n- Stack memory reuse and direct context switching for better performance\n- Thread parking support for blocking operations\n\n## Changed\n\n- `JoinHandle(T)` type parameter `T` now represents only the success payload, errors are stored separately\n- All async operations can now return `error.Canceled`\n- Increased default stack size to 2MB on Windows due to inefficient filename handling in `std.os.windows`\n\n## Fixed\n\n- Windows TIB fields handling and shadow space allocation\n- Socket I/O vectored operations and EOF translation\n- Context switching clobber lists for x86_64 and aarch64",
      "prerelease": false,
      "published_at": "2025-10-10T08:00:00Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "v0.1.0",
      "body": "Initial release of ZIO - Zig I/O Library\n\nAn async I/O library for Zig, built on top of stackful coroutines and libxev.\n\n## Features\n\n- Supports Linux, Windows and macOS\n- Single-threaded event loop\n- Spawn stackful coroutines, and wait for the results\n- Spawn blocking tasks in a thread pool, and wait for the results\n- File I/O on all platforms\n- Network I/O, supports TCP/UDP sockets\n- Full `std.Io.Reader` and `std.Io.Writer` support for TCP streams\n- Synchronization primitives matching `std.Thread` API\n- `Queue(T)` for producer-consumer patterns across coroutines",
      "prerelease": false,
      "published_at": "2025-10-05T16:14:53Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Trenčín, Slovakia",
  "owner_blog": "https://lalinsky.com",
  "owner_twitter_username": null,
  "owner_followers": 298,
  "owner_following": 27,
  "owner_created_at": "2010-03-11T19:55:55Z",
  "homepage": "https://lalinsky.github.io/zio/",
  "license": "Apache-2.0",
  "category": "library"
}