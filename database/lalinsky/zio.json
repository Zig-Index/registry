{
  "name": "zio",
  "owner": "lalinsky",
  "repo": "zio",
  "description": "Async I/O framework for Zig",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 356,
  "forks": 13,
  "watchers": 0,
  "updated_at": "2026-01-30T18:55:35Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# ZIO - Async I/O framework for Zig\n\n[![CI](https://github.com/lalinsky/zio/actions/workflows/test.yml/badge.svg)](https://github.com/lalinsky/zio/actions/workflows/test.yml)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Zig](https://img.shields.io/badge/zig-0.15.2-orange.svg)](https://ziglang.org/download/)\n[![Documentation](https://img.shields.io/badge/docs-online-green.svg)](https://lalinsky.github.io/zio/)\n\nThe project consists of a few high-level components:\n- Runtime for executing stackful coroutines (fibers, green threads) on one or more CPU threads.\n- Asynchronous I/O layer that makes it look like operations are blocking for easy state management, but using event-driven OS APIs under the hood.\n- Synchronization primitives that cooperate with this runtime.\n- Integration with standard library interfaces, like [`std.Io`], [`std.Io.Reader`] and [`std.Io.Writer`].\n\nIt's similar to [goroutines] in Go, but with the pros and cons of being implemented in a language with manual memory management and without compiler support.\n\n[`std.Io`]: https://ziglang.org/documentation/master/std/#std.Io\n[`std.Io.Reader`]: https://ziglang.org/documentation/0.15.2/std/#std.Io.Reader\n[`std.Io.Writer`]: https://ziglang.org/documentation/0.15.2/std/#std.Io.Writer\n[`std.Io`]: https://ziglang.org/documentation/master/std/#std.Io.Writer\n[goroutines]: https://en.wikipedia.org/wiki/Go_(programming_language)#Concurrency\n\n*The `main` branch works with Zig 0.15. If you want to use the library with the development version of Zig with the `std.Io` interface, use the [`zig-0.16`] branch. Keep in mind that the development version Zig has frequent breaking changes, so the branch might not be always up to date. Contributions are welcome.*\n\n[`zig-0.16`]: https://github.com/lalinsky/zio/tree/zig-0.16\n\n## Features\n\n- Support for Linux (`io_uring`, `epoll`), Windows (`iocp`), macOS (`kqueue`), most BSDs (`kqueue`), and many other systems (`poll`).\n- User-mode coroutine context switching for `x86_64`, `aarch64`, `arm`, `thumb`, `riscv32`, `riscv64` and `loongarch64` architectures.\n- Growable stacks for the coroutines implemented by auto-extending virtual memory reservations.\n- Multi-threaded coroutine scheduler.\n- Fully asynchronous network I/O on all systems.\n- Asynchronous file I/O on Linux and Windows, simulated using auxiliary thread pool on other systems.\n- Cancelation support for all operations.\n- Structured concurrency using task groups.\n- Synchronization primitives, including more advanced ones, like channels.\n\n## Installation\n\n1) Add zio as a dependency in your `build.zig.zon`:\n\n```bash\nzig fetch --save \"git+https://github.com/lalinsky/zio\"\n```\n\n2) In your `build.zig`, add the `zio` module as a dependency to your program:\n\n```zig\nconst zio = b.dependency(\"zio\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// the executable from your call to b.addExecutable(...)\nexe.root_module.addImport(\"zio\", zio.module(\"zio\"));\n```\n\n## Usage\n\nBasic TCP echo server:\n\n```zig\nconst std = @import(\"std\");\nconst zio = @import(\"zio\");\n\nfn handleClient(rt: *zio.Runtime, stream: zio.net.Stream) !void {\n    defer stream.close(rt);\n\n    var read_buffer: [1024]u8 = undefined;\n    var reader = stream.reader(rt, &read_buffer);\n\n    var write_buffer: [1024]u8 = undefined;\n    var writer = stream.writer(rt, &write_buffer);\n\n    while (true) {\n        const line = reader.interface.takeDelimiterInclusive('\\n') catch |err| switch (err) {\n            error.EndOfStream => break,\n            else => return err,\n        };\n        try writer.interface.writeAll(line);\n        try writer.interface.flush();\n    }\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n\n    const rt = try zio.Runtime.init(gpa.allocator(), .{});\n    defer rt.deinit();\n\n    const addr = try zio.net.IpAddress.parseIp4(\"127.0.0.1\", 8080);\n    const server = try addr.listen(rt, .{});\n    defer server.close(rt);\n\n    std.log.info(\"Listening on {f}\", .{server.socket.address});\n\n    var group: zio.Group = .init;\n    defer group.cancel(rt);\n\n    while (true) {\n        const stream = try server.accept(rt);\n        errdefer stream.close(rt);\n\n        try group.spawn(rt, handleClient, .{ rt, stream });\n    }\n}\n```\n\nSee `examples/*.zig` for more examples.\n\n## Ecosystem\n\nThe following libraries use zio for networking and concurrency:\n\n- [Dusty](https://github.com/lalinsky/dusty) - HTTP client and server library\n- [nats.zig](https://github.com/lalinsky/nats.zig) - NATS client library\n- [pg.zig](https://github.com/lalinsky/pg.zig) - PostgreSQL client library (fork of [karlseguin/pg.zig](https://github.com/karlseguin/pg.zig))\n\n## Building\n\n```bash\n# Build the library and examples\nzig build\n\n# Run tests\nzig build test\n```\n\n## License\n\nThis project is licensed under the [MIT license].\n\n[MIT license]: https://github.com/lalinsky/zio/blob/main/LICENSE\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/220839?u=76f817358cb458727e81dd4ec11188d343becc9e&v=4",
  "releases": [
    {
      "tag_name": "v0.5.1",
      "name": "v0.5.1",
      "body": "### Added\n\n- Added `readVec` and `writeVec` methods to `Stream` (#236)\n- Added custom panic handler to avoid stack overflow during panics (#237)\n\n### Changed\n\n- Made `ResetEvent.reset` idempotent (#235)",
      "prerelease": false,
      "published_at": "2026-01-25T20:01:34Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.5.1",
      "assets": []
    },
    {
      "tag_name": "v0.5.0",
      "name": "v0.5.0",
      "body": "This is a major release with many changes. It has been in development for a while, but I finally decided\nto release it.\n\nFirst of all, the codebase has been relicensed under the MIT license.\n\nI replaced `libxev` with a custom I/O event loop, that has better cross-platform support,\nnatively supports multiple threads each running its own event loop, supports more filesystem operations,\nconsistent timer behavior across platforms, grouped operations, and more. This is avialable in `zio.ev` and\ncan be also used separately from the rest of the library. This switch was motivated by with Zig 0.16 which\nremoved a lot of lower-level I/O APIs, so it was hard to upgrade `libxev`, but in the end, I'm glad I did it.\nThe new event loop is more feature complete, more efficient, and more flexible.\n\nThe coroutine library has also been restructured, and it's now available in `zio.coro`.\nI've added support for riscv64 and loongarch64 CPUs. Stack allocation has been completel rewritten,\nit now properly allocates vitual memory from the operating system, marks guard pages and we also have\nsignal handlers for growing the virtual memory reservation on demand. Coroutines now start with 64KiB\nof stack space, and grow dynamically as needed.\n\nThe `zio.select()` function has been completely rewritten, and now support comptime-based support\nfor waiting on things other than tasks. For example, you can use it to race two channel reads,\nor add timeout support to any operation that doesn't handle timeouts natively.\n\nThere is now `zio.AutoCancel` for automatically cancelling the current task after a timeout.\nThis is useful when you want to call an arbitrary function that may take a long time to complete,\nand you want to make sure it gets cancelled if it doesn't complete in a timely manner, for example,\nin HTTP request handlers.\n\nMany networking APIs now have direct timeout support. Additionally, in `zio.net.Stream.Reader` and\n`zio.net.Stream.Writer`, you can call `setTimeout()` and it will make sure the underlaying \n`std.Io.Reader` or `std.Io.Writer` doesn't block for too long. This is similar to\nPOSIX socket read/write timeouts, but also supports absolute deadlines.\n\nMany new APIs have been added, for compatibility with the future `std.Io` API.\n\nInternally, I've done a lot of refactoring to prepare for a future scheduler replacement.\nI've started with project with an event-loop-per-thread model, and I still think it's the better\napproach for servers, but I'm slowly migrating to a hybrid model, where tasks primarily stick to\nthe thread they were created on, but also can be freely moved to other threads,\nwhen it's beneficial for load balancing.",
      "prerelease": false,
      "published_at": "2026-01-24T20:00:12Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.5.0",
      "assets": []
    },
    {
      "tag_name": "v0.4.0",
      "name": "v0.4.0",
      "body": "### Added\n\n- Extended runtime to support multiple threads/executors (not full work-stealing yet)\n- Added `Signal` for listening to OS signals\n- Added `Notify` and `Future(T)` synchronization primitives\n- Added `select()` for waiting on multiple tasks\n\n### Changed\n\n- Added `zio.net.IpAddress` and `zio.net.UnixAddress`, matching the future `std.net` API\n- Renamed `zio.TcpListener` to `zio.net.Server`\n- Renamed `zio.TcpStream` to `zio.net.Stream`\n- Renamed `zio.UdpSocket` to `zio.net.Socket` (`Socket` can be also as a low-level primitive)\n- `join()` is now uncancelable, it will cancel the task if the parent task is cancelled\n- `sleep()` now correctly propagates `error.Canceled`\n- Internal refactoring to allow more objects (e.g. `ResetEvent`) to participate in `select()`\n\n### Fixed\n\n- IPv6 address truncatation in network operations",
      "prerelease": false,
      "published_at": "2025-10-25T07:06:12Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.4.0",
      "assets": []
    },
    {
      "tag_name": "v0.3.0",
      "name": "v0.3.0",
      "body": "### Added\n\n- `Runtime.now()` for getting the current monotonic time in milliseconds\n- `JoinHandle.cast()` for converting between compatible error sets\n- Exported `Barrier` and `RefCounter` synchronization primitives\n\n### Changed\n\n- **BREAKING**: Renamed `Queue` to `Channel` with channel-style API\n- **BREAKING**: `JoinHandle(T)` type parameter `T` now represents the full error union type, not just the success payload\n- Updated to use `std.net.Address` directly\n- Internal refactoring to prepare for future multi-threaded runtime support (executor separation, unified waiter lists, improved cancellation-safety)\n\n### Fixed\n\n- macOS crash in event loop (updated libxev with kqueue fixes)",
      "prerelease": false,
      "published_at": "2025-10-16T21:47:31Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v0.2.0",
      "name": "v0.2.0",
      "body": "## Added\n\n- Cancellation support for all task types with proper cleanup and error handling\n- `Barrier` and `BroadcastChannel` synchronization primitives\n- `Future(T)` object for task-less async operations\n- Stack memory reuse and direct context switching for better performance\n- Thread parking support for blocking operations\n\n## Changed\n\n- `JoinHandle(T)` type parameter `T` now represents only the success payload, errors are stored separately\n- All async operations can now return `error.Canceled`\n- Increased default stack size to 2MB on Windows due to inefficient filename handling in `std.os.windows`\n\n## Fixed\n\n- Windows TIB fields handling and shadow space allocation\n- Socket I/O vectored operations and EOF translation\n- Context switching clobber lists for x86_64 and aarch64",
      "prerelease": false,
      "published_at": "2025-10-10T08:00:00Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "v0.1.0",
      "body": "Initial release of ZIO - Zig I/O Library\n\nAn async I/O library for Zig, built on top of stackful coroutines and libxev.\n\n## Features\n\n- Supports Linux, Windows and macOS\n- Single-threaded event loop\n- Spawn stackful coroutines, and wait for the results\n- Spawn blocking tasks in a thread pool, and wait for the results\n- File I/O on all platforms\n- Network I/O, supports TCP/UDP sockets\n- Full `std.Io.Reader` and `std.Io.Writer` support for TCP streams\n- Synchronization primitives matching `std.Thread` API\n- `Queue(T)` for producer-consumer patterns across coroutines",
      "prerelease": false,
      "published_at": "2025-10-05T16:14:53Z",
      "html_url": "https://github.com/lalinsky/zio/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Trenčín, Slovakia",
  "owner_blog": "https://lalinsky.com",
  "owner_twitter_username": null,
  "owner_followers": 304,
  "owner_following": 27,
  "owner_created_at": "2010-03-11T19:55:55Z",
  "homepage": "https://lalinsky.github.io/zio/",
  "category": "library"
}