{
  "name": "sokol-zig",
  "owner": "floooh",
  "repo": "sokol-zig",
  "description": "Zig bindings for the sokol headers (https://github.com/floooh/sokol)",
  "type": "package",
  "topics": [
    "zig",
    "sokol",
    "crossplatform",
    "zig-package"
  ],
  "stars": 641,
  "forks": 73,
  "watchers": 8,
  "updated_at": "2026-02-20T18:45:11Z",
  "dependencies": [
    {
      "name": "emsdk",
      "url": "git+https://github.com/emscripten-core/emsdk?ref=4.0.14#eff90ca04a3785f571a8095b3a42b63799cf384a",
      "hash": "N-V-__8AAMGsDwC6L1OfDgzRF1zFI2t-CaR0sVhEm8pmrpxm"
    },
    {
      "name": "shdc",
      "url": "git+https://github.com/floooh/sokol-tools-bin#87a6914bb5eab83f13b12db6dfd4c1333494d076",
      "hash": "sokolshdc-0.1.0-r2KZDhCTcARkWp7-FHBGPghlpM9lLOxPaccqSdy5Cr-R"
    }
  ],
  "readme": "[![build](https://github.com/floooh/sokol-zig/actions/workflows/main.yml/badge.svg)](https://github.com/floooh/sokol-zig/actions/workflows/main.yml)\n\nFor Zig version 0.15+\n\nIn case of breaking changes in Zig, the bindings might fall behind. Please don't hesitate to\nping me via a Github issue, or even better, provide a PR :)\n\nSupport for stable Zig versions is in branches (e.g. `zig-0.12.0`), those versions are 'frozen in time' though.\n\nRelated projects:\n\n- [pacman.zig](https://github.com/floooh/pacman.zig)\n- [chipz emulators](https://github.com/floooh/chipz)\n- [Dear ImGui sample project](https://github.com/floooh/sokol-zig-imgui-sample)\n\n## Building the samples\n\nSupported platforms are: Windows, macOS, Linux (with X11) and web\n\nOn Linux install the following packages: libglu1-mesa-dev, mesa-common-dev, xorg-dev, libasound-dev\n(or generally: the dev packages required for X11, GL and ALSA development)\n\nTo build the platform-native samples:\n\n```sh\n# build all examples:\nzig build examples\n# build and run individual examples\nzig build run-clear\nzig build run-triangle\nzig build run-quad\nzig build run-bufferoffsets\nzig build run-cube\nzig build run-noninterleaved\nzig build run-texcube\nzig build run-offscreen\nzig build run-instancing\nzig build run-mrt\nzig build run-saudio\nzig build run-sgl\nzig build run-sgl-context\nzig build run-sgl-points\nzig build run-debugtext\nzig build run-debugtext-print\nzig build run-debugtext-userfont\nzig build run-shapes\n```\n\n(also run ```zig build -l``` to get a list of build targets)\n\nBy default, the backend 3D API will be selected based on the target platform:\n\n- macOS: Metal\n- Windows: D3D11\n- Linux: GL\n\nTo force the GL backend on macOS or Windows, build with `-Dgl=true`:\n\n```\n> zig build -Dgl=true run-clear\n```\n\nTo force the experimental Vulkan backend, build with `-Dvulkan=true`\n```\n> zig build -Dvulkan=true run-clear\n```\n\n> NOTE: Vulkan support is currently only supported on Linux, and\n> as of Zig 0.16.x there's an issue with the libvulkan.so DLL from the\n> Vulkan SDK (linking with the system Vulkan DLL appears to work)\n\nThe ```clear``` sample prints the selected backend to the terminal:\n\n```\nsokol-zig âž¤ zig build -Dgl=true run-clear\nBackend: .sokol.gfx.Backend.GLCORE33\n```\n\nFor the web-samples, run:\n\n```sh\nzig build examples -Dtarget=wasm32-emscripten\n# or to build and run one of the samples\nzig build run-clear -Dtarget=wasm32-emscripten\n...\n```\n\nWhen building with target `wasm32-emscripten` for the first time, the build script will\ninstall and activate the Emscripten SDK into the Zig package cache for the latest SDK\nversion. There is currently no build system functionality to update or delete the Emscripten SDK\nafter this first install. The current workaround is to simply delete the `zig-pkg` subdirectory\n(for zig-0.16.x - previous versions stored the emsdk in the global Zig cache instead).\n\nImproving the Emscripten SDK integration with the Zig build system is planned for the future.\n\n\n## How to integrate sokol-zig into your project\n\nAdd a build.zig.zon file to your project which has at least a `.sokol` dependency:\n\n```zig\n.{\n    .name = \"my_project\",\n    .version = \"0.1.0\",\n    .paths = .{\n        \"src\",\n        \"build.zig\",\n        \"build.zig.zon\",\n    },\n    .dependencies = .{\n        .sokol = .{\n            .url = \"git+https://github.com/floooh/sokol-zig.git#[commit-hash]\",\n            .hash = \"[content-hash]\",\n        },\n    },\n}\n```\n\nThe easiest way to populate or update the `sokol` dependency is to run this on the cmdline:\n\n```\nzig fetch --save=sokol git+https://github.com/floooh/sokol-zig.git\n```\n\nThis will automatically use the latest sokol-zig commit.\n\nFor a native-only project, a `build.zig` file looks entirely vanilla:\n\n```zig\nconst std = @import(\"std\");\nconst Build = std.Build;\n\npub fn build(b: *Build) !void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n    const dep_sokol = b.dependency(\"sokol\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    const hello = b.addExecutable(.{\n        .name = \"hello\",\n        .root_module = b.createModule(.{\n            .root_source_file = b.path(\"src/hello.zig\"),\n            .target = target,\n            .optimize = optimize,\n            .imports = &.{\n                .{\n                    .name = \"sokol\",\n                    .module = dep_sokol.module(\"sokol\"),\n                },\n            },\n        }),\n    });\n    b.installArtifact(hello);\n    const run = b.addRunArtifact(hello);\n    b.step(\"run\", \"Run hello\").dependOn(&run.step);\n}\n```\n\nTo force the GL backend on macOS or Windows, you can pass `.gl = true` to the dependency call:\n\n```zig\nconst dep_sokol = b.dependency(\"sokol\", .{\n    .target = target,\n    .optimize = optimize,\n    // same as building sokol-zig with -Dgl=true\n    .gl = true\n});\n```\n\nThis can be done with any build option declared in `sokol-zig`.\n\nIf you also want to run on the web via `-Dtarget=wasm32-emscripten`, the web platform\nbuild must look special, because Emscripten must be used for linking, and to run\nthe build result in a browser, a special run step must be created.\n\nSuch a 'hybrid' build script might look like this (copied straight from [pacman.zig](https://github.com/floooh/pacman.zig)):\n\n```zig\nconst std = @import(\"std\");\nconst Build = std.Build;\nconst sokol = @import(\"sokol\");\n\nconst Options = struct {\n    mod: *Build.Module,\n    dep_sokol: *Build.Dependency,\n};\n\npub fn build(b: *Build) !void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n    const dep_sokol = b.dependency(\"sokol\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    const mod_pacman = b.createModule(.{\n        .root_source_file = b.path(\"src/pacman.zig\"),\n        .target = target,\n        .optimize = optimize,\n        .imports = &.{\n            .{ .name = \"sokol\", .module = dep_sokol.module(\"sokol\") },\n            .{ .name = \"shader\", .module = try createShaderModule(b, dep_sokol) },\n        },\n    });\n\n    // special case handling for native vs web build\n    const opts = Options{ .mod = mod_pacman, .dep_sokol = dep_sokol };\n    if (target.result.cpu.arch.isWasm()) {\n        try buildWeb(b, opts);\n    } else {\n        try buildNative(b, opts);\n    }\n}\n\n// this is the regular build for all native platforms, nothing surprising here\nfn buildNative(b: *Build, opts: Options) !void {\n    const exe = b.addExecutable(.{\n        .name = \"pacman\",\n        .root_module = opts.mod,\n    });\n    b.installArtifact(exe);\n    const run = b.addRunArtifact(exe);\n    b.step(\"run\", \"Run pacman\").dependOn(&run.step);\n}\n\n// for web builds, the Zig code needs to be built into a library and linked with the Emscripten linker\nfn buildWeb(b: *Build, opts: Options) !void {\n    const lib = b.addLibrary(.{\n        .name = \"pacman\",\n        .root_module = opts.mod,\n    });\n\n    // create a build step which invokes the Emscripten linker\n    const emsdk = opts.dep_sokol.builder.dependency(\"emsdk\", .{});\n    const link_step = try sokol.emLinkStep(b, .{\n        .lib_main = lib,\n        .target = opts.mod.resolved_target.?,\n        .optimize = opts.mod.optimize.?,\n        .emsdk = emsdk,\n        .use_webgl2 = true,\n        .use_emmalloc = true,\n        .use_filesystem = false,\n        .shell_file_path = opts.dep_sokol.path(\"src/sokol/web/shell.html\"),\n    });\n    // attach Emscripten linker output to default install step\n    b.getInstallStep().dependOn(&link_step.step);\n    // ...and a special run step to start the web build output via 'emrun'\n    const run = sokol.emRunStep(b, .{ .name = \"pacman\", .emsdk = emsdk });\n    run.step.dependOn(&link_step.step);\n    b.step(\"run\", \"Run pacman\").dependOn(&run.step);\n}\n\n// compile shader via sokol-shdc\nfn createShaderModule(b: *Build, dep_sokol: *Build.Dependency) !*Build.Module {\n    // ...\n}\n```\n\n## Shader compilation\n\nsokol-zig comes with builtin `sokol-shdc` support and offers two ways to\nintegrate shader compilation into the build process:\n\n1. Compile the shader source file into a Zig source file within the\n   project's source directory, which is then directly imported.\n2. Compile the shader source file into a Zig module, with the module\n   source file existing only in the Zig cache.\n\nFor both cases, you need to import the sokol dependency in your\nproject's build.zig:\n\n```zig\nconst sokol = @import(\"sokol\");\n```\n\n...you'll also need the sokol and shdc dependencies:\n\n```zig\n    const dep_sokol = b.dependency(\"sokol\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n```\n\n### Option 1: compile shader source into a Zig source file\n\n```zig\n    // extract shdc dependency from sokol dependency\n    const dep_shdc = dep_sokol.builder.dependency(\"shdc\", .{});\n\n    // call shdc.createSourceFile() helper function, this returns a `!*Build.Step`:\n    const shdc_step = try sokol.shdc.createSourceFile(b, .{\n        .shdc_dep = dep_shdc,\n        .input = \"src/shader.glsl\",\n        .output = \"src/shader.zig\",\n        .slang = .{ .hlsl5 = true, ... },\n    });\n\n    // add the shader compilation step as dependency to the build step\n    // which requires the generated Zig source file\n    exe_step.step.dependOn(shdc_step);\n```\n\n...and then import the shader as Zig source file in your application code:\n\n```zig\nconst shd = @import(\"shader.zig\");\n```\n\n### Option 2: compile shader source into a Zig module\n\n```zig\n    // extract the sokol module and shdc dependency from sokol dependency\n    const mod_sokol = dep_sokol.module(\"sokol\");\n    const dep_shdc = dep_sokol.builder.dependency(\"shdc\", .{});\n\n    // call shdc.createModule() helper function, this returns a `!*Build.Module`:\n    const mod_shd = try sokol.shdc.createModule(b, \"shader\", mod_sokol, .{\n        .shdc_dep = dep_shdc,\n        .input = \"src/shader.glsl\",\n        .output = \"shader.zig\",\n        .slang = .{ .hlsl5 = true, ... },\n    });\n\n    // add the module as import to the module which imports the shader:\n    const main_mod = b.createModule(.{\n        .root_source_file = \"src/main.zig\",\n        .target = target,\n        .optimize = optimize,\n        .imports = &.{\n            .{ .name = \"sokol\", .module = mod_sokol },\n            .{ .name = \"shader\", .module = mod_shd },\n        }\n    });\n```\n\nThen in your `main.zig`, import the shader module:\n\n```zig\nconst shd = @import(\"shader\");\n```\n\n...also see the pacman.zig project's build.zig as example:\n\nhttps://github.com/floooh/pacman.zig/blob/main/build.zig\n\n## Using sokol headers in C code\n\nThe sokol-zig build.zig exposes a C library artifact called `sokol_clib`.\n\nYou can lookup the build step for this library via:\n\n```zig\n    const dep_sokol = b.dependency(\"sokol\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    const sokol_clib = dep_sokol.artifact(\"sokol_clib\");\n```\n\n...once you have that library artifact, 'link' it to your compile step which contains\nyour own C code:\n\n```zig\n    const my_clib = ...;\n    my_clib.linkLibrary(sokol_clib);\n```\n\nThis makes the Sokol C headers available to your C code in a `sokol/` subdirectory:\n\n```c\n#include \"sokol/sokol_app.h\"\n#include \"sokol/sokol_gfx.h\"\n// etc...\n```\n\nKeep in mind that the implementation is already provided in the `sokol_clib`\nstatic link library (e.g. don't try to build the Sokol implementations yourself\nvia the `SOKOL_IMPL` macro).\n\n\n## wasm32-emscripten caveats\n\n- the Zig stdlib only has limited support for the `wasm32-emscripten`\n  target, for instance using `std.fs` functions will most likely fail\n  to compile (the sokol-zig bindings might add more sokol headers\n  in the future to fill some of the gaps)\n\n## Dear ImGui support\n\nThe sokol-zig bindings come with sokol_imgui.h (exposed as the Zig package\n`sokol.imgui`), but integration into a project's build.zig requires some extra\nsteps, mainly because I didn't want to add a\n[cimgui](https://github.com/cimgui/cimgui) dependency to the sokol-zig package\n(especially since cimgui uses git submodule which are not supported by the Zig\npackage manager).\n\nThe main steps to create Dear ImGui apps with sokol-zig are:\n\n1. 'bring your own cimgui'\n2. tell the sokol dependency that it needs to include sokol_imgui.h into\n  the compiled C library:\n    ```zig\n    const dep_sokol = b.dependency(\"sokol\", .{\n        .target = target,\n        .optimize = optimize,\n        .with_sokol_imgui = true,\n    });\n    ```\n3. inject the path to the cimgui directory into the sokol dependency so\n  that C compilation works (this needs to find the `cimgui.h` header)\n\n    ```zig\n    dep_sokol.artifact(\"sokol_clib\").root_module.addIncludePath(cimgui_root);\n    ```\n\nAlso see the following example project:\n\nhttps://github.com/floooh/sokol-zig-imgui-sample/\n\n## Optional sokol-gfx tracing/debug ui\n\nOn top of the Dear ImGui support outlined above, you can also integrate\nthe sokol-gfx tracing/debug ui which is implemented in sokol_gfx_imgui.h.\n\nTo do this, add the `.with_tracing = true` option when looking up\nthe sokol-dependency, e.g.:\n\n    ```zig\n    const dep_sokol = b.dependency(\"sokol\", .{\n        .target = target,\n        .optimize = optimize,\n        .with_sokol_imgui = true,\n        .with_tracing = true,\n    });\n    ```\n(note that `.with_tracing` also implicitly enables `.with_sokol_imgui`, so that's\nnot strictly necessary)\n\nFor an example of how to integrate the tracing/debug UI, see also:\n\nhttps://github.com/floooh/sokol-zig-imgui-sample/\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/1699414?u=78fddd83a07cf36de9d44ad3dd06bbea3aa773b1&v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Berlin",
  "owner_blog": "http://floooh.github.io",
  "owner_twitter_username": null,
  "owner_followers": 2973,
  "owner_following": 37,
  "owner_created_at": "2012-05-02T15:38:15Z",
  "license": "Zlib",
  "category": "library"
}