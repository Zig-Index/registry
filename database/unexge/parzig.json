{
  "name": "parzig",
  "owner": "unexge",
  "repo": "parzig",
  "description": "A Parquet parser written in Zig",
  "type": "package",
  "topics": [
    "zig",
    "zig-package"
  ],
  "stars": 2,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-19T19:49:55Z",
  "minimum_zig_version": "0.16.0-dev.2261+d6b3dd25a",
  "readme": "# parzig\n\nA Parquet parser written in Zig using only the standard library.\n\n## Usage\n\nHere's an example analyzing [NYC taxi trip data](https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page):\n\n```zig\nconst std = @import(\"std\");\nconst parzig = @import(\"parzig\");\n\nconst Io = std.Io;\nconst File = parzig.parquet.File;\n\npub fn main(init: std.process.Init) !void {\n    const allocator = init.gpa;\n    const io = init.io;\n\n    var reader_buf: [4096]u8 = undefined;\n    const f = try Io.Dir.cwd().openFile(io, \"green_tripdata_2025-10.parquet\", .{ .mode = .read_only });\n    var file_reader = f.reader(io, &reader_buf);\n\n    var file = try parzig.parquet.File.read(allocator, &file_reader);\n    defer file.deinit();\n\n    var rg = file.rowGroup(0);\n\n    // Static typing: specify column type at compile time\n    const fares = try rg.readColumn(f64, columnIndex(&file, \"fare_amount\"));\n    const tips = try rg.readColumn(f64, columnIndex(&file, \"tip_amount\"));\n    const passengers = try rg.readColumn(?i64, columnIndex(&file, \"passenger_count\")); // nullable\n\n    var total_fare: f64 = 0;\n    var total_tips: f64 = 0;\n    var total_passengers: i64 = 0;\n\n    for (fares, tips, passengers) |fare, tip, passenger| {\n        total_fare += fare;\n        total_tips += tip;\n        if (passenger) |p| total_passengers += p;\n    }\n\n    std.debug.print(\"Total rides: {}\\n\", .{file.metadata.num_rows});\n    std.debug.print(\"Total fares: ${d:.2}\\n\", .{total_fare});\n    std.debug.print(\"Total tips: ${d:.2}\\n\", .{total_tips});\n    std.debug.print(\"Total passengers: {}\\n\", .{total_passengers});\n\n    // Dynamic typing: type determined at runtime\n    const dynamic = try rg.readColumnDynamic(columnIndex(&file, \"fare_amount\"));\n    switch (dynamic) {\n        .double => |values| std.debug.print(\"First fare: ${d:.2}\\n\", .{values[0].?}),\n        else => unreachable,\n    }\n}\n\nfn columnIndex(file: *File, name: []const u8) usize {\n    return file.findSchemaElement(&.{name}).?.column_index;\n}\n```\n\nOutput:\n```\nTotal rides: 49416\nTotal fares: $898727.45\nTotal tips: $136046.83\nTotal passengers: 57441\nFirst fare: $5.80\n```\n\n### Column Access\n\n**Static typing** - specify the column type at compile time:\n```zig\nconst values = try rg.readColumn(i64, 0);\nconst nullable = try rg.readColumn(?i64, 1);\n```\n\n**Dynamic typing** - type determined at runtime:\n```zig\nconst dynamic = try rg.readColumnDynamic(0);\nswitch (dynamic) {\n    .int64 => |data| // ...\n    .double => |data| // ...\n    .byte_array => |data| // ...\n    // ...\n}\n```\n\n**Nested types** - lists and maps:\n```zig\nconst list = try rg.readListColumn(i32, 0);\nconst map = try rg.readMapColumn([]const u8, i64, 0, 1);\n```\n\n**Logical types** - choose how to interpret physical values:\n```zig\nconst logical = parzig.parquet.logical;\n\nconst dates = try rg.readColumn(logical.Date, 0);\nconst timestamps = try rg.readColumn(logical.TimestampMicros, 1);\nconst decimals = try rg.readColumn(logical.Decimal, 2);\nconst uuids = try rg.readColumn(logical.UUID, 3);\n```\n\nSupported logical types:\n- **Temporal**: `Date`, `TimeMillis`, `TimeMicros`, `TimeNanos`, `TimestampMillis`, `TimestampMicros`, `TimestampNanos`\n- **Numeric**: `Int8`, `UInt8`, `Int16`, `UInt16`, `UInt32`, `UInt64`, `Float16`, `Decimal`\n- **Other**: `UUID`, `String`, `Enum`, `Json`, `Bson`\n\n### Schema Inspection\n\nAfter reading a file, you can inspect its schema through `file.metadata.schema`, which is an array of `SchemaElement` entries. The first element is always the root; the rest describe individual fields.\n\n**Listing all fields and their types:**\n```zig\nfor (file.metadata.schema[1..]) |elem| {\n    std.debug.print(\"name={s} type={any} repetition={any} logical={any}\\n\", .{\n        elem.name,\n        elem.type,\n        elem.repetition_type,\n        elem.logicalType,\n    });\n}\n```\n\nEach `SchemaElement` exposes:\n- `name` — field name\n- `type` — physical type (`BOOLEAN`, `INT32`, `INT64`, `INT96`, `FLOAT`, `DOUBLE`, `BYTE_ARRAY`, `FIXED_LEN_BYTE_ARRAY`)\n- `repetition_type` — `REQUIRED`, `OPTIONAL`, or `REPEATED`\n- `logicalType` — logical type (`STRING`, `DATE`, `TIMESTAMP`, `DECIMAL`, `UUID`, `MAP`, `LIST`, etc.)\n- `converted_type` — legacy converted type\n- `num_children` — non-null for group (struct/nested) elements\n- `type_length` — byte width for `FIXED_LEN_BYTE_ARRAY`\n- `scale` / `precision` — for decimal types\n\n**Looking up a column by name:**\n```zig\nconst info = file.findSchemaElement(&.{\"fare_amount\"}).?;\n// info.column_index — index to pass to readColumn / readColumnDynamic\n// info.max_definition_level — for nullable columns\n// info.max_repetition_level — for repeated (list) columns\n// info.elem — the SchemaElement with full type info\n```\n\nFor nested schemas, pass the full path:\n```zig\nconst nested = file.findSchemaElement(&.{ \"address\", \"city\" }).?;\n```\n\n**File-level metadata** is also available:\n```zig\nstd.debug.print(\"version: {d}\\n\", .{file.metadata.version});\nstd.debug.print(\"num_rows: {d}\\n\", .{file.metadata.num_rows});\nstd.debug.print(\"row_groups: {d}\\n\", .{file.metadata.row_groups.len});\nif (file.metadata.created_by) |created_by| {\n    std.debug.print(\"created_by: {s}\\n\", .{created_by});\n}\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/16212576?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 67,
  "owner_following": 109,
  "owner_created_at": "2015-12-08T18:35:49Z",
  "category": "library"
}