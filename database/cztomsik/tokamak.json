{
  "name": "tokamak",
  "owner": "cztomsik",
  "repo": "tokamak",
  "description": "Web framework for Zig that leverages dependency injection for clean, modular application development.",
  "type": "package",
  "topics": [
    "express",
    "framework",
    "server",
    "spring",
    "zig-package",
    "api",
    "http",
    "rest",
    "dependency-injection"
  ],
  "stars": 538,
  "forks": 19,
  "watchers": 5,
  "updated_at": "2025-12-07T17:09:20Z",
  "dependencies": [
    {
      "name": "httpz",
      "url": "git+https://github.com/karlseguin/http.zig?ref=master#00014146eaf9e17750b752fa4905f7623fbe30f7",
      "hash": "httpz-0.0.0-PNVzrFndBgDr9zQx7Mj_MFiqYslgcRlx45FJ_gERmRTb"
    }
  ],
  "readme": "# Tokamak\n\nðŸ“š **[Documentation](https://tomsik.cz/tokamak)**\n\nTokamak is a server-side framework for Zig, built around\n[http.zig](https://github.com/karlseguin/http.zig) and a simple dependency\ninjection container.\n\n> **Note:** The main branch currently targets **Zig 0.15.2**.\n\nNote that it is **not designed to be used alone**, but with a reverse proxy in\nfront of it, like Nginx or Cloudfront, which will handle SSL, caching,\nsanitization, etc.\n\n> ### Recent changes\n> - renamed few `bundle.addXxx()` methods to `bundle.provide()`,\n>   `bundle.override()`, ...\n> - renamed `inj.call0(fun)` â†’ `inj.call(fun)`, `inj.call(fun, ...args)` â†’\n>   `inj.callArgs(fun, ...args)`\n> - opt dependencies were removed, ie. you can no longer inject `?Cfg` - it was\n>   undocumented, incomplete, subtly broken, and not worth the extra complexity\n> - multi-mod API has changed\n>   [considerably](https://github.com/cztomsik/tokamak/pull/25)\n> - there's a new [cli module](https://github.com/cztomsik/tokamak/tree/master/src/cli.zig)\n> - injecting `tk.Injector` is deprecated, use `*tk.Injector`\n> - multi-module support (cross-module initializers, providers, overrides)\n> - Switched to [http.zig](https://github.com/karlseguin/http.zig) for improved\n>   performance over `std.http`.\n> - Implemented hierarchical and introspectable routes.\n> - Added basic Swagger support.\n> - Added `tk.static.dir()` for serving entire directories.\n\n## Installation\n\n```bash\nzig fetch --save \"git+https://github.com/cztomsik/tokamak#main\"\n```\n\nThen in your `build.zig`:\n\n```zig\nconst tokamak = @import(\"tokamak\");\n\npub fn build(b: *std.Build) void {\n    ...\n    const exe = b.addExecutable(.{ ... });\n    ...\n\n    // Add tokamak\n    tokamak.setup(exe, .{});\n}\n```\n\n## Getting Started\n\nSimple things should be easy to do.\n\n```zig\nconst std = @import(\"std\");\nconst tk = @import(\"tokamak\");\n\nconst routes: []const tk.Route = &.{\n    .get(\"/\", hello),\n};\n\nfn hello() ![]const u8 {\n    return \"Hello\";\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    defer _ = gpa.deinit();\n    \n    var server = try tk.Server.init(allocator, routes, .{ .listen = .{ .port = 8080 } });\n    try server.start();\n}\n```\n\n## Dependency Injection\n\nThe framework is built around the concept of dependency injection.\nThis means that your handler function can take any number of parameters, and the\nframework will try to provide them for you.\n\nNotable types you can inject are:\n\n- `std.mem.Allocator` (request-scoped arena allocator)\n- `*tk.Request` (current request, including headers, body reader, etc.)\n- `*tk.Response` (current response, with methods to send data, set headers, etc.)\n- `*tk.Injector` (the injector itself, see below)\n- and everything you provide yourself\n\nFor example, you can easily write a handler function which will create a\nstring on the fly and return it to the client without any tight coupling to the\nserver or the request/response types.\n\n```zig\nfn hello(arena: std.mem.Allocator) ![]const u8 {\n    return std.fmt.allocPrint(arena, \"Hello {}\", .{std.time.timestamp()});\n}\n```\n\nIf you return any other type than `[]const u8`, the framework will try to\nserialize it to JSON.\n\n```zig\nfn hello() !HelloRes {\n    return .{ .message = \"Hello\" };\n}\n```\n\nIf you need a more fine-grained control over the response, you can inject a\n`*tk.Response` and use its methods directly.\n\n> But this will of course make your code tightly coupled to respective types\n> and it should be avoided if possible.\n\n```zig\nfn hello(res: *tk.Response) !void {\n    try res.json(.{ .message = \"Hello\" }, .{});\n}\n```\n\n## Custom Dependencies\n\nYou can also provide your own (global) dependencies by passing your own\n`*tk.Injector` to the server.\n\n```zig\npub fn main() !void {\n    var db = try sqlite.open(\"my.db\");\n    var inj = tk.Injector.init(&.{ .ref(&db) }, null)\n\n    var server = try tk.Server.init(allocator, routes, .{\n        .injector = &inj,\n        .port = 8080\n    });\n\n    try server.start();\n}\n```\n\n> For advanced dependency injection features like multi-module support,\n> intrusive interfaces, and lifecycle hooks, see the [Advanced Dependency\n> Injection](#advanced-dependency-injection) section below.\n\n## Middleware\n\nWhile Tokamak doesn't have Express-style middleware, it achieves the same\nfunctionality through nested routes. Since routes can be nested and the\n`prefix`, `path`, and `method` fields are optional, you can create powerful\nmiddleware patterns.\n\nHere's how to create a simple logging middleware:\n\n```zig\nfn logger(children: []const Route) tk.Route {\n    const H = struct {\n        fn handleLogger(ctx: *Context) anyerror!void {\n            log.debug(\"{s} {s}\", .{ @tagName(ctx.req.method), ctx.req.url });\n\n            return ctx.next();\n        }\n    };\n\n    return .{ .handler = &H.handleLogger, .children = children };\n}\n\nconst routes = []const tk.Route = &.{\n    logger(&.{\n        .get(\"/\", hello),\n    }),\n};\n```\n\nMiddleware handlers receive a `*Context` and return `anyerror!void`. They can\nperform pre-processing, logging, authentication, etc., and then call\n`ctx.next()` to continue to the next handler in the chain.\n\n\n## Request-Scoped Dependencies\n\nSince Zig doesn't have closures, you can't capture variables from the outer\nscope. Instead, Tokamak allows you to add request-scoped dependencies that will\nbe available to downstream handlers:\n\n```zig\nfn auth(ctx: *Context) anyerror!void {\n    const db = ctx.injector.get(*Db);\n    const token = try jwt.parse(ctx.req.getHeader(\"Authorization\"));\n    const user = db.find(User, token.id) catch null;\n\n    return ctx.nextScoped(&.{ user });\n}\n```\n\n> Note: Middleware handlers need to use `ctx.injector.get(T)` to access\n> dependencies manually, as they don't support the automatic dependency\n> injection syntax.\n\n## Routing\n\nTokamak includes an Express-inspired router that supports path parameters and\nwildcards. It can handle up to 16 path parameters and uses the `*` character for\nwildcards.\n\n```zig\nconst tk = @import(\"tokamak\");\n\nconst routes: []const tk.Route = &.{\n    .get(\"/\", hello),                        // fn(...deps)\n    .get(\"/hello/:name\", helloName),         // fn(...deps, name)\n    .get(\"/hello/:name/:age\", helloNameAge), // fn(...deps, name, age)\n    .get(\"/hello/*\", helloWildcard),         // fn(...deps)\n    .post(\"/hello\", helloPost),              // fn(...deps, body)\n    .post0(\"/hello\", helloPost0),            // fn(...deps)\n    ...\n};\n```\n\nFor more organized routing, use the `Route.router(T)` method with a DSL-like\nstruct:\n\n```zig\nconst routes: []const tk.Route = &.{\n    tk.logger(.{}),\n    .get(\"/\", tk.send(\"Hello\")),        // Classic Express-style routing\n    .group(\"/api\", &.{ .router(api) }), // Structured routing with a module\n    .send(error.NotFound),\n};\n\nconst api = struct {\n    pub fn @\"GET /\"() []const u8 {\n        return \"Hello\";\n    }\n\n    pub fn @\"GET /:name\"(arena: std.mem.Allocator, name: []const u8) ![]const u8 {\n        return std.fmt.allocPrint(arena, \"Hello {s}\", .{name});\n    }\n};\n```\n\n## Error Handling\n\nTokamak handles errors gracefully by automatically serializing them to JSON:\n\n```zig\nfn hello() !void {\n    // This will send a 500 response with {\"error\": \"TODO\"}\n    return error.TODO;\n}\n```\n\n## Static Files\n\nServe static files easily with built-in helpers:\n\n```zig\nconst routes: []const tk.Route = &.{\n    .get(\"/\", tk.static.file(\"public/index.html\")),\n};\n```\n\nServe entire directories:\n\n```zig\nconst routes: []const tk.Route = &.{\n    tk.static.dir(\"public\", .{}),\n};\n```\n\nUse with wildcard routes for more flexibility:\n\n```zig\nconst routes: []const tk.Route = &.{\n    tk.get(\"/assets/*\", tk.static.dir(\"assets\", .{ .index = null })),\n};\n```\n\nIf you want to embed some files into the binary, you can specify such paths to\nthe `tokamak.setup()` call in your `build.zig` file.\n\n```zig\nconst tokamak = @import(\"tokamak\");\n\n...\n\ntokamak.setup(exe, .{\n    .embed = &.{\n        \"public/index.html\",\n    },\n});\n```\n\nIn this case, only the files listed in the `embed` array will be embedded into\nthe binary and any other files will be served from the filesystem.\n\n## MIME types\n\nThe framework will try to guess the MIME type based on the file extension, but\nyou can also provide your own in the root module.\n\n```zig\npub const mime_types = tk.mime_types ++ .{\n    .{ \".foo\", \"text/foo\" },\n};\n```\n\n## Configuration\n\nFor a simple configuration, you can use the `tk.config.read(T, opts)` function,\nwhich will read the configuration from a JSON file. The `opts` parameter is\noptional and can be used to specify the path to the config file and parsing\noptions.\n\n```zig\nconst Cfg = struct {\n    foo: u32,\n    bar: []const u8,\n};\n\nconst cfg = try tk.config.read(Cfg, .{ .path = \"config.json\" });\n```\n\nThere's also experimental `tk.config.write(T, opts)` function, which will write\nthe configuration back to the file.\n\n## Process Monitoring\n\nThe `tk.monitor(procs)` function runs multiple processes in parallel and\nautomatically restarts them if they crash. This creates a self-healing\napplication that stays running even after unexpected failures.\n\n```zig\nmonitor(.{\n    .{ \"server\", &runServer, .{ 8080 } },\n    .{ \"worker\", &runWorker, .{} },\n    ...\n});\n```\n\nIt takes a tuple of `{ name, fn_ptr, args_tuple }` triples as input.\n\n> **Note:** This feature requires a system with `fork()` support. It takes over\n> the main thread and forks processes, which may lead to unexpected behavior if\n> used incorrectly. Use with caution.\n\n## Advanced Dependency Injection\n\n### Multi-Module System\n\nTokamak supports a powerful multi-module system where dependencies are\nautomatically resolved across module boundaries. Modules are Zig structs where\nfields become dependencies:\n\n```zig\nconst SharedModule = struct {\n    db_pool: DbPool,\n\n    pub fn configure(bundle: *tk.Bundle) void {\n        // Add more deps conditionally, override how they should be initialized, add hooks... (see below)\n    }\n};\n\nconst WebModule = struct {\n    server: tk.Server,\n    routes: []const tk.Route = &.{ ... },\n};\n\n// Register modules when creating a Container\npub fn main() !void {\n    try tk.app.run(Server.start, &.{\n        SharedModule,\n        WebModule,\n    });\n}\n```\n\nThe Bundle API provides compile-time dependency configuration:\n\n- `addModule(M)` - Add all fields of module M as dependencies\n- `provide(T, how)` - Provide a single dependency with initialization strategy\n- `override(T, how)` - Override dependency initialization (works across modules)\n- `mock(T, how)` - Test-only override for mocking\n- `expose(T, field)` - Expose a reference to a struct field as dependency\n- `addInitHook(fn)` - Add runtime initialization callback\n- `addDeinitHook(fn)` - Add runtime cleanup callback\n\nInitialization strategies:\n- `.auto` - Automatic initialization (uses `T.init()` if available, otherwise autowires struct fields)\n- `.init` - Explicitly use `T.init()` method\n- `.autowire` - Initialize struct by injecting all fields\n- `.factory(fn)` - Use custom factory function\n- `.initializer(fn)` - Use initializer function (receives pointer to initialize)\n- `.value(v)` - Use provided comptime value directly\n\n### Intrusive Interface Pattern\n\nTokamak supports an intrusive interface pattern for pluggable implementations.\nTypes with an `interface` field are automatically registered for dependency\ninjection, ie:\n\n```\nconst AppModule = struct {\n    http_client: StdClient,  // Define concrete implementation\n};\n\n// client will point to &StdClient.interface\nfn handler(client: *HttpClient) !void {\n    ...\n}\n```\n\n### Testing\n\nFor testing, you can override dependencies:\n\n```zig\nconst TestModule = struct {\n    pub fn configure(bundle: *Bundle) void {\n        bundle.mock(Database, .value(MockDatabase{}));\n        bundle.mock(EmailService, .factory(createMockEmailService));\n    }\n};\n\n// Run test with mocked dependencies\nconst ct = try Container.init(test_allocator, &.{AppModule, TestModule});\nct.injector.call(myTestFun)\n```\n\n## License\n\nMIT\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/3526922?u=c238259210ea197b3c06bc8f156246749db71d97&v=4",
  "releases": [],
  "owner_bio": "Working on a desktop app for chatting with LLMs (Ava PLS).",
  "owner_company": null,
  "owner_location": "Brno, Czech Republic",
  "owner_blog": "https://www.avapls.com",
  "owner_twitter_username": "cztomsik",
  "owner_followers": 195,
  "owner_following": 250,
  "owner_created_at": "2013-02-10T20:02:00Z",
  "license": "MIT",
  "category": "library"
}