{
  "name": "ziggurat",
  "owner": "martineausw",
  "repo": "ziggurat",
  "description": "Type assertion and constraints zig library.",
  "type": "package",
  "topics": [
    "assertions",
    "traits",
    "zig-package",
    "constraints",
    "type-checking"
  ],
  "stars": 3,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2026-02-15T23:11:30Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# ziggurat\n\n![zig 0.15.1](https://img.shields.io/badge/zig-0.15.1-brightgreen)\n\nLibrary for defining type constraints and assertions.\n\nInspired off of [this brainstorming thread](https://ziggit.dev/t/implementing-generic-concepts-on-function-declarations/1490).\n\n```zig\nconst any_data: ziggurat.Prototype = .any(&.{\n    .is_array(.{}),\n    .is_vector(.{}),\n    .is_pointer(.{ .size = .{ .slice = true } }),\n})\n\n\n\npub fn wrapIndex(\n    data: anytype,\n    index: i128,\n) ziggurat.sign(any_data)(@TypeOf(data))(usize) {\n    return if (index < 0)\n        getLen(data) - @as(usize, @intCast(@abs(index)))\n    else\n        @as(usize, @intCast(index));\n}\n\npub fn at(\n    data: anytype,\n    index: i128,\n) ziggurat.sign(any_data)(@TypeOf(data))(switch (@typeInfo(@TypeOf(data))) {\n    inline .array, .vector => |info| info.child,\n\n    .pointer => |info| switch (info.size) {\n        .slice => info.child,\n        else => unreachable,\n    },\n\n    else => unreachable,\n}) {\n    return switch (@typeInfo(@TypeOf(data))) {\n        .pointer => |info| switch (info.size) {\n            .slice => data[wrapIndex(data, index)],\n            else => unreachable,\n        },\n\n        .array, .vector => data[wrapIndex(data, index)],\n\n        else => unreachable,\n    };\n}\n```\n\n## About\n\nThe goal of ziggurat is to enable developers to comprehensibly define arbitrarily complex type constraints and assertions.\n\n## Installation\n\n### Remote\n\n```bash\nzig fetch --save git+https://github.com/martineausw/ziggurat.git#0.0.0\n```\n\n### Local\n\n```bash\ncd /path/to/clone/\n\ngit clone https://github.com/martineausw/ziggurat.git#0.0.0\n\ncd /path/to/zig/project\n\nzig fetch --save /path/to/clone/ziggurat/\n```\n\n## Usage\n\n### Closures\n\nziggurat makes generous use of closures. This is done by returning function pointers as a member access of struct definitions.\n\nI justify using closures as it lends itself to a declarative approach which appears more sensible than an imperative approach, in that it's easier to wrap (ha) my head around and favors type safety, also I appreciate the aesthetics.\n\n```zig\nfn foo() fn () void { // Returns signature of enclosed function\n    return struct {\n        fn bar() void {}\n    }.bar; // Accesses `bar` function pointer.\n}\n\nconst bar: *const fn () void = foo();\n\n// These are all equivalent: bar() == foo()() == void\n\ntest \"closure equality\" {\n    try std.testing.expectEqual(*const fn () void, @TypeOf(bar));\n    try std.testing.expectEqual(bar, foo());\n    try std.testing.expectEqual(void, @TypeOf(bar()));\n    try std.testing.expectEqual(bar(), foo()());\n}\n\n```\n\nThat out of the way, hopefully this isn't terribly intimidating:\n\n```zig\nfn foo(actual_value: anytype) sign(some_prototype)(actual_value)(void) { ... }\n```\n\n### Prototype\n\nPrototype requires an _eval_ function pointer.\n\n```zig\nconst Prototype = struct {\n    name: [:0]const u8,\n    eval: *const fn (actual: anytype) anyerror!bool,\n    onFail: ?*const fn (prototype: Prototype, actual: anytype) void = null,\n    onError: ?*const fn (err: anyerror, prototype: Prototype, actual: anytype) void = null,\n};\n```\n\n#### Implementing\n\nHere is an example implementation of a prototype.\n\n```zig\nconst int: Prototype = .{\n    .eval = struct {\n        fn eval(actual: anytype) !bool {\n            return switch (@typeInfo(@TypeOf(actual))) {\n                .int => true,\n                else => false,\n            };\n        }\n    }.eval,\n};\n```\n\nHere's an implementation that only accepts odd integer values:\n\n```zig\nconst odd_int: Prototype = .{\n    .eval = struct {\n        fn eval(actual: anytype) bool {\n            return switch (@typeInfo(@TypeOf(actual))) {\n                .comptime_int => @mod(actual, 2) == 1,\n                .int => actual % 2 == 1,\n                else => false,\n            };\n        }\n    }.eval,\n};\n```\n\n### Included\n\nIntended to be used in _comptime_:\n\n-   is_array - asserts an array type value with length interval, child type info, and sentinel existence assertions.\n-   is_bool - asserts a boolean type value.\n-   is_float - asserts a float type value with a bit interval assertion.\n-   is_int - asserts an integer type value with bit interval and signedness filter assertions.\n-   is_optional - asserts an optional type value with a child type info filter assertion.\n-   is_pointer - asserts a pointer type value with child type info filter, size filter, const qualifier presence, volatile qualifier presence, and sentinel existence assertions.\n-   is_struct - asserts a struct type value with layout filter, field set, declaration set, and tuple type assertions.\n-   is_type - asserts a type value.\n-   is_vector - asserts a vector type value with child type info filter and length interval assertions.\n\n#### Ancillary\n\n-   equals_bool\n-   has_decl(s)\n-   has_field(s)\n-   has_tag\n-   has_type_info\n-   has_value\n-   on_type\n-   within_interval\n\n#### Operator\n\nBoolean operations for prototype evaluation results\n\n-   all - asserts all prototypes evaluate to true.\n-   any - asserts at least one prototype evaluates to true.\n-   not - asserts a prototype evaluates to false without an error.\n-   seq - applies indexable prototypes to respective indices of provided argument.\n\n### Sign\n\n_sign_ calls _eval_ on a given prototype and will call _onError_ or _onFail_ for error or false return values, respectively. Complex prototypes are intended to be composed using operators and auxiliary prototypes.\n\n```zig\npub fn sign(prototype: Prototype) fn (actual: anytype) fn (comptime return_type: type) type {\n    return struct {\n        pub fn validate(actual: anytype) fn (comptime return_type: type) type {\n            if (comptime prototype.eval(actual)) |result| {\n                if (!result) if (prototype.onFail) |onFail|\n                    comptime onFail(prototype, actual);\n            } else |err| {\n                if (prototype.onError) |onError|\n                    comptime onError(err, prototype, actual);\n            }\n\n            return struct {\n                pub fn returns(comptime return_type: type) type {\n                    return return_type;\n                }\n            }.returns;\n        }\n    }.validate;\n};\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/86982237?u=5a14e79dd7814c12167a6052831ea97ed8ddbe92&v=4",
  "releases": [
    {
      "tag_name": "v0.0.0",
      "name": "initial version",
      "body": "**Full Changelog**: https://github.com/martineausw/ziggurat/commits/v0.0.0",
      "prerelease": false,
      "published_at": "2025-08-17T06:58:03Z",
      "html_url": "https://github.com/martineausw/ziggurat/releases/tag/v0.0.0",
      "assets": []
    }
  ],
  "owner_bio": "A hobbyist programmer of several years looking to go pro in back-end or game programming",
  "owner_company": null,
  "owner_location": "South Carolina, US",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 1,
  "owner_following": 0,
  "owner_created_at": "2021-07-05T18:52:12Z",
  "homepage": "https://martineausw.github.io/ziggurat/",
  "license": "MIT",
  "category": "library"
}