{
  "name": "zig-javascript-bridge",
  "owner": "scottredig",
  "repo": "zig-javascript-bridge",
  "description": "Easily call Javascript from Zig wasm",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 82,
  "forks": 6,
  "watchers": 3,
  "updated_at": "2026-02-02T02:14:04Z",
  "readme": "# zig-javascript-bridge\n\nThis library creates bindings for accessing Javascript from within a WASM runtime.  For example:\n\n```zig\nconst zjb = @import(\"zjb\");\n\nexport fn main() void {\n    zjb.global(\"console\").call(\"log\", .{zjb.constString(\"Hello from Zig\")}, void);\n}\n\n```\n\nIs equivalent to this Javascript:\n```javascript\nconsole.log(\"Hello from Zig\");\n```\n\n## Project Status\n\nZJB is fully functional and is ready to be used in other projects.  However 1.0 will not be tagged until Zig is 1.0, and there is significant enough usage that confidence in the API not needing further changes is high.\n\n## Why\n\nCalling Javascript functions from Zig is a pain.  WASM has restrictions on the function API surface, and how references to the runtime environment (Javascript) can be stored.  So to access Javascript functionality from Zig, you must create: a function in Zig which is friendly to call, a function export, and a function in Javascript which translates into the call you actually want.\n\nThis isn't too bad so far, but the Javascript API surface is large, has a lot of variadic functions, and accepts many types.  The result is that your programming loop of just wanting to write code slows down writing a large amount of ill fitting boilerplate whenever you must cross the Zig to Javascript boundary.\n\nThis package is clearly inspired by Go's solution to this problem: https://pkg.go.dev/syscall/js  However, there are a few significant deviations to note if you're familiar with that library:\n\n1. Every call from Go's package involves string decoding, garbage creation, and reflection calls.\n2. Go has a one size fits all Javascript file, while zjb uses a generator to produce Javascript for the calls you use.\n3. Go's garbage collection and finalizers allows for automatically cleaning up references from Go to Javascript, while zjb requires manual Handle releasing.\n4. Zig has no runtime, so there's none of Go's weirdness about blocking on the main thread.\n\n## Usage\n\nAs of March 2025, zjb is only known to work with Zig 0.14.0.\n\nThe simple folder provides a good template to start from.  You'll need to update to reference to zjb in `build.zig.zon`.  There's currently no release schedule for point releases, so you should use the latest available code.  Eg, copy the entire `simple` folder into your empty project, then run `zig fetch --save=zjb git+https://github.com/scottredig/zig-javascript-bridge`\n\nCall into Javascript using `zjb`, generate the Javascript side code, and then build an html page to combine them.\n\n### Example\n\nAn example which demonstrates usage of all of the components of `zjb` is in the example folder.  It includes:\n\n- `src/main.zig` has usage examples for the `zjb` Zig import.\n- `build.zig`'s example for how to set up your build file.\n- `static` includes HTML and Javascript files to run the example.\n\n`zig build` from inside the example folder builds the example to `zig-out`.  As a webserver is required to view the samples in action, you can instead use `zig build serve` to build and host the example locally.\n\n### Details\n\nZjb functions which return a value from Javascript require specifying which type is returned.  As arguments or return types to be passed into Javascript, zjb supports:\n\n- `i32`, `i64`, `f32`, `f64`.  These are the only numerical types that are supported by the WebAssembly JavaScript Interface, so you must cast to one of these before passing.\n- `comptime_int`, `comptime_float`.  These are valid as arguments, and are passed as f64 to Javascript, which is Javascript's main number type.\n- `zjb.Handle`.  The Zig side type for referring to Javascript values.  Most of the time this will be a Javascript object of some kind, but in some rare cases it might be something else, such as null, a Number, NaN, or undefined.  Used as an argument, it is automatically converted into the value that is held in zjb's Javascript `_handles` map.  When used as a return value, it is automatically added to zjb's Javascript `_handles` map.  It is the caller's responsibility to call `release` to remove it from the `_handles` map when you're done using it.\n- `zjb.ConstHandle` as arguments but not return types.  These values are returned by `zjb.constString`, `zjb.global`, and `zjb.fnHandle`.  `zjb.ConstHandle` works similarly to `zjb.Handle`, with a few notable exceptions: 1. Values are memoized upon first use on the Zig side, so they can be used any number of times without churning garbage.  2. There is no `release` function.  These values are intended to be around for the lifetime of your program, with reduced friction of using them.  As the functions which produce ConstHandle values all take only comptime arguments, these cannot balloon uncontrolably at runtime.  Some values are always defined as handles, `zjb.ConstHandle.null` is Javascript's `null`, `zjb.ConstHandle.global` is the global scope, and `zjb.ConstHandle.empty_string` is a Javascript empty string.\n- `void` is a valid type for method calls which have no return value.\n\nZjb supports multiple ways to expose Zig functions to Javascript:\n- `zjb.exportFn` exposes the function with the passed name to Javascript.  This supports `zjb.Handle`, so if you pass an object from a Javascript function, a handle will automatically be created and passed into Zig.  It is the responsibility of the Zig function being called to call `release` on any handles in its arguments at the appropriate time to avoid memory leaks.\n- `zjb.fnHandle` uses `zjb.exportFn` and additionally returns a `zjb.ConstHandle` to that function.  This can be used as a callback argument in Javascript functions.\n- Zig's `export` keyword on functions works as it always does in WASM, but doesn't support `zjb.Handle` correctly.\n\nSimple Zig global variables can also be exposed to Javascript:\n- `zjb.exportGlobal` exposes the variable with the passed address to Javascript. This supports `bool`, `i32`, `i64`, `u32`, `u64`, `f32`, and `f64`. Property descriptors will be created with get/set methods that provide access to the variable.\n\nA few extra notes:\n\n\n`zjb.string([]const u8)` decodes the slice of memory as a utf-8 string, returning a Handle.  The string will NOT update to reflect changes in the slice in Zig.\n\n`zjb.global` will be set to the value of that global variable the first time it is called.  As it is intended to be used for Javascript objects or classes defined in the global scope, that usage will be safe.  For example, `console`, `document` or `Map`.  If you use it to retrieve a value or object you've defined in Javascript, ensure it's defined before your program runs and doesn't change.\n\nThe \\_ArrayView functions (`i8ArrayView`, `u8ArrayView`, etc) create the respective JavaScript typed array backed by the same memory as the Zig WASM instance.\n\n`dataView` is similar in functionality to the ArrayView functions, but returns a DataView object.  Accepts any pointer or slice.\n\nThe generated Javascript also includes a shortcut function named `dataView` to get an up-to-date cached `DataView` of the entire WebAssembly `Memory`. \n\n> [!CAUTION]\n> There are three important notes about using the \\_ArrayView and dataView functions:\n>\n> The \\_ArrayView and dataView functions will accept const values.  If you pass one (such as []const u8), you are exposing Zig's memory to Javascript.  Changing the values from Javascript may lead to undefined behavior.  Zjb allows this as there are plenty of use cases which only read the data, and requiring non-const values throughout your program if they are eventually passed to Javascript isn't a desirable API.  It's up to you to be safe here.\n>\n> Changes to the values in either Zig or Javascript will be visible in the other.  HOWEVER, if the wasm memory grows for whatever reason (either through a direct @wasmMemoryGrow call or through allocators), all \\_ArrayViews and DataViews are invalided, and their length will be zero.  You have (roughly speaking) three choices to handle this:\n> 1. Always create just before using, and release immediately after use.\n> 1. Never allocate after using these functions.\n> 1. Check their length before any use, if it does not match the intended length, release and recreate the Handle.\n>\n> Javascripts's DataView allows pulling out arbitrary values from offsets.  This may be useful for working with Zig structs from Javascript, however remember that Zig may reorder the fields for structs.  Use `extern struct` to be safe here.\n\n## How\n\nTo solve the general problem of referencing Javascript objects from Zig, an object on the Javascript side with integer indices is used.  When passing to Javascript, the object is added to the map with a unique ID, and that ID is passed to Zig.  When calling from Zig, Javascript will translate the ID into the object stored on the map before calling the intended function.  To avoid building up garbage endlessly inside the object map, zjb code must call release to delete the reference from the map.\n\nzjb works with two steps:\n\n1. Your Zig code calls zjb functions.  Many functions use comptime to create export functions with specialized export signatures.  Only methods which are actually used are in the final WASM file.\n2. Run an extract methods program on the WASM file, producing a Javascript file to use along with your WASM file.  The example above produces this export, for example:\n\n```javascript\nconst Zjb = class {\n  new_handle(value) {\n    if (value === null) {\n      return 0;\n    }\n    const result = this._next_handle;\n    this._handles.set(result, value);\n    this._next_handle++;\n    return result;\n  }\n  dataView() {\n    if (this._cached_data_view.buffer.byteLength !== this.instance.exports.memory.buffer.byteLength) {\n      this._cached_data_view = new DataView(this.instance.exports.memory.buffer);\n    }\n    return this._cached_data_view;\n  }\n  constructor() {\n    this._decoder = new TextDecoder();\n    this.imports = {\n      \"call_o_v_log\": (arg0, id) => {\n        this._handles.get(id).log(this._handles.get(arg0));\n      },\n      \"get_o_console\": (id) => {\n        return this.new_handle(this._handles.get(id).console);\n      },\n      \"string\": (ptr, len) => {\n        return this.new_handle(this._decoder.decode(new Uint8Array(this.instance.exports.memory.buffer, ptr, len)));\n      },\n    };\n    this.exports = {\n    };\n    this.instance = null;\n    this._cached_data_view = null;\n    this._export_reverse_handles = {};\n    this._handles = new Map();\n    this._handles.set(0, null);\n    this._handles.set(1, window);\n    this._handles.set(2, \"\");\n    this._handles.set(3, this.exports);\n    this._next_handle = 4;\n  }\n  setInstance(instance) {\n    this.instance = instance;\n    const initialView = new DataView(instance.exports.memory.buffer);\n    this._cached_data_view = initialView;\n  }\n};\n\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/164466470?u=6651fa3069f93b04ebf21a3179ff41e1217d7ec8&v=4",
  "releases": [
    {
      "tag_name": "0.1.0",
      "name": "0.1.0",
      "body": "The first proper release of Zig Javascript Bridge.  There's not really a reason I haven't done a release before.  However recent changes added `zjb.ConstHandle` and exporting functions with `zjb.Handle` arguments.  See the updated readme for usage.\r\n\r\nThis is considered 0.1.0 and not a 1.0.0 release only because there has yet to be high usage, so confidence that no major API changes will need to be made is low.",
      "prerelease": true,
      "published_at": "2024-05-23T23:12:20Z",
      "html_url": "https://github.com/scottredig/zig-javascript-bridge/releases/tag/0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 7,
  "owner_following": 0,
  "owner_created_at": "2024-03-22T05:58:43Z",
  "license": "MIT",
  "category": "library"
}