{
  "name": "jetkv",
  "owner": "jetzig-framework",
  "repo": "jetkv",
  "description": "Key-value store designed for local development",
  "type": "project",
  "topics": [
    "zig-package"
  ],
  "stars": 20,
  "forks": 3,
  "watchers": 1,
  "updated_at": "2025-12-05T03:51:55Z",
  "readme": "# JetKV\n\n_JetKV_ is a key-value store written in _Zig_ intended for use in development and production web servers. Basic in-memory and on-disk backends are provided for local development and a [Valkey](https://valkey.io/) backend is provided for production. All backends are exposed by a unified interface.\n\n_JetKV_ can be used for:\n\n* Background job queuing\n* Persistent data storage\n* Cache\n\n_JetKV_ is used by the [Jetzig Web Framework](https://jetzig.dev/) to provide a zero-setup, in-process key-value store for all of the above.\n\n## Checklist\n\n* :white_check_mark: In-memory storage.\n* :white_check_mark: String value storage.\n* :white_check_mark: Array value storage.\n* :white_check_mark: Array pop/queue implementation.\n* :white_check_mark: On-disk storage.\n* :white_check_mark: Valkey backend.\n* :white_check_mark: Key expiry (Valkey only at the moment).\n* :x: Shared memory.\n\n## Usage\n\n### Valkey Backend\n\nRecommended for production.\n\n```zig\nvar kv = try JetKV(.{\n    .backend = .valkey,\n    .valkey_backend_options = .{\n        .pool_size = 8,\n        .buffer_size = 8192,\n    },\n}).init(allocator);\n```\n\n### Memory Backend\n\nRecommended for local development.\n\n```zig\nvar kv = try JetKV(.{ .backend = .memory }).init(allocator);\n```\n\n### File Backend\n\nRecommended for local development where persistent storage is required.\n\nWhen using the file allocator, `JetKV.init` receives an allocator in order to provide a consistent API but does not perform any allocations. It is therefore possible to pass `undefined` instead of an allocator when using the file allocator.\n\nThe file passed as the `path` field is locked on startup.\n\n```zig\nvar kv = try JetKV(.{\n    .backend = .file,\n    .file_backend_options = .{\n        // Path to storage file (JetKV stores all data in a single, platform-agnostic file)\n        .path = \"/path/to/jetkv.db\",\n        // Set to `true` to clear the store on each launch.\n        .truncate = false,\n        // Set the size of the on-disk hash table (each address is currently 4 bytes)\n        // Use `jetkv.addressSpaceSize` to guarantee a valid size if address size changes in future\n        .address_space_size = jetkv.addressSpaceSize(4096),\n    },\n}).init(allocator);\n```\n\n### Key-Value Operations\n\nAll operations are identical for `.file`, `.memory`, and `.valkey` backends with the exception of `putExpire` which is not supported by the `.file` backend.\n\nOperations are _O(1)_ complexity for `.memory` and `.file` backends. See [Valkey Commands Reference](https://valkey.io/commands/) for _Valkey_ operation complexity.\n\nRead operations receive an allocator to allow separation of internal allocation and value reads. e.g. you may want to use one allocator for the KV store's internal storage and a stack fallback/arena allocator for reading values.\n\n```zig\n// Put some strings into the KV store\ntry kv.put(\"foo\", \"baz\");\ntry kv.put(\"bar\", \"qux\");\n\n// `append` and `prepend` create a new array if one does not already exist\ntry kv.append(\"example_array\", \"quux\");\ntry kv.prepend(\"example_array\", \"corge\");\n\nif (try kv.get(allocator, \"foo\")) |value| {\n    // \"baz\"\n    allocator.free(value);\n}\n\nif (try kv.fetchRemove(allocator, \"bar\")) |value| {\n    // \"qux\"\n    allocator.free(value);\n}\n\n// Remove a string from the KV store. Does not remove arrays.\ntry kv.remove(\"foo\");\n\nif (kv.pop(allocator, \"example_array\")) |value| {\n    // \"quux\"\n    allocator.free(value);\n}\n\nif (kv.popFirst(allocator, \"example_array\")) |value| {\n    // \"corge\"\n    allocator.free(value);\n}\n```\n\n## Testing\n\nLaunch _Valkey_:\n\n```console\ndocker compose up\n```\n\nRun tests:\n\n```console\nzig build test\n```\n\n## Implementation\n\n### Valkey\n\nNative _Zig_ adapter for [Valkey](https://valkey.io/) implementing [RESP 3](https://www.mankier.com/7/valkey-protocol).\n\nBenchmark:\n\n```console\nzig build -Doptimize=ReleaseFast run\n```\n\n### Memory\n\nThe memory backend uses a _Zig_ `std.StringHashMap` of `[]const u8` for string storage and `std.DoublyLinkedList([]const u8)` for array storage.\n\n### File\n\nThe file backend implements a fixed-sized hash table at the beginning of the file.\n\nHash collisions are resolved as singly-linked lists. Arrays are implemented as doubly-linked lists.\n\nEach index in the hash table references a location in the file which provides address information:\n\n* Value type\n* Next linked item (for collision resolution)\n* Next array item\n* Previous array item\n* End array item\n* Key length\n* Initial key length\n* Value length\n* Initial value length\n* Key\n* Value\n\nValues are inserted with a relative amount of over-allocation to allow re-use of space when replacing values.\n\nKeys have a maximum length of `1024` bytes in order to allow key comparison to operate exclusively on the stack.\n\nReference counting is used to allow truncating the file when the store becomes empty.\n\n## License\n\n[MIT](LICENSE)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/157241284?v=4",
  "releases": [],
  "owner_bio": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_created_at": "2024-01-20T18:49:18Z",
  "license": "MIT",
  "category": "library"
}