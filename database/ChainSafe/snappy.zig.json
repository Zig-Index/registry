{
  "name": "snappy.zig",
  "owner": "ChainSafe",
  "repo": "snappy.zig",
  "description": "Zig bindings for the Google Snappy compression library",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 3,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-01-06T16:10:45Z",
  "dependencies": [
    {
      "name": "snappy",
      "url": "git+https://github.com/google/snappy#6f99459b5b837fa18abb1be317d3ac868530f384",
      "hash": "N-V-__8AAGQlMwAN9FGuTgQ6eeGHXgLOoQUSPaBmljRIqfzy"
    }
  ],
  "minimum_zig_version": "0.14.1",
  "readme": "# snappy.zig\n\nA Zig library providing bindings to the [Google Snappy compression library](https://github.com/google/snappy), a fast compression/decompression library that aims for high speeds and reasonable compression ratios.\n\nThe [Snappy framing format](https://github.com/google/snappy/blob/main/framing_format.txt) is supported in this library.\n\n\nRequires `0.14.0` or later.\n\n## Usage\n\nAdd the dependency to your project:\n\n```sh\nzig fetch --save=snappy git+https://github.com/chainsafe/snappy.zig\n```\n\nThis dependency includes:\n\n- the `\"snappy\"` module - a zig module providing idiomatic zig bindings to the original snappy (`raw.zig`) and optional snappy frames support (`frame.zig`)\n- the `\"snappy\"` artifact - the upstream snappy static library and headers\n\nIn your `build.zig`, add the module:\n\n```zig\nconst snappy_dep = b.dependency(\"snappy\", .{});\n\nconst snappy_mod = snappy_dep.module(\"snappy\");\n\nconst snappy_lib = snappy_dep.artifact(\"snappy\");\n```\n\nImport `snappy` and use the functions. You can choose between using `raw` or `frame` compression/decompression:\n\n```zig\nconst snappy = @import(\"snappy\").raw;\n// or const snappy = @import(\"snappy\").frame;\n```\n\nAn example using the `raw` library:\n\n```zig\nconst snappy = @import(\"snappy\");\n\nconst input = \"Hello, world!\";\nconst compressed = try allocator.alloc(u8, snappy.maxCompressedLength(input.len));\ndefer allocator.free(compressed);\n\nconst compressed_len = try snappy.raw.compress(input, compressed);\nconst uncompressed = try allocator.alloc(u8, try snappy.uncompressedLength(compressed[0..compressed_len]));\ndefer allocator.free(uncompressed);\n\nconst uncompressed_len = try snappy.raw.uncompress(compressed[0..compressed_len], uncompressed);\n```\n\nAn example using the `frame` library:\n\n```zig\nconst snappy = @import(\"snappy\");\n\nconst input = \"Hello, world!\";\nconst compressed = try snappy.frame.compress(allocator, input);\ndefer allocator.free(compressed);\n\nvar buf = std.ArrayList(u8).init(allocator);\ndefer buf.deinit();\nconst slice = (try snappy.frame.uncompress(compressed, &buf)).?;\ndefer allocator.free(slice);\n```\n\n## API\n\n### `raw`\n\nSupports raw snappy compression and decompression.\n\n- `compress(input: []const u8, compressed: []u8) Error!usize`: Compresses input data into compressed buffer. Returns compressed length.\n- `uncompress(compressed: []const u8, uncompressed: []u8) Error!usize`: Decompresses compressed data into uncompressed buffer. Returns uncompressed length.\n- `maxCompressedLength(source_length: usize) usize`: Returns the maximum possible compressed size for given input length.\n- `uncompressedLength(compressed: []const u8) Error!usize`: Returns the uncompressed length of compressed data.\n- `validateCompressedBuffer(compressed: []const u8) Error!void`: Validates if compressed data is valid.\n\n### `frame`\n\nSupports snappy frames compression and decompression.\n\n- `compress(allocator: std.mem.Allocator, bytes: []const u8) CompressError![]u8`: Frame `bytes` into Snappy chunks, choosing compressed payloads only\nwhen they are smaller than their uncompressed counterparts.\n\n- `uncompress(allocator: std.mem.Allocator, bytes: []const u8) UncompressError!?[]const u8`: Parse framed Snappy data and return the uncompressed payload,\nor `null` if the frame explicitly signalled an empty buffer.\n\n## License\n\nMIT\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/27474093?v=4",
  "releases": [],
  "owner_bio": "Building the infrastructure for web3.",
  "owner_location": "Toronto, Canada",
  "owner_blog": "chainsafe.io",
  "owner_twitter_username": "chainsafeth",
  "owner_created_at": "2017-04-14T04:59:30Z",
  "license": "MIT",
  "category": "library"
}