{
  "name": "testz",
  "owner": "srjilarious",
  "repo": "testz",
  "description": "A testing library for zig",
  "type": "package",
  "topics": [
    "zig-package",
    "zig"
  ],
  "stars": 3,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-26T13:57:03Z",
  "minimum_zig_version": "0.15.1",
  "readme": "\n![Testz Logo](images/testz.png)\n\n\n![Version Badge](https://img.shields.io/badge/Version-1.0.0-brightgreen)\n![Zig Version Badge](https://img.shields.io/badge/Zig%20Version-0.15.1-%23f7a41d?logo=zig)\n![License Badge](https://img.shields.io/badge/License-MIT-blue)\n\n# Overview\n\nTestz is a testing library for zig that provides some extra features compared to the built in unit testing.\n\n- Color output with both a verbose mode and non-verbose mode\n  - A non-verbose mode, where each test shows as a symbol for passed, skipped, or failed:\n\n    ![non-verbose output](images/non_verbose_output.png)\n\n  - In verbose mode, you can see the name of each test run and how long it took to run.\n\n    ![Failing test example, verbose output](images/verbose_output.png)\n\n  - In both cases a test run summary lets you know how many tests ran and the overall time.\n\n- Easy filtering by group tag or test name itself\n  - Making it easier to set a breakpoint and debug a single test.\n\n- Provides a test runner utility function with argument parsing for a default use case.\n\n- Has a test discovery helper that searches for tests by finding public functions in a passed in module, allowing tests to be skipped by prepending `skip_` to the start of the function name.\n\n- Stack traces of relevant code only\n  - Skips stack frames from `testz` itself as well as `main` where the test runner is called.\n  - Stack traces provide context lines around the stack frame.\n\n- Per-test stdout/stderr capture, shown alongside failure output so diagnostic prints don't get lost in the overall run.\n\nTestz runners are just another executable you setup in your `build.zig`, with the library providing a number of helpers to make it as easy as possible to create tests.  Debugging is simple since you can run your debugger just like with any normal flat executable and use the built in filtering to narrow down what test or set of tests gets run.\n\n# Example\n\nCheck the example program under `example/` with a main program and a separate test program.\n\n## Test module\n\nA module of tests looks like:\n\n```zig\nconst std = @import(\"std\");\nconst testz = @import(\"testz\");\n\npub fn allowNonTestzErrors() !void {\n    const mem = try std.heap.page_allocator.alloc(u8, 10);\n    defer std.heap.page_allocator.free(mem);\n    try testz.expectEqual(true, true);\n}\n\npub fn alwaysFail() !void {\n    try testz.fail();\n}\n\npub fn successTest() !void {\n    try testz.expectEqual(12, 12);\n    try testz.expectEqualStr(\"hello\", \"hello\");\n    try testz.expectNotEqual(10, 20);\n    try testz.expectNotEqualStr(\"hello\", \"world\");\n    try testz.expectTrue(true);\n    try testz.expectFalse(false);\n}\n\npub fn skip_notReadyYet() !void {\n    // prepend skip_ to any function name to have it skipped at runtime\n}\n```\n\nThe test functions are simply any public function in a module you pass into `discoverTests`.  The `testz` library has a number of `expectXYZ` functions you can use to make assertions in your code.  If one fails, `testz` will capture the name of the failed test, error message, and stack trace (with contextual lines).\n\n## Expect / assertion functions\n\n| Function | Description |\n|---|---|\n| `expectEqual(actual, expected)` | Passes if `actual == expected`. Works with optionals. |\n| `expectEqualT(T, actual, expected)` | Typed variant of `expectEqual` — both args coerced to `T`. |\n| `expectEqualStr(actual, expected)` | Passes if the two strings are equal; reports first differing index and lengths on failure. |\n| `expectNotEqual(actual, expected)` | Passes if `actual != expected`. |\n| `expectNotEqualStr(actual, expected)` | Passes if the two strings differ. |\n| `expectTrue(actual)` | Passes if `actual == true`. |\n| `expectFalse(actual)` | Passes if `actual == false`. |\n| `expectError(actual, expected)` | Passes if the error union `actual` holds the error `expected`. |\n| `fail()` | Unconditionally fails the test. |\n| `failWith(err)` | Fails the test and includes `err` in the failure message — useful for custom enum values or runtime context. |\n\n### Test Runner\n\nHere is an example test runner program using the built-in `testzRunner` method, as you could use in your project, which handles standard argument parsing.  It also shows test discovery by passing in modules as groups to the `discoverTests` method.\n\n```zig\nconst std = @import(\"std\");\nconst testz = @import(\"testz\");\n\nconst DiscoveredTests = testz.discoverTests(.{\n    testz.Group{ .name = \"Expect Tests\", .tag = \"expect\", .mod = @import(\"./expect_tests.zig\") },\n    testz.Group{ .name = \"Misc Tests\",   .tag = \"misc\",   .mod = @import(\"./misc_tests.zig\") },\n}, .{});\n\npub fn main() !void {\n    try testz.testzRunner(DiscoveredTests);\n}\n```\n\nThe function `testz.discoverTests` takes a tuple of modules (or `Group`/`GroupList` structs) and a `DiscoverOpts` struct, and returns a comptime slice of `TestFuncInfo`.\n\n## Test discovery in depth\n\n### Plain modules\n\nThe simplest usage is to pass a bare `@import` directly.  Tests land in a group called `\"default\"`:\n\n```zig\nconst Tests = testz.discoverTests(.{\n    @import(\"my_tests.zig\"),\n}, .{});\n```\n\n### `Group` — one module, one tag\n\nWraps a single module with a display name and filter tag:\n\n```zig\ntestz.Group{ .name = \"Auth Tests\", .tag = \"auth\", .mod = @import(\"auth_tests.zig\") }\n```\n\n### `GroupList` — multiple modules under one tag\n\nCollects several modules under a single group name and tag, handy when you split a large test suite across files:\n\n```zig\ntestz.GroupList{\n    .name = \"Auth Tests\",\n    .tag  = \"auth\",\n    .mods = &.{\n        @import(\"login_tests.zig\"),\n        @import(\"token_tests.zig\"),\n        @import(\"session_tests.zig\"),\n    },\n}\n```\n\n### `DiscoverOpts`\n\nThe second argument to `discoverTests` is a `DiscoverOpts` struct with these fields:\n\n| Field | Default | Description |\n|---|---|---|\n| `testsEndWithTest` | `false` | When `true`, only functions whose names end with `\"Test\"` are collected. Useful when test files also contain helper functions you don't want auto-discovered. |\n| `debugDiscovery` | `false` | Emits `@compileLog` lines for every function examined during discovery, so you can see exactly why a function was or wasn't picked up. |\n\n## CLI flags\n\nWhen you use `testzRunner`, your test binary accepts the following flags:\n\n| Flag | Short | Default | Description |\n|---|---|---|---|\n| `--verbose` | `-v` | off | Show each test name, pass/fail symbol, and elapsed time. |\n| `--stack_trace` | `-s` | **on** | Print stack traces with context lines on failure. Pass `--no-stack_trace` to disable. |\n| `--groups` | `-g` | — | List all available group names and their filter tags, then exit. Use this to discover what tags you can filter on. |\n| `--capture` | `-c` | off | Capture stdout and stderr written during each test at the OS level. Captured output from failing tests is shown in the failure section; captured output from passing tests is shown inline in verbose mode. |\n| `--color` | — | **on** | Force ANSI color output even when not writing to a TTY. |\n| `--help` | `-h` | — | Print usage text and exit. |\n\nPositional arguments are treated as filters.  Pass one or more group tags or exact test function names to run only the matching tests:\n\n```sh\n# run only the \"auth\" group\n./tests auth\n\n# run only a specific test by name\n./tests test_login_with_bad_password\n\n# combine multiple filters\n./tests auth billing\n```\n\nThis makes it easy to set a breakpoint in your debugger and re-run a single test without recompiling.\n\n## Advanced: using `runTests` directly\n\n`testzRunner` is a convenience wrapper that parses `argv` for you.  For more control — custom argument handling, embedding testz in a larger harness, or programmatic test selection — call `runTests` directly:\n\n```zig\nconst passed = try testz.runTests(myTests, .{\n    .verbose              = true,\n    .captureOutput        = true,\n    .printStackTraceOnFail = false,\n    .allowFilters         = &.{ \"auth\", \"billing\" },\n    .alloc                = my_allocator,\n});\n```\n\n`RunTestOpts` fields:\n\n| Field | Default | Description |\n|---|---|---|\n| `verbose` | `false` | Verbose per-test output. |\n| `captureOutput` | `false` | Capture stdout/stderr per test. |\n| `printStackTraceOnFail` | `true` | Include stack trace in failure output. |\n| `allowFilters` | `null` | Slice of group tags or test names to run; `null` means run all. |\n| `printColor` | `null` | `null` = auto-detect TTY, `true`/`false` = force on/off. |\n| `alloc` | `page_allocator` | Allocator used for test bookkeeping. |\n| `writer` | stdout | A `Printer` to direct output to (e.g. an in-memory buffer for testing `testz` itself). |\n| `testContext` | `null` | A pre-existing `TestContext` to push onto the context stack. |\n\n### A `build.zig` Setup\n\nRun `zig fetch --save https://github.com/srjilarious/testz` to add `testz` as a dependency in your `build.zig.zon` file.\n\nNext, in your `build.zig`, you would create a new exe for your tests and add:\n\n```zig\n    const testzMod = b.dependency(\"testz\", .{});\n    [...]\n    testsExe.root_module.addImport(\"testz\", testzMod.module(\"testz\"));\n```\nSee the project under `example/` for how this looks in a simple dummy project.\n\n# Contributing\n\nFeel free to open an issue or open a PR if there is a feature you'd like to see!\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/1356248?u=b4e78dd97be59fc9c316238e479cd50e50a2cb9c&v=4",
  "releases": [
    {
      "tag_name": "v1.0.0",
      "name": "v1.0.0",
      "body": "![Zig Version Badge](https://img.shields.io/badge/Zig%20Version-0.15.1-%23f7a41d?logo=zig)\r\n\r\nWith all of the main features of library being implemented, marking this as version 1.0.0.\r\n\r\n## Main changes\r\n- Upgraded to work with zig 0.15.1\r\n- Fixed Windows unicode output.\r\n- Test skip detection now happens at runtime instead of compile-time\r\n    - Fixes compilation issues when running projects with large test suites (~190+ tests)\r\n\r\n**Full Changelog**: https://github.com/srjilarious/testz/compare/v0.6.1...v1.0.0",
      "prerelease": false,
      "published_at": "2025-09-07T16:56:25Z",
      "html_url": "https://github.com/srjilarious/testz/releases/tag/v1.0.0",
      "assets": []
    },
    {
      "tag_name": "v0.6.0",
      "name": "v0.6.0",
      "body": "![Zig Version Badge](https://img.shields.io/badge/Zig%20Version-0.13.0-%23f7a41d?logo=zig)\r\n\r\nFirst release of testz library with all major features implemented.  Built for Zig v0.13.0",
      "prerelease": false,
      "published_at": "2025-01-11T16:53:33Z",
      "html_url": "https://github.com/srjilarious/testz/releases/tag/v0.6.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "Boulder, Colorado",
  "owner_blog": "https://www.walknsqualk.com/",
  "owner_twitter_username": null,
  "owner_followers": 2,
  "owner_following": 1,
  "owner_created_at": "2012-01-20T01:02:55Z",
  "license": "MIT",
  "category": "library"
}