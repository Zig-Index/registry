{
  "name": "zig-nanoid",
  "owner": "SasLuca",
  "repo": "zig-nanoid",
  "description": "A tiny, secure, URL-friendly, unique string ID generator. Now available in pure Zig.",
  "type": "package",
  "topics": [
    "nanoid",
    "zig",
    "zig-package",
    "ziglang",
    "unique-id",
    "unique-identifier",
    "uniqueid",
    "uuid",
    "uuid-generator",
    "id"
  ],
  "stars": 34,
  "forks": 3,
  "watchers": 1,
  "updated_at": "2026-02-09T17:56:13Z",
  "readme": "# Nano ID in Zig\n\n[![License](https://img.shields.io/badge/license-MIT%20License-blue.svg)](https://github.com/SasLuca/nanoid-zig/master/LICENSE)\n[![cross build tests](https://github.com/SasLuca/zig-nanoid/actions/workflows/cross-build.yml/badge.svg)](https://github.com/SasLuca/zig-nanoid/actions/workflows/cross-build.yml)\n![Maintenance intention for this crate](https://img.shields.io/badge/maintenance-actively--developed-brightgreen.svg)\n\n<img src=\"https://raw.githubusercontent.com/SasLuca/zig-nanoid/main/logo.svg\" align=\"right\" alt=\"Nano ID x Zig logo by Anton Lovchikov, adapted by Luca Sas\" width=\"180\" height=\"94\">\n\nA battle-tested, tiny, secure, URL-friendly, unique string ID generator. Now available in pure Zig.\n\n* **Freestanding.** zig-nanoid is entirely freestanding.\n* **Fast.** The algorithm is very fast and relies just on basic math, speed will mostly depend on your choice of RNG.\n* **Safe.** It can use any random generator you want and the library has no errors to handle.\n* **Short IDs.** It uses a larger alphabet than UUID (`A-Za-z0-9_-`). So ID length was reduced from 36 to 21 symbols and it is URL friendly.\n* **Battle Tested.** Original implementation has over 18 million weekly downloads on [npm](https://www.npmjs.com/package/nanoid).\n* **Portable.** Nano ID was ported to [20+ programming languages](https://github.com/ai/nanoid#other-programming-languages).\n\n## Example\n\nBasic usage with `std.crypto.random`:\n```zig\nconst std = @import(\"std\");\nconst nanoid = @import(\"nanoid\");\n\npub fn main() !void\n{   \n    const result = nanoid.generate(std.crypto.random);\n\n    std.log.info(\"Nanoid: {s}\", .{result});\n}\n```\n\n## Comparison to UUID\n\nNano ID is quite comparable to UUID v4 (random-based).\n\nIt has a similar number of random bits in the ID (126 in Nano ID and 122 in UUID), so it has a similar collision probability.\n\nIt also uses a bigger alphabet, so a similar number of random bits are packed in just 21 symbols instead of 36.\n\nFor there to be a one in a billion chance of duplication, 103 trillion version 4 IDs must be generated.\n\n## How to use\n\n### Generating an id with the default size\n\nThe simplest way to generate an id with the default alphabet and length is by using the function `generate` like so:\n\n```zig\nconst result = nanoid.generate(std.crypto.random);\n```\n\nIf you want a custom alphabet you can use `generateWithAlphabet` and pass either a custom alphabet or one from `nanoid.alphabets`:\n```zig\nconst result = nanoid.generateWithAlphabet(std.crypto.random, nanoid.alphabets.numbers); // This id will only contain numbers\n```\n\nYou can find a variety of other useful alphabets inside of `nanoid.alphabets`.\n\nThe result is an array of size `default_id_len` which happens to be 21 which is returned by value.\n\nThere are no errors to handle, assuming your rng object is valid everything will work.\nThe default alphabet includes the symbols \"-_\", numbers and English lowercase and uppercase letters.\n\n### Generating an id with a custom size\n\nIf you want a custom alphabet and length use `generateEx` or `generateExWithIterativeRng`.\n\nThe function `generateEx` takes an rng, an `alphabet`, a `result_buffer` that it will write the id to, and a `step_buffer`.\nThe `step_buffer` is used by the algorithm to store a random bytes so it has to do less calls to the rng and `step_buffer.len` must be at \nleast `computeRngStepBufferLength(computeMask(@truncate(u8, alphabet.len)), result_buffer.len, alphabet.len)`.\n\nThe function `generateExWithIterativeRng` is the same as `generateEx` except it doesn't need a `step_buffer`. It will use `Random.int(u8)` \ninstead of `Random.bytes()` to get a random byte at a time thus avoiding the need for a rng step buffer. Normally this will be slower but \ndepending on your rng algorithm or other requirements it might not be, so the option is there in case you need but normally it is \nrecommended you use `generateEx` which requires a temporary buffer that will be filled using `Random.bytes()` in order to get the best\nperformance.\n\nAdditionally you can precompute a sufficient length for the `step_buffer` and pre-allocate it as an optimization using \n`computeSufficientRngStepBufferLengthFor` which simply asks for the largest possible id length you want to generate.\n\nIf you intend to use the `default_id_len`, you can use the constant `nanoid.rng_step_buffer_len_sufficient_for_default_length_ids`.\n\n### Regarding RNGs\n\nYou will need to provide an random number generator (rng) yourself. You can use the zig standard library ones, either `std.rand.DefaultPrng`\nor if you have stricter security requirements use `std.rand.DefaultCsprng` or `std.crypto.random`.\n\nWhen you initialize them you need to provide a seed, providing the same one every time will result in the same ids being generated every \ntime you run the program, except for `std.crypto.random`.\n\nIf you want a good secure seed you can generate one using `std.crypto.random.bytes`. \n\nHere is an example of how you would initialize and seed `std.rand.DefaultCsprng` and use it:\n\n```zig\n// Generate seed\nvar seed: [std.rand.DefaultCsprng.secret_seed_length]u8 = undefined;\nstd.crypto.random.bytes(&seed);\n\n// Initialize the rng and allocator\nvar rng = std.rand.DefaultCsprng.init(seed);\n\n// Generate id\nvar id = nanoid.generate(rng.random());\n```\n\n## Add zig-nanoid to your project\n\n### Manually\n\nTo add the library as a package to your zig project:\n1. Download the repo and put it in a folder (eg: `thirdparty`) in your project.\n2. Import the library's `build.zig` in your build script (eg: `const nanoid = @import(\"thirdparty/nanoid-zig/build.zig\");`)\n3. Add the library as a package to your steps (eg: `exe.addPackage(nanoid.getPackage(\"nanoid\"));`)\n\nFull example:\n```zig\n// build.zig\nconst std = @import(\"std\");\nconst nanoid = @import(\"thirdparty/zig-nanoid/build.zig\");\n\npub fn build(b: *std.build.Builder) void \n{\n    const target = b.standardTargetOptions(.{});\n    const mode = b.standardReleaseOptions();\n\n    const exe = b.addExecutable(\"zig-nanoid-test\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    exe.addPackage(nanoid.getPackage(\"nanoid\"));\n    exe.install();\n}\n```\n\n### Using the gyro package manager\n\nWe support the zig [gyro package manager](https://github.com/mattnite/gyro).\nHere is how to use it:\n\n1. From your terminal initialize a gyro project and add the package `SasLuca/nanoid`.\n    ```\n    gyro init\n    gyro add SasLuca/nanoid\n    ```\n\n2. In your `build.zig` do an import like so `const pkgs = @import(\"deps.zig\").pkgs;` and call `pkgs.addAllTo(exe);` to add all libraries to your executable (or some other target).\n\n3. Import `const nanoid = @import(\"nanoid\");` in your `main.zig` and use it.\n\n4. Invoke `gyro build run` which will generate `deps.zig` and other files as well as building and running your project.\n\n## Useful links\n\n- Original implementation: https://github.com/ai/nanoid\n\n- Online Tool: https://zelark.github.io/nano-id-cc/\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/15983269?u=a9324011fcd1141464f41474cd24de17b02ca58e&v=4",
  "releases": [
    {
      "tag_name": "v1.0.4",
      "name": "Version 1.0.4",
      "body": "- Updated to work with the latest zig master version.",
      "prerelease": false,
      "published_at": "2022-09-06T13:17:24Z",
      "html_url": "https://github.com/SasLuca/zig-nanoid/releases/tag/v1.0.4",
      "assets": []
    },
    {
      "tag_name": "v1.0.3",
      "name": "Version 1.0.3",
      "body": "- Updated build script to work with latest zig master version.",
      "prerelease": false,
      "published_at": "2022-06-04T20:33:41Z",
      "html_url": "https://github.com/SasLuca/zig-nanoid/releases/tag/v1.0.3",
      "assets": []
    },
    {
      "tag_name": "v1.0.2",
      "name": "Version 1.0.2",
      "body": "- Basic generation functions now return a raw byte array.\r\n- Examples now don't require allocators and use `std.crypto.random` instead of `DefaultCsprng`.\r\n- Updated documentation.\r\n- Added changelog.",
      "prerelease": false,
      "published_at": "2022-05-02T14:39:10Z",
      "html_url": "https://github.com/SasLuca/zig-nanoid/releases/tag/v1.0.2",
      "assets": []
    },
    {
      "tag_name": "v1.0.1",
      "name": "Version 1.0.1",
      "body": "Initial release following some adjustments and bug fixes.",
      "prerelease": false,
      "published_at": "2022-05-02T10:42:55Z",
      "html_url": "https://github.com/SasLuca/zig-nanoid/releases/tag/v1.0.1",
      "assets": []
    }
  ],
  "owner_bio": "Low level game dev.",
  "owner_company": null,
  "owner_location": "Bucharest, Romania",
  "owner_blog": null,
  "owner_twitter_username": "SasLuca",
  "owner_followers": 215,
  "owner_following": 10,
  "owner_created_at": "2015-11-23T15:27:24Z",
  "license": "MIT",
  "category": "library"
}