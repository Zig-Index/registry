{
  "name": "lmdbx-zig",
  "owner": "theseyan",
  "repo": "lmdbx-zig",
  "description": "Zig bindings for libMDBX (a fork of LMDB)",
  "type": "package",
  "topics": [
    "database",
    "libmdbx",
    "lmdb",
    "zig",
    "zig-package"
  ],
  "stars": 8,
  "forks": 2,
  "watchers": 1,
  "updated_at": "2025-12-04T07:43:03Z",
  "dependencies": [
    {
      "name": "mdbx",
      "url": "https://libmdbx.dqdkfa.ru/release/libmdbx-amalgamated-0.14.1.tar.xz",
      "hash": "N-V-__8AAIzzNwBcWaOwMMMoxu0xyd8cin1JI1BpMe1_1AVn"
    },
    {
      "name": "cpu_features",
      "url": "https://github.com/slyshykO/cpu_model/archive/refs/heads/main.tar.gz",
      "hash": "122016a054f0c745d27cd20d02ebbef0c091d0f9c124061afd58c76b25628a3ea353"
    }
  ],
  "minimum_zig_version": "0.15.2",
  "readme": "# lmdbx-zig\n\nZig bindings for [libMDBX](https://libmdbx.dqdkfa.ru/) (a fork of LMDB).\n\nBuilt and tested with Zig version `0.15.2`.\n\n> _libmdbx_ is an extremely fast, compact, powerful, embedded, transactional [key-value database](https://en.wikipedia.org/wiki/Key-value_database) with a specific set of properties and capabilities,\n> focused on creating unique lightweight solutions.\n> _libmdbx_ is superior to legendary _[LMDB](https://symas.com/lmdb/)_ in\nterms of features and reliability, not inferior in performance. In\ncomparison to _LMDB_, _libmdbx_ make things \"just work\" perfectly and\nout-of-the-box, not silently and catastrophically break down.\n\n## Table of Contents\n\n- [Installation](#installation)\n- [Usage](#usage)\n- [API](#api)\n  - [`Environment`](#environment)\n  - [`Transaction`](#transaction)\n  - [`Database`](#database)\n  - [`Cursor`](#cursor)\n- [Benchmarks](#benchmarks)\n\n## Installation\n\n```bash\n# replace {VERSION} with the latest release eg: v0.2.3\nzig fetch https://github.com/theseyan/lmdbx-zig/archive/refs/tags/{VERSION}.tar.gz\n```\n\nCopy the hash generated and add lmdbx-zig to `build.zig.zon`:\n\n```zig\n.{\n    .dependencies = .{\n        .lmdbx = .{\n            .url = \"https://github.com/theseyan/lmdbx-zig/archive/refs/tags/{VERSION}.tar.gz\",\n            .hash = \"{HASH}\",\n        },\n    },\n}\n```\n\n### Targets\n\n`lmdbx-zig` officially supports cross-compiling to the following target triples:\n- `x86_64-linux-gnu`, `x86_64-macos`, `x86_64-windows-gnu`\n- `aarch64-linux-gnu`, `aarch64-macos`, `aarch64-windows-gnu`\n\nSuccessful compilation on other targets is not guaranteed (but might work).\n\n## Usage\n\nA libMDBX environment can either have multiple named databases, or a single unnamed database.\n\nTo use a single unnamed database, open a transaction and use the `txn.get`, `txn.set`, `txn.delete`, and `txn.cursor` methods directly.\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\n\npub fn main() !void {\n    const env = try lmdbx.Environment.init(\"path/to/db\", .{});\n    defer env.deinit();\n\n    const txn = try lmdbx.Transaction.init(env, .{ .mode = .ReadWrite });\n    errdefer txn.abort();\n\n    try txn.set(\"aaa\", \"foo\", .Create);\n    try txn.set(\"bbb\", \"bar\", .Upsert);\n\n    try txn.commit();\n}\n```\n\nTo use named databases, open the environment with a non-zero `max_dbs` value. Then open each named database using `Transaction.database`, which returns a `Database` struct with `db.get`/`db.set`/`db.delete`/`db.cursor` methods. You don't have to close databases, but they're only valid during the lifetime of the transaction.\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\n\npub fn main() !void {\n    const env = try lmdbx.Environment.init(\"path/to/db\", .{ .max_dbs = 2 });\n    defer env.deinit();\n\n    const txn = try lmdbx.Transaction.init(env, .{ .mode = .ReadWrite });\n    errdefer txn.abort();\n\n    const widgets = try txn.database(\"widgets\", .{ .create = true });\n    try widgets.set(\"aaa\", \"foo\", .Create);\n\n    const gadgets = try txn.database(\"gadgets\", .{ .create = true });\n    try gadgets.set(\"aaa\", \"bar\", .Create);\n\n    try txn.commit();\n}\n```\n\n## API\n\n### `Environment`\n\n```zig\npub const Environment = struct {\n    pub const Options = struct {\n        geometry: ?DatabaseGeometry = null,\n        max_dbs: u32 = 0,\n        max_readers: u32 = 126,\n        read_only: bool = false,\n        write_map: bool = false,\n        no_sticky_threads: bool = false,\n        exclusive: bool = false,\n        no_read_ahead: bool = false,\n        no_mem_init: bool = false,\n        lifo_reclaim: bool = false,\n        no_meta_sync: bool = false,\n        safe_nosync: bool = false,\n        mode: u16 = 0o664\n    };\n\n    pub const Info = struct {\n        map_size: usize,\n        max_readers: u32,\n        num_readers: u32,\n        autosync_period: u32,\n        autosync_threshold: u64,\n        db_pagesize: u32,\n        mode: u32,\n        sys_pagesize: u32,\n        unsync_volume: u64\n    };\n\n    pub const DatabaseGeometry = struct {\n        lower_size: isize = -1,\n        upper_size: isize = -1,\n        size_now: isize = -1,\n        growth_step: isize = -1,\n        shrink_threshold: isize = -1,\n        pagesize: isize = -1\n    };\n\n    pub fn init(path: [*:0]const u8, options: Options) !Environment\n    pub fn deinit(self: Environment) !void\n\n    pub fn transaction(self: Environment, options: Transaction.Options) !Transaction\n\n    pub fn sync(self: Environment) !void\n    pub fn stat(self: Environment) !Stat\n    pub fn info(self: Environment) !Info\n\n    pub fn setGeometry(self: Environment, options: DatabaseGeometry) !void\n};\n```\n\n### `Transaction`\n\n```zig\npub const Transaction = struct {\n    pub const Mode = enum { ReadOnly, ReadWrite };\n\n    pub const Options = struct {\n        mode: Mode,\n        parent: ?Transaction = null,\n        txn_try: bool = false\n    };\n\n    pub fn init(env: Environment, options: Options) !Transaction\n    pub fn abort(self: Transaction) !void\n    pub fn commit(self: Transaction) !void\n\n    pub fn get(self: Transaction, key: []const u8) !?[]const u8\n    pub fn set(self: Transaction, key: []const u8, value: []const u8, flag: Database.SetFlag) !void\n    pub fn delete(self: Transaction, key: []const u8) !void\n\n    pub fn cursor(self: Database) !Cursor\n    pub fn database(self: Transaction, name: ?[*:0]const u8, options: Database.Options) !Database\n};\n```\n\n### `Database`\n\n```zig\npub const Database = struct {\n    pub const Options = struct {\n        reverse_key: bool = false,\n        integer_key: bool = false,\n        create: bool = false,\n    };\n\n    pub const Stat = struct {\n        psize: u32,\n        depth: u32,\n        branch_pages: usize,\n        leaf_pages: usize,\n        overflow_pages: usize,\n        entries: usize,\n    };\n\n    pub const SetFlag = enum {\n        Create, Update, Upsert, Append, AppendDup\n    };\n\n    pub fn open(txn: Transaction, name: ?[*:0]const u8, options: Options) !Database\n\n    pub fn get(self: Database, key: []const u8) !?[]const u8\n    pub fn set(self: Database, key: []const u8, value: []const u8, flag: SetFlag) !void\n    pub fn delete(self: Database, key: []const u8) !void\n\n    pub fn cursor(self: Database) !Cursor\n\n    pub fn stat(self: Database) !Stat\n};\n```\n\n### `Cursor`\n\n```zig\npub const Cursor = struct {\n    pub const Entry = struct { key: []const u8, value: []const u8 };\n\n    pub fn init(db: Database) !Cursor\n    pub fn deinit(self: Cursor) void\n\n    pub fn getCurrentEntry(self: Cursor) !Entry\n    pub fn getCurrentKey(self: Cursor) ![]const u8\n    pub fn getCurrentValue(self: Cursor) ![]const u8\n\n    pub fn set(self: Cursor, key: []const u8, value: []const u8) !void\n    pub fn setCurrentValue(self: Cursor, value: []const u8) !void\n    pub fn deleteCurrentKey(self: Cursor) !void\n\n    pub fn goToNext(self: Cursor) !?[]const u8\n    pub fn goToPrevious(self: Cursor) !?[]const u8\n    pub fn goToLast(self: Cursor) !?[]const u8\n    pub fn goToFirst(self: Cursor) !?[]const u8\n    pub fn goToKey(self: Cursor, key: []const u8) !void\n\n    pub fn seek(self: Cursor, key: []const u8) !?[]const u8\n};\n```\n\n> ⚠️ Always close cursors **before** committing or aborting the transaction.\n\n## Benchmarks\n\nRun the benchmarks:\n```\nzig build bench\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/30970706?u=0eda0e38a8d8119e58d975ba82a07d7ae4c68428&v=4",
  "releases": [
    {
      "tag_name": "v0.2.3",
      "name": "v0.2.3",
      "body": "- Updated for Zig 0.15.2\r\n- Fix/workaround runtime SIMD feature detection bug",
      "prerelease": false,
      "published_at": "2025-12-04T07:44:45Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.2.3",
      "assets": []
    },
    {
      "tag_name": "v0.2.0",
      "name": "v0.2.0",
      "body": "- Updated libMDBX to latest 0.14.1\r\n- Updated Zig version to 0.14\r\n- Update `s2s.zig`",
      "prerelease": false,
      "published_at": "2025-05-10T16:28:39Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.2",
      "name": "v0.1.2",
      "body": "",
      "prerelease": false,
      "published_at": "2024-12-14T07:36:47Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.1.2",
      "assets": []
    },
    {
      "tag_name": "v0.1.1",
      "name": "",
      "body": "- Fix windows build\r\n- Don't panic when target CPU or arch is unknown",
      "prerelease": false,
      "published_at": "2024-11-05T18:03:10Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.1.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2024-11-05T16:05:08Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "computer enthusiast",
  "owner_company": null,
  "owner_location": "Agartala, India",
  "owner_blog": "seyan.co",
  "owner_twitter_username": "sayanjdas",
  "owner_followers": 36,
  "owner_following": 3,
  "owner_created_at": "2017-08-13T05:59:42Z",
  "license": "MIT",
  "category": "database"
}