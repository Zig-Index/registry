{
  "name": "lmdbx-zig",
  "owner": "theseyan",
  "repo": "lmdbx-zig",
  "description": "Zig bindings for libMDBX (a fork of LMDB)",
  "type": "package",
  "topics": [
    "database",
    "libmdbx",
    "lmdb",
    "zig",
    "zig-package"
  ],
  "stars": 8,
  "forks": 2,
  "watchers": 1,
  "updated_at": "2026-01-30T19:19:59Z",
  "dependencies": [
    {
      "name": "mdbx",
      "url": "https://libmdbx.dqdkfa.ru/release/libmdbx-amalgamated-0.14.1.tar.xz",
      "hash": "N-V-__8AAIzzNwBcWaOwMMMoxu0xyd8cin1JI1BpMe1_1AVn"
    },
    {
      "name": "cpu_features",
      "url": "https://github.com/slyshykO/cpu_model/archive/refs/heads/main.tar.gz",
      "hash": "122016a054f0c745d27cd20d02ebbef0c091d0f9c124061afd58c76b25628a3ea353"
    },
    {
      "name": "zbench",
      "url": "https://github.com/hendriknielaender/zbench/archive/v0.12.0.tar.gz",
      "hash": "zbench-0.11.1-YTdc7zkmAQBWI99esNFueJc9GuzK-KaU6Nfr1ZXhNGmc"
    }
  ],
  "minimum_zig_version": "0.15.2",
  "readme": "# lmdbx-zig\n\nZig bindings for [libMDBX](https://libmdbx.dqdkfa.ru/) (a fork of LMDB).\n\nBuilt and tested with Zig version `0.15.2`.\n\n> _libmdbx_ is an extremely fast, compact, powerful, embedded, transactional [key-value database](https://en.wikipedia.org/wiki/Key-value_database) with a specific set of properties and capabilities,\n> focused on creating unique lightweight solutions.\n> _libmdbx_ is superior to legendary _[LMDB](https://symas.com/lmdb/)_ in\nterms of features and reliability, not inferior in performance. In\ncomparison to _LMDB_, _libmdbx_ make things \"just work\" perfectly and\nout-of-the-box, not silently and catastrophically break down.\n\n## Table of Contents\n\n- [Installation](#installation)\n- [Usage](#usage)\n- [API](#api)\n  - [`Environment`](#environment)\n  - [`BatchedDB`](#batcheddb)\n  - [`Transaction`](#transaction)\n  - [`Database`](#database)\n  - [`Cursor`](#cursor)\n  - [Low-level bindings](#low-level-bindings)\n- [Benchmarks](#benchmarks)\n\n## Installation\n\n```bash\n# replace {VERSION} with the latest release eg: v0.2.3\nzig fetch https://github.com/theseyan/lmdbx-zig/archive/refs/tags/{VERSION}.tar.gz\n```\n\nCopy the hash generated and add lmdbx-zig to `build.zig.zon`:\n\n```zig\n.{\n    .dependencies = .{\n        .lmdbx = .{\n            .url = \"https://github.com/theseyan/lmdbx-zig/archive/refs/tags/{VERSION}.tar.gz\",\n            .hash = \"{HASH}\",\n        },\n    },\n}\n```\n\n### Targets\n\n`lmdbx-zig` officially supports cross-compiling to the following target triples:\n- `x86_64-linux-gnu`, `x86_64-macos`, `x86_64-windows-gnu`\n- `aarch64-linux-gnu`, `aarch64-macos`, `aarch64-windows-gnu`\n\nSuccessful compilation on other targets is not guaranteed (but might work).\n\n## Usage\n\nA libMDBX environment can either have multiple named databases, or a single unnamed database.\n\nTo use a single unnamed database, open a transaction and use the `txn.get`, `txn.set`, `txn.delete`, and `txn.cursor` methods directly.\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\n\npub fn main() !void {\n    const env = try lmdbx.Environment.init(\"path/to/db\", .{});\n    defer env.deinit();\n\n    const txn = try env.transaction(.{ .mode = .ReadWrite });\n    errdefer txn.abort();\n\n    try txn.set(\"aaa\", \"foo\", .Create);\n    try txn.set(\"bbb\", \"bar\", .Upsert);\n\n    try txn.commit();\n}\n```\n\nTo use named databases, open the environment with a non-zero `max_dbs` value. Then open each named database using `Transaction.database`, which returns a `Database` struct with `db.get`/`db.set`/`db.delete`/`db.cursor` methods. You don't have to close databases, but they're only valid during the lifetime of the transaction.\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\n\npub fn main() !void {\n    const env = try lmdbx.Environment.init(\"path/to/db\", .{ .max_dbs = 2 });\n    defer env.deinit();\n\n    const txn = try env.transaction(.{ .mode = .ReadWrite });\n    errdefer txn.abort();\n\n    const widgets = try txn.database(\"widgets\", .{ .create = true });\n    try widgets.set(\"aaa\", \"foo\", .Create);\n\n    const gadgets = try txn.database(\"gadgets\", .{ .create = true });\n    try gadgets.set(\"aaa\", \"bar\", .Create);\n\n    try txn.commit();\n}\n```\n\nNested transactions are supported through `Transaction.nested(...)` (or `Options.parent`).\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\n\npub fn main() !void {\n    const env = try lmdbx.Environment.init(\"path/to/db\", .{});\n    defer env.deinit();\n\n    const parent = try env.transaction(.{ .mode = .ReadWrite });\n    errdefer parent.abort();\n\n    const child = try parent.nested(.{ .mode = .ReadWrite });\n    errdefer child.abort();\n    try child.set(\"k\", \"v\", .Upsert);\n    try child.commit();\n\n    try parent.commit();\n}\n```\n\n`BatchedDB` is a fully ACID transaction layer on top of libMDBX's `SAFE_NOSYNC` flag combined with configurable disk syncs by interval/max-bytes threshold, enabling callback-based async transaction commits while massively increasing write throughput by amortizing disk I/O costs. On the flip side, write transactions show a considerable increase in latency which may or may not be acceptable based on your requirements.\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const env = try lmdbx.Environment.init(\"path/to/db\", .{});\n    defer env.deinit();\n\n    var batched: lmdbx.BatchedDB = undefined;\n    try batched.init(env, std.heap.page_allocator, .{\n        .sync_interval_ms = 2,\n        .sync_bytes = 0,\n        .callback_capacity = 64,\n    });\n    defer batched.deinit();\n\n    const txn = try batched.transaction(.{ .mode = .ReadWrite });\n    errdefer txn.abort();\n    try txn.set(\"aaa\", \"foo\", .Upsert);\n    try txn.commit();\n}\n```\n\n## API\n\n### `Environment`\n\n```zig\npub const Environment = struct {\n    pub const Options = struct {\n        geometry: ?DatabaseGeometry = null,\n        max_dbs: u32 = 0,\n        max_readers: u32 = 126,\n        read_only: bool = false,\n        write_map: bool = false,\n        no_sticky_threads: bool = false,\n        exclusive: bool = false,\n        no_read_ahead: bool = false,\n        no_mem_init: bool = false,\n        lifo_reclaim: bool = false,\n        no_meta_sync: bool = false,\n        safe_nosync: bool = false,\n        unsafe_nosync: bool = false,\n        sync_durable: bool = true,\n        /// Autosync period in milliseconds. 0 disables periodic autosync.\n        sync_period_ms: u32 = 0,\n        /// Autosync threshold in bytes. 0 disables threshold-based autosync.\n        sync_bytes: usize = 0,\n        mode: u16 = 0o664\n    };\n\n    pub const FlagsInfo = struct {\n        raw: u32,\n        no_meta_sync: bool,\n        safe_nosync: bool,\n        unsafe_nosync: bool,\n        sync_durable: bool,\n        write_map: bool,\n        exclusive: bool,\n    };\n\n    pub const Info = struct {\n        map_size: usize,\n        max_readers: u32,\n        num_readers: u32,\n        autosync_period: u32,\n        autosync_threshold: u64,\n        db_pagesize: u32,\n        mode: u32,\n        sys_pagesize: u32,\n        unsync_volume: u64\n    };\n\n    pub const DatabaseGeometry = struct {\n        lower_size: isize = -1,\n        upper_size: isize = -1,\n        size_now: isize = -1,\n        growth_step: isize = -1,\n        shrink_threshold: isize = -1,\n        pagesize: isize = -1\n    };\n\n    pub fn init(path: [*:0]const u8, options: Options) !Environment\n    pub fn deinit(self: Environment) !void\n\n    pub fn transaction(self: Environment, options: Transaction.Options) !Transaction\n\n    pub fn sync(self: Environment, force: bool, nonblock: bool) !bool\n    pub fn stat(self: Environment) !Stat\n    pub fn info(self: Environment) !Info\n    pub fn flagsInfo(self: Environment) !FlagsInfo\n    pub fn syncBytes(self: Environment) !usize\n    pub fn syncPeriod(self: Environment) !u32\n\n    pub fn setGeometry(self: Environment, options: DatabaseGeometry) !void\n};\n```\n\n### `BatchedDB`\n\n```zig\npub const BatchedDB = struct {\n    pub const Options = struct {\n        /// Sync interval in milliseconds.\n        sync_interval_ms: u32 = 2,\n        /// If non-zero, trigger early sync when unsynced volume reaches this threshold.\n        sync_bytes: u64 = 0,\n        /// Max pending callbacks. 0 disables callback queue.\n        callback_capacity: usize = 0,\n    };\n\n    pub const CommitCallback = *const fn (ctx: ?*anyopaque, success: bool) void;\n\n    pub fn init(self: *BatchedDB, env: Environment, allocator: std.mem.Allocator, options: Options) !void\n    pub fn deinit(self: *BatchedDB) void\n\n    pub fn transaction(self: *BatchedDB, options: Transaction.Options) !Transaction\n\n    pub const Transaction = struct {\n        pub fn abort(self: Transaction) !void\n        pub fn commit(self: Transaction) !void\n        pub fn commitAsync(self: Transaction, cb: CommitCallback, ctx: ?*anyopaque) !void\n        /// Returns the underlying lmdbx.Transaction.\n        pub fn inner(self: Transaction) Transaction\n        /// All other Transaction APIs are forwarded (get/set/delete, cursor, database, nested, etc).\n    };\n};\n```\n\n### `Transaction`\n\n```zig\npub const Transaction = struct {\n    pub const Mode = enum { ReadOnly, ReadWrite };\n\n    pub const Options = struct {\n        mode: Mode = .ReadWrite,\n        parent: ?Transaction = null,\n        txn_try: bool = false\n    };\n\n    pub fn init(env: Environment, options: Options) !Transaction\n    pub fn nested(self: Transaction, options: Options) !Transaction\n    pub fn abort(self: Transaction) !void\n    pub fn commit(self: Transaction) !void\n    pub fn reset(self: Transaction) !void\n    pub fn renew(self: Transaction) !void\n    pub fn park(self: Transaction, autounpark: bool) !void\n    pub fn unpark(self: Transaction, restart_if_ousted: bool) !void\n    pub fn setUserctx(self: Transaction, ctx: ?*anyopaque) !void\n    pub fn getUserctx(self: Transaction) ?*anyopaque\n    pub fn replace(self: Transaction, key: []const u8, new_value: ?[]const u8, old_value: ?[]const u8, flag: Database.ReplaceFlag) !?[]const u8\n    pub fn estimateRange(self: Transaction, db: Database, begin_key: ?[]const u8, begin_data: ?[]const u8, end_key: ?[]const u8, end_data: ?[]const u8) !isize\n    pub fn canaryPut(self: Transaction, canary: ?*const Canary) !void\n    pub fn canaryGet(self: Transaction) !Canary\n    pub fn releaseAllCursors(self: Transaction, unbind: bool) !void\n    pub fn getEqualOrGreat(self: Transaction, key: []const u8) !?Cursor.Entry\n\n    pub fn get(self: Transaction, key: []const u8) !?[]const u8\n    pub fn set(self: Transaction, key: []const u8, value: []const u8, flag: Database.SetFlag) !void\n    pub fn delete(self: Transaction, key: []const u8) !void\n\n    pub fn cursor(self: Transaction) !Cursor\n    pub fn database(self: Transaction, name: ?[*:0]const u8, options: Database.Options) !Database\n};\n```\n\n### `Database`\n\n```zig\npub const Database = struct {\n    pub const DBI = c.MDBX_dbi;\n\n    pub const Options = struct {\n        reverse_key: bool = false,\n        integer_key: bool = false,\n        create: bool = false,\n    };\n\n    pub const Stat = struct {\n        psize: u32,\n        depth: u32,\n        branch_pages: usize,\n        leaf_pages: usize,\n        overflow_pages: usize,\n        entries: usize,\n    };\n\n    pub const SetFlag = enum {\n        Create, Update, Upsert, Append, AppendDup\n    };\n\n    pub const ReplaceFlag = enum {\n        Upsert,\n        Create,\n        Update,\n        Append,\n        AppendDup,\n        CurrentNoOverwrite,\n    };\n\n    pub fn open(txn: Transaction, name: ?[*:0]const u8, options: Options) !Database\n\n    pub fn get(self: Database, key: []const u8) !?[]const u8\n    pub fn set(self: Database, key: []const u8, value: []const u8, flag: SetFlag) !void\n    pub fn delete(self: Database, key: []const u8) !void\n    pub fn replace(self: Database, key: []const u8, new_value: ?[]const u8, old_value: ?[]const u8, flag: ReplaceFlag) !?[]const u8\n    pub fn drop(self: Database, delete_dbi: bool) !void\n\n    pub fn cursor(self: Database) !Cursor\n    pub fn getEqualOrGreat(self: Database, key: []const u8) !?Cursor.Entry\n\n    pub fn stat(self: Database) !Stat\n    pub fn rename(self: Database, name: [*:0]const u8) !void\n    pub fn sequence(self: Database, increment: u64) !u64\n};\n```\n\n### `Cursor`\n\n```zig\npub const Cursor = struct {\n    pub const Entry = struct { key: []const u8, value: []const u8 };\n\n    pub fn init(db: Database) !Cursor\n    pub fn deinit(self: Cursor) void\n\n    pub fn setUserctx(self: Cursor, ctx: ?*anyopaque) !void\n    pub fn getUserctx(self: Cursor) ?*anyopaque\n    pub fn renew(self: Cursor, txn: Transaction) !void\n    pub fn reset(self: Cursor) !void\n\n    pub fn getCurrentEntry(self: Cursor) !Entry\n    pub fn getCurrentKey(self: Cursor) ![]const u8\n    pub fn getCurrentValue(self: Cursor) ![]const u8\n\n    pub fn set(self: Cursor, key: []const u8, value: []const u8) !void\n    pub fn setCurrentValue(self: Cursor, value: []const u8) !void\n    pub fn deleteCurrentKey(self: Cursor) !void\n\n    pub fn goToNext(self: Cursor) !?[]const u8\n    pub fn goToPrevious(self: Cursor) !?[]const u8\n    pub fn goToLast(self: Cursor) !?[]const u8\n    pub fn goToFirst(self: Cursor) !?[]const u8\n    pub fn goToKey(self: Cursor, key: []const u8) !void\n\n    pub fn seek(self: Cursor, key: []const u8) !?[]const u8\n};\n```\n\n> ⚠️ Always close cursors **before** committing or aborting the transaction.\n\n### Low-level bindings\n\n`lmdbx.c` exposes raw libMDBX bindings (constants, types, and functions) as imported C symbols:\n\n```zig\nconst lmdbx = @import(\"lmdbx\");\nconst c = lmdbx.c;\n```\n\n## Benchmarks\n\nRun the benchmarks:\n```\nzig build bench\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/30970706?u=0eda0e38a8d8119e58d975ba82a07d7ae4c68428&v=4",
  "releases": [
    {
      "tag_name": "v0.3.0",
      "name": "v0.3.0: BatchedDB, Nested transactions, more API coverage",
      "body": "## What's Changed\r\n* v0.3.0: BatchedDB API, Nested transactions, and more API coverage by @theseyan in https://github.com/theseyan/lmdbx-zig/pull/5\r\n\r\n\r\n**Full Changelog**: https://github.com/theseyan/lmdbx-zig/compare/v0.2.3...v0.3.0",
      "prerelease": false,
      "published_at": "2026-01-30T19:20:56Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v0.2.3",
      "name": "v0.2.3",
      "body": "- Updated for Zig 0.15.2\r\n- Fix/workaround runtime SIMD feature detection bug",
      "prerelease": false,
      "published_at": "2025-12-04T07:44:45Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.2.3",
      "assets": []
    },
    {
      "tag_name": "v0.2.0",
      "name": "v0.2.0",
      "body": "- Updated libMDBX to latest 0.14.1\r\n- Updated Zig version to 0.14\r\n- Update `s2s.zig`",
      "prerelease": false,
      "published_at": "2025-05-10T16:28:39Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.2.0",
      "assets": []
    },
    {
      "tag_name": "v0.1.2",
      "name": "v0.1.2",
      "body": "",
      "prerelease": false,
      "published_at": "2024-12-14T07:36:47Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.1.2",
      "assets": []
    },
    {
      "tag_name": "v0.1.1",
      "name": "",
      "body": "- Fix windows build\r\n- Don't panic when target CPU or arch is unknown",
      "prerelease": false,
      "published_at": "2024-11-05T18:03:10Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.1.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "",
      "body": "",
      "prerelease": false,
      "published_at": "2024-11-05T16:05:08Z",
      "html_url": "https://github.com/theseyan/lmdbx-zig/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "computer enthusiast",
  "owner_company": null,
  "owner_location": "Agartala, India",
  "owner_blog": "seyan.co",
  "owner_twitter_username": "sayanjdas",
  "owner_followers": 40,
  "owner_following": 3,
  "owner_created_at": "2017-08-13T05:59:42Z",
  "license": "MIT",
  "category": "database"
}