{
  "name": "bufzilla",
  "owner": "theseyan",
  "repo": "bufzilla",
  "description": "Fast & compact serialization format in Zig.",
  "type": "project",
  "topics": [
    "zig-package"
  ],
  "stars": 47,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-12-05T17:06:23Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# ⚡ bufzilla\n\n_buffer • zilla_\n\nA compact and fast **binary encoding format** in pure Zig.\nOriginally based on rxi's article - [\"A Simple Serialization System\"](https://rxi.github.io/a_simple_serialization_system.html).\n\nbufzilla is ideal for serializing JSON-like objects and arrays, and has the following qualities:\n\n- **Portable** across endianness and architectures.\n- **Schemaless**, fully self-describing format; no \"pre-compilation\" step is necessary.\n- **Zero-copy** reads directly from the encoded bytes.\n- **Variable length integer encoding** enabled by default, no wasted bytes.\n- **Safety** against untrusted inputs with configurable, zero-overhead parsing limits.\n- Data can be read _linearly_ without any intermediate representation (eg. trees).\n- Format encoded objects as JSON via `Inspect` API.\n- Serialize Zig structs and data types recursively.\n\n## Installation\n\n- Zig version: `0.15.2`\n\n```sh\nzig fetch https://github.com/theseyan/bufzilla/archive/refs/tags/{VERSION}.tar.gz\n```\n\nCopy the hash generated and add `bufzilla` to your `build.zig.zon`:\n\n```zig\n.{\n    .dependencies = .{\n        .bufzilla = .{\n            .url = \"https://github.com/theseyan/bufzilla/archive/refs/tags/{VERSION}.tar.gz\",\n            .hash = \"{HASH}\",\n        },\n    },\n}\n```\n\n## Usage\n\nbufzilla simply takes a `std.Io.Writer` interface, and writes encoded data to it. Such a writer can be backed by a growing buffer, a fixed array, a file, or a network socket, etc.\n\n### Writing to a dynamic buffer\n\nUse `std.Io.Writer.Allocating` when you need a dynamically growing buffer:\n\n```zig\nconst std = @import(\"std\");\nconst Io = std.Io;\nconst Writer = @import(\"bufzilla\").Writer;\n\n// Create an allocating writer\nvar aw = Io.Writer.Allocating.init(allocator);\ndefer aw.deinit();\n\n// Initialize bufzilla writer\nvar writer = Writer.init(&aw.writer);\n\nconst DataType = struct {\n    a: i64,\n    b: struct {\n        c: bool,\n    },\n    d: []const union(enum) {\n        null: ?void,\n        f64: f64,\n        string: []const u8,\n    },\n};\n\nconst data = DataType{\n    .a = 123,\n    .b = .{ .c = true },\n    .d = &.{ .{ .f64 = 123.123 }, .{ .null = null }, .{ .string = \"value\" } },\n};\n\ntry writer.writeAny(data);\n\n// Get the encoded bytes\nconst encoded = aw.written();\nstd.debug.print(\"Encoded {d} bytes\\n\", .{encoded.len});\n```\n\n### Writing to a fixed buffer\n\nUse `std.Io.Writer.fixed` to prevent dynamic allocations when you know the maximum size upfront:\n\n```zig\nvar buffer: [1024]u8 = undefined;\nvar fixed = Io.Writer.fixed(&buffer);\n\nvar writer = Writer.init(&fixed);\ntry writer.writeAny(\"hello\");\ntry writer.writeAny(@as(i64, 42));\n\nconst encoded = fixed.buffered();\n```\n\n### Incremental writing\n\nYou can also build messages incrementally:\n\n```zig\nvar writer = Writer.init(&aw.writer);\n\ntry writer.startObject();\ntry writer.writeAny(\"name\");\ntry writer.writeAny(\"Alice\");\ntry writer.writeAny(\"scores\");\ntry writer.startArray();\ntry writer.writeAny(@as(i64, 100));\ntry writer.writeAny(@as(i64, 95));\ntry writer.endContainer(); // end array\ntry writer.endContainer(); // end object\n```\n\n### Inspecting encoded data as JSON\n\nThe `Inspect` API renders encoded bufzilla data as pretty-printed JSON:\n\n```zig\nconst Inspect = @import(\"bufzilla\").Inspect;\n\n// Output to an allocating writer\nvar aw = Io.Writer.Allocating.init(allocator);\ndefer aw.deinit();\n\nvar inspector = Inspect(.{}).init(encoded_bytes, &aw.writer, .{});\ntry inspector.inspect();\n\nstd.debug.print(\"{s}\\n\", .{aw.written()});\n```\n\nOr output directly to a fixed buffer:\n\n```zig\nvar buffer: [4096]u8 = undefined;\nvar fixed = Io.Writer.fixed(&buffer);\n\nvar inspector = Inspect(.{}).init(encoded_bytes, &fixed, .{});\ntry inspector.inspect();\n\nstd.debug.print(\"{s}\\n\", .{fixed.buffered()});\n```\n\nOutput:\n\n```json\n{\n    \"a\": 123,\n    \"b\": {\n        \"c\": true\n    },\n    \"d\": [\n        123.12300000000000,\n        null,\n        \"value\"\n    ]\n}\n```\n\n### Reading encoded data\n\nThe `Reader` provides zero-copy access to encoded data:\n\n```zig\nconst Reader = @import(\"bufzilla\").Reader;\n\nvar reader = Reader(.{}).init(encoded_bytes);\n\n// Read values sequentially\nconst val = try reader.read();\nswitch (val) {\n    .object => { /* iterate object */ },\n    .array => { /* iterate array */ },\n    .i64 => |n| std.debug.print(\"int: {d}\\n\", .{n}),\n    .bytes => |s| std.debug.print(\"string: {s}\\n\", .{s}),\n    // ... other types\n}\n\n// Or iterate containers\nwhile (try reader.iterateObject(obj)) |kv| {\n    // kv.key and kv.value\n}\n```\n\nYou can find more examples in the [unit tests](https://github.com/theseyan/bufzilla/tree/main/test).\n\n### Safety & Security\n\nWhen reading untrusted data, bufzilla provides configurable limits at compile time to prevent infinite recursion/stack overflow errors, with negligible performance loss.\n\n```zig\nconst Reader = @import(\"bufzilla\").Reader;\n\n// Default limits\nvar reader = Reader(.{}).init(data);\n\n// Custom limits\nvar reader = Reader(.{\n    .max_depth = 50,                    // Max nesting depth\n    .max_bytes_length = 1024 * 1024,    // Max string/binary blob size\n    .max_array_length = 10_000,         // Max array elements\n    .max_object_size = 10_000,          // Max object key-value pairs\n}).init(data);\n\n// Unlimited depth\nvar reader = Reader(.{ .max_depth = null }).init(data);\n```\n\n| Limit | Default | Error |\n|-------|---------|-------|\n| `max_depth` | 2048 | `MaxDepthExceeded` |\n| `max_bytes_length` | unlimited | `BytesTooLong` |\n| `max_array_length` | unlimited | `ArrayTooLarge` |\n| `max_object_size` | unlimited | `ObjectTooLarge` |\n\n**Notes:**\n- `max_array_length` and `max_object_size` require `max_depth` to be set. Setting them with `max_depth = null` is a compile error.\n- Reader internally allocates a stack buffer of size `max_depth` for iteration counters when array/object limits are enabled. Keep `max_depth` reasonable (default 2048 uses ~16KB).\n\nThe `Inspect` API also accepts limits as a parameter:\n\n```zig\nvar inspector = Inspect(.{ .max_depth = 100 }).init(data, &writer, .{});\n```\n\n## Gotchas\n\n- As a self-describing format, field names (keys) are present in the encoded result which can inflate the encoded size compared to other schemaful encoding formats.\n\n## Testing\n\nComprehensive unit tests are present in the `test/` directory.\n\n```bash\nzig build test\n```\n\n## Benchmarks\n\nRun the [benchmark suite](https://github.com/theseyan/bufzilla/blob/main/bench/main.zig) with `zig build bench -Doptimize=ReleaseFast`.\n\n**bufzilla is competitive in performance with similar self-describing binary formats, and in most cases, much faster.**\n![Benchmark Comparison](misc/bench.png)\n*Avg. throughput (ops/sec): [bufzilla](https://github.com/theseyan/bufzilla) vs [zbor](https://github.com/r4gus/zbor) vs [zig-msgpack](https://github.com/zigcc/zig-msgpack)*\n\nResults on x86_64 Linux, Ryzen 7 9700X CPU:\n```\nBasic Types:\n--------------------------------------------------------------------------------\n                              Null Write |  1000000 iterations |        0 ns/op |        0 ops/sec\n                               Null Read |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                              Bool Write |  1000000 iterations |        0 ns/op |        0 ops/sec\n                               Bool Read |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                         Small Int Write |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                          Small Int Read |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                         Large Int Write |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                          Large Int Read |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                             Float Write |  1000000 iterations |        2 ns/op | 500000000 ops/sec\n                              Float Read |  1000000 iterations |        1 ns/op | 1000000000 ops/sec\n\nStrings:\n--------------------------------------------------------------------------------\n            Short String Write (5 bytes) |   500000 iterations |        4 ns/op | 250000000 ops/sec\n             Short String Read (5 bytes) |   500000 iterations |        2 ns/op | 500000000 ops/sec\n        Medium String Write (~300 bytes) |   100000 iterations |        4 ns/op | 250000000 ops/sec\n         Medium String Read (~300 bytes) |   100000 iterations |        2 ns/op | 500000000 ops/sec\n\nBinary Data:\n--------------------------------------------------------------------------------\n           Small Binary Write (32 bytes) |   500000 iterations |        6 ns/op | 166666666 ops/sec\n            Small Binary Read (32 bytes) |   500000 iterations |        2 ns/op | 500000000 ops/sec\n                Large Binary Write (1KB) |   100000 iterations |        9 ns/op | 111111111 ops/sec\n                 Large Binary Read (1KB) |   100000 iterations |        2 ns/op | 500000000 ops/sec\n\nArrays:\n--------------------------------------------------------------------------------\n         Small Array Write (10 elements) |   100000 iterations |       25 ns/op | 40000000 ops/sec\n          Small Array Read (10 elements) |   100000 iterations |       27 ns/op | 37037037 ops/sec\n       Medium Array Write (100 elements) |    50000 iterations |      260 ns/op |  3846153 ops/sec\n        Medium Array Read (100 elements) |    50000 iterations |      243 ns/op |  4115226 ops/sec\n\nObjects (Maps):\n--------------------------------------------------------------------------------\n         Small Object Write (10 entries) |   100000 iterations |      143 ns/op |  6993006 ops/sec\n          Small Object Read (10 entries) |   100000 iterations |      116 ns/op |  8620689 ops/sec\n        Medium Object Write (50 entries) |    50000 iterations |      712 ns/op |  1404494 ops/sec\n         Medium Object Read (50 entries) |    50000 iterations |      629 ns/op |  1589825 ops/sec\n\nComplex Structures:\n--------------------------------------------------------------------------------\n                  Nested Structure Write |    50000 iterations |       36 ns/op | 27777777 ops/sec\n                   Nested Structure Read |    50000 iterations |       71 ns/op | 14084507 ops/sec\n                       Mixed Types Write |    50000 iterations |       31 ns/op | 32258064 ops/sec\n                        Mixed Types Read |    50000 iterations |       57 ns/op | 17543859 ops/sec\n\nStruct Serialization:\n--------------------------------------------------------------------------------\n                     Simple Struct Write |   100000 iterations |       29 ns/op | 34482758 ops/sec\n                      Simple Struct Read |   100000 iterations |       46 ns/op | 21739130 ops/sec\n                    Complex Struct Write |    50000 iterations |      136 ns/op |  7352941 ops/sec\n                     Complex Struct Read |    50000 iterations |      272 ns/op |  3676470 ops/sec\n```",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/30970706?u=0eda0e38a8d8119e58d975ba82a07d7ae4c68428&v=4",
  "releases": [
    {
      "tag_name": "v0.3.0",
      "name": "v0.3.0",
      "body": "- Upgrade to Zig 0.15.2\r\n- `Writer` now accepts a `*std.Io.Writer` instead of an allocator.\r\n- `Inspect` now accepts a `*std.Io.Writer` instead of the deprecated `std.io.AnyWriter`.\r\n- Removed `Writer.deinit()`, `Writer.bytes()`, `Writer.len()`, `Writer.toOwnedSlice()` in favor of `std.Io.Writer`.\r\n\r\n### Safety\r\n- Added configurable `ReadLimits` with the following options:\r\n  - `max_depth`: maximum nesting depth for containers\r\n  - `max_bytes_length`: maximum string/binary blob size\r\n  - `max_array_length`: maximum array element count\r\n  - `max_object_size`: maximum object key-value pair count\r\n- New errors: `MaxDepthExceeded`, `BytesTooLong`, `ArrayTooLarge`, `ObjectTooLarge`.\r\n- `Inspect.printValue` now returns `NonFiniteFloat` error for NaN and Infinity float value.\r\n\r\n### Benchmarks\r\n- A benchmark suite has been added (mostly ported from [zig-msgpack](https://github.com/zigcc/zig-msgpack)).\r\n\r\n### Bugfixes and Optimizations\r\n- Fix integer overflow in `Reader` bounds checks that could bypass validation with malicious length values.\r\n- Fix `Reader` depth underflow when encountering `containerEnd` at depth 0.\r\n- Fix `Reader` float decoding to use little-endian byte order always.\r\n- Fix `Inspect` JSON output to escape all control characters (0x00-0x1F).\r\n- Fix `encodeVarInt` computing wrong size on big-endian machines.\r\n- `Inspect` now returns `error.InvalidUtf8` for non-UTF-8 byte sequences instead of producing invalid JSON.\r\n- Fix integer overflow in `Writer.write` when writing extremely large integers.\r\n- Fix `Writer.writeAny` silently dropping pointer-to-array values like `&[_]u8{1,2,3}` (data loss).\r\n- Optimize: pre-compute key field for struct serialization. ",
      "prerelease": false,
      "published_at": "2025-12-03T17:09:22Z",
      "html_url": "https://github.com/theseyan/bufzilla/releases/tag/v0.3.0",
      "assets": []
    },
    {
      "tag_name": "v2.1",
      "name": "v0.2.1",
      "body": "- Compatible with Zig 0.14.1\r\n- Fix an issue in `build.zig` preventing compilation in macOS hosts.\r\n\r\n### v0.2.0\r\n\r\n- Upgrade to Zig 0.14\r\n- Simple variable length integer encoding (strictly better space efficiency) by prefixing length in the tag byte.\r\n- Use ZigZag algorithm for efficiently encoding negative variable integers.\r\n- Rename `string` type to `bytes` because a string is just an array of bytes. Also makes it clear that the type is meant for arbitrary binary values, not just strings. We don't want multiple \"bytes\" types like in MessagePack.\r\n- `bool` is now stored directly inside it's tag, saving 1 byte per bool.\r\n- Change runtime `error.UnsupportedType`s to compile errors where possible.\r\n- Rename to `bufzilla` because the old name was similar to Z-buffers (term in 3-D graphics programming).",
      "prerelease": false,
      "published_at": "2025-05-26T04:55:08Z",
      "html_url": "https://github.com/theseyan/bufzilla/releases/tag/v2.1",
      "assets": []
    },
    {
      "tag_name": "v0.1.0",
      "name": "v0.1.0",
      "body": "",
      "prerelease": false,
      "published_at": "2025-02-12T06:31:52Z",
      "html_url": "https://github.com/theseyan/bufzilla/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_bio": "computer enthusiast",
  "owner_company": null,
  "owner_location": "Agartala, India",
  "owner_blog": "seyan.co",
  "owner_twitter_username": "sayanjdas",
  "owner_followers": 36,
  "owner_following": 3,
  "owner_created_at": "2017-08-13T05:59:42Z",
  "license": "MIT",
  "category": "library"
}