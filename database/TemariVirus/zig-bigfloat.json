{
  "name": "zig-bigfloat",
  "owner": "TemariVirus",
  "repo": "zig-bigfloat",
  "description": "Generic fixed-precision floating point type with large exponents",
  "type": "package",
  "topics": [
    "bignum",
    "floating-point",
    "zig-package"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-12-28T20:34:36Z",
  "minimum_zig_version": "0.15.0",
  "readme": "# zig-bigfloat\n\nzig-bigfloat represents a floating point value as `s * 2^e`,\nwhere `1 >= |s| > 2` is a regular floating point number and `e` is a signed integer.\nThis allows for extremely large and small numbers to be represented with a fixed number of bits,\nwithout excessive precision by selecting a suitable floating point type.\n\nzig-bigfloat is primarily optimized for speed over precision. Benchmark results are in [src/bench.zig](src/bench.zig).\n\n## Usage\n\nIn your project folder, run this to add zig-bigfloat to your `build.zig.zon`:\n\n```bash\nzig fetch git+https://github.com/TemariVirus/zig-bigfloat#<COMMIT-HASH>\n```\n\nThen, add the following to your `build.zig`:\n\n```zig\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // ...other build code\n\n    // Import zig-bigfloat's module into your own\n    const bigfloat = b.dependency(\"zig-bigfloat\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n    exe_mod.addImport(\"bigfloat\", bigfloat.module(\"bigfloat\"));\n\n    // ...other build code\n}\n```\n\nNow you can use zig-bigfloat in your code:\n\n```zig\nconst std = @import(\"std\");\nconst F = @import(\"bigfloat\").BigFloat(.{ .Significand = f64, .Exponent = i64 });\n\npub fn main() void {\n    const pie: F = .init(3.14);\n    // pie ^ BOOBIES = 5.097e3979479\n    std.debug.print(\"pie ^ BOOBIES = {e:.3}\\n\", .{pie.powi(8008135)});\n    // Or, if you prefer:\n    // std.debug.print(\"pie ^ BOOBIES = {e:.3}\\n\", .{F.powi(pie, 8008135)});\n}\n```\n\n## Use cases\n\n- Incremental games that require numbers larger than f128 can represent (~10^4932)\n- not sure, I just wanted to make an incremental game with big ass numbers\n\n## TODO\n\n- add decimal parser?\n  - https://github.com/tiehuis/parse-number-fxx-test-data\n- add exhaustive decimal formatting/parsing roundtrip tests over f16's range\n- fuzz test decimal formatting/parsing roundtripping for f32, f64, f80, f128\n\n## A note on correctness\n\nI'm 99% sure that the functions provided are correct, except for base-10 formatting (used by the `{f}`, `{d}` and `{e}` format specifiers).\n\nThe base-10 formatting uses Schubfach. I do not fully understand how to determine the precision needed for it to always be correct.\nI instead found the minimum precision needed for various bit-width floats to be formatted correctly by comparing it to Zig's float formating, then fit a line above the recorded points, and added an extra bit of precision just in case.\nI have been unable to find a failing example, but also do not have a proof of correctness.\n\nIf you need formatting and parsing to always roundtrip, use the `{x}`, `{o}` or `{b}` format specifiers, which are always exact.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/103554944?u=9410c585c693390d6d30eafb8c6872d9400c4dd5&v=4",
  "releases": [],
  "owner_bio": "I code cool stuff. Student of Singapore Institute of Technology.",
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 8,
  "owner_following": 7,
  "owner_created_at": "2022-04-13T04:56:24Z",
  "license": "MIT",
  "category": "library"
}