{
  "name": "ziglang-caches",
  "owner": "Jeevananthan-23",
  "repo": "ziglang-caches",
  "description": "In-memory cache implementation with commonly used LRU, W-LFU and S3-FIFO as the eviction policy",
  "type": "project",
  "topics": [
    "cache",
    "lfu-cache",
    "lru-cache",
    "sieve",
    "zig",
    "ziglang",
    "s3fifo",
    "zig-package"
  ],
  "stars": 15,
  "forks": 0,
  "watchers": 2,
  "updated_at": "2025-09-06T11:22:58Z",
  "minimum_zig_version": "0.12.0-dev.2334+aef1da163",
  "readme": "# ziglang-caches\n\nThis is a modern cache implementation, inspired by the following papers, provides high efficiency.\n\n- SIEVE | [SIEVE is Simpler than LRU: an Efficient Turn-Key Eviction Algorithm for Web Caches (NSDI'24)](https://junchengyang.com/publication/nsdi24-SIEVE.pdf)\n- S3-FIFO | [FIFO queues are all you need for cache eviction (SOSP'23)](https://dl.acm.org/doi/10.1145/3600006.3613147)\n- W-TinyLFU | [TinyLFU: A Highly Efficient Cache Admission Policy](https://arxiv.org/abs/1512.00727)\n\nThis offers state-of-the-art efficiency and scalability compared to other LRU-based cache algorithms.\n\n## Basic usage\n > [!LRU_Cache]\n > Least recents used cache eviction policy for cache your data in-memory for fast access. \n\n\n```zig\nconst std = @import(\"std\");\nconst lru = @import(\"lru\");\n\nconst cache = lru.LruCache(.locking, u8, []const u8);\n\npub fn main() !void {\n\n    // Create a cache backed by DRAM\n    var lrucache = try cache.init(std.heap.page_allocator, 4);\n    defer lrucache.deinit();\n\n    // Add an object to the cache\n    try lrucache.insert(1, \"one\");\n    try lrucache.insert(2, \"two\");\n    try lrucache.insert(3, \"three\");\n    try lrucache.insert(4, \"four\");\n\n    // Most recently used cache\n    std.debug.print(\"mru: {s} \\n\", .{lrucache.mru().?.value});\n\n    // least recently used cache\n    std.debug.print(\"lru: {s} \\n\", .{lrucache.lru().?.value});\n\n    // remove from cache\n    _ = lrucache.remove(1);\n\n    // Check if an object is in the cache O/P: false\n    std.debug.print(\"key: 1 exists: {} \\n\", .{lrucache.contains(1)});\n}\n```\n\n### :rocket: Usage\n\n1. Add `ziglang-caches` as a dependency in your `build.zig.zon`.\n\n    <details>\n\n    <summary><code>build.zig.zon</code> example</summary>\n\n    ```zig\n    .{\n        .name = \"<name_of_your_package>\",\n        .version = \"<version_of_your_package>\",\n        .dependencies = .{\n            .caches = .{\n                .url = \"https://github.com/jeevananthan-23/ziglang-caches/archive/<git_tag_or_commit_hash>.tar.gz\",\n                .hash = \"<package_hash>\",\n            },\n        },\n    }\n    ```\n\n    Set `<package_hash>` to `12200000000000000000000000000000000000000000000000000000000000000000`, and Zig will provide the correct found value in an error message.\n\n    </details>\n\n2. Add `lrucache` as a module in your `build.zig`.\n\n    <details>\n\n    <summary><code>build.zig</code> example</summary>\n\n    ```zig\n    const lrucache = b.dependency(\"caches\", .{});\n    exe.addModule(\"lrucache\", lrucache.module(\"lrucache\"));\n    ```\n\n    </details>\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/71455761?u=d78d00214fd830ecc1f3aaae39f27133a818f99b&v=4",
  "releases": [],
  "owner_bio": "Proactive Programmer",
  "owner_company": null,
  "owner_location": "India",
  "owner_blog": null,
  "owner_twitter_username": "Jeevananthan05",
  "owner_followers": 7,
  "owner_following": 12,
  "owner_created_at": "2020-09-17T16:06:59Z",
  "license": "MIT",
  "category": "library"
}