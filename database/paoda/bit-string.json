{
  "name": "bit-string",
  "owner": "paoda",
  "repo": "bit-string",
  "description": "",
  "type": "package",
  "topics": [
    "zig-library",
    "zig-package"
  ],
  "stars": 13,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-05-16T22:46:26Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.14.0",
  "readme": "# Bit String\n\n A library to check and extract values from integers based on a \"bit string\". Primarily intended for (my) emulator instruction decoding, but maybe someone else can find a use for it?\n\n## Example\n\n ```zig\n const std = @import(\"std\");\n\n test \"doc test\" {\n    const value: u8 = 0b10001011;\n\n    try std.testing.expectEqual(true, match(\"1000_1011\", value));\n    try std.testing.expectEqual(false, match(\"11111011\", value));\n    try std.testing.expectEqual(true, match(\"1---1011\", value));\n\n    {\n        const ret = extract(\"1000aaaa\", value);\n        try std.testing.expectEqual(@as(u4, 0b1011), ret.a);\n    }\n    {\n        const ret = extract(\"1aaa1aaa\", value);\n        try std.testing.expectEqual(@as(u6, 0b000011), ret.a);\n    }\n    {\n        const ret = extract(\"1---abcd\", value);\n        try std.testing.expectEqual(@as(u3, 0b1), ret.a);\n        try std.testing.expectEqual(@as(u3, 0b0), ret.b);\n        try std.testing.expectEqual(@as(u3, 0b1), ret.c);\n        try std.testing.expectEqual(@as(u3, 0b1), ret.d);\n    }\n }\n ```\n\n## Syntax\n\n |  Token  |  Meaning  | Description\n | ------- | --------- | -----------\n | `0`     | Clear bit | In the equivalent position, the value's bit must be cleared.\n | `1`     | Set bit   | In the equivalent position, the value's bit must be set.\n | `a..=z` | Variable  | Given the 4-bit bit string, `\"1aa0\"`, the value `0b1010` would produce the variable `a` with the value `0b01`\n | `-`     | Ignored   | In the equivalent position, the value's bit does not matter.\n | `_`     | Ignored*  | Underscores are completely ignored during parsing, use to make bit strings easier to read e.g. `1111_1111`\n\n## Notes\n\n- This library does the majority of it's work at `comptime`. Due to this, you cannot create strings to match against at runtime.\n- Variables do not have to be \"sequential\". This means the 5-bit bit string `\"1aa0a\"` with the value `0b10101` will produce the variable `a` with the value `0b011`.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/22038970?u=7d82a47c81f4722620030dd3cc064cd80098fd56&v=4",
  "releases": [],
  "owner_bio": "Freelance Developer + University of Manitoba Student",
  "owner_company": null,
  "owner_location": "Winnipeg, Manitoba, Canada",
  "owner_blog": "https://musuka.dev",
  "owner_twitter_username": "paoda_",
  "owner_followers": 64,
  "owner_following": 58,
  "owner_created_at": "2016-09-06T22:02:43Z",
  "license": "MIT",
  "category": "library"
}