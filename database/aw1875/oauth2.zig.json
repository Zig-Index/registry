{
  "name": "oauth2.zig",
  "owner": "aw1875",
  "repo": "oauth2.zig",
  "description": "A light weight oauth2 wrapper for zig",
  "type": "package",
  "topics": [
    "zig-package",
    "oauth2",
    "zig"
  ],
  "stars": 2,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-12-13T00:20:12Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# oauth2.zig\n\nA light weight oauth2 wrapper for zig. Contains implementations for the authorization code flow with no external dependencies.\n\n## Installation\n\nAdd oauth2.zig as a dependency to your project with:\n\n```sh\nzig fetch --save git+https://github.com/aw1875/oauth2.zig\n```\n\nThen, add it as a dependency in your `build.zig` file:\n\n```zig\nconst oauth2 = b.dependency(\"oauth2\", .{ .target = target, .optimize = optimize });\nexe.root_module.addImport(\"oauth2\", oauth2.module(\"oauth2\"));\n```\n\n## Supported Providers\n\nThis is a work in progress, but currently supports the following providers:\n- [BattleNet](https://develop.battle.net/documentation/guides/using-oauth)\n- [Coinbase](https://docs.cdp.coinbase.com/coinbase-app/docs/auth/oauth-integration)\n- [Discord](https://discord.com/developers/docs/topics/oauth2)\n- [GitHub](https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps)\n- [Google](https://developers.google.com/identity/protocols/oauth2)\n- [LinkedIn](https://docs.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow)\n\nThe BaseOAuth2Provider is also exposed, which allows you to create your own custom provider by directly accessing the underlying OAuth2 functions used by each provider. See [CustomProvider](#custom-provider)\n\n## Examples\n\nCheck out the [examples folder](./examples) for a few examples of how to use the library with different providers.\n\n#### Custom Provider\n\nWe'll use Google here for clarity, but the `BaseOAuth2Provider` just exposes all the underlying functions used by any given individual provider.\nOne important thing to note, depending on your provider you may need to use the `createAuthorizationUrlWithPKCE` version when creating your authorization URL.\nThe `code_verifier` is only required for providers that require this (Google is a great example):\n\n```zig\nconst std = @import(\"std\");\n\nconst httpz = @import(\"httpz\");\nconst oauth2 = @import(\"oauth2\");\n\nconst CustomProvider = oauth2.BaseOAuth2Provider;\n\nconst SessionData = struct {\n    state: []const u8,\n    code_verifier: []const u8,\n    expires_at: u64,\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    defer if (gpa.deinit() != .ok) @panic(\"Failed to deinitialize allocator\");\n\n    var oauth2_provider = try CustomProvider.init(allocator, .{\n        .client_id = \"<google_client_id>\",\n        .client_secret = \"<google_client_secret>\",\n        .redirect_uri = \"http://localhost:3000/api/v1/oauth/google/callback\",\n    });\n    defer oauth2_provider.deinit();\n\n    var session_store = std.StringHashMap(SessionData).init(allocator);\n    defer session_store.deinit();\n\n    var app = App{ .oauth = &oauth2_provider, .session_store = &session_store };\n\n    var server = try httpz.Server(*App).init(allocator, .{ .port = 3000 }, &app);\n    defer {\n        server.stop();\n        server.deinit();\n    }\n\n    var router = try server.router(.{});\n    router.get(\"/api/v1/oauth/google\", handleLogin, .{});\n    router.get(\"/api/v1/oauth/google/callback\", handleCallback, .{});\n\n    try server.listen();\n}\n\nconst App = struct {\n    oauth: *CustomProvider,\n    session_store: *std.StringHashMap(SessionData),\n};\n\nfn handleLogin(app: *App, _: *httpz.Request, res: *httpz.Response) !void {\n    const state = try oauth2.createStateNonce(res.arena);\n    const code_verifier = try oauth2.createStateNonce(res.arena);\n    const url = try app.oauth.createAuthorizationUrlWithPKCE(\n        res.arena,\n        \"https://accounts.google.com/o/oauth2/v2/auth\",\n        state,\n        \"S256\",\n        code_verifier,\n        &[_][]const u8{ \"email\", \"profile\", \"openid\" },\n    );\n\n    const session_id = try oauth2.createStateNonce(res.arena);\n    try app.session_store.put(session_id, SessionData{\n        .state = state,\n        .code_verifier = code_verifier,\n        .expires_at = @intCast(std.time.milliTimestamp() + (60 * 5 * 1000)), // 5 minutes\n    });\n\n    try res.setCookie(\"example.sid\", session_id, .{ .path = \"/\", .secure = true, .http_only = true, .max_age = 60 * 5 }); // Session ID cookie\n\n    res.headers.add(\"Location\", url);\n    res.setStatus(.found);\n}\n\nfn handleCallback(app: *App, req: *httpz.Request, res: *httpz.Response) !void {\n    const query = try req.query();\n\n    if (query.get(\"error\") != null) {\n        std.log.err(\"OAuth Error: {s}\", .{query.get(\"error\").?});\n        return res.setStatus(.internal_server_error);\n    }\n\n    const code = query.get(\"code\") orelse {\n        std.log.err(\"Missing 'code' parameter in OAuth callback.\", .{});\n        return res.setStatus(.internal_server_error);\n    };\n\n    const state = query.get(\"state\") orelse {\n        std.log.err(\"Missing 'state' parameter in OAuth callback.\", .{});\n        return res.setStatus(.internal_server_error);\n    };\n\n    const session_id = req.cookies().get(\"example.sid\") orelse {\n        std.log.err(\"Missing 'session ID' cookie in OAuth callback.\", .{});\n        return res.setStatus(.bad_request);\n    };\n\n    try res.setCookie(\"example.sid\", \"\", .{ .path = \"/\", .secure = true, .http_only = true, .max_age = 0 }); // Clear session ID cookie\n\n    const session_data = app.session_store.fetchRemove(session_id) orelse {\n        std.log.err(\"Invalid session ID: {s}\", .{session_id});\n        return res.setStatus(.bad_request);\n    };\n\n    if (std.time.milliTimestamp() > session_data.value.expires_at) {\n        std.log.err(\"Session expired for ID: {s}\", .{session_id});\n        return res.setStatus(.unauthorized);\n    }\n\n    if (!std.mem.eql(u8, state, session_data.value.state)) {\n        std.log.err(\"State mismatch: expected {s}, got {s}\", .{ session_data.value.state, state });\n        return res.setStatus(.bad_request);\n    }\n\n    return res.json(try app.oauth.validateAuthorizationCode(GoogleTokenResponse, res.arena, \"https://oauth2.googleapis.com/token\", code, session.code_verifier), .{});\n}\n\n// This is the response we expect to get back when validating the authorization code\npub const GoogleTokenResponse = struct {\n    access_token: []const u8,\n    expires_in: i64,\n    refresh_token: ?[]const u8 = null,\n    scope: []const u8,\n    token_type: []const u8,\n    id_token: []const u8,\n};\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/4970015?v=4",
  "releases": [],
  "owner_bio": "Software Engineering Student @ RIT",
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://wolfyy.me",
  "owner_twitter_username": null,
  "owner_followers": 20,
  "owner_following": 1,
  "owner_created_at": "2013-07-09T03:27:36Z",
  "license": "MIT",
  "category": "library"
}