{
  "name": "env-struct.zig",
  "owner": "xarunoba",
  "repo": "env-struct.zig",
  "description": "ðŸŒ± â€” Parse environment variables into typed structs in Zig",
  "type": "package",
  "topics": [
    "env",
    "environment-variables",
    "env-parser",
    "struct",
    "env-struct",
    "zig-library",
    "zig-package",
    "zig"
  ],
  "stars": 7,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-21T02:58:38Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.15.2",
  "readme": "# @xarunoba/env-struct.zig ðŸŒ±\n\n![Static Badge](https://img.shields.io/badge/Made_with-%E2%9D%A4%EF%B8%8F-red?style=for-the-badge) ![Static Badge](https://img.shields.io/badge/Zig-0.15.1-orange?style=for-the-badge&logo=zig) ![GitHub License](https://img.shields.io/github/license/xarunoba/env-struct?style=for-the-badge)\n\n**`env-struct`** â€” environment variables to typed structs\n\nA Zig library for parsing environment variables directly into typed structs, providing automatic type conversion and validation.\n\n> [!NOTE]\n> This library does not read environment variables from files; it only parses existing environment variables into a struct.\n\n> [!WARNING]\n> **`env-struct` is currently in v0. Every release might have breaking changes before `v1.0.0`. Make sure to specify the version you'd like to use.**\n\n## Why\n\nManaging configuration with environment variables is common, but environment variables are always strings and require manual parsing and validation. `env-struct` eliminates boilerplate by mapping environment variables directly to typed Zig structs, providing automatic type conversion and validation at load time. This approach improves safety, reduces errors, and makes configuration handling more robust and maintainable.\n\n> [!NOTE]\n> This is my first ever Zig project so feel free to contribute and send PRs!\n\n## Features\n\n- âœ… **Type-safe**: Automatically parse environment variables into the correct types\n- âœ… **Multiple types**: Strings, integers, floats, booleans, and nested structs\n- âœ… **Optional fields**: Support for optional fields with defaults\n- âœ… **Flexible mapping**: Fields map to their names by default, optional custom mapping\n- âœ… **Skip fields**: Map fields to \"-\" to explicitly skip environment variable lookup\n- âœ… **Flexible boolean parsing**: Parse \"true\", \"1\", \"yes\" (case-insensitive) as true\n- âœ… **Custom parsers**: Validation and complex parsing functions for advanced use cases\n- âœ… **Custom environment maps**: Load from custom maps for testing\n\n## Installation\n\n### Using `zig fetch` (Recommended)\n\nAdd this library to your project using `zig fetch`:\n\n```bash\nzig fetch --save \"git+https://github.com/xarunoba/env-struct.zig#v0.10.0\"\n```\n\nThen in your `build.zig`:\n\n```zig\nconst env_struct = b.dependency(\"env_struct\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"env_struct\", env_struct.module(\"env_struct\"));\n```\n\n### Direct Copy\n\nAlternatively, you can directly copy the [`env_struct.zig`](./src/env_struct.zig) file from the `src/` directory into your project and import it locally to prevent any external dependencies:\n\n```zig\nconst env_struct = @import(\"env_struct.zig\");\n```\n\n## Usage\n\n```zig\nconst std = @import(\"std\");\nconst env_struct = @import(\"env_struct\");\n\nconst Config = struct {\n    APP_NAME: []const u8,    // Maps to \"APP_NAME\" env var\n    PORT: u32,               // Maps to \"PORT\" env var\n    DEBUG: bool = false,     // Maps to \"DEBUG\" env var, defaults to false\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}).init;\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    const config = try env_struct.load(Config, allocator);\n\n    std.debug.print(\"App: {s}\\n\", .{config.APP_NAME});\n    std.debug.print(\"Port: {}\\n\", .{config.PORT});\n}\n```\n\nSet environment variables:\n```bash\nexport APP_NAME=\"My App\"\nexport PORT=\"8080\"\n```\n\n### Custom Mapping\n\n#### Mapping Rules\n\nFields are mapped to environment variables with these behaviors:\n\n- **Default mapping**: Fields automatically map to environment variables with the same name\n- **Custom mapping**: Use the `env` declaration to map fields to different environment variable names\n- **Skip mapping**: Map a field to `\"-\"` to skip environment variable lookup (must have default values or be optional)\n- **Field requirements**: Fields without default values must either have corresponding environment variables or be optional\n- **Optional env declaration**: The `env` declaration is only needed for custom mappings or parsing/validation\n\n```zig\nconst Config = struct {\n    name: []const u8,\n    port: u32,\n    debug: bool = false,\n    timeout: ?f32 = null,\n\n    const env = .{\n        .name = \"APP_NAME\",\n        .port = \"PORT\",\n        .debug = \"DEBUG\",\n        .timeout = \"TIMEOUT\",\n    };\n};\n\nconst config = try env_struct.load(Config, allocator);\n```\n\nSet environment variables:\n```bash\nexport APP_NAME=\"My App\"\nexport PORT=\"8080\"\n```\n\n## Advanced Usage\n\n### Custom Parsers and Validators\n\nThe library provides two main approaches for custom parsing:\n\n#### 1. Validators (Recommended for validation)\nUse the `validator` function to combine default parsing with custom validation:\n\n```zig\nconst std = @import(\"std\");\nconst env_struct = @import(\"env_struct\");\n\n// Simple validation function\nfn validatePort(port: u32) !u32 {\n    if (port > 65535) return error.InvalidPort;\n    return port;\n}\n\nconst Config = struct {\n    port: u32,\n\n    const env = .{\n        .port = .{\n            .key = \"PORT\",  // .key can be omitted to use field name automatically\n            .parser = env_struct.validator(u32, validatePort),\n        },\n    };\n};\n```\n\n#### 2. Full Custom Parsers\nFor complex parsing logic that doesn't use default parsing:\n\n```zig\n// Enum parsing function\nconst LogLevel = enum { debug, info, warn, err };\n\nfn parseLogLevel(raw: []const u8, allocator: std.mem.Allocator) !LogLevel {\n    _ = allocator; // unused in this case\n    if (std.mem.eql(u8, raw, \"debug\")) return .debug;\n    if (std.mem.eql(u8, raw, \"info\")) return .info;\n    if (std.mem.eql(u8, raw, \"warn\")) return .warn;\n    if (std.mem.eql(u8, raw, \"error\")) return .err;\n    return error.InvalidLogLevel;\n}\n\nconst Config = struct {\n    port: u32,\n    log_level: LogLevel,\n\n    const env = .{\n        .port = .{\n            .key = \"PORT\",\n            .parser = env_struct.validator(u32, validatePort),\n        },\n        .log_level = .{\n            .key = \"LOG_LEVEL\",\n            .parser = parseLogLevel,\n        },\n    };\n};\n```\n\n**Key Points:**\n- `.key` is the environment variable name, can be omitted to use the field name\n- `.parser` is the custom parser function, can be a validator or a full custom parser\n- Use `validator()` when you want default parsing + validation\n- Use custom parsers for complex parsing that doesn't follow default rules\n- All custom parsers use the signature: `fn(raw: []const u8, allocator: Allocator) !T`\n- The `parseValue()` function is available for implementing custom parsers that want to reuse default parsing\n\n### Nested Structs & Complex Configuration\n\n```zig\nconst Config = struct {\n    app_name: []const u8,           // Maps to \"app_name\" env var\n    custom_port: u32,               // Maps to \"PORT\" env var (custom mapping)\n    debug: bool = false,            // Maps to \"debug\" env var, uses default\n    internal_field: []const u8 = \"computed\",  // Skipped from env lookup\n    optional_feature: ?u32,         // Maps to \"optional_feature\", can be null\n\n    const env = .{\n        .custom_port = \"PORT\",      // Custom environment variable name\n        .internal_field = \"-\",      // Skip environment variable lookup\n    };\n};\n```\n\n### Custom Environment Maps\n\n```zig\nconst DatabaseConfig = struct {\n    host: []const u8,\n    port: u32 = 5432,\n\n    const env = .{\n        .host = \"DB_HOST\",\n        .port = \"DB_PORT\",\n    };\n};\n\nconst ServerConfig = struct {\n    host: []const u8 = \"localhost\",\n    port: u32,\n    database: DatabaseConfig,\n\n    const env = .{\n        .host = \"SERVER_HOST\",\n        .port = \"SERVER_PORT\",\n    };\n};\n\n// Load from system environment\nconst config = try env_struct.load(ServerConfig, allocator);\n\n// Or load from custom environment map (useful for testing)\nvar custom_env = std.process.EnvMap.init(allocator);\ndefer custom_env.deinit();\ntry custom_env.put(\"SERVER_PORT\", \"3000\");\nconst test_config = try env_struct.loadMap(ServerConfig, custom_env, allocator);\n```\n\n## Built-in Parser Supported Types\n\n| Type | Examples | Notes |\n|------|----------|-------|\n| `[]const u8` | `\"hello\"` | String values |\n| `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `\"42\"`, `\"-123\"` | Signed integers |\n| `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `\"42\"`, `\"255\"` | Unsigned integers |\n| `f16`, `f32`, `f64`, `f80`, `f128` | `\"3.14\"` | Floating point |\n| `bool` | `\"true\"`, `\"1\"`, `\"yes\"` | Case-insensitive |\n| `enum` | `\"debug\"`, `\"info\"` | Matches enum field names |\n| `?T` | Any valid `T` or missing | Optional types |\n| `struct` | N/A | Nested structs |\n\n## API\n\n### `load(comptime T: type, allocator: std.mem.Allocator) !T`\nLoad configuration from system environment variables.\n\n### `loadMap(comptime T: type, env_map: std.process.EnvMap, allocator: std.mem.Allocator) !T`\nLoad configuration from a custom environment map.\n\n### `parseValue(comptime T: type, raw_value: []const u8, allocator: std.mem.Allocator) !T`\nParse a raw string value into the specified type. Useful for implementing custom parsers that want to preserve default parsing behavior.\n\n### `validator(comptime T: type, comptime validateFn: anytype) fn([]const u8, std.mem.Allocator) anyerror!T`\nCreate a validator function that combines default parsing with custom validation. The validation function should have the signature `fn(T) !T`.\n\n### Custom Parser Function Signature\n\nCustom parsers must follow this signature:\n\n```zig\nfn parserFunction(raw_value: []const u8, allocator: std.mem.Allocator) !T\n```\n\nWhere:\n- `raw_value`: The raw string from the environment variable\n- `allocator`: Memory allocator for dynamic allocations (can be ignored if not needed)\n- `T`: The target type to parse into\n- Returns the parsed value or an error\n\n### Validator Function Signature\n\nValidator functions used with `validator()` should have this signature:\n\n```zig\nfn validatorFunction(value: T) !T\n```\n\nWhere:\n- `value`: The already-parsed value from default parsing\n- `T`: The type being validated\n- Returns the validated value or an error\n\n## Building\n\n```bash\nzig build\n```\n\n## Testing\n\n```bash\nzig test src/env_struct.zig\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/68542460?v=4",
  "releases": [],
  "owner_bio": "Avid programming enthusiast.\r\n\r\n",
  "owner_company": null,
  "owner_location": "Philippines",
  "owner_blog": "https://xaru.win",
  "owner_twitter_username": null,
  "owner_followers": 12,
  "owner_following": 16,
  "owner_created_at": "2020-07-20T10:33:46Z",
  "license": "MIT",
  "category": "library"
}