{
  "name": "env-struct.zig",
  "owner": "xarunoba",
  "repo": "env-struct.zig",
  "description": "ðŸŒ± â€” Parse environment variables into typed structs in Zig",
  "type": "package",
  "topics": [
    "env",
    "environment-variables",
    "env-parser",
    "struct",
    "env-struct",
    "zig-library",
    "zig-package",
    "zig"
  ],
  "stars": 7,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-24T08:49:32Z",
  "dependencies": [
    {
      "name": "example",
      "url": "https://example.com/foo.tar.gz",
      "hash": "..."
    }
  ],
  "minimum_zig_version": "0.15.2",
  "readme": "# @xarunoba/env-struct.zig ðŸŒ±\n\n![Static Badge](https://img.shields.io/badge/Made_with-%E2%9D%A4%EF%B8%8F-red?style=for-the-badge) ![Static Badge](https://img.shields.io/badge/Zig-0.15.2-orange?style=for-the-badge&logo=zig) ![GitHub License](https://img.shields.io/github/license/xarunoba/env-struct?style=for-the-badge)\n\n**`env-struct`** â€” environment variables to typed structs\n\nA Zig library for parsing environment variables directly into typed structs, providing automatic type conversion and validation.\n\n> [!NOTE]\n> This library does not read environment variables from files; it only parses existing environment variables into a struct.\n\n> [!WARNING]\n> **`env-struct` is currently in v0. Every release might have breaking changes before `v1.0.0`. Make sure to specify the version you'd like to use.**\n\n## Why\n\nManaging configuration with environment variables is common, but environment variables are always strings and require manual parsing and validation. `env-struct` eliminates boilerplate by mapping environment variables directly to typed Zig structs, providing automatic type conversion and validation at load time. This approach improves safety, reduces errors, and makes configuration handling more robust and maintainable.\n\n> [!NOTE]\n> This is my first ever Zig project so feel free to contribute and send PRs!\n\n## Features\n\n- âœ… **Zero-allocation by default**: String fields borrow from EnvMap, no heap copies needed\n- âœ… **Type-safe**: Automatically parse environment variables into the correct types\n- âœ… **Multiple types**: Strings, integers, floats, booleans, and nested structs\n- âœ… **Optional fields**: Support for optional fields with defaults\n- âœ… **Flexible mapping**: Fields map to their names by default, optional custom mapping\n- âœ… **Skip fields**: Map fields to \"-\" to explicitly skip environment variable lookup\n- âœ… **Flexible boolean parsing**: Parse \"true\", \"1\", \"yes\" (case-insensitive) as true\n- âœ… **Custom parsers**: Validation and complex parsing functions for advanced use cases\n- âœ… **Custom environment maps**: Load from custom maps for testing\n\n## Installation\n\n### Using `zig fetch` (Recommended)\n\nAdd this library to your project using `zig fetch`:\n\n```bash\nzig fetch --save \"git+https://github.com/xarunoba/env-struct.zig#v0.11.0\"\n```\n\nThen in your `build.zig`:\n\n```zig\nconst env_struct = b.dependency(\"env_struct\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"env_struct\", env_struct.module(\"env_struct\"));\n```\n\n### Direct Copy\n\nAlternatively, you can directly copy the [`env_struct.zig`](./src/env_struct.zig) file from the `src/` directory into your project and import it locally to prevent any external dependencies:\n\n```zig\nconst env_struct = @import(\"env_struct.zig\");\n```\n\n## Usage\n\n```zig\nconst std = @import(\"std\");\nconst env_struct = @import(\"env_struct\");\n\nconst Config = struct {\n    APP_NAME: []const u8,    // Maps to \"APP_NAME\" env var\n    PORT: u32,               // Maps to \"PORT\" env var\n    DEBUG: bool = false,     // Maps to \"DEBUG\" env var, defaults to false\n};\n\npub fn main() !void {\n    var config = try env_struct.load(Config);\n    defer config.deinit();  // Frees the EnvMap\n\n    std.debug.print(\"App: {s}\\n\", .{config.value.APP_NAME});\n    std.debug.print(\"Port: {}\\n\", .{config.value.PORT});\n}\n```\n\n> [!NOTE]\n> String fields are borrowed slices pointing into the internal EnvMap. The wrapper struct owns the EnvMap and provides a `deinit()` method to clean up. No heap allocation occurs for string fields.\n\nSet environment variables:\n```bash\nexport APP_NAME=\"My App\"\nexport PORT=\"8080\"\n```\n\n### Custom Mapping\n\n#### Mapping Rules\n\nFields are mapped to environment variables with these behaviors:\n\n- **Default mapping**: Fields automatically map to environment variables with the same name\n- **Custom mapping**: Use the `env` declaration to map fields to different environment variable names\n- **Skip mapping**: Map a field to `\"-\"` to skip environment variable lookup (must have default values or be optional)\n- **Field requirements**: Fields without default values must either have corresponding environment variables or be optional\n- **Optional env declaration**: The `env` declaration is only needed for custom mappings or parsing/validation\n\n```zig\nconst Config = struct {\n    name: []const u8,\n    port: u32,\n    debug: bool = false,\n    timeout: ?f32 = null,\n\n    const env = .{\n        .name = \"APP_NAME\",\n        .port = \"PORT\",\n        .debug = \"DEBUG\",\n        .timeout = \"TIMEOUT\",\n    };\n};\n\nconst config = try env_struct.load(Config);\ndefer config.deinit();\n```\n\nSet environment variables:\n```bash\nexport APP_NAME=\"My App\"\nexport PORT=\"8080\"\n```\n\n## Advanced Usage\n\n### Custom Parsers and Validators\n\nThe library provides two approaches for custom parsing, optimized for zero-allocation:\n\n#### 1. Validators (Recommended for validation)\nUse the `validator` function to combine default parsing with custom validation. Validators don't require an allocator:\n\n```zig\nconst std = @import(\"std\");\nconst env_struct = @import(\"env_struct\");\n\n// Simple validation function\nfn validatePort(port: u32) !u32 {\n    if (port > 65535) return error.InvalidPort;\n    return port;\n}\n\nconst Config = struct {\n    port: u32,\n\n    const env = .{\n        .port = .{\n            .key = \"PORT\",  // .key can be omitted to use field name automatically\n            .parser = env_struct.validator(u32, validatePort),\n        },\n    };\n};\n```\n\n#### 2. Full Custom Parsers\nFor complex parsing logic that doesn't use default parsing:\n\n```zig\n// Enum parsing function (zero-allocation)\nconst LogLevel = enum { debug, info, warn, err };\n\nfn parseLogLevel(raw: []const u8) !LogLevel {\n    if (std.mem.eql(u8, raw, \"debug\")) return .debug;\n    if (std.mem.eql(u8, raw, \"info\")) return .info;\n    if (std.mem.eql(u8, raw, \"warn\")) return .warn;\n    if (std.mem.eql(u8, raw, \"error\")) return .err;\n    return error.InvalidLogLevel;\n}\n\nconst Config = struct {\n    port: u32,\n    log_level: LogLevel,\n\n    const env = .{\n        .port = .{\n            .key = \"PORT\",\n            .parser = env_struct.validator(u32, validatePort),\n        },\n        .log_level = .{\n            .key = \"LOG_LEVEL\",\n            .parser = parseLogLevel,\n        },\n    };\n};\n```\n\n#### 3. Parsers That Require Allocation\nFor parsers that need to allocate (e.g., parsing arrays):\n\n```zig\n// Array parsing function (requires allocator)\nfn parseStringArray(raw: []const u8, allocator: std.mem.Allocator) ![][]const u8 {\n    if (raw.len == 0) return &[_][]const u8{};\n\n    var result = std.ArrayList([]const u8).init(allocator);\n    defer result.deinit();\n\n    var iter = std.mem.splitScalar(u8, raw, ',');\n    while (iter.next()) |item| {\n        const trimmed = std.mem.trim(u8, item, \" \\t\");\n        if (trimmed.len > 0) {\n            const owned = try allocator.dupe(u8, trimmed);\n            try result.append(owned);\n        }\n    }\n\n    return result.toOwnedSlice();\n}\n\nconst Config = struct {\n    tags: [][]const u8,\n\n    const env = .{\n        .tags = .{\n            .key = \"TAGS\",\n            .parser = parseStringArray,\n        },\n    };\n};\n```\n\n**Key Points:**\n- `.key` is the environment variable name, can be omitted to use field name\n- `.parser` is the custom parser function\n- Use `validator()` when you want default parsing + validation (no allocator needed)\n- Zero-allocation parsers: `fn(raw: []const u8) !T`\n- Allocating parsers: `fn(raw: []const u8, allocator: std.mem.Allocator) !T`\n- The `parseValue()` function is available for implementing custom parsers that want to reuse default parsing\n\n### Nested Structs & Complex Configuration\n\n```zig\nconst Config = struct {\n    app_name: []const u8,           // Maps to \"app_name\" env var\n    custom_port: u32,               // Maps to \"PORT\" env var (custom mapping)\n    debug: bool = false,            // Maps to \"debug\" env var, uses default\n    internal_field: []const u8 = \"computed\",  // Skipped from env lookup\n    optional_feature: ?u32,         // Maps to \"optional_feature\", can be null\n\n    const env = .{\n        .custom_port = \"PORT\",      // Custom environment variable name\n        .internal_field = \"-\",      // Skip environment variable lookup\n    };\n};\n```\n\n### Custom Environment Maps\n\n```zig\nconst DatabaseConfig = struct {\n    host: []const u8,\n    port: u32 = 5432,\n\n    const env = .{\n        .host = \"DB_HOST\",\n        .port = \"DB_PORT\",\n    };\n};\n\nconst ServerConfig = struct {\n    host: []const u8 = \"localhost\",\n    port: u32,\n    database: DatabaseConfig,\n\n    const env = .{\n        .host = \"SERVER_HOST\",\n        .port = \"SERVER_PORT\",\n    };\n};\n\n// Load from system environment\nvar config = try env_struct.load(ServerConfig);\ndefer config.deinit();\n\n// Or load from custom environment map (useful for testing)\nvar custom_env = std.process.EnvMap.init(std.testing.allocator);\ndefer custom_env.deinit();\ntry custom_env.put(\"SERVER_PORT\", \"3000\");\nconst test_config = try env_struct.loadMap(ServerConfig, custom_env);\n```\n\n> [!NOTE]\n> When using `loadMap()`, the returned configuration borrows string slices from the provided `env_map`. Ensure the `env_map` outlives the configuration. For production use with allocating parsers, prefer `load()` which handles memory management automatically.\n\n## Built-in Parser Supported Types\n\n| Type | Examples | Notes |\n|------|----------|-------|\n| `[]const u8` | `\"hello\"` | String values (borrowed slice, zero allocation) |\n| `i8`, `i16`, `i32`, `i64`, `i128`, `isize` | `\"42\"`, `\"-123\"` | Signed integers |\n| `u8`, `u16`, `u32`, `u64`, `u128`, `usize` | `\"42\"`, `\"255\"` | Unsigned integers |\n| `f16`, `f32`, `f64`, `f80`, `f128` | `\"3.14\"` | Floating point |\n| `bool` | `\"true\"`, `\"1\"`, `\"yes\"` | Case-insensitive |\n| `enum` | `\"debug\"`, `\"info\"` | Matches enum field names |\n| `?T` | Any valid `T` or missing | Optional types |\n| `struct` | N/A | Nested structs |\n\n## API\n\n### `load(comptime T: type) !ConfigWrapper(T)`\nLoad configuration from system environment variables. Returns a wrapper struct that owns the EnvMap and contains the configuration.\n\n```zig\nconst ConfigWrapper = struct {\n    value: T,\n    env_map: std.process.EnvMap,\n\n    pub fn deinit(self: *Self) void {\n        self.env_map.deinit();\n    }\n};\n```\n\n### `loadMap(comptime T: type, env_map: std.process.EnvMap) !T`\nLoad configuration from a custom environment map. All string fields are borrowed slices pointing into the provided `env_map`. The `env_map` must outlive the returned configuration.\n\n### `parseValue(comptime T: type, raw_value: []const u8) !T`\nParse a raw string value into the specified type. Returns borrowed slices for string types. Useful for implementing custom parsers that want to reuse default parsing behavior.\n\n### `validator(comptime T: type, comptime validateFn: anytype) fn([]const u8) anyerror!T`\nCreate a validator function that combines default parsing with custom validation. The validation function should have the signature `fn(T) !T`.\n\n### Custom Parser Function Signature\n\nCustom parsers can use either signature:\n\n**Zero-allocation parser (preferred):**\n```zig\nfn parserFunction(raw_value: []const u8) !T\n```\n\n**Parser with allocation (for complex types):**\n```zig\nfn parserFunction(raw_value: []const u8, allocator: std.mem.Allocator) !T\n```\n\nWhere:\n- `raw_value`: The raw string from the environment variable\n- `allocator`: Memory allocator for dynamic allocations (only for allocating parsers)\n- `T`: The target type to parse into\n- Returns the parsed value or an error\n\n### Validator Function Signature\n\nValidator functions used with `validator()` should have this signature:\n\n```zig\nfn validatorFunction(value: T) !T\n```\n\nWhere:\n- `value`: The already-parsed value from default parsing\n- `T`: The type being validated\n- Returns the validated value or an error\n\n## Building\n\n```bash\nzig build\n```\n\n## Testing\n\n```bash\nzig test src/env_struct.zig\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/68542460?v=4",
  "releases": [],
  "owner_bio": "Avid programming enthusiast.\r\n\r\n",
  "owner_company": null,
  "owner_location": "Philippines",
  "owner_blog": "https://xaru.win",
  "owner_twitter_username": null,
  "owner_followers": 12,
  "owner_following": 16,
  "owner_created_at": "2020-07-20T10:33:46Z",
  "license": "MIT",
  "category": "library"
}