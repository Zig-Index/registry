{
  "name": "edn-data",
  "owner": "travisstaloch",
  "repo": "edn-data",
  "description": "An edn (extensibile data notation) library in zig",
  "type": "package",
  "topics": [
    "zig-package"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-11-03T23:58:36Z",
  "dependencies": [
    {
      "name": "zig_afl_kit",
      "url": "git+https://github.com/kristoff-it/zig-afl-kit#e8026e45fb8b7c62515e753a1911ba97b60c1d00",
      "hash": "afl_kit-0.1.0-NdJ3cncdAADtO8S74G1yMYKO1f2XoHputmaJBInsHLp2"
    }
  ],
  "readme": "## EDN Data - Extensible Data Notation for Zig\n\nA parser for [Extensible Data Notation (EDN)](https://github.com/edn-format/edn) implemented in Zig. EDN is a data format akin to JSON or [Ziggy](https://ziggy-lang.io/) but with more data types and extensibility features, commonly used in Clojure.\n\nThis library provides both runtime and compile-time parsing capabilities for EDN data in Zig applications.\n\n#### Table of Contents\n- [Features](#features)\n- [Usage](#usage)\n\n#### Features\n* parse arbitrary data with `edn.parseFromSlice(edn.Result, ...)` or `edn.parseFromSliceBuf()`.  `edn.measure()` is used to determine required buffer sizes for `parseFromSliceBuf()`.\n  * `edn.Options.whitespace` - whether to save whitespace and comments.  false means to minify and each whitespace/comment span will be replaced by a single space in `fmtParseResult()`.\n* parse structured data with `edn.parseFromSlice(T)`\n  * custom parsing when `T` provides a  `pub fn ednParse()`.  see [src/tests.zig](src/tests.zig) `test \"ednParse()\"` for an example.\n* [tagged element](https://github.com/edn-format/edn#tagged-elements) handlers.  see [src/tests.zig](src/tests.zig) `test \"tagged handler\"` for an example.\n* `ParseResult.find()` - access parsed data with simple queries such as `'0//1//foo'`.  see [src/tests.zig](src/tests.zig) `test \"ParseResult find()\"` for examples.\n* comptime parsing\n  * parse arbitrary data with `edn.parseFromSliceComptime()`\n  * parse structured data with `comptime edn.parseFromSlice(T)`\n* formatting\n  * format parse results with `parse_result.formatter(src)`\n\n#### Tools\n```console\n$ zig-out/bin/edn-parse\n\nerror: MissingArgs\n\nusage: <options?> <input-file>\n\n  parse <input-file> and print formatted edn to stdout.\n\noptions:\n  --json-to-edn: convert json <input-file> to edn\n```\n\n#### Usage\nfetch with the package manager\n```console\n# with zig 0.14.0\n$ zig fetch --save git+https://github.com/travisstaloch/edn-data#0.14.0\n```\n```console\n# with zig nightly - TODO\n$ zig fetch --save git+https://github.com/travisstaloch/edn-data\n```\n```zig\n// build.zig\nconst edn_dep = b.dependency(\"extensible_data_notation\", .{\n    .target = target,\n    .optimize = optimize,\n});\nexe.root_module.addImport(\"extensible-data-notation\", edn_dep.module(\"extensible-data-notation\"));\n```\n```zig\n// main.zig\nconst edn = @import(\"extensible-data-notation\");\ntest \"parseFromSlice demo with Diagnostic\" {\n    const src = \"a (a b c [1 2 3] {:a 1, :b 2})\";\n    // on error, Diagnostic line, column, and error_message will be populated.\n    var diag: edn.Diagnostic = .{ .file_path = \"<test-file>\" };\n    const result = edn.parseFromSlice(edn.Result, src, .{\n        .diagnostic = &diag,\n        .allocator = std.testing.allocator,\n    }, .{}) catch |e| {\n        std.log.debug(\"{s}\\n\", .{diag.error_message});\n        return e;\n    };\n    defer result.deinit(std.testing.allocator);\n    if (!@import(\"builtin\").is_test) { // use format helper\n        std.debug.print(\"{}\\n\", .{result.formatter(src)});\n    }\n    try std.testing.expectFmt(src, \"{}\", .{result.formatter(src)});\n}\n\ntest \"parseFromSliceComptime demo\" {\n    const src = \"{:eggs 2 :lemon-juice 3.5 :butter 1}\";\n    const result = comptime try edn.parseFromSliceComptime(src, .{}, .{ .eval_branch_quota = 2000 });\n    const src2 = std.fmt.comptimePrint(\"{}\", .{comptime result.formatter(src)});\n    try std.testing.expectEqualStrings(src, src2);\n}\n\ntest \"parseFromSliceBuf demo - runtime no allocation\" {\n    const src = \"{:eggs 2 :lemon-juice 3.5 :butter 1}\";\n    const shape = comptime try edn.measure(src, .{}, .{}); // src must be comptime known here\n    var arrays: shape.Arrays() = undefined;\n    const result = try edn.parseFromSliceBuf(src, shape, arrays.buffers(), .{}, .{});\n    try std.testing.expectFmt(src, \"{}\", .{result.formatter(src)});\n}\n```\n\n#### Testing\nrun tests in [src/tests.zig](src/tests.zig), [src/Tokenizer.zig](src/Tokenizer.zig), and [src/ringbuffer.zig](src/ringbuffer.zig)\n```console\n$ zig build test\n```\n\n##### Fuzzing\n```console\n$ nix-shell\n$ mkdir afl/output\n$ ./afl-fuzz.sh\n```\n```console\n$ zig build test -Dtest-filters=\"fuzz parseFromSlice and format\" --summary all --fuzz --port 38495\n```\n\n#### References\n* https://github.com/edn-format/edn\n* https://github.com/jorinvo/edn-data/blob/main/test/parse.test.ts\n* https://www.ryanliptak.com/blog/fuzzing-zig-code/\n* https://github.com/kristoff-it/zig-afl-kit\n\n#### Ideas and Planned Features\n- [ ] built-in tagged elements\n  - [ ] #inst - instant http://www.ietf.org/rfc/rfc3339.txt\n  - [ ] #uuid - http://en.wikipedia.org/wiki/Universally_unique_identifier\n- [ ] maybe cannonical encoding/parsing - https://en.wikipedia.org/wiki/Canonical_S-expressions\n- [x] rework parser, use Tokenizer.zig\n- [ ] simplify parsing by using some kind of writer interface. goal is to replace `ParseMode = enum{measure, allocate}` with some writer where one writer does measuring while another allocates.  hopefully this remove lots of duplication such as `if(mode == .measure) something() else otherthing()`\n  - [x] this would require to re-think how parse results are ordered.\n    - [x] parse results are stored with the tree structure represented by first_child_ids and next_sibling_ids arrays.  \n      - [ ] this is quite a wasteful since most entries are empty. would be bettter as if it was a sparse array represented by a bitset and a full array.\n- [x] fix test \"unclosed containers\"\n  - [x] add more \"unclosed containers\" test cases\n- [w] fuzz test the parser\n  - [x] parseFromSliceAlloc, fmtParseResult\n  - [x] expand fuzzing: parseTypeFromSlice\n  - [ ] expand fuzzing\n- [x] merge Parser and root.zig as Parser.zig. rename some redundant names such as ParseResult, ParseError.\n- [x] compresss parser code by reusing parseList to parse maps.\n- [x] store top level items in a list and reuse parseList again.\n- [x] merge ParseMode and some Parser fields into Options\n- [x] make ValueId an enum\n- [ ] unify parseFrom* methods with parseType* like std.json\n- [ ] api to parse from reader\n  - [ ] option for duping strings.  currently we don't dupe anything.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/1562827?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 67,
  "owner_following": 32,
  "owner_created_at": "2012-03-22T00:22:23Z",
  "license": "MIT",
  "category": "library"
}