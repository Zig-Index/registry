{
  "name": "flagset",
  "owner": "travisstaloch",
  "repo": "flagset",
  "description": "A command line flag parsing package",
  "type": "project",
  "topics": [
    "zig-package"
  ],
  "stars": 5,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-11-19T21:58:35Z",
  "minimum_zig_version": "0.14.0",
  "readme": "# flagset\nA command line flag parsing package\n\n# goals\nSimplicity, fast compile times, and small binary size with measured use of comptime.\n\n# features\n* auto generated usage/help text\n  * placeholder width controls column width.  passing `\": <25\"` sets width to 25.  default width is 25.\n* positional (unnamed) flags may occur in any position, not just after named flags.  positional flags are always parsed in declaration order.\n* compososition: `parse()` methods return unparsed args or a modified iterator.  this allows for composing flagsets by passing `parse_result.unparsed_args` on to further `parse()` methods with different flagsets.\n  * Flag parsing stops when all flags have been parsed, just before the first non-flag argument (\"-\" is a non-flag argument) or after the terminator \"--\"\n* parse into pointers by passing optional runtime `ParseOptions.ptrs` fields.  this allows for storing parse results in some existing location instead of a returned `ParseResult()`.\n* custom flag parsing with `flagset.Flag.Options.parseFn`.  this also makes it possible to parse into other types such as structs.\n* parse integers from utf8 strings by setting `flagset.Flag.Options.int_from_utf8`\n* abbreviated short bool flags: '-abc' is parsed the same as '-a -b -c'\n* accept command line args as slice or iterator with `parseFromSlice()` and `parseFromIter()`\n  * supports any iterator with a `fn next() ?[]const u8` such as `std.process.args()`, `std.mem.tokenize()`, `std.mem.split()`\n* supports parsing repeated flags into lists when `flag.options.kind == .list`. see `Flag.Options.kind` doc comments and tests.\n\n# use\n```console\nzig fetch --save git+https://github.com/travisstaloch/flagset\n```\n\n```zig\n// build.zig\nconst flagset_dep = b.dependency(\"flagset\", .{\n    .target = target,\n    .optimize = optimize,\n});\nexe.root_module.addImport(\"flagset\", flagset_dep.module(\"flagset\"));\n```\n\n[src/demo.zig](src/demo.zig)\n```zig\nconst std = @import(\"std\");\n\nconst flagset = @import(\"flagset\");\n\npub fn main() !void {\n    const flags = [_]flagset.Flag{\n        .init(bool, \"flag\", .{ .short = 'f', .desc = \"flag description\" }),\n        .init(u32, \"count\", .{ .desc = \"count description\" }),\n        .init(enum { one, two }, \"enum\", .{ .kind = .positional, .desc = \"enum description\" }),\n        // NOTE: `default_value_ptr=&null` means there is no default value.  so we have to give it a type.\n        .init(?[]const u8, \"opt-string\", .{ .short = 's', .desc = \"opt-string description\", .default_value_ptr = &@as(?[]const u8, \"opt-string-default\") }),\n        .init([]const u8, \"string\", .{ .desc = \"string description\" }),\n        .init([]const u8, \"pos-str\", .{ .kind = .positional, .desc = \"pos-str description\" }),\n        .init(u8, \"with-default\", .{ .desc = \"with-default description\", .default_value_ptr = &@as(u8, 10) }),\n        .init([]const u8, \"list\", .{ .desc = \"list description\", .kind = .list, .short = 'l' }),\n    };\n\n    const alloc = std.heap.page_allocator; // TODO use a better allocator\n    var args = try std.process.argsWithAllocator(alloc);\n    defer args.deinit();\n\n    var result = flagset.parseFromIter(&flags, args, .{ .allocator = alloc }) catch |e| switch (e) {\n        error.HelpRequested => {\n            std.debug.print(\"{f}\", .{flagset.fmtUsage(&flags, \": <45\", .full,\n                \\\\\n                \\\\usage: demo <options>\n                \\\\\n                \\\\\n            )});\n            return;\n        },\n        else => return e,\n    };\n    std.debug.print(\"parsed: {f}\\n\", .{flagset.fmtParsed(&flags, result.parsed, .{})});\n    std.debug.print(\"unparsed args: \", .{});\n    while (result.unparsed_args.next()) |arg| std.debug.print(\"{s} \", .{arg});\n    std.debug.print(\"\\n\", .{});\n}\n```\n```console\n$ zig build demo -- -h\n\nusage: demo <options>\n\noptions:\n  --help, -h                                 show this message and exit\n  --flag, --no-flag, -f                      flag description\n  --count <u32>                              count description\n  <enum:one|two>                             enum description\n  --opt-string, --no-opt-string, -s <string> opt-string description\n  --string <string>                          string description\n  <pos-str:string>                           pos-str description\n  --with-default <u8>                        with-default description\n  --list, -l <string> (many)                 list description\n\n$ zig build demo -- --flag --count 10 two --string \"s\" pos-str --list foo --list bar --foo --bar\nparsed: --flag --count 10 two --opt-string opt-string-default --string s pos-str --with-default 10 --list foo --list bar\nunparsed args: --foo --bar\n```\n\n# more examples\n* [src/tests.zig](src/tests.zig)\n\n# references\n* https://github.com/Games-by-Mason/structopt\n* https://pkg.go.dev/flag\n\n# todo\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/1562827?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 68,
  "owner_following": 32,
  "owner_created_at": "2012-03-22T00:22:23Z",
  "license": "MIT",
  "category": "library"
}