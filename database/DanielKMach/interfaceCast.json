{
  "name": "interfaceCast",
  "owner": "DanielKMach",
  "repo": "interfaceCast",
  "description": "A Zig-ish way of handling interfaces",
  "type": "package",
  "topics": [
    "zig",
    "zig-package"
  ],
  "stars": 3,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2025-08-01T20:14:20Z",
  "minimum_zig_version": "0.14.1",
  "readme": "# interfaceCast\n\nA Zig-ish way of handling interfaces.\n\n### Features\n\n- [x] `interfaceCast` allows you to cast any struct into an interface.\n    - Interfaces are just structs that have both a `vtable` and a `context` field.\n    - The `context` (`ptr`, `data` and `userdata` also works) field must be of type `*anyopaque`.\n    - The `vtable` field must be a constant pointer to a struct and each field of that struct must be a constant pointer to a function.\n- [x] Automatic casting of `*anyopaque` into the interface's context type.\n- [x] Automatic error coercion if the interface returns an error superset of its context type's (see example below).\n- [x] Allows for generic interfaces (see example below).\n- [x] Friendly with predefined interfaces (like the ones from std).\n\n### Example\n\n```zig\nconst std = @import(\"std\");\nconst interfaceCast = @import(\"interfaceCast\").interfaceCast;\nconst print = std.debug.print;\nconst assert = std.debug.assert;\n\n/// This is an interface that can be used to represent a list\n/// that can append and pop elements of type `T`.\npub fn AnyList(comptime T: type) type {\n\n    // Interfaces are just structs with `context` and `vtable` fields.\n    return struct {\n\n        // This is the context field, which must of type `*anyopaque`.\n        context: *anyopaque,\n\n        // This is the vtable field, which must be a constant pointer to a struct.\n        //\n        // Each field in the vtable must be a constant pointer to a function\n        //\n        // The name of each field is significant, as it directly maps to the context type's function names.\n        // Since we want this interface to append and pop elements, we define the vtable with `append` and `pop` fields.\n        // The function signatures must match the context type's function signatures.\n        vtable: *const struct {\n            append: *const fn (self: *anyopaque, value: T) error{ OutOfMemory, Overflow }!void,\n            pop: *const fn (self: *anyopaque) ?T,\n        },\n\n        // Notice how the following function return type is an error union with `OutOfMemory` and `Overflow`.\n        // This is the case because `ArrayList` might return `error.OutOfMemory` when appending an element,\n        // and `BoundedArray` might return `error.Overflow` when trying to append an element\n        // that exceeds its defined capacity.\n        //\n        // So to allow both `ArrayList` and `BoundedArray` to be cast to this interface,\n        // we need to define the return type to be an error union that is a superset\n        // of both `ArrayList` and `BoundedArray` error sets.\n        //\n        // This is possible because `interfaceCast` automatically detects that the return\n        // type is a superset of the context type's.\n        pub fn append(self: @This(), value: T) error{ OutOfMemory, Overflow }!void {\n            // Here we call the function from the vtable.\n            try self.vtable.append(self.context, value);\n        }\n\n        // Interfaces can also return values.\n        pub fn pop(self: @This()) ?T {\n            // Here we also call the function from the vtable.\n            return self.vtable.pop(self.context);\n        }\n    };\n}\n\n/// Appends numbers from 0 to `count - 1` to the provided list.\npub fn appendNumbers(list: AnyList(usize), count: usize) anyerror!void {\n    for (0..count) |i| {\n        try list.append(i);\n    }\n}\n\n/// Pops all elements from the list and prints them.\npub fn popAll(list: AnyList(usize)) void {\n    while (list.pop()) |item| {\n        print(\"{d} \", .{item});\n    }\n    print(\"\\r\\n\", .{});\n}\n\npub fn main() !void {\n    // Lets try casting an `ArrayList` to the `AnyList` interface.\n    var arraylist = std.ArrayList(usize).init(std.heap.page_allocator);\n    defer arraylist.deinit();\n\n    const any_list = interfaceCast(AnyList(usize), &arraylist);\n    try appendNumbers(any_list, 5);\n    assert(arraylist.items.len == 5);\n    // Notice how we fed `any_list` to `appendNumbers`, and `arraylist` gets updated.\n\n    popAll(any_list); // Prints: 4 3 2 1 0\n    assert(arraylist.items.len == 0);\n\n    // Lets try the same thing, but now with a `BoundedArray`.\n    var bounded_array = std.BoundedArray(usize, 3){};\n\n    const any_list2 = interfaceCast(AnyList(usize), &bounded_array);\n    try appendNumbers(any_list2, 3);\n    assert(bounded_array.len == 3);\n    // Just like the last time, when we append to `any_list2`, `bounded_array` gets updated.\n\n    assert(any_list2.append(3) == error.Overflow);\n    // Interfaces can also return errors.\n\n    popAll(any_list2); // Prints: 2 1 0\n    assert(bounded_array.len == 0);\n}\n```\n\n## Adding to a project\n\nRun the following command to add the package to your project.\n\n```bash\nzig fetch --save git+https://github.com/DanielKMach/interfaceCast#main\n```\n\nThen add it as an import in your `build.zig`\n\n```zig\nconst interface_cast = b.dependency(\"interfaceCast\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nyour_exe_module.addImport(\"interfaceCast\", interface_cast.module(\"interfaceCast\"));\n```\n\nNow you are ready to use it in your code.\n\n```zig\nconst interfaceCast = @import(\"interfaceCast\").interfaceCast;\n```\n\n## Contributing\n\nFeel free to open an issue or make a PR.",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/41847530?u=4d87714827b3c90c00c903c0d0638ee8865f4883&v=4",
  "releases": [],
  "owner_bio": "Estudante do Instituto Federal do Rio Grande do Sul.",
  "owner_company": "@VortexVR-Brasil",
  "owner_location": "Rio Grande do Sul, Brasil",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 3,
  "owner_following": 8,
  "owner_created_at": "2018-07-29T03:57:57Z",
  "license": "MIT",
  "category": "library"
}