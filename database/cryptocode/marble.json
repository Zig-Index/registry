{
  "name": "marble",
  "owner": "cryptocode",
  "repo": "marble",
  "description": "A metamorphic testing library for Zig",
  "type": "package",
  "topics": [
    "metamorphic-testing",
    "zig",
    "testing",
    "testing-tool",
    "testing-tools",
    "zig-library",
    "zig-package"
  ],
  "stars": 44,
  "forks": 2,
  "watchers": 2,
  "updated_at": "2026-01-21T16:03:28Z",
  "readme": "<img align=\"right\" width=\"320\" src=\"https://user-images.githubusercontent.com/34946442/159163318-432052e3-69c7-4598-aaac-74d54f67c8b4.png\">\n\nMarble is a [metamorphic testing](https://en.wikipedia.org/wiki/Metamorphic_testing) library for Zig.\n\nThe main branch tracks Zig master. Use a tagged release to target a specific Zig version.\n\nMetamorphic testing is a powerful technique that provides additional test coverage by applying a number of transformations to test input, and then checking if certain relations still hold between the outputs. Marble will automatically run through all possible combinations of these transformations.\n\nHere's a [great introduction by](https://www.cockroachlabs.com/blog/metamorphic-testing-the-database/) Cockroach Labs. I highly recommend reading before using this library.\n\nThe repository contains a few [test examples](https://github.com/cryptocode/marble/blob/main/src/example_tests.zig)\n\n## Resources\n* [Hillel Wayne's blog post on Metamorphic Testing (highly recommended)](https://www.hillelwayne.com/post/metamorphic-testing/)\n* [Test your Machine Learning Algorithm with Metamorphic Testing](https://medium.com/trustableai/testing-ai-with-metamorphic-testing-61d690001f5c)\n* [Original paper by T.Y. Chen et al](https://www.cse.ust.hk/~scc/publ/CS98-01-metamorphictesting.pdf)\n* [Case study T.Y. Chen et al](http://grise.upm.es/rearviewmirror/conferencias/jiisic04/Papers/25.pdf)\n* [Metamorphic Testing and Beyond T.Y. Chen et al](https://www.cs.hku.hk/data/techreps/document/TR-2003-06.pdf)\n* [Survey on Metamorphic Testing](http://www.cs.ecu.edu/reu/reufiles/read/metamorphicTesting-16.pdf)\n* [Performance Metamorphic Testing](http://www.lsi.us.es/~jtroya/publications/NIER17_at_ICSE17.pdf)\n* [Experiences from Three Fuzzer Tools](https://johnwickerson.github.io/papers/dreamingup_MET21.pdf)\n* [Monarch, a similar library for Rust](https://github.com/zmitchell/monarch/blob/master/src/runner.rs)\n\n## Building\n\nTo build and run test examples:\n\n```bash\nzig build\nzig build test\n```\n\n## Writing tests\n\nA metamorphic Zig test looks something like this:\n\n```zig\nconst SinusTest = struct {\n    const tolerance = std.math.epsilon(f64) * 20;\n\n    /// This test has a single value, but you could also design the test to take an\n    /// array as input. The transformations, check and execute functions would then\n    /// loop through them all. Alternatively, the test can be run multiple times\n    /// with different inputs.\n    value: f64,\n\n    /// The mathematical property \"sin(x) = sin(π − x)\" must hold\n    pub fn transformPi(self: *SinusTest) void {\n        self.value = std.math.pi - self.value;\n    }\n\n    /// Adding half the epsilon must still cause the relation to hold given the tolerance\n    pub fn transformEpsilon(self: *SinusTest) void {\n        self.value = self.value + std.math.epsilon(f64) / 2.0;\n    }\n\n    /// A metamorphic relation is a relation between outputs in different executions.\n    /// This relation must hold after every execution of transformation combinations.\n    pub fn check(_: *SinusTest, original_output: f64, transformed_output: f64) bool {\n        return std.math.approxEqAbs(f64, original_output, transformed_output, tolerance);\n    }\n\n    /// Called initially to compute the baseline output, and after every transformation combination\n    pub fn execute(self: *SinusTest) f64 {\n        return std.math.sin(self.value);\n    }\n};\n\n...\n\nvar i: f64 = 1;\nwhile (i < 100) : (i += 1) {\n    var t = SinusTest{ .value = i };\n    try std.testing.expect(try marble.run(SinusTest, &t, allocator, .{}));\n}\n```\n\nYou will get compile time errors if the requirements for a metamorphic test are not met.\n\nIn short, you must provide a `value` field, a `check` function, an `execute` function and one or more `transform...` functions.\n\n### Writing transformations\nAdd one or more functions starting with `transform...`\n\nMarble will execute all combinations of the transformation functions. After every\ncombination, `execute` is called followed by `check`.\n\nTransformations should change the `value` property - Marble will remember what it was originally. The transformations must be such that `check`\nsucceeds. That is, the relations between the inital output and the transformed output must still hold.\n\n### Checking if relations still hold\nYou must provide a `check` function to see if one or more relations hold, and return true if so. If false is returned, the test fails with a print-out of the current transformation-combination.\n\nRelation checks may be conditional; check out the tests for examples on how this works.\n\n### Executing\nYou must provide an `execute` function that computes a result based on the current value. The simplest form will simply return the current value, but you can\ndo any arbitrary operation here. This function is called before any transformations to form a baseline. This baseline is passed as the first argument to `check`\n\n### Optional before/after calls\n\nBefore and after the test, and every combination, `before(...)` and `after(...)` is called if present. This is useful to reset state, initialize test cases, and perform clean-up.\n\n### What happens during a test run?\n\nUsing the example above, the following pseudocode runs will be performed:\n\n```\nbaseline = execute()\n\n// First combination\ntransformPi()\nout = execute()\ncheck(baseline, out)\n\n// Second combination\ntransformEpsilon()\nout = execute()\ncheck(baseline, out)\n\n// Third combination\ntransformPi()\ntransformEpsilon()\nout = execute()\ncheck(baseline, out)\n```\n\n### Configuring runs\n\nThe `run` function takes a `RunConfiguration`:\n\n```zig\n/// If set to true, only run each transformation once separately\nskip_combinations: bool = false,\n\n/// If true, print detailed information during the run\nverbose: bool = false,\n```\n\n### Error reporting\n\nIf a test fails, the current combination being executed is printed. For instance, the following tells us that the combination of `transformAdditionalTerm` and `transformCase` caused the metamorphic relation to fail:\n\n```\nTest [2/2] test \"query\"... Test case failed with transformation(s):\n  >> transformAdditionalTerm\n  >> transformCase\n```\n\n### Terminology\n\n* Source test case output: The output produced by `execute()` on the initial input. This is also known as the baseline.\n* Derived test case output: The output produced by `execute()` after applying a specific combination of transformations.\n* Metamorphic relation: A property that must hold when considering a source test case and a derived test case.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/34946442?u=5de89bdf8ffb0f3c7b211d4f6598709ce622e831&v=4",
  "releases": [
    {
      "tag_name": "zig-0.15.1",
      "name": "zig-0.15.1",
      "body": "This release targets Zig 0.15.1",
      "prerelease": false,
      "published_at": "2025-08-24T16:32:14Z",
      "html_url": "https://github.com/cryptocode/marble/releases/tag/zig-0.15.1",
      "assets": []
    },
    {
      "tag_name": "zig-0.14",
      "name": "zig-0.14",
      "body": "This release targets Zig 0.14.x",
      "prerelease": false,
      "published_at": "2025-08-24T16:23:10Z",
      "html_url": "https://github.com/cryptocode/marble/releases/tag/zig-0.14",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://cryptocode.github.io/blog/",
  "owner_twitter_username": null,
  "owner_followers": 119,
  "owner_following": 55,
  "owner_created_at": "2017-12-29T18:50:57Z",
  "license": "MIT",
  "category": "library"
}