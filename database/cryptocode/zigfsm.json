{
  "name": "zigfsm",
  "owner": "cryptocode",
  "repo": "zigfsm",
  "description": "A finite state machine library for Zig",
  "type": "package",
  "topics": [
    "zig",
    "finite-state-machine",
    "fsm",
    "fsm-library",
    "graphviz",
    "state-machine",
    "zig-library",
    "zig-package"
  ],
  "stars": 178,
  "forks": 7,
  "watchers": 4,
  "updated_at": "2025-12-05T03:02:12Z",
  "readme": "<img align=\"right\" width=\"160\" height=\"160\" src=\"https://user-images.githubusercontent.com/34946442/152222895-9c8adb22-a22d-4bce-a513-3486ca28bdd5.png\"> zig**fsm** is a [finite state machine](https://en.wikipedia.org/wiki/Finite-state_machine) library for Zig.\n\nThis library supports Zig 0.12.x, 0.13, 0.14.x, and 0.15.1.\n\nUse the zigfsm main branch to compile with Zig master. Use the appropriate zig-*version* tag to target a specific Zig version.\n\nTested on Linux, macOS, FreeBSD and Windows.\n\n## Table of Contents\n* [Features](#features)\n* [Motivation](#motivation)\n* [Using zigfsm](#using-zigfsm)\n  * [Building](#building)\n  * [Importing the library](#importing-the-library)\n  * [Learning from the tests](#learning-from-the-tests)\n  * [Creating a state machine type](#creating-a-state-machine-type)\n  * [Making an instance](#making-an-instance)\n  * [Adding state transitions](#adding-state-transitions)\n  * [Optionally defining events](#optionally-defining-events)\n  * [Defining transitions and events at the same time](#defining-transitions-and-events-at-the-same-time)\n  * [Defining transitions and events as a table](#defining-transitions-and-events-as-a-table)\n  * [Changing state](#changing-state)\n  * [Probing the current state](#probing-the-current-state)\n  * [Inspecting what transition happened](#inspecting-what-transition-happened)\n  * [Valid states iterator](#valid-states-iterator)\n  * [Importing state machines](#importing-state-machines)\n  * [Transition handlers](#transition-handlers)\n     * [Canceling transitions](#canceling-transitions)\n\n## Features\n* Never allocates\n* Works at both comptime and runtime\n* Fast transition validation\n* Compact memory representation\n* State machines can export themselves to the Graphviz DOT format\n* Defined programmatically or by importing Graphviz or libfsm text (even at compile time)\n* Imported state machines can autogenerate state- and event enums\n* Optional event listeners can add functionality and cancel transitions\n* Push-down automaton wrappers are easy to write (see GameState example in tests.zig)\n* Comprehensive test coverage which also serves as examples\n\n## Motivation\nUsing an FSM library may have some benefits over hand-written state machines:\n* Many real-world processes, algorithms, and protocols have rigorously defined state machines available. These can be imported directly or programmatically into zigfsm.\n* Can lead to significant simplification of code, as transition rules are explicitly stated in one place. Contrast this with the brittleness of manually checking and documenting which states can follow a certain state when a certain event happens.\n* An invalid state transition is an immediate error with useful contextual information. \n* You get visualization for free, which is helpful during development, debugging and as documentation.\n\n## Using zigfsm\nBefore diving into code, it's worth repeating that zigfsm state machines can generate their own diagram, as well as import them. This can be immensely helpful when working on your state machines,\nas you get a simple visualization of all transitions and events. Obviously, the diagrams can be used as part of your documentation as well.\n\nHere's the diagram from the CSV parser test, as generated by the library:\n\n![csv](https://user-images.githubusercontent.com/34946442/150114019-8dc15ab1-35b9-4631-98b4-976dbb1217c3.png)\n\nDiagrams can be exported to any writer using `exportGraphviz(...)`, which accepts `StateMachine.ExportOptions` to change style and layout.\n\nA png can be produced using the following command: `dot -Tpng csv.gv -o csv.png`\n\n### Building\nTo build, test and benchmark:\n\n```\nzig build -Doptimize=ReleaseFast\nzig build test\nzig build benchmark\n```\n\nThe benchmark always runs under ReleaseFast.\n\n### Importing the library\n\nAdd zigfsm as a Zig package to your `zon` file, or simply import `main.zig` directly if vendoring.\n\nHere's how to update your zon file using the latest commit of zigfsm:\n\n```bash\nzig fetch --save git+https://github.com/cryptocode/zigfsm\n```\n\nNext, update your `build.zig` to add zigfsm as an import. For example:\n\n```zig\nexe.root_module.addImport(\"zigfsm\", b.dependency(\"zigfsm\", .{}).module(\"zigfsm\"));\n```\n\nNow you can import zigfsm from any Zig file:\n\n```zig\n// This example implements a simple Moore machine: a three-level intensity lightswitch\nconst std = @import(\"std\");\nconst zigfsm = @import(\"zigfsm\");\n\npub fn main() !void {\n    // A state machine type is defined using state enums and, optionally, event enums.\n    // An event takes the state machine from one state to another, but you can also switch to\n    // other states without using events.\n    //\n    // State and event enums can be explicit enum types, comptime generated enums, or\n    // anonymous enums like in this example.\n    //\n    // If you don't want to use events, simply pass null to the second argument.\n    // We also define what state is the initial one, in this case .off\n    var fsm = zigfsm.StateMachine(enum { off, dim, medium, bright }, enum { click }, .off).init();\n\n    // There are many ways to define transitions (and optionally events), including importing\n    // from Graphviz. In this example we use a simple API to add events and transitions.\n    try fsm.addEventAndTransition(.click, .off, .dim);\n    try fsm.addEventAndTransition(.click, .dim, .medium);\n    try fsm.addEventAndTransition(.click, .medium, .bright);\n    try fsm.addEventAndTransition(.click, .bright, .off);\n\n    std.debug.assert(fsm.isCurrently(.off));\n\n    // Do a full cycle: off -> dim -> medium -> bright -> off\n    _ = try fsm.do(.click);\n    _ = try fsm.do(.click);\n    _ = try fsm.do(.click);\n    _ = try fsm.do(.click);\n\n    // Make sure we're in the expected state\n    std.debug.assert(fsm.isCurrently(.off));\n    std.debug.assert(fsm.canTransitionTo(.dim));\n}\n```\n\n### Learning from the tests\n\nA good way to learn zigfsm is to study the [tests](https://github.com/cryptocode/zigfsm/blob/main/src/tests.zig) file.\n\nThis file contains a number of self-contained tests that also demonstrates various aspects of the library.\n\n### Creating a state machine type\n\nA state machine type is defined using state enums and, optionally, event enums.\n\nHere we create an FSM for a button that can be clicked to flip between on and off states. The initial state is `.off`:\n\n```zig\nconst State = enum { on, off };\nconst Event = enum { click };\nconst FSM = zigfsm.StateMachine(State, Event, .off);\n```\n\nIf you don't need events, simply pass null:\n\n```zig\nconst FSM = zigfsm.StateMachine(State, null, .off);\n```\n\n### Making an instance\nNow that we have a state machine *type*, let's create an instance with an initial state :\n\n```zig\nvar fsm = FSM.init();\n```\n\nIf you don't need to reference the state machine type, you can define the type and get an instance like this:\n\n```zig\nvar fsm = zigfsm.StateMachine(State, Event, .off).init();\n```\n\nYou can also pass anonymous state/event enums:\n\n```zig\nvar fsm = zigfsm.StateMachine(enum { on, off }, enum { click }, .off).init();\n```\n\n### Adding state transitions\n\n```zig\ntry fsm.addTransition(.on, .off);\ntry fsm.addTransition(.off, .on);\n```\n\n### Optionally defining events\n\nWhile `transitionTo` can now be used to change state, it's also common to invoke state transitions\nusing events. This can vastly simplify using and reasoning about your state machine.\n\nThe same event can cause different transitions to happen, depending on the current state.\n\nLet's define what `.click` means for the on and off states:\n\n```zig\ntry fsm.addEvent(.click, .on, .off);\ntry fsm.addEvent(.click, .off, .on);\n```\n\nThis expresses that if `.click` happens in the `.on` state, then transition to the `.off` state, and vice versa.\n\n### Defining transitions and events at the same time\nA helper function is available to define events and state transitions at the same time:\n\n```zig\ntry fsm.addEventAndTransition(.click, .on, .off);\ntry fsm.addEventAndTransition(.click, .off, .on);\n```\n\nWhich approach to use depends on the application.\n\n### Defining transitions and events as a table\n\nRather than calling addTransition and addEvent, `StateMachineFromTable` can be used to pass a table of event- and state transitions.\n\n```zig\nconst State = enum { on, off };\nconst Event = enum { click };\nconst definition = [_]Transition(State, Event){\n    .{ .event = .click, .from = .on, .to = .off },\n    .{ .event = .click, .from = .off, .to = .on },\n};\nvar fsm = zigfsm.StateMachineFromTable(State, Event, &definition, .off, &.{}).init();\n```\n\nNote that the `.event` field is optional, in which case only transition validation is added.\n\n### Changing state\n\nLet's flip the lights on by directly transitioning to the on state:\n\n```zig\ntry fsm.transitionTo(.on);\n```\n\nThis will fail with `StateError.Invalid` if the transition is not valid.\n\nNext, let's change state using the click event. In fact, let's do it several times, flipping the switch off and on and off again:\n\n```zig\ntry fsm.do(.click);\ntry fsm.do(.click);\ntry fsm.do(.click);\n```\n\nAgain, this will fail with `StateError.Invalid` if a transition is not valid.\n\nFinally, it's possible to change state through the more generic `apply` function, which takes either a new state or an event.\n\n```zig\ntry fsm.apply(.{ .state = .on });\ntry fsm.apply(.{ .event = .click });\n```\n\n### Probing the current state\n\nThe current state is available through `currentState()`. To check if the current state is a specific state, call `isCurrently(...)`\n\nIf final states have been added through `addFinalState(...)`, you can check if the current state is in a final state by calling `isInFinalState()`\n\nTo check if the current state is in the start state, call `isInStartState()`\n\nSee the API docstring for more information about these are related functions.\n\n### Inspecting what transition happened\n\n```zig\nconst transition = try fsm.do(.identifier);\n\nif (transition.to == .jumping and transition.from == .running) {\n    ...\n}\n```\n\n... where `transition` contains the fields `from`, `to` and `event`.\n\nFollowed by an if/else chain that checks relevant combinations of from- and to states. This could, as an example, be used in a parser loop.\n\nSee the tests for examples.\n\n### Valid states iterator\n\nIt's occasionally useful to know which states are possible to reach from the current state. This is done using an iterator:\n\n```zig\nwhile (fsm.validNextStatesIterator()) |valid_next_state| {\n    ...\n}\n```\n\n### Importing state machines\n\nIt's possible, even at compile time, to parse a `Graphviz` or `libfsm` text file and create a state machine from this.\n\n* `importText` is used when you already have state- and event enums defined in Zig. `importText` can also be called at runtime to define state transitions.\n\n* `generateStateMachineFromText` is used when you want the compiler to generate these enums for you. While this saves you from writing enums manually, a downside is that editors and language servers are unlikely to support autocomplete on generated types.\n\nThe source input can be a string literal, or brought in by `@embedFile`.\n\nSee the test cases for examples on how to use the import features.\n\n### Transition handlers\n\nA previous section explained how to inspect the source and target state. There's another way to do this, using callbacks.\n\nThis gets called when a transition happens. The main benefit is that it allows you to cancel a transition.\n\nHandlers also makes it easy to keep additional state, such as source locations when writing a parser.\n\nLet's keep track of the number of times a light switch transition happens:\n\n```zig\nvar countingHandler = CountingHandler.init();\ntry fsm.addTransitionHandler(&countingHandler.handler);\n```\n\nWhenever a transition happens, the handler's public `onTransition` function will be called. See tests for complete\nexamples of usage.\n\n#### Canceling transitions\n\nThe transition handler can conditionally stop a transition from happening by returning `HandlerResult.Cancel`. The callsite of `transitionTo` or `do` will then fail with `StateError.Invalid`\n\nAlternatively,`HandlerResult.CancelNoError` can be used to cancel without failure (in other words, the current state remains but the callsite succeeds)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/34946442?u=5de89bdf8ffb0f3c7b211d4f6598709ce622e831&v=4",
  "releases": [
    {
      "tag_name": "zig-0.15.1",
      "name": "zig-0.15.1",
      "body": "This release support Zig 0.15.1. Please use the main branch to compile with Zig master.\r\n",
      "prerelease": false,
      "published_at": "2025-08-22T10:13:41Z",
      "html_url": "https://github.com/cryptocode/zigfsm/releases/tag/zig-0.15.1",
      "assets": []
    },
    {
      "tag_name": "zig-0.14",
      "name": "zig-0.14",
      "body": "This release support Zig 0.14. Please use the main branch to compile with Zig master.",
      "prerelease": false,
      "published_at": "2025-03-22T15:14:58Z",
      "html_url": "https://github.com/cryptocode/zigfsm/releases/tag/zig-0.14",
      "assets": []
    },
    {
      "tag_name": "zig-0.13",
      "name": "zig-0.13",
      "body": "This release support Zig 0.13. Please use the main branch to compile with Zig master.",
      "prerelease": false,
      "published_at": "2024-06-26T17:25:19Z",
      "html_url": "https://github.com/cryptocode/zigfsm/releases/tag/zig-0.13",
      "assets": []
    },
    {
      "tag_name": "zig-0.12",
      "name": "zig-0.12",
      "body": "This release support Zig 0.12. Please use the main branch to compile with Zig master.",
      "prerelease": false,
      "published_at": "2024-05-30T21:41:25Z",
      "html_url": "https://github.com/cryptocode/zigfsm/releases/tag/zig-0.12",
      "assets": []
    }
  ],
  "owner_bio": "Dad, programmer, avocational musician",
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "https://cryptocode.github.io/blog/",
  "owner_twitter_username": null,
  "owner_followers": 116,
  "owner_following": 54,
  "owner_created_at": "2017-12-29T18:50:57Z",
  "license": "MIT",
  "category": "library"
}