{
  "name": "zig-hyperscan",
  "owner": "flier",
  "repo": "zig-hyperscan",
  "description": "A high-performance Zig binding for Hyperscan, Intel's high-performance multiple regex matching library. This library provides fast, memory-efficient pattern matching capabilities for Zig applications.",
  "type": "package",
  "topics": [
    "hyperscan",
    "regex-engine",
    "zig-package",
    "ziglang"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-10-19T06:03:06Z",
  "dependencies": [
    {
      "name": "zlinter",
      "url": "git+https://github.com/kurtwagner/zlinter?ref=0.15.x#543d0f96907a0369eefd1a55e2042f468572463a",
      "hash": "zlinter-0.0.1-OjQ08XlVCwB5nFaGD-AamzZFFT-_2i_jpXzIKLazNEq3"
    },
    {
      "name": "clap",
      "url": "https://github.com/Hejsil/zig-clap/archive/refs/tags/0.11.0.tar.gz",
      "hash": "clap-0.11.0-oBajB-HnAQDPCKYzwF7rO3qDFwRcD39Q0DALlTSz5H7e"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# zig-hyperscan\n\n[![CI](https://github.com/flier/zig-hyperscan/actions/workflows/ci.yml/badge.svg)](https://github.com/flier/zig-hyperscan/actions/workflows/ci.yml)\n[![Zig](https://img.shields.io/badge/Zig-0.15.1+-blue.svg)](https://ziglang.org/)\n[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)\n\nA high-performance Zig binding for [Hyperscan](https://github.com/intel/hyperscan), Intel's high-performance multiple regex matching library. This library provides fast, memory-efficient pattern matching capabilities for Zig applications.\n\n## Features\n\n- **High Performance**: Leverages Hyperscan's optimized regex engines for maximum throughput\n- **Multiple Matching Modes**: Support for block, streaming, and vectored scanning modes\n- **Pattern Compilation**: Compile single or multiple regex patterns into optimized databases\n- **Memory Efficient**: Minimal memory footprint with efficient scratch space management\n- **Type Safe**: Full Zig type safety with comprehensive error handling\n- **Cross Platform**: Works on macOS, Linux, and other supported platforms\n- **Unicode Support**: Full UTF-8 and Unicode pattern matching capabilities\n\n## Installation\n\n### Prerequisites\n\n- Zig 0.15.1 or later\n- Hyperscan library installed on your system\n\n### Installing Hyperscan\n\n#### macOS (Homebrew)\n```bash\n$ brew install hyperscan\n```\n\n#### Ubuntu/Debian\n```bash\n$ sudo apt-get install libhyperscan-dev\n```\n\n#### From Source\nFollow the [official Hyperscan installation guide](http://intel.github.io/hyperscan/dev-reference/getting_started.html).\n\n### Adding to Your Project\n\nDepending on which developer you are, you need to run different `zig fetch` commands:\n\n```bash\n# Version of zig-hyperscan that works with a tagged release of Zig\n# Replace `<REPLACE ME>` with the version of zig-hyperscan that you want to use\n# See: https://github.com/flier/zig-hyperscan/releases\n$ zig fetch --save https://github.com/flier/zig-hyperscan/archive/refs/tags/<REPLACE ME>.tar.gz\n\n# Version of zig-hyperscan that works with latest build of Zigs master branch\n$ zig fetch --save git+https://github.com/flier/zig-hyperscan\n```\n\nAnd in your `build.zig`:\n\n```zig\nconst hyperscan = b.dependency(\"hyperscan\", .{});\nexe.root_module.addImport(\"hyperscan\", hyperscan.module(\"hyperscan\"));\nexe.root_module.linkSystemLibrary(\"hs\");\n```\n\n## Quick Start\n\n```zig\n// Parse a pattern\nvar pattern: Pattern = try .parse(\"hello.*world\");\n\n// Set the `som_leftmost` flag to true, this will make the match event callback function be called for the leftmost match\npattern.flags.som_leftmost = true;\n\n// Compile the pattern into a Hyperscan database, default is block mode\nconst db: Database = try .compile(&pattern, .{});\ndefer db.deinit();\n\n// Allocate scratch space\nconst scratch = try db.allocScratch();\ndefer scratch.deinit();\n\n// Define a match struct to store the match\nconst Match = struct { from: u64, to: u64 };\n\nvar m: Match = undefined;\n\n// Scan some text, onEvent is a callback function that will be called for each match\ntry db.scanBlock(\"hello beautiful world\", scratch, .{\n    .onEvent = struct {\n        fn handler(event: hs.MatchEvent) !void {\n            std.log.info(\"Match found at offset {d} to {d}\", .{ event.from.?, event.to });\n\n            // Store the match in the match struct\n            event.data(Match).* = .{ .from = event.from.?, .to = event.to };\n        }\n    }.handler,\n    .context = &m,\n});\n\ntry std.testing.expectEqualDeep(Match{ .from = 0, .to = 21 }, m);\n```\n\n## API Overview\n\n### Regex helper (high-level API)\n\n```zig\nconst std = @import(\"std\");\n\nconst Regex = @import(\"hyperscan\").Regex;\n\ntest Regex {\n    //Compile a pattern and create a Regex object\n    const regex = try Regex.compile(\"he[l]+\");\n    defer regex.deinit();\n\n    // Match the data\n    try std.testing.expect(try regex.match(\"hello world\"));\n\n    // Find the first match, default is leftmost match\n    var s = try regex.find(\"hello world\", .{});\n    try std.testing.expectEqualStrings(\"hel\", s.?);\n\n    // Find the longest match\n    s = try regex.find(\"hello world\", .{ .longest = true });\n    try std.testing.expectEqualStrings(\"hell\", s.?);\n\n    // Find indices\n    const m = try regex.findIndex(\"hello world\", .{});\n    try std.testing.expectEqualDeep(Regex.Match{ .from = 0, .to = 3 }, m.?);\n\n    // Find all matches (views into original data)\n    const matches = try regex.findAll(std.testing.allocator, \"hello helo helo\", .{});\n    defer std.testing.allocator.free(matches.?);\n\n    // The matches are views into the original data\n    try std.testing.expectEqualDeep(&[_][]const u8{ \"hel\", \"hell\", \"hel\", \"hel\" }, matches.?);\n\n    // Replace all (allocates new string). Uses longest matching internally.\n    const replaced = try regex.replace(std.testing.allocator, \"hello world\", \"HELL\");\n    defer std.testing.allocator.free(replaced);\n\n    try std.testing.expectEqualStrings(\"HELLo world\", replaced);\n\n    // Replace with function. Return null to keep original. Non-null must be heap-allocated;\n    // replaceFn copies bytes then frees the temporary returned buffer.\n    const out = try regex.replaceFn(\n        std.testing.allocator,\n        \"hello helo\",\n        struct {\n            fn upper(allocator: std.mem.Allocator, str: []const u8) ?[]const u8 {\n                return std.ascii.allocUpperString(allocator, str) catch return null;\n            }\n        }.upper,\n    );\n    defer std.testing.allocator.free(out);\n\n    try std.testing.expectEqualStrings(\"HELLo HELo\", out);\n\n    // Split the data into parts separated by the regex pattern\n    const sep = try Regex.compile(\"-+\");\n    defer sep.deinit();\n\n    // Split (delimiters omitted). Returns views into original input.\n    const parts = try sep.split(std.testing.allocator, \"he-llo--helo\");\n    defer std.testing.allocator.free(parts);\n\n    try std.testing.expectEqualDeep(&[_][]const u8{ \"he\", \"llo\", \"helo\" }, parts);\n}\n```\n\n### Pattern Compilation\n\n```zig\n// Single pattern\nconst pattern = try Pattern.parse(\"test\");\nconst db: Database = try .compile(&pattern, .{});\ndefer db.deinit();\n\n// Multiple patterns\nconst patterns = [_]Pattern{\n    try .parse(\"foo\"),\n    try .parse(\"bar\"),\n};\nconst mdb: Database = try .compileMulti(&patterns, .{});\ndefer mdb.deinit();\n```\n\n### Scanning Modes\n\n```zig\nconst pattern = try Pattern.parse(\"test\");\n\n// Block mode (default)\nconst block_db: Database = try .compile(&pattern, .{ .mode = .{ .block = true } });\ndefer block_db.deinit();\n\n// Streaming mode\nconst stream_db: Database = try .compile(&pattern, .{ .mode = .{ .stream = true } });\ndefer stream_db.deinit();\n\n// Vectored mode\nconst vectored_db: Database = try .compile(&pattern, .{ .mode = .{ .vectored = true } });\ndefer vectored_db.deinit();\n```\n\n### Pattern Flags\n\n```zig\n_ = try Pattern.parse(\"test\");\n_ = try Pattern.parse(\"/test/s\"); // Dot matches newline\n_ = try Pattern.parse(\"2:/test/m\"); // Multiline mode with id\n```\n\n### Advanced Features\n\n```zig\n// Pattern with extensions\nvar pattern = try Pattern.parse(\"test!+\");\n\npattern = pattern.withExt(.{\n    .min_offset = 10,\n    .max_offset = 100,\n    .min_length = 5,\n});\n\n// Platform-specific optimization\nconst db: Database = try .compile(&pattern, .{\n    .platform = .{\n        .tune = .haswell,\n        .cpu_features = .avx2,\n    },\n});\ndefer db.deinit();\n```\n\n## Examples\n\n### Simple Grep Tool\n\nSee `examples/simplegrep.zig` for a complete grep-like tool implementation.\n\n```bash\nzig build simplegrep -- \"pattern\" input.txt\n```\n\n### Streaming Scanner\n\n```zig\n// Compile the pattern into a streaming database\nconst pattern: Pattern = try .parse(\"chunk\\\\d+\");\nconst db: Database = try .compile(&pattern, .{ .mode = .{ .stream = true } });\nconst stream = try db.openStream(.{});\n\nconst scratch = try db.allocScratch();\ndefer scratch.deinit();\n\nvar matches: std.ArrayList(u64) = try .initCapacity(std.testing.allocator, 3);\ndefer matches.deinit(std.testing.allocator);\n\nconst opts: ScanOptions = .{\n    .onEvent = struct {\n        fn handler(evt: hs.MatchEvent) !void {\n            evt.data(std.ArrayList(u64)).append(std.testing.allocator, evt.to) catch {};\n        }\n    }.handler,\n    .context = &matches,\n};\n\n// Scan the data in streaming mode\ntry stream.scan(\"chunk1\", scratch, opts);\ntry stream.scan(\"chunk2\", scratch, opts);\ntry stream.scan(\"chunk3\", scratch, opts);\ntry stream.close(scratch, opts);\n\ntry std.testing.expectEqualDeep(&[_]u64{ 6, 12, 18 }, matches.items);\n```\n\n## Performance\n\nHyperscan is designed for high-performance pattern matching:\n\n- **Throughput**: Can process gigabytes of text per second\n- **Memory**: Efficient memory usage with configurable scratch space\n- **Scalability**: Handles thousands of patterns simultaneously\n- **Optimization**: Automatic CPU feature detection and optimization\n\n## Error Handling\n\nThe library provides comprehensive error handling:\n\n```zig\nconst pattern: Pattern = try .parse(\"a+b\");\nconst db = Database.compile(&pattern, .{}) catch |err| switch (err) {\n    error.DbModeError => {\n        std.log.err(\"Database mode error\", .{});\n        return;\n    },\n    error.CompileError => {\n        std.log.err(\"Pattern compilation failed\", .{});\n        return;\n    },\n    else => |e| {\n        std.log.err(\"Unexpected error: {s}\", .{@errorName(e)});\n        return;\n    },\n};\n\ndefer db.deinit();\n```\n\n## Testing\n\nRun the test suite:\n\n```bash\n$ zig build test\n```\n\n## Examples\n\nRun the `simplegrep` example:\n\n```bash\n$ zig build simplegrep -Dwith-examples -- -s zig build.zig\n```\n\n## Linting\n\nRun with linting:\n\n```bash\n$ zig build lint -Dwith-zlinter\n```\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## Acknowledgments\n\n- [Intel Hyperscan](https://github.com/intel/hyperscan) - The underlying regex matching engine\n- [Zig](https://ziglang.org/) - The programming language this binding is written in",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/61618?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Beijing, China",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 157,
  "owner_following": 11,
  "owner_created_at": "2009-03-09T15:35:50Z",
  "license": "MIT",
  "category": "library"
}