{
  "name": "clay-zig",
  "owner": "raugl",
  "repo": "clay-zig",
  "description": "Zig bindings for the library clay: A high performance UI layout library in C.",
  "type": "package",
  "topics": [
    "layout",
    "ui",
    "zig",
    "zig-binding",
    "zig-package"
  ],
  "stars": 30,
  "forks": 5,
  "watchers": 1,
  "updated_at": "2025-08-27T13:15:54Z",
  "dependencies": [
    {
      "name": "clay_src",
      "url": "git+https://github.com/nicbarker/clay#c9e1a63378ecfba448ecd42796838264b10adafb",
      "hash": "122051848fc0b06aac52586cd63a202d602a37c63c9cf0bd4c4e6ce6d13f5cef44d4"
    }
  ],
  "minimum_zig_version": "0.14.0",
  "readme": "### Zig Language Bindings\n\n> [!IMPORTANT]\n> Zig 0.14.0 or higher is required.\n\n> [!NOTE]\n> This project currently is in beta.\n\nThis directory contains bindings for the [Zig](odin-lang.org) programming language, as well as an example implementation of the [clay website](https://nicbarker.com/clay) in Zig.\n\nSpecial thanks to [johan0A](githubusercontent.com/johan0A) for the reference implementation.\n\nIf you haven't taken a look at the [full documentation for clay](https://github.com/nicbarker/clay/blob/main/README.md), it's recommended that you take a look there first to familiarise yourself with the general concepts. This README is abbreviated and applies to using clay in Zig specifically.\n\nThe **most notable difference** between the C API and the Zig bindings is the use of if statements to open the scope for declaring child elements and then having to close it \"manually\" with a deferred function call.\n\nOther changes include:\n - minor naming changes\n - ability to initialize a parameter by calling a function that is part of its type's namespace for example `.fixed()` or `.all()`\n - ability to initialize a parameter by using a public constant that is part of its type's namespace for example `.grow` \n\nTODO:\n - Talk about integrations with raylib\n - Talk about special `getOpenElementId()`, `element()`, and `hovered()` functions\n\n```c\n// C macro for creating a scope\nCLAY(\n    CLAY_ID(\"SideBar\"),\n    CLAY_LAYOUT({\n        .layoutDirection = CLAY_TOP_TO_BOTTOM,\n        .childAlignment = { .x = CLAY_ALIGN_X_CENTER, .y = CLAY_ALIGN_Y_TOP  },\n        .sizing = { .width = CLAY_SIZING_FIXED(300), .height = CLAY_SIZING_GROW() },\n        .padding = {16, 16},\n        .childGap = 16,\n    }),\n    CLAY_RECTANGLE({ .color = COLOR_LIGHT })\n) {\n    // Child elements here\n}\n```\n\n```zig\n// Zig form of element macros\nif (clay.open(.{\n    .id = clay.Id(\"SideBar\"),\n    .layout = .{\n        .direction = .top_to_bottom,\n        .alignment = .center_top,\n        .sizing = .{ .w = .fixed(300), .h = .grow },\n        .padding = .all(16),\n        .child_gap = 16,\n    },\n    .rectangle = .{ .color = COLOR_LIGHT },\n})) {\n    defer clay.close();\n    // Child elements here\n}\n```\n\n### Install\n\nDownload and add `clay-zig` as a dependency by running the following command in your project root:\n```sh\nzig fetch --save https://github.com/raugl/clay-zig/archive/<commit sha>.tar.gz\n```\nThen add `clay-zig` as a dependency and import its modules and artifact in your build.zig:\n```zig\nconst clay_dep = b.dependency(\"clay-zig\", .{\n    .target = target,\n    .optimize = optimize,\n});\nexe.linkLibrary(clay_dep.artifact(\"clay\"));\nexe.root_module.addImport(\"clay\", clay_dep.module(\"clay\"));\n```\nTo enable a builtin renderer you should first add its third party library to your project separately (eg: raylib, sdl2), then tell clay-zig about it. In this example we are using [raylib-zig](https://github.com/Not-Nik/raylib-zig):\n```zig\nconst cl = @import(\"clay-zig\");\n\nconst raylib_dep = b.dependency(\"raylib-zig\", .{ ... });\ncl.enableRenderer(exe.root_module, clay_dep, .{ .raylib = raylib_dep.module(\"raylib\") });\n```\n\n### Quick Start\n\n1. Ask clay for how much static memory it needs using [clay.minMemorySize()](https://github.com/nicbarker/clay/blob/main/README.md#clay_minmemorysize), create an Arena for it to use with [clay.createArenaWithCapacityAndMemory(min_memory_size, memory)](https://github.com/nicbarker/clay/blob/main/README.md#clay_createarenawithcapacityandmemory), and initialize it with [clay.initialize(arena, layout_size, error_handler)](https://github.com/nicbarker/clay/blob/main/README.md#clay_initialize).\n\n```zig\nconst memory = try allocator.alloc(u8, clay.minMemorySize());\ndefer allocator.free(memory);\nconst arena = clay.createArenaWithCapacityAndMemory(@intCast(memory.len), @ptrCast(memory));\nclay.initialize(arena, .{}, .{});\n```\n\n2. Provide a `measureText(text, config)` function with [clay.setMeasureTextFunction(function)](https://github.com/nicbarker/clay/blob/main/README.md#clay_setmeasuretextfunction) so that clay can measure and wrap text.\n\n```zig\n// Example measure text function\npub fn measureText(text: []const u8, config: *clay.TextConfig) clay.Dimensions {\n    // clay.TextConfig contains members such as font_id, font_size, letter_spacing etc\n}\n\n// Tell clay how to measure text\nclay.setMeasureTextFunction(measureText)\n```\n\n3. **Optional** - Call [clay.setPointerPosition(pointerPosition)](https://github.com/nicbarker/clay/blob/main/README.md#clay_setpointerposition) if you want to use mouse interactions.\n\n```zig\nclay.setPointerState(.{ .x = mouse_position_x, .y = mouse_position_y }, is_left_mouse_button_down);\n```\n\n4. Call [clay.beginLayout()](https://github.com/nicbarker/clay/blob/main/README.md#clay_beginlayout) and declare your layout using the provided functions.\n\n```zig\nconst COLOR_LIGHT = clay.Color.init(224, 215, 210, 255);\nconst COLOR_RED = clay.Color.init(168, 66, 28, 255);\nconst COLOR_ORANGE = clay.Color.init(225, 138, 50, 255);\n\n// Layout config is just a struct that can be declared statically, or inline\nconst sidebar_item_layout = clay.LayoutConfig{\n    .sizing = .{ .w = .grow, .h = .fixed(50) },\n};\n\n// Re-useable components are just normal functions\nfn sidebarItemComponent(index: usize) void {\n    clay.element(.{\n        .id = clay.IdWithIndex(\"SidebarBlob\", index),\n        .layout = sidebar_item_layout,\n        .rectangle = .{ .color = COLOR_ORANGE },\n    });\n}\n\n// An example function to begin the \"root\" of your layout tree\nfn createLayout() clay.RenderCommandArray {\n    clay.beginLayout();\n\n    // An example of laying out a UI with a fixed width sidebar and flexible width main content\n    if (clay.open(.{\n        .id = clay.Id(\"OuterContainer\"),\n        .layout = .{ .sizing = .grow, .padding = .all(16), .child_gap = 16 },\n        .rectangle = .{ .color = .init(250, 250, 250, 255) },\n    })) {\n        defer clay.close();\n        if (clay.open(.{\n            .id = clay.Id(\"SideBar\"),\n            .layout = .{ .direction = .top_to_bottom, .sizing = .{ .w = .fixed(300), .h = .grow }, .padding = .all(16), .child_gap = 16 },\n            .rectangle = .{ .color = COLOR_LIGHT },\n        })) {\n            defer clay.close();\n            if (clay.open(.{\n                .id = clay.Id(\"ProfilePictureOuter\"),\n                .layout = .{ .sizing = .{ .w = .grow }, .padding = .all(16), .child_gap = 16, .alignment = .left_center },\n                .rectangle = .{ .color = COLOR_RED },\n            })) {\n                defer clay.close();\n                clay.element(.{\n                    .id = clay.Id(\"ProfilePicture\"),\n                    .layout = .{ .sizing = .fixed(60) },\n                    .image = .{ .image_data = &profile_picture, size = .all(60) },\n                });\n                clay.text(\"Clay - UI Library\", .{ .font_size = 24, .text_color = .init(255, 255, 255, 255) });\n            }\n\n            // Standard Zig code like loops etc. work inside components\n            for (0..10) |i| sidebarItemComponent(i)\n        }\n\n        if (clay.open(.{\n            .id = clay.Id(\"MainContent\"),\n            .layout = .{ .sizing = .grow },\n            .rectangle = .{ .color = COLOR_LIGHT },\n        })) {\n            defer clay.close();\n            // ...\n        }\n    }\n    return clay.endLayout();\n}\n```\n\n5. Call [clay.endLayout()](https://github.com/nicbarker/clay/blob/main/README.md#clay_endlayout) and process the resulting [clay.RenderCommandArray](https://github.com/nicbarker/clay/blob/main/README.md#clay_rendercommandarray) in your choice of renderer.\n\n```zig\nconst render_commands = clay.endLayout();\n\nfor (render_commands.slice()) |render_command| {\n    switch (render_command.type) {\n        .rectangle => {\n            drawRectangle(render_command.bounding_box, render_command.config.rectangle.color);\n        },\n        // ... Implement handling of other command types\n    }\n}\n```\n\nPlease see the [full C documentation for clay](https://github.com/nicbarker/clay/blob/main/README.md) for API details. All public C functions and Macros have Zig binding equivalents, generally of the form `Clay_BeginLayoup` (C) -> `clay.beginLayout` (Zig)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/95168615?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 0,
  "owner_following": 0,
  "owner_created_at": "2021-11-28T10:50:15Z",
  "license": "MIT",
  "category": "library"
}