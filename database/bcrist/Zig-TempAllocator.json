{
  "name": "Zig-TempAllocator",
  "owner": "bcrist",
  "repo": "Zig-TempAllocator",
  "description": "Arena allocator for interactive programs and simulations",
  "type": "package",
  "topics": [
    "allocator",
    "utilities",
    "utility-library",
    "zig",
    "zig-library",
    "zig-package",
    "ziglang"
  ],
  "stars": 9,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-28T17:58:36Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# Zig Temp Allocator\n\nA stack allocator similar to std.heap.ArenaAllocator, except:\n\n- A fixed amount of virtual address space will be used (which must be known at initialization time) but not all of it need be mapped to real pages unless needed.\n- You can take a snapshot at any time and later invalidate/free all allocations after that point, but preserving allocations before it.\n- It will track how much memory is usually used before being reset, and release some if it remains significantly lower than the current committed capacity.\n- The inner \"child allocator\" is not configurable; internally it uses OS memory management facilities directly.\n\nThe primary use-cases are real-time interactive programs and simulations (games, GUIs, etc.), but it can be useful for anything where work is done sequentially in a main loop, and it's easy to guarantee that memory allocated from it won't be held across resets.\n\n## Usage Example\n\n```zig\nconst std = @import(\"std\");\nconst Temp_Allocator = @import(\"Temp_Allocator\");\nconst app = @import(\"whatever.zig\");\n\npub fn main() void {\n    var temp = Temp_Allocator.init(1024*1024*1024); // 1GB of virtual address space\n    defer temp.deinit();\n\n    var n: usize = 0;\n    while (!app.shouldExit()) {\n        temp.reset();\n        n += 1;\n\n        var temp: []u8 = std.fmt.allocPrint(temp.allocator(), \"number {} is {s}\", .{ n, \"Something\" });\n        app.doSomethingWithAString(temp);\n    }\n}\n```\n\n## Implementation Notes\n\nThe allocator utilizes a fixed chunk of virtual address space to allocate from.  The size of this chunk must be specified when initializing the allocator, and can't be changed while the allocator is in use.  But the maximum size may be enormous (up to several terabytes on windows, and possibly even more on other systems).  This is because the full virtual address chunk won't be \"committed\" to physical memory and/or swap pages until it's actually used.\n\n### Windows\nThe full virtual address chunk is allocated with:\n\n    VirtualAlloc(null, capacity, MEM_RESERVE, PAGE_NOACCESS)\n\nThen when regions need to be used, they're committed with:\n\n    VirtualAlloc(ptr, len, MEM_COMMIT, PAGE_READWRITE)\n\nLater, those regions may be decommitted with:\n\n    VirtualFree(ptr, len, MEM_DECOMMIT)\n\n### Linux/MacOS\nThe full virtual address chunk is allocated with:\n\n    mmap(null, capacity, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE)\n\nThen when regions need to be used, they're committed with:\n\n    mprotect(ptr, len, PROT_READ | PROT_WRITE)\n\nLater, those regions may be decommitted with:\n\n    madvise(ptr, len, MADV_DONTNEED);\n    mprotect(ptr, len, PROT_NONE);\n\nThe use of `MAP_NORESERVE` means we open up the possibility of getting segfaults later when the allocator's memory is written to, if the system runs out of physical memory.  But linux's default `vm.overcommit_memory` sysctl (and some other linux design decisions around OOM handling) means that out-of-memory conditions on linux simply can't be handled gracefully anyway.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/2828351?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "http://magicmoremagic.com",
  "owner_twitter_username": null,
  "owner_followers": 9,
  "owner_following": 0,
  "owner_created_at": "2012-11-18T17:51:58Z",
  "license": "MIT",
  "category": "library"
}