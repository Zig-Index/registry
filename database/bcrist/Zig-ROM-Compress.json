{
  "name": "Zig-ROM-Compress",
  "owner": "bcrist",
  "repo": "Zig-ROM-Compress",
  "description": "Simple compression scheme for sparse ROM data",
  "type": "package",
  "topics": [
    "compression",
    "compression-algorithm",
    "encoding",
    "rom",
    "zig",
    "zig-library",
    "zig-package",
    "ziglang",
    "embedded"
  ],
  "stars": 0,
  "forks": 0,
  "watchers": 1,
  "updated_at": "2026-02-28T21:30:00Z",
  "dependencies": [
    {
      "name": "bit_helper",
      "url": "git+https://github.com/bcrist/zig-bithelper#01fe5f519f54ab42c649096573c45ddaa351e1d5",
      "hash": "bit_helper-1.0.1-C8c75iguAABAXw3jPh9pvNp-RPvblh1vV7MbQ1w99fFF"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# Zig-Rom-Compress\n\nA simple algorithm for in-storage compression of potentially sparse data where the data will be fully uncompressed before usage.\n\nThe motivating use case is when using a microcontroller to bootstrap an SRAM at reset, which will thereafter function as a lookup table/ROM.\nOften times such lookup tables may contain several megabytes of highly patterned data, but you'd like to initialize it with just a small/cheap microcontroller, and typically these will have much less than 1MB of flash memory.\n\nNote for most data, an LZ-based compressor like DEFLATE will achieve a better compression ratio, but doesn't support sparse data without adding additional metadata.\nThe decompressor for this scheme is also very simple and requires only a few bytes of working RAM.\n\n## Algorithm\n\nThe key insight that we make use of is that many data words are likely to be repeated many times,\nand there may be many \"don't care\" addresses that we need not initialize at all.\nFurthermore, the data need not be reconstructed in linear order.\n\nThe compressor begins by partitioning the data into lists of addresses which point to the same data value.\nThen it sorts the addresses within those lists, and sorts the partitions based on the data value.\nIt can then use delta compression and RLE on the transformed data.\n\nThe algorithm works well in most real-world cases where there are many addresses with the same data value,\nand even better if those addresses appear in contiguous blocks.\nIt is possible, however, (particularly with encrypted or random-like data) that the compressed version may actually be larger.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/2828351?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "http://magicmoremagic.com",
  "owner_twitter_username": null,
  "owner_followers": 9,
  "owner_following": 0,
  "owner_created_at": "2012-11-18T17:51:58Z",
  "license": "MIT",
  "category": "embedded"
}