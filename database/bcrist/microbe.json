{
  "name": "microbe",
  "owner": "bcrist",
  "repo": "microbe",
  "description": "Embedded Zig framework for ARM microcontrollers",
  "type": "package",
  "topics": [
    "cortex-m",
    "embedded",
    "rpi-pico",
    "stm32",
    "zig",
    "zig-library",
    "zig-package",
    "ziglang"
  ],
  "stars": 7,
  "forks": 0,
  "watchers": 2,
  "updated_at": "2025-11-28T15:56:47Z",
  "minimum_zig_version": "0.14.0-dev.1694+3b465ebec",
  "readme": "# Microbe\n\nMicrobe is a framework for developing embedded firmware in Zig, primarily targeting small 32-bit architectures like ARM Cortex-M0.  It is similar in many ways to [microzig](https://github.com/ZigEmbeddedGroup/microzig) and in fact some parts were forked directly from that project.  But there are a few things about microzig that I didn't like:\n\n* Microzig caters heavily to the use of development boards, which is great for beginners, but just adds a lot of unnecessary complexity if you're using a microcontroller directly on your project/product board.\n* It forces a complex project structure on you.  You can't define the root source file yourself, instead it only exists in an \"app\" module.  There's a HAL (hardware abstraction layer) module that doesn't make sense; the entire project is a hardware abstraction layer, so why is there a HAL within the HAL?\n* The use of anonymous types to represent pins is weird.  It seems the only reason is to ensure they're used at comptime, but you can do that just as easily with an enum passed as a `comptime` parameter.  The conflation of chip pins names and board pin names is annoying.\n* The UART interface doesn't provide a non-blocking interface, or an easy way to support buffered implementations using interrupts or DMA.\n* There's no facility to easily work with multiple GPIOs simultaneously as a parallel bus.\n* The SVD-generated register types can be difficult to use, especially where a field would ideally be represented by an enum.\n\nI don't bring these up to criticize the microzig project, but rather to highlight the areas where Microbe takes a different path.  If you haven't tried microzig yet but you're looking to do embedded programming with Zig, start there first.  If you have tried microzig but share some of the feelings I listed above, then this project may be useful to you.  And if you're a microzig contributor and think something you see here should be ported, let me know and I'll see if I can help.\n\n## Building\nAdd this package to your `build.zig.zon` file and import it in your `build.zig` script as `microbe`.  Then just call `microbe.addExecutable(...)` instead of `std.Build.addExecutable(...)`, providing the chip and section information for your desired target.\n\nYou can find example applications and `build.zig` scripts here:\n* [STM32](https://github.com/bcrist/microbe-stm32/tree/main/example)\n* [RP2040](https://github.com/bcrist/microbe-rpi/tree/main/example)\n\n## Conventions\nThere are a few API conventions that should be followed in order for chip-specific code to interact well with application code and the common code in this repo, as well as to make porting between architectures as easy as possible.\n\nMost of the symbols that chip implementations are expected to expose can be found in `src/chip_interface.zig`.\n\n### Interrupt Configuration\nChip implementations should provide an enum `chip.interrupts.Interrupt` which lists all the \"external\" (i.e. NVIC-controlled) interrupts supported by the chip.  The integer values associated with this enum indicate their offset in the NVIC registers.  Additionally `chip.interrupts.Exception` should be an enum which includes all the interrupts, but also may contain synchronous exceptions & fault conditions.  The integer values associated with this enum indicate the exception number.  An interrupts exception number is generally different from its interrupt number.\n\nChip implementations should look for an `interrupts` struct in the root source file and automatically populate the vector table with the addresses of the handlers provided within it.  The handler names must match the names from `chip.interrupts.Exception` exactly.\n\n### Clock & Power Configuration\nChip implementations should provide a struct `chip.clocks.Config` which allows configuration of all the major clock domains on the chip.  The exact format will depend on the details of the architecture, but for every major clock domain in the chip, the clock config should have a field:\n\n    xxx_frequency_hz: comptime_int\n\nWhere `xxx` is the name of the clock domain.  A frequency of 0 Hz should be considered to mean \"clock disabled\".  If a clock domain is sourced from another clock, it should additionally have a field:\n\n    xxx_source: E\n\nWhere `E` is an enum type, or optional-wrapped enum type, giving the options that can be used as a source.\n\nOn reset, chip implementations should initialize the chip's clocks based on a `clocks` constant (of type `chip.clocks.Config`) declared in the root source file.  If no such declaration exists, the chip's default clock configuration should be used.\n\nChip implementations should also provide `chip.clocks.apply_config(...)` to allow dynamic clock changes.  Peripherals that are sensitive to clock frequencies (UARTs, PWMs etc.) will generally assume the clocks they use do not change, so care must be taken when using this.\n\nChip implementations may also provide `chip.clocks.get_config()` to provide a version of the configuration with additional details and defaults filled in.  This should be comptime callable.  If it does not return a `chip.clocks.Config` struct, it should return a `chip.clocks.Parsed_Config` struct.\n\nThe clock config struct may also contain fields for configuring low-power modes or other power-related features.\n\n### UARTs\nChip implementations may provide one or more UART implementations that allow `std.io` streams to be used.  If there is only one implementation, `chip.uart.UART` should be a function that takes a comptime configuration struct and returns an implementation struct.  If multiple implementations are provided via separate constructor functions.\n\nThe recommended names and types for some common configuration options are:\n\n- `baud_rate_hz: comptime_int`\n- `data_bits: enum`\n    - Generally `.seven` or `.eight`, sometimes maybe other values\n    - Should not include parity bit\n- `parity: enum`\n    - `.even`, `.odd`, or `.none`\n- `stop_bits: enum`\n    - Usually `.one` or `.two`, sometimes `.one_and_half` or `.half`\n- `which: ?enum`\n    - If the chip has multiple UART peripherals, allows selection of which one to use\n    - If set to null, select automatically based on rx/tx pins specified\n- `rx: ?Pad_ID`\n    - The input pin to use for receiving, or null to disable receiving\n- `tx: ?Pad_ID`\n    - The output pin to use for transmitting, or null to disable transmitting\n- `cts: ?Pad_ID`\n    - The input pin to use for RTS/CTS bidirectional flow control\n- `rts: ?Pad_ID`\n    - The output pin to use for RTS/CTS bidirectional flow control\n- `tx_buffer_size: comptime_int`\n    - The size of the internal software transmit FIFO buffer\n    - Set to 0 to disable interrupt/DMA driven I/O\n- `rx_buffer_size: comptime_int`\n    - The size of the internal software receive FIFO buffer\n    - Set to 0 to disable interrupt/DMA driven I/O\n- `tx_dma_channel: ?enum`\n    - If multiple DMA channels are available, select one to use for transmission\n    - Set to null to not use DMA for transmitted data\n- `rx_dma_channel: ?enum`\n    - If multiple DMA channels are available, select one to use for reception\n    - Set to null to not use DMA for received data\n\nAll UART implementations should expose at least these declarations:\n\n    const Data_Type // usually u8\n    fn init() Self\n    fn start(*Self) void\n    fn stop(*Self) void\n\nImplementations that have reception capability should provide:\n\n    fn is_rx_idle(*Self) bool // optional; some hardware may not be capable of reporting this\n    fn get_rx_available_count(*Self) usize\n    fn can_read(*Self) bool\n    fn peek(*Self, []Data_Type) Read_Error![]const Data_Type\n    fn peek_one(*Self) Read_Error!?Data_Type\n\n    const Read_Error\n    const Reader // usually std.io.Reader(..., Read_Error, ...)\n    fn reader(*Self) Reader\n\n    const Read_Error_Nonblocking\n    const Reader_Nonblocking\n    fn reader_nonblocking(*Self) Reader_Nonblocking\n\n`Read_Error` usually consists of some subset of:\n\n- `error.Overrun`\n    - Indicates some received data was lost because older data was not read fast enough\n    - Attempting to read again should return at least one word before another Overrun can occur\n- `error.Parity_Error`\n    - Indicates potential data corruption due to parity mismatch\n    - The character received should still be provided if another read is performed\n- `error.Framing_Error`\n    - Indicates an incorrect line state during the stop bit, which may indicate data corruption, configuration mismatch, or severe clock drift\n    - The character received should still be provided if another read is performed\n- `error.Break_Interrupt`\n    - Indicates an entire frame of 0 bits was received, including stop bits\n    - May be used as a data separator in some protocols, or may indicate a broken cable or other physical issue\n    - Note some implementations may not be capable of differentiating a break character from a framing error\n- `error.Noise_Error`\n    - Indicates that a signal transition was detected too close to the \"center\" of a bit period\n    - May indicate borderline baud rate mismatch or significant noise on the line\n    - The received noisy character should still be readable after this error is seen\n\nImplementations that have transmission capability should provide:\n\n    fn is_tx_idle(*Self) bool // optional; some hardware may not be capable of reporting this\n    fn get_tx_available_count(*Self) usize\n    fn can_write(*Self) bool\n\n    const Write_Error\n    const Writer // usually std.io.Writer(..., Write_Error, ...)\n    fn writer(*Self) Writer\n\n    const Write_Error_Nonblocking\n    const Writer_Nonblocking\n    fn writer_nonblocking(*Self) Writer_Nonblocking\n\nThe `Read_Error_Nonblocking` and `Write_Error_Nonblocking` should generally match include everything from the blocking variants, as well as `error.Would_Block`, which is returned when the buffer is empty/full and no more data can be read or written.  Ideally, when reading or writing multiple words, either the entire operation succeeds, or it has no effect if `Would_Block` is returned, except for functions that give feedback on how much work they accomplished (e.g. `Writer.write`).  This precludes the use of `std.io.Reader`/`Writer` for the non-blocking variants.\n\nSome implementations may require additional functions, e.g. to handle interrupts.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/2828351?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "http://magicmoremagic.com",
  "owner_twitter_username": null,
  "owner_followers": 8,
  "owner_following": 0,
  "owner_created_at": "2012-11-18T17:51:58Z",
  "category": "embedded"
}