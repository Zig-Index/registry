{
  "name": "microbe",
  "owner": "bcrist",
  "repo": "microbe",
  "description": "Embedded Zig framework for ARM microcontrollers",
  "type": "package",
  "topics": [
    "cortex-m",
    "embedded",
    "rpi-pico",
    "stm32",
    "zig",
    "zig-library",
    "zig-package",
    "ziglang"
  ],
  "stars": 7,
  "forks": 0,
  "watchers": 2,
  "updated_at": "2025-12-24T17:46:33Z",
  "minimum_zig_version": "0.15.2",
  "readme": "# Microbe\n\nMicrobe is a framework for developing embedded firmware in Zig, primarily targeting small 32-bit architectures like ARM Cortex-M0.  Some parts were originally based on [microzig](https://github.com/ZigEmbeddedGroup/microzig), but there were a few things about microzig that I didn't like (at least at the time).  It has been a long time and I have not kept up with microzig so I expect there are many significant differences at this point.\n\n## Building\nAdd the main microbe dependency to your project:\n```bash\nzig fetch --save https://github.com/bcrist/microbe\n```\n\nAdd a chip implementation dependency to your project:\n```bash\nzig fetch --save https://github.com/bcrist/microbe-rpi\n```\n\nSet up your `build.zig`:\n```zig\nconst microbe = @import(\"microbe\");\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    microbe.addExecutable(.{\n        .root_module = b.path(\"...\"),\n        .chip = ...\n    });\n}\n```\n\nSee the examples in a chip implementation repo for more specific setup for a particular target.\n\n## Conventions\nAll chip implementations should implement the symbols found in `template/chip.zig`.  Implementations are free to provide additional functionality, but if firmware can be written using only these \"public\" APIs then it should be relatively easy to port between different chips.\n\n### Interrupt Configuration\nChip implementations should provide an enum `chip.interrupts.Interrupt` which lists all the \"external\" interrupts supported by the chip.  Additionally `chip.interrupts.Exception` should be an enum which includes all the interrupts, but also may contain synchronous exceptions & fault conditions.  The integer values associated with an interrupt need not be the same as the integer associated with the corresponding Exception.\n\nChip implementations should look for an `interrupts` struct in the root source file and automatically populate the vector table (or equivalent) with the addresses of the handlers provided within it.  The handler names must match the names from `chip.interrupts.Exception` exactly.\n\n### Clock & Power Configuration\nChip implementations should provide a struct `chip.clocks.Config` which allows configuration of all the major clock domains on the chip.  The exact format will depend on the details of the architecture, but for every major clock domain in the chip, the clock config should have a field:\n```zig\n    xxx_frequency_hz: comptime_int\n```\n\nWhere `xxx` is the name of the clock domain.  A frequency of 0 Hz should be considered to mean \"clock disabled\".  If a clock domain is sourced from another clock, it should additionally have a field:\n```zig\n    xxx_source: E\n```\nWhere `E` is an enum type, or optional-wrapped enum type, giving the options that can be used as a source.\n\nOn reset, chip implementations should initialize the chip's clocks based on a `clocks` constant (of type `chip.clocks.Config`) declared in the root source file.  If no such declaration exists, the chip's default clock configuration should be used.\n\nChip implementations should also provide `chip.clocks.apply_config(...)` to allow dynamic clock changes.  Peripherals that are sensitive to clock frequencies (UARTs, PWMs etc.) will generally assume the clocks they use do not change, so care must be taken when using this.\n\nChip implementations should also provide `chip.clocks.get_config()` to provide a version of the configuration with additional details and defaults filled in.  This should be comptime callable.  If it does not return a `chip.clocks.Config` struct, it should return a `chip.clocks.Parsed_Config` struct.\n\nThe clock config struct may also contain fields for configuring low-power modes or other power-related features.\n\n### UARTs\nChip implementations may provide one or more UART implementations that allow `std.io.Reader`/`std.io.Writer` streams to be used.  If there is only one implementation, `chip.uart.UART` should be a function that takes a comptime configuration struct and returns an implementation struct.  Multiple implementations may be provided via separate constructor functions.\n\nThe recommended names and types for some common configuration options are:\n\n- `baud_rate_hz: comptime_int`\n- `data_bits: enum`\n    - Generally `.seven` or `.eight`, sometimes maybe other values\n    - Should not include parity bit\n- `parity: enum`\n    - `.even`, `.odd`, or `.none`\n- `stop_bits: enum`\n    - Usually `.one` or `.two`, sometimes `.one_and_half` or `.half`\n- `which: ?enum`\n    - If the chip has multiple UART peripherals, allows selection of which one to use\n    - If set to null, select automatically based on rx/tx pins specified\n- `rx: ?Pad_ID`\n    - The input pin to use for receiving, or null to disable receiving\n- `tx: ?Pad_ID`\n    - The output pin to use for transmitting, or null to disable transmitting\n- `cts: ?Pad_ID`\n    - The input pin to use for RTS/CTS bidirectional flow control\n- `rts: ?Pad_ID`\n    - The output pin to use for RTS/CTS bidirectional flow control\n- `tx_buffer_size: comptime_int`\n    - The size of the internal software transmit FIFO buffer\n    - Set to 0 to disable interrupt/DMA driven I/O\n- `rx_buffer_size: comptime_int`\n    - The size of the internal software receive FIFO buffer\n    - Set to 0 to disable interrupt/DMA driven I/O\n- `tx_dma_channel: ?enum`\n    - If multiple DMA channels are available, select one to use for transmission\n    - Set to null to not use DMA for transmitted data\n- `rx_dma_channel: ?enum`\n    - If multiple DMA channels are available, select one to use for reception\n    - Set to null to not use DMA for received data\n\nAll UART implementations should expose at least these declarations:\n\n    fn init() Self\n    fn start(*Self) void\n    fn stop(*Self) void\n\nImplementations that have reception capability should provide:\n\n    fn is_rx_idle(*Self) bool // optional; some hardware may not be capable of reporting this\n    fn get_rx_available_count(*Self) usize\n    fn can_read(*Self) bool\n    fn peek(*Self, []Data_Type) Read_Error![]const Data_Type\n    fn peek_one(*Self) Read_Error!?Data_Type\n\n    const Read_Error\n    last_read_error: ?Read_Error\n    reader: std.io.Reader\n\n`Read_Error` usually consists of some subset of:\n\n- `error.Overrun`\n    - Indicates some received data was lost because older data was not read fast enough\n    - Attempting to read again should return at least one word before another Overrun can occur\n- `error.Parity_Error`\n    - Indicates potential data corruption due to parity mismatch\n    - The character received should still be provided if another read is performed\n- `error.Framing_Error`\n    - Indicates an incorrect line state during the stop bit, which may indicate data corruption, configuration mismatch, or severe clock drift\n    - The character received should still be provided if another read is performed\n- `error.Break_Interrupt`\n    - Indicates an entire frame of 0 bits was received, including stop bits\n    - May be used as a data separator in some protocols, or may indicate a broken cable or other physical issue\n    - Note some implementations may not be capable of differentiating a break character from a framing error\n- `error.Noise_Error`\n    - Indicates that a signal transition was detected too close to the \"center\" of a bit period\n    - May indicate borderline baud rate mismatch or significant noise on the line\n    - The received noisy character should still be readable after this error is seen\n\nImplementations that have transmission capability should provide:\n\n    fn is_tx_idle(*Self) bool // optional; some hardware may not be capable of reporting this\n    fn get_tx_available_count(*Self) usize\n    fn can_write(*Self) bool\n\n    const Write_Error\n    last_write_error: ?Write_Error\n    writer: std.io.Writer\n\nSome implementations may require additional functions, e.g. to handle interrupts.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/2828351?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": "http://magicmoremagic.com",
  "owner_twitter_username": null,
  "owner_followers": 8,
  "owner_following": 0,
  "owner_created_at": "2012-11-18T17:51:58Z",
  "category": "embedded"
}