{
  "name": "painterz",
  "owner": "ziglibs",
  "repo": "painterz",
  "description": "Low-level implementation of different painting primitives (lines, rectangles, ...) without specialization on a certain draw target",
  "type": "package",
  "topics": [
    "graphics",
    "canvas",
    "painting",
    "2d-graphics",
    "ziglang",
    "zig",
    "zig-package"
  ],
  "stars": 24,
  "forks": 1,
  "watchers": 2,
  "updated_at": "2025-09-21T17:59:14Z",
  "readme": "# painterz\n\nThe idea of this library is to provide platform-independent, embedded-feasible implementations of several drawing primitives.\n\nThe library exports a generic `Canvas` type which is specialized on a `setPixel` function that will put pixels of type `Color` onto a `Framebuffer`.\nIt's currently not possible or planned to do blending, but alpha test could be implemented by ignoring certain color values in the `setPixel` function.\n\n## Usage Example\n\n![Usage example rendering](docs/example.png)\n\nSee [`src/example.zig`](src/example.zig) for a full usage example.\n\n```zig\nconst Pixel = packed struct {\n    r: u8, g: u8, b: u8, a: u8\n};\n\nconst Framebuffer = struct {\n    buffer: []Pixel,\n\n    fn setPixel(fb: @This(), x: isize, y: isize, c: Pixel) void {\n        if (x < 0 or y < 0) return;\n        if (x >= 100 or y >= 100) return;\n        fb.buffer[100 * std.math.absCast(y) + std.math.absCast(x)] = c;\n    }\n};\n\nvar canvas = painterz.Canvas(Framebuffer, Pixel, Framebuffer.setPixel).init(Framebuffer{\n    .buffer = â€¦,\n});\n\ncanvas.drawLine(100, 120, 110, 90, Pixel{\n    .r = 0xFF,\n    .g = 0x00,\n    .b = 0xFF,\n    .a = 0xFF,\n});\n```\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/65570835?v=4",
  "releases": [],
  "owner_bio": "Community-driven library development",
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_created_at": "2020-05-18T21:45:12Z",
  "license": "MIT",
  "category": "graphics"
}