{
  "name": "uuid",
  "owner": "jamesfrancis2004",
  "repo": "uuid",
  "description": "A uuid library written in zig",
  "type": "project",
  "topics": [
    "zig-package"
  ],
  "stars": 3,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-12-01T09:58:58Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# UUID Library for Zig\nA comprehensive UUID (Universally Unique Identifier) library for Zig, supporting all standard UUID versions (1-5) and modern extensions (6-8) as defined in RFC 4122 and the draft RFC for UUIDv6, UUIDv7, and UUIDv8.\n\n## Features\n- **All UUID Versions**: Support for UUID versions 1-8\n  - **v1**: Time-based with MAC address\n  - **v3**: Name-based using MD5 hashing\n  - **v4**: Random UUIDs using cryptographically secure randomness\n  - **v5**: Name-based using SHA-1 hashing\n  - **v6**: Time-ordered with MAC address (reordered timestamp for better sorting)\n  - **v7**: Time-ordered with random data (millisecond precision, sortable)\n  - **v8**: Custom UUIDs with user-defined data\n- **Multiple Parsing Formats**: Parse UUIDs from hyphenated, simple, braced, and URN formats\n- **Flexible Formatting**: Convert UUIDs to hyphenated or simple string formats\n- **Timestamp Extraction**: Extract timestamps from time-based UUIDs (v1, v6, v7)\n- **Comparison Operations**: Built-in comparison methods for sorting and equality checking\n- **Hash Map Support**: Includes `HashContext` for use in Zig hash maps and sets\n- **Zero Dependencies**: Pure Zig implementation with no external dependencies\n- **Compile-Time Safety**: Leverages Zig's compile-time features for optimal performance\n\n## Compatibility\n| UUID Library Version | Zig Version |\n|---------------------|-------------|\n| 0.1.0               | 0.15.x      |\n\n## Installation\n\n### Using Zig Package Manager (Zig 0.11+)\nFirst, fetch the package to get the hash:\n\n```bash\nzig fetch --save https://github.com/jamesfrancis2004/uuid/archive/refs/tags/v0.1.0.tar.gz\n```\nThis will automatically add the dependency to your `build.zig.zon` file. Alternatively, you can manually add it to your `build.zig.zon`:\n\n```zig\n.{\n    .name = \"your-project\",\n    .version = \"0.1.0\",\n    .dependencies = .{\n        .uuid = .{\n            .url = \"https://github.com/jamesfrancis2004/uuid/archive/refs/tags/v0.1.0.tar.gz\",\n            .hash = \"...\", // Zig will provide this hash\n        },\n    },\n}\n```\n\nThen in your `build.zig`:\n\n```zig\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    // Add the uuid dependency\n    const uuid = b.dependency(\"uuid\", .{\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const exe = b.addExecutable(.{\n        .name = \"your-app\",\n        .root_source_file = b.path(\"src/main.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    // Import the uuid module\n    exe.root_module.addImport(\"uuid\", uuid.module(\"uuid\"));\n\n    b.installArtifact(exe);\n}\n```\n\n### Manual Installation\nClone or download this repository and include it in your project:\n\n```zig\nconst uuid_module = b.addModule(\"uuid\", .{\n    .root_source_file = b.path(\"path/to/uuid/src/uuid.zig\"),\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"uuid\", uuid_module);\n```\n\n## Usage\n\n### Basic Usage\n\n```zig\nconst std = @import(\"std\");\nconst uuid = @import(\"uuid\");\n\npub fn main() !void {\n    // Generate a random UUID (v4)\n    const id = uuid.Uuid.v4();\n    const id_str = id.toString();\n    std.debug.print(\"Generated UUID: {s}\\n\", .{id_str});\n\n    // Parse a UUID from string\n    const parsed = try uuid.Uuid.parse(\"550e8400-e29b-41d4-a716-446655440000\");\n    std.debug.print(\"Parsed UUID: {s}\\n\", .{parsed.toString()});\n\n    // Compare UUIDs\n    if (id.eql(parsed)) {\n        std.debug.print(\"UUIDs are equal\\n\", .{});\n    }\n}\n```\n\n### UUID Version Examples\n\n#### Version 1 (Time-based with MAC)\n\n```zig\nconst node: [6]u8 = .{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB };\nconst id_v1 = uuid.Uuid.v1(node);\n\n// Extract timestamp (in nanoseconds since Unix epoch)\nif (id_v1.getNanos()) |nanos| {\n    std.debug.print(\"Timestamp: {d} ns\\n\", .{nanos});\n}\n\n// Extract timestamp (in milliseconds)\nif (id_v1.getMillis()) |millis| {\n    std.debug.print(\"Timestamp: {d} ms\\n\", .{millis});\n}\n\n// Extract MAC address\nif (id_v1.getNode()) |mac| {\n    std.debug.print(\"MAC: {x:0>2}:{x:0>2}:{x:0>2}:{x:0>2}:{x:0>2}:{x:0>2}\\n\", \n        .{mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]});\n}\n\n// Generate v1 UUID at specific timestamp\nconst id_v1_at = uuid.Uuid.v1At(1_000_000_000, node);\n\n// Set global clock sequence\nuuid.Uuid.v1SetGlobalClockSeq(100);\n```\n\n#### Version 3 & 5 (Name-based)\n\n```zig\nconst namespace = @import(\"uuid\").namespace;\n\n// v3 uses MD5\nconst id_v3 = uuid.Uuid.v3(&namespace.NAMESPACE_DNS, \"example.org\");\n\n// v5 uses SHA-1 (preferred over v3)\nconst id_v5 = uuid.Uuid.v5(&namespace.NAMESPACE_URL, \"https://example.org\");\n```\n\n#### Version 4 (Random)\n\n```zig\n// Using cryptographically secure random\nconst id_v4 = uuid.Uuid.v4();\n\n// Using custom RNG\nvar prng = std.Random.DefaultPrng.init(12345);\nconst rng = prng.random();\nconst id_v4_custom = uuid.Uuid.v4WithRng(rng);\n```\n\n#### Version 6 (Sortable time-based with MAC)\n\n```zig\nconst node: [6]u8 = .{ 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB };\n\n// Generate v6 UUID (reordered v1 for better database indexing)\nconst id_v6 = uuid.Uuid.v6(node);\n\n// v6 UUIDs are naturally sortable by timestamp\nconst id_v6_1 = uuid.Uuid.v6(node);\nconst id_v6_2 = uuid.Uuid.v6(node);\nstd.debug.print(\"v6_2 > v6_1: {}\\n\", .{id_v6_2.gt(id_v6_1)});\n\n// Generate at specific timestamp\nconst id_v6_at = uuid.Uuid.v6At(1_000_000_000, node);\n\n// Set global clock sequence\nuuid.Uuid.v6SetGlobalClockSeq(200);\n```\n\n#### Version 7 (Sortable time-based with random)\n\n```zig\n// Generate v7 UUID (millisecond precision, highly sortable)\nconst id_v7 = uuid.Uuid.v7();\n\n// Generate at specific timestamp (milliseconds since Unix epoch)\nconst id_v7_at = uuid.Uuid.v7At(1_645_557_742_000);\n\n// Using custom RNG\nvar prng = std.Random.DefaultPrng.init(12345);\nconst rng = prng.random();\nconst id_v7_custom = uuid.Uuid.v7WithRng(rng);\nconst id_v7_custom_at = uuid.Uuid.v7WithRngAt(1_645_557_742_000, rng);\n```\n\n#### Version 8 (Custom)\n\n```zig\n// Create custom UUID with your own data\nconst custom_data: [16]u8 = .{\n    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n    0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,\n};\nconst id_v8 = uuid.Uuid.v8(custom_data);\n// Version and variant bits are automatically set\n```\n\n### Parsing UUIDs\n```zig\n// Hyphenated format (standard)\nconst uuid1 = try uuid.Uuid.parse(\"550e8400-e29b-41d4-a716-446655440000\");\n\n// Simple format (no hyphens)\nconst uuid2 = try uuid.Uuid.parse(\"550e8400e29b41d4a716446655440000\");\n\n// Braced format\nconst uuid3 = try uuid.Uuid.parse(\"{550e8400-e29b-41d4-a716-446655440000}\");\n\n// URN format\nconst uuid4 = try uuid.Uuid.parse(\"urn:uuid:550e8400-e29b-41d4-a716-446655440000\");\n\n// Explicit parsing functions\nconst uuid5 = try uuid.Uuid.parseHyphenated(\"550e8400-e29b-41d4-a716-446655440000\");\nconst uuid6 = try uuid.Uuid.parseSimple(\"550e8400e29b41d4a716446655440000\");\n```\n\n### Formatting UUIDs\n```zig\nconst id = uuid.Uuid.v4();\n\n// Hyphenated format (e.g., \"550e8400-e29b-41d4-a716-446655440000\")\nconst hyphenated = id.toString();\n\n// Simple format (e.g., \"550e8400e29b41d4a716446655440000\")\nconst simple = id.toSimpleString();\n\n// Using std.fmt\nstd.debug.print(\"UUID: {}\\n\", .{id});\n```\n\n### Comparison and Sorting\n```zig\nconst id1 = uuid.Uuid.v7();\nconst id2 = uuid.Uuid.v7();\n\n// Comparison operators\nif (id1.lt(id2)) {\n    std.debug.print(\"id1 < id2\\n\", .{});\n}\nif (id1.lte(id2)) {\n    std.debug.print(\"id1 <= id2\\n\", .{});\n}\nif (id1.gt(id2)) {\n    std.debug.print(\"id1 > id2\\n\", .{});\n}\nif (id1.gte(id2)) {\n    std.debug.print(\"id1 >= id2\\n\", .{});\n}\nif (id1.eql(id2)) {\n    std.debug.print(\"id1 == id2\\n\", .{});\n}\n```\n\n### Using UUIDs in Hash Maps\n```zig\nconst std = @import(\"std\");\nconst uuid = @import(\"uuid\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    var map = std.HashMap(uuid.Uuid, []const u8, uuid.Uuid.HashContext, 80).init(allocator);\n    defer map.deinit();\n\n    const id = uuid.Uuid.v4();\n    try map.put(id, \"some value\");\n\n    if (map.get(id)) |value| {\n        std.debug.print(\"Found: {s}\\n\", .{value});\n    }\n}\n```\n\n### Special UUIDs\n\n```zig\n// Nil UUID (all zeros)\nconst nil = uuid.Uuid.nil();\nstd.debug.print(\"Is nil: {}\\n\", .{nil.isNil()});\n\n// Max UUID (all ones)\nconst max = uuid.Uuid.max();\nstd.debug.print(\"Is max: {}\\n\", .{max.isMax()});\n```\n\n### UUID Metadata\n\n```zig\nconst id = uuid.Uuid.v4();\n\n// Get version\nif (id.getVersion()) |version| {\n    std.debug.print(\"Version: {}\\n\", .{version});\n}\n\n// Get raw version number\nconst version_num = id.getVersionNum();\n\n// Get variant\nconst variant = id.getVariant();\n\n// Get high/low 64-bit parts\nconst high = id.getHighBits();\nconst low = id.getLowBits();\nconst high_low = id.getHighLowBits(); // Returns tuple\n\n// Access raw bytes\nconst bytes = id.asBytes();\n```\n\n## Running Tests\nRun the test suite:\n\n```bash\nzig build test\n```\n\n## Benchmarks\nThis library includes a benchmark suite to measure UUID generation and parsing performance.\n\n### Running Benchmarks\nThe benchmark command follows this format:\n\n```bash\nzig build bench -- <iterations> <version>\n```\n\nWhere:\n- `<iterations>`: Number of UUIDs to generate/parse\n- `<version>`: One of: `v1`, `v3`, `v4`, `v5`, `v6`, `v7`, `parseString`\n\n### Benchmark Examples\n\n```bash\n# Benchmark v4 (random) generation - 10 million UUIDs\nzig build bench -- 10000000 v4\n\n# Benchmark v7 (sortable) generation - 10 million UUIDs\nzig build bench -- 10000000 v7\n\n# Benchmark v1 (time-based) generation - 10 million UUIDs\nzig build bench -- 10000000 v1\n\n# Benchmark parsing from string - 10 million parses\nzig build bench -- 10000000 parseString\n\n# Benchmark v3 (MD5 name-based) - 1 million UUIDs\nzig build bench -- 1000000 v3\n\n# Benchmark v5 (SHA-1 name-based) - 1 million UUIDs\nzig build bench -- 1000000 v5\n```\n\n### Example Benchmark Output\n```\nv7: 10000000 UUIDs in 234ms\nv4: 10000000 UUIDs in 312ms\nparseString: 10000000 UUIDs in 156ms\n```\n\n### Interpreting Results\nThe benchmarks measure raw throughput for each operation:\n- **v1/v6**: Time-based generation with MAC address (includes counter management)\n- **v3/v5**: Name-based hashing (MD5 and SHA-1 respectively)\n- **v4**: Random UUID generation using cryptographic RNG\n- **v7**: Time-ordered sortable UUIDs with random data\n- **parseString**: Parsing hyphenated UUID strings\n\n## API Reference\n### Core Types\n#### `Uuid`\nThe main UUID type, represented as 16 bytes internally.\n\n#### `Version` (enum)\n- `Nil` (0): Nil UUID\n- `Mac` (1): Time-based with MAC\n- `Dce` (2): DCE Security\n- `Md5` (3): Name-based with MD5\n- `Random` (4): Random\n- `Sha1` (5): Name-based with SHA-1\n- `SortMac` (6): Time-ordered with MAC\n- `SortRand` (7): Time-ordered with random\n- `Custom` (8): Custom\n- `Max` (0xFF): Max UUID\n\n#### `Variant` (enum)\n- `Ncs`: Reserved for NCS compatibility\n- `Rfc4122`: Standard RFC 4122 variant\n- `Microsoft`: Reserved for Microsoft\n- `Future`: Reserved for future definition\n\n### Generation Methods\n- `v1(node: [6]u8) Uuid`\n- `v1At(nanos: i128, node: [6]u8) Uuid`\n- `v1WithCount(count: u14, node: [6]u8) Uuid`\n- `v1WithCountAt(nanos: i128, count: u14, node: [6]u8) Uuid`\n- `v1SetGlobalClockSeq(clockSeq: u14) void`\n- `v3(namespace: *const Uuid, name: []const u8) Uuid`\n- `v4() Uuid`\n- `v4WithRng(rng: std.Random) Uuid`\n- `v5(namespace: *const Uuid, name: []const u8) Uuid`\n- `v6(node: [6]u8) Uuid`\n- `v6At(nanos: i128, node: [6]u8) Uuid`\n- `v6WithCount(count: u14, node: [6]u8) Uuid`\n- `v6WithCountAt(nanos: i128, count: u14, node: [6]u8) Uuid`\n- `v6SetGlobalClockSeq(clockSeq: u14) void`\n- `v7() Uuid`\n- `v7At(millis: i64) Uuid`\n- `v7WithRng(rng: std.Random) Uuid`\n- `v7WithRngAt(millis: i64, rng: std.Random) Uuid`\n- `v8(bytes: [16]u8) Uuid`\n\n### Parsing Methods\n- `parse(buf: []const u8) Error!Uuid`\n- `parseHyphenated(buf: []const u8) Error!Uuid`\n- `parseSimple(buf: []const u8) Error!Uuid`\n\n### Formatting Methods\n- `toString() [36]u8`\n- `toSimpleString() [32]u8`\n- `format(writer: *std.Io.Writer) !void`\n\n### Comparison Methods\n- `eql(other: Uuid) bool`\n- `gt(other: Uuid) bool`\n- `gte(other: Uuid) bool`\n- `lt(other: Uuid) bool`\n- `lte(other: Uuid) bool`\n\n### Metadata Methods\n- `getVersion() ?Version`\n- `getVersionNum() u64`\n- `getVariant() Variant`\n- `getNanos() ?i128`\n- `getMillis() ?i64`\n- `getNode() ?[6]u8`\n- `getCounter() ?u14`\n\n### Utility Methods\n- `nil() Uuid`\n- `max() Uuid`\n- `isNil() bool`\n- `isMax() bool`\n- `init(high: comptime_int, low: comptime_int) Uuid`\n- `fromBytes(bytes: [16]u8) Uuid`\n- `asBytes() *const [16]u8`\n- `getHighBits() u64`\n- `getLowBits() u64`\n- `getHighLowBits() struct { u64, u64 }`\n\n## Standard Namespaces\nThe library provides standard namespace UUIDs as defined in RFC 4122:\n\n```zig\nconst namespace = @import(\"uuid\").namespace;\n\n// Available namespaces:\nnamespace.NAMESPACE_DNS   \nnamespace.NAMESPACE_URL   \nnamespace.NAMESPACE_OID   \nnamespace.NAMESPACE_X500  \n```\n\n## License\nMIT License\n\n## Contributing\nContributions are welcome! Please submit pull requests or open issues on the project repository.\n\n## Resources\n- [RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace](https://tools.ietf.org/html/rfc4122)\n- [Draft RFC: UUID Version 6, 7, and 8](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format)",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/112323474?u=d10b7d396042af0a49f9293ffa23325fef9c7c2c&v=4",
  "releases": [
    {
      "tag_name": "v0.1.0",
      "name": "0.1.0",
      "body": "Supports Zig compiler version [0.15.1](https://ziglang.org/download/0.15.1/release-notes.html)\r\n",
      "prerelease": false,
      "published_at": "2025-10-25T06:41:14Z",
      "html_url": "https://github.com/jamesfrancis2004/uuid/releases/tag/v0.1.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 0,
  "owner_following": 0,
  "owner_created_at": "2022-08-28T11:46:46Z",
  "license": "MIT",
  "category": "library"
}