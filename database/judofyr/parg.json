{
  "name": "parg",
  "owner": "judofyr",
  "repo": "parg",
  "description": "Lightweight argument parser for Zig",
  "type": "package",
  "topics": [
    "argument-parser",
    "zig",
    "zig-package"
  ],
  "stars": 49,
  "forks": 3,
  "watchers": 1,
  "updated_at": "2026-01-11T14:06:07Z",
  "readme": "# parg\n\n**parg** is a lightweight argument parser for Zig which focuses on a single task:\nParsing command-line arguments into positional arguments and long/short flags.\nIt doesn't concern itself _anything_ else.\nYou may find this useful as a quick way of parsing some arguments, or use it as a building block for a more elaborate CLI toolkit.\n\n## Features / non-features\n\n* Parses command-line arguments into **positional arguments**, **long flags** and **short flags**.\n* Provides an iterator interface (`while (parser.next()) |token| â€¦`).\n* Supports boolean flags (`--force`, `-f`).\n* Supports multiple short flags (`-avz`).\n* Values can be provided as separate arguments (`--message Hello`), with a delimiter (`--message=Hello`) and also part of short flag (`-mHello`).\n* Automatically detects `--` and skips any further parsing.\n* Licensed under 0BSD.\n\n## Usage\n\nThe principles of `parg` are as follows:\n\n* Use `parseProcess`, `parseSlice` or `parse` to create a new parser.\n* Remember to call `deinit()` when you're done with the parser.\n* Call `next()` in a loop to parse arguments.\n* Call `nextValue()` whenever you need a plain value.\n* There's a few more knobs you can tweak with.\n\nLet's go over these steps a bit more in detail.\n\n### Create a new parser instance\n\nThere's three ways of creating a parser instance.\nAll of these accept some _options_ as the last argument.\n\n```zig\nconst parg = @import(\"parg\");\n\n// (1) Parse arguments given to the current process:\nvar p = try parg.parseProcess(init, .{});\n\n// (2) Parse arguments from a `[]const []const u8`:\nvar p = parg.parseSlice(slice, .{});\n\n// (3) Parse arguments from an iterator (advanced usage):\nvar p = parg.parse(it, .{});\n\n// Always remember to deinit:\ndefer p.deinit();\n```\n\nIn addition, remember that the first parameter given to a process is the file name of the executable.\nYou typically want to call `nextValue()` to retrieve this value before you continue parsing any arguments.\n\n```zig\nconst program_name = p.nextValue() orelse @panic(\"no executable name\");\n```\n\n### Parsing boolean flags and positional arguments\n\nOnce you have a parser you want to call `next()` in a loop.\nThis returns a token which has three different possibilities:\n\n* `.flag` when it encounters a flag (e.g. `--verbose` or `-v`).\n  This flag has a `.name` field which contains the name of the flag (without the dashes) and a `.kind` field if you need to distinguish between long and short flags.\n  There are also a helper functions `isLong` and `isShort` to easily check the name of the field.\n* `.arg` when it encounters a positional argument.\n* `.unexpected_value` when it encounters an unexpected value.\n  You should just quit the program with an error when this happens.\n  We'll come back to this in the next section.\n\nAlso note that this will automatically split up short flags as expected:\nIf you give the program `-fv` then `next()` will first return a flag with name `f`, and then a flag with name `v`.\n\n```zig\n// See examples/ex1.zig for full example.\n\nvar verbose = false;\nvar force = false;\nvar arg: ?[]const u8 = null;\n\nwhile (p.next()) |token| {\n    switch (token) {\n        .flag => |flag| {\n            if (flag.isLong(\"force\") or flag.isShort(\"f\")) {\n                force = true;\n            } else if (flag.isLong(\"verbose\") or flag.isShort(\"v\")) {\n                verbose = true;\n            } else if (flag.isLong(\"version\")) {\n                std.debug.print(\"v1\\n\", .{});\n                std.os.exit(0);\n            }\n        },\n        .arg => |val| {\n            if (arg != null) @panic(\"only one argument supported\");\n            arg = val;\n        },\n        .unexpected_value => @panic(\"unexpected value\"),\n    }\n}\n```\n\n### Parsing flags with values\n\nWhen you find a flag which require a value you need to invoke `nextValue()`.\nThis returns an optional slice:\n\n```zig\n// See examples/ex2.zig for full example.\n\nwhile (p.next()) |token| {\n    switch (token) {\n        .flag => |flag| {\n            if (flag.isLong(\"file\") or flag.isShort(\"f\")) {\n                file = p.nextValue() orelse @panic(\"--file requires value\");\n            } else if (flag.isLong(\"verbose\") or flag.isShort(\"v\")) {\n                verbose = true;\n            } else if (flag.isLong(\"version\")) {\n                std.debug.print(\"v1\\n\", .{});\n                std.os.exit(0);\n            }\n        },\n        .arg => @panic(\"unexpected argument\"),\n        .unexpected_value => @panic(\"unexpected value\"),\n    }\n}\n```\n\nAll of these will be treated the same way:\n\n* `--file build.zig`\n* `--file=build.zig`\n* `-f build.zig`\n* `-f=build.zig`\n* `-fbuild.zig`\n\nMost notably, notice that when you call `nextValue()` it will \"break out\" of parsing short flags.\nWithout the call to `nextValue()` the code would parse `-fbuild.zig` as the short flags `-f`, `-b`, `-u`, and so on.\n\nThis also explains the need for `.unexpected_value` in `next()`:\nIf you pass `--force=yes` to the first example it will parse the `--force` as a long flag.\nWhen you then _don't_ invoke `nextValue()` (since it's a boolean flag) then we need to later bail out since we didn't expect a value.\n\n### Options and other functionality\n\nThere's currently only one option (which you configure when instantiate the parser):\n\n* `auto_double_dash` (defaults to `true`).\n  When this is `true` it will look for `--` and then stop parsing anything as a flag.\n  Your program will _not_ observe the `--` token at all, and all tokens after this point will be returned as `.arg` (even though they start with a dash).\n  When this is `false` it will return `--` as a regular argument (`.arg`) and argument parsing will continue as usual.\n\nThere's also one additional method:\n\n* `p.skipFlagParsing()`.\n  This turns off any further argument parsing.\n  All tokens after this point will be returned as `.arg` (even though they start with a dash).\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/499?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": "Oslo, Norway",
  "owner_blog": "http://judofyr.net",
  "owner_twitter_username": null,
  "owner_followers": 571,
  "owner_following": 56,
  "owner_created_at": "2008-02-20T16:48:23Z",
  "license": "0BSD",
  "category": "library"
}