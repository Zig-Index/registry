{
  "name": "zevy-reflect",
  "owner": "captkirk88",
  "repo": "zevy-reflect",
  "description": "A reflection library in Zig with utilities covering change detection and interface validation and vtable generation using real structs.",
  "type": "package",
  "topics": [
    "reflection",
    "zig",
    "zig-library",
    "ziglang",
    "zig-package",
    "zig-programming-language"
  ],
  "stars": 2,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-12-16T02:42:40Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# zevy-reflect\n\nA lightweight reflection and change detection library for Zig.\n\n[![Zig Version](https://img.shields.io/badge/zig-0.15.1+-blue.svg)](https://ziglang.org/)\n\n## Features\n\n- **Runtime Type Information**: Get detailed type information at runtime including fields, functions, and nested types\n- **Interface Validation**: Compile-time validation of interface implementations with clear error messages\n    - **VTable Generation**: Create vtables for dynamic dispatch based on interfaces, with support for interface extension. Tested using std.mem.Allocation.VTable interface.\n- **Change Detection**: Track changes to struct fields with minimal memory overhead (8 bytes)\n- **Zero Dependencies**: Pure Zig implementation with no external dependencies\n- **Branch Quota Efficient**: Reduced comptime branch quota usage for better compile-time performance.\n\n## Installation\n\nAdd to your `build.zig.zon`:\n\n```bash\nzig fetch --save git+https://github.com/captkirk88/zevy-reflect\n```\n\nThen in your `build.zig`:\n\n```zig\nconst zevy_reflect = b.dependency(\"zevy_reflect\", .{});\nexe.root_module.addImport(\"zevy_reflect\", zevy_reflect.module(\"zevy_reflect\"));\n```\n\n## Quick Start\n\n### Reflection\n\nThis library provides both lightweight (shallow) runtime `TypeInfo` and a small set of helpers to query type structure without blowing up comptime.\n\n```zig\nconst reflect = @import(\"zevy_reflect\");\nconst std = @import(\"std\");\n\nconst MyStruct = struct {\n    id: u32,\n    name: []const u8,\n    active: bool,\n\n    pub fn getId(self: @This()) u32 { return self.id; }\n};\n\ncomptime {\n    const info = reflect.getTypeInfo(MyStruct);\n    std.debug.print(\"Name: {s}, Size: {d}\\n\", .{ info.name, info.size });\n\n    // Field checks (comptime-safe helpers):\n    try std.testing.expect(comptime reflect.hasField(MyStruct, \"id\"));\n    try std.testing.expect(comptime reflect.hasFunc(MyStruct, \"getId\"));\n\n    // List field names at comptime\n    const fields = reflect.getFields(MyStruct);\n    inline for (fields) |f| std.debug.print(\"field: {s}\\n\", .{ f });\n}\n\n// Runtime: use TypeInfo to introspect dynamic metadata (shallow info avoids recursion)\nconst ti = reflect.getTypeInfo(MyStruct);\nstd.debug.print(\"Runtime fields: {d}\\n\", .{ ti.fields.len });\n\n// Construct a value using `TypeInfo.new` from a tuple literal (comptime API)\ncomptime {\n    const ti_comp = reflect.getTypeInfo(MyStruct);\n    const instance_default = ti_comp.new(.{});\n    const instance_override = ti_comp.new(.{ .id = 10, .name = \"bob\" });\n    try std.testing.expectEqual(@as(u32, 10), instance_override.id);\n}\n```\n\nNotes:\n- `getTypeInfo` returns shallow field and function metadata suitable for runtime use.\n- `TypeInfo.new` is a comptime helper that constructs values from tuple literals; useful for code generation and tests.\n\n### Interface Validation and VTable\n\n`Template(...)` provides a compile-time validator and a typed vtable generator. Useful when you want an explicit interface and a vtable for dynamic dispatch. You can also obtain a convenience bound interface instance with `Template.interface(ImplType, &instance)`.\n\nThis is a different approach to interfaces in Zig.  Hopefully more useful and generally easier to integrate.\n\nSee [common_interfaces.zig](src/common_interfaces.zig) for a examples.\n\n### Change Detection\n\n`Change(T)` is a tiny tracker that hashes trackable fields and detects modifications. Fields beginning with `_` are ignored.\n\n```zig\nconst reflect = @import(\"zevy_reflect\");\nconst std = @import(\"std\");\n\nconst Player = struct {\n    health: i32,\n    score: u32,\n    _internal_id: u64, // ignored by Change\n};\n\nvar player = Player{ .health = 100, .score = 0, ._internal_id = 123 };\nvar tracker = reflect.Change(Player).init(player);\n\n// Mutate through `get()` (mutable) and finish when processed\nvar data = tracker.get();\ndata.health = 80;\ndata.score = 100;\n\nif (tracker.isChanged()) {\n    std.debug.print(\"Player changed: {d}\\n\", .{ tracker.getConst().score });\n    tracker.finish();\n}\n```\n\n> [!WARNING]\n> The tracker compares raw bytes for tracked fields; pointer/slice/array contents are hashed as their pointer/length/contents as appropriate. Be cautious with non-stable data (e.g., transient pointers).\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Add tests for any new functionality\n4. Ensure all tests pass: `zig build test`\n5. Submit a pull request\n\n## Related Projects\n\n- [zevy-ecs](https://github.com/captkirk88/zevy-ecs) - Entity Component System framework that uses zevy-reflect.",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6296457?u=57a7319f473f4c068419efb04c3c3b0f54a42efe&v=4",
  "releases": [],
  "owner_bio": "Am I A.I?",
  "owner_company": "Evil Lair",
  "owner_location": "Moon",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 5,
  "owner_following": 18,
  "owner_created_at": "2014-01-01T08:56:32Z",
  "license": "MIT",
  "category": "library"
}