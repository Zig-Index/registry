{
  "name": "zevy-reflect",
  "owner": "captkirk88",
  "repo": "zevy-reflect",
  "description": "A reflection library in Zig with utilities covering change detection and interface validation and vtable generation using real structs.",
  "type": "package",
  "topics": [
    "reflection",
    "zig",
    "zig-library",
    "ziglang",
    "zig-package",
    "zig-programming-language"
  ],
  "stars": 1,
  "forks": 0,
  "watchers": 0,
  "updated_at": "2025-12-14T12:34:43Z",
  "minimum_zig_version": "0.15.1",
  "readme": "# zevy-reflect\n\nA lightweight reflection and change detection library for Zig.\n\n[![Zig Version](https://img.shields.io/badge/zig-0.15.1+-blue.svg)](https://ziglang.org/)\n\n## Features\n\n- **Runtime Type Information**: Get detailed type information at runtime including fields, functions, and nested types\n- **Interface Validation**: Compile-time validation of interface implementations with clear error messages\n    - **VTable Generation**: Create vtables for dynamic dispatch based on interfaces, with support for interface extension. Tested using std.mem.Allocation.VTable interface.\n- **Change Detection**: Track changes to struct fields with minimal memory overhead (8 bytes)\n- **Zero Dependencies**: Pure Zig implementation with no external dependencies\n- **Branch Quota Efficient**: Reduced comptime branch quota usage for better compile-time performance.\n\n## Installation\n\nAdd to your `build.zig.zon`:\n\n```bash\nzig fetch --save git+https://github.com/captkirk88/zevy-reflect\n```\n\nThen in your `build.zig`:\n\n```zig\nconst zevy_reflect = b.dependency(\"zevy_reflect\", .{});\nexe.root_module.addImport(\"zevy_reflect\", zevy_reflect.module(\"zevy_reflect\"));\n```\n\n## Quick Start\n\n### Reflection\n\nThis library provides both lightweight (shallow) runtime `TypeInfo` and a small set of helpers to query type structure without blowing up comptime.\n\n```zig\nconst reflect = @import(\"zevy_reflect\");\nconst std = @import(\"std\");\n\nconst MyStruct = struct {\n    id: u32,\n    name: []const u8,\n    active: bool,\n\n    pub fn getId(self: @This()) u32 { return self.id; }\n};\n\ncomptime {\n    const info = reflect.getTypeInfo(MyStruct);\n    std.debug.print(\"Name: {s}, Size: {d}\\n\", .{ info.name, info.size });\n\n    // Field checks (comptime-safe helpers):\n    try std.testing.expect(comptime reflect.hasField(MyStruct, \"id\"));\n    try std.testing.expect(comptime reflect.hasFunc(MyStruct, \"getId\"));\n\n    // List field names at comptime\n    const fields = reflect.getFields(MyStruct);\n    inline for (fields) |f| std.debug.print(\"field: {s}\\n\", .{ f });\n}\n\n// Runtime: use TypeInfo to introspect dynamic metadata (shallow info avoids recursion)\nconst ti = reflect.getTypeInfo(MyStruct);\nstd.debug.print(\"Runtime fields: {d}\\n\", .{ ti.fields.len });\n\n// Construct a value using `TypeInfo.new` from a tuple literal (comptime API)\ncomptime {\n    const ti_comp = reflect.getTypeInfo(MyStruct);\n    const instance_default = ti_comp.new(.{});\n    const instance_override = ti_comp.new(.{ .id = 10, .name = \"bob\" });\n    try std.testing.expectEqual(@as(u32, 10), instance_override.id);\n}\n```\n\nNotes:\n- `getTypeInfo` returns shallow field and function metadata suitable for runtime use.\n- `TypeInfo.new` is a comptime helper that constructs values from tuple literals; useful for code generation and tests.\n\n### Interface Validation and VTable\n\n`Interface(Template)` provides a compile-time validator and a typed vtable generator. Useful when you want an explicit interface and a vtable for dynamic dispatch.\n\n```zig\nconst VTable = struct {\n    doThing: *const fn (self: *anyopaque, value: u32) u32,\n};\n\nconst Impl = struct {\n    pub fn doThing(_: *@This(), value: u32) u32 {\n        return value * 2;\n    }\n};\n\nconst TraitImpl = Interface(VTable);\nvar inst = Impl{};\nvar vt = TraitImpl.vTableAsTemplate(Impl);\n\nconst result = vt.doThing(&inst, 21);\nstd.debug.assert(result == 42); // The answer to life, the universe, and everything\n```\n\nNotes:\n- `validate` checks method names and signatures (including handling `self`), emitting clear compile-time errors when mismatched.\n- `vTable` returns a compile-time constructed struct of function pointers matching the template methods.\n- `extend` allows adding another interface to create composite interfaces.\n\n### Change Detection\n\n`Change(T)` is a tiny tracker that hashes trackable fields and detects modifications. Fields beginning with `_` are ignored.\n\n```zig\nconst reflect = @import(\"zevy_reflect\");\nconst std = @import(\"std\");\n\nconst Player = struct {\n    health: i32,\n    score: u32,\n    _internal_id: u64, // ignored by Change\n};\n\nvar player = Player{ .health = 100, .score = 0, ._internal_id = 123 };\nvar tracker = reflect.Change(Player).init(player);\n\n// Mutate through `get()` (mutable) and finish when processed\nvar data = tracker.get();\ndata.health = 80;\ndata.score = 100;\n\nif (tracker.isChanged()) {\n    std.debug.print(\"Player changed: {d}\\n\", .{ tracker.getConst().score });\n    tracker.finish();\n}\n```\n\n> [!WARNING]\n> The tracker compares raw bytes for tracked fields; pointer/slice/array contents are hashed as their pointer/length/contents as appropriate. Be cautious with non-stable data (e.g., transient pointers).\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch\n3. Add tests for any new functionality\n4. Ensure all tests pass: `zig build test`\n5. Submit a pull request\n\n## Related Projects\n\n- [zevy-ecs](https://github.com/captkirk88/zevy-ecs) - Entity Component System framework that uses zevy-reflect.",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6296457?u=57a7319f473f4c068419efb04c3c3b0f54a42efe&v=4",
  "releases": [],
  "owner_bio": "Am I A.I?",
  "owner_company": "Evil Lair",
  "owner_location": "Moon",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 5,
  "owner_following": 17,
  "owner_created_at": "2014-01-01T08:56:32Z",
  "license": "MIT",
  "category": "library"
}