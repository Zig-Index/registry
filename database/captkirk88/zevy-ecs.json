{
  "name": "zevy-ecs",
  "owner": "captkirk88",
  "repo": "zevy-ecs",
  "description": "High-performance, archetype-based Entity-Component-System (ECS) framework written in Zig. Manage entities, components, systems, resources, events, stages, states.  Inspired by rust Bevy",
  "type": "package",
  "topics": [
    "archetype",
    "ecs",
    "entity-component-system",
    "systems",
    "zig-package",
    "zig-library",
    "bevy",
    "entity-component-framework"
  ],
  "stars": 9,
  "forks": 1,
  "watchers": 0,
  "updated_at": "2026-01-01T17:15:16Z",
  "dependencies": [
    {
      "name": "zevy_reflect",
      "url": "git+https://github.com/captkirk88/zevy-reflect#15e55f475c1b0d2f38accbd83a5a75c970ac5981",
      "hash": "zevy_reflect-0.0.1-8SzYxmR0AgBRzHSiEaDYGLb6aMr_-tPzB-WEM31uKQfz"
    },
    {
      "name": "zevy_reflect",
      "url": "../zevy-reflect"
    },
    {
      "name": "zevy_mem",
      "url": "git+https://github.com/captkirk88/zevy-mem#bb9b83e8d4a3ac689f0dfc9edae8015a1aa8835d",
      "hash": "zevy_mem-0.0.1-jK9L0ZWmAgC17MDoo2QPM9b9LveBYWzxdqzQL6nTj6nH"
    },
    {
      "name": "zevy_mem",
      "url": "../zevy-mem"
    },
    {
      "name": "zevy_buildtools",
      "url": "git+https://github.com/captkirk88/zevy-buildtools#ec089b7ab9607311e12ab5a92936702d8df94461",
      "hash": "zevy_buildtools-0.0.0-So808bhxAADKN4Hd4CWr_EUNIg2xUIqzfKdM_XMD9eum"
    }
  ],
  "minimum_zig_version": "0.15.1",
  "readme": "# zevy_ecs\n\nzevy_ecs is a high-performance, archetype-based Entity-Component-System (ECS) framework written in Zig. It provides a type-safe, efficient way to manage entities, components, systems, resources, and events in your applications.\n\n[license]: https://img.shields.io/github/license/captkirk88/zevy-ecs?style=for-the-badge&logo=opensourcehardware&label=License&logoColor=C0CAF5&labelColor=414868&color=8c73cc\n\n[![][license]](https://github.com/captkirk88/zevy-ecs/blob/main/LICENSE)\n\n[![Zig Version](https://img.shields.io/badge/zig-0.15.1+-blue.svg)](https://ziglang.org/)\n\n## Features\n\n- **Archetype-based storage**: Efficiently groups entities with the same component combinations for cache-friendly iteration\n- **Type-safe queries**: Compile-time validated component queries with include/exclude filters and optional components\n- **Flexible system parameters**: Built-in support for Query, Res (resources), Local (per-system state), State/NextState, EventReader/EventWriter, Relations\n- **Relationship Support** : Manage entity relationships with minimal overhead using the Relations system parameter\n- **Resource management**: Global state accessible across systems with automatic cleanup\n- **Event system**: Built-in event queue with filtering and handling capabilities in a circular buffer\n- **Batch operations**: High-performance batch entity creation\n- **Component serialization**: Built-in support for serializing/deserializing components and entities\n- **Extensible parameter system**: Create custom system parameters by implementing `analyze` and `apply` functions\n- **Zero runtime overhead**: All parameter resolution happens at compile time\n\n## Table of Contents\n\n- [Quick Start](#quick-start)\n    - [Installation](#installation)\n    - [Examples](#examples)\n    - [Basic Usage](#basic-usage)\n- [Core Concepts](#core-concepts)\n    - [Entities](#entities)\n    - [Components](#components)\n    - [Queries](#queries)\n    - [Systems](#systems)\n    - [System Parameters](#system-parameters)\n    - [Resources](#resources)\n    - [Events](#events)\n    - [Relations](#relations)\n- [Advanced Features](#advanced-features)\n    - [System Composition](#system-composition)\n    - [Custom System Registries](#custom-system-registries)\n    - [Serialization](#serialization)\n        - [Basic Component Serialization](#basic-component-serialization)\n        - [Using ComponentWriter](#using-componentwriter)\n        - [Using ComponentReader](#using-componentreader)\n        - [Entity Serialization](#entity-serialization)\n        - [Batch Entity Serialization](#batch-entity-serialization)\n    - [Plugin System](#plugin-system)\n        - [Basic Plugin Usage](#basic-plugin-usage)\n        - [Creating Reusable Plugins](#creating-reusable-plugins)\n    - [Scheduler](#scheduler)\n        - [Predefined Stages](#predefined-stages)\n        - [Basic Usage](#basic-usage-1)\n        - [Creating Custom Stages](#creating-custom-stages)\n        - [State Management](#state-management)\n        - [Event Registration](#event-registration)\n        - [Getting Stage Information](#getting-stage-information)\n- [Performance](#performance)\n- [Projects](#projects)\n- [Dependencies](#dependencies)\n- [Contributing](#contributing)\n\n## Quick Start\n\n### Installation\n\n```zig\nzig fetch --save https://github.com/captkirk88/zevy-ecs/archive/refs/tags/<tag name>.tar.gz\n// OR for latest commit from main branch\nzig fetch --save git+https://github.com/captkirk88/zevy-ecs\n```\n\nAnd in your `build.zig`:\n\n```zig\nconst zevy_ecs = b.dependency(\"zevy_ecs\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\nexe.root_module.addImport(\"zevy_ecs\", zevy_ecs.module(\"zevy_ecs\"));\n\n// Optional: If you want to use the benchmarking utilities\nexe.root_module.addImport(\"zevy_ecs_benchmark\", zevy_ecs.module(\"benchmark\"));\n\n// Optional: If you want to use the plugin system\nexe.root_module.addImport(\"zevy_ecs_plugins\", zevy_ecs.module(\"plugins\")); // Would recommend calling it something easier to work with.\n```\n\n### Examples\n\n[Examples](./examples) directory.\n\nRun them with `zig build examples`.  Or use `zig build --help` to see all available examples.\n\n### Basic Usage\n\n```zig\nconst std = @import(\"std\");\nconst zevy_ecs = @import(\"zevy_ecs\");\n\n// Define your components\nconst Position = struct {\n    x: f32,\n    y: f32,\n};\n\nconst Velocity = struct {\n    dx: f32,\n    dy: f32,\n};\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    // Create the ECS manager\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    // Create entities with components\n    const entity1 = manager.create(.{\n        Position{ .x = 0.0, .y = 0.0 },\n        Velocity{ .dx = 1.0, .dy = 0.5 },\n    });\n\n    const entity2 = manager.create(.{\n        Position{ .x = 10.0, .y = 5.0 },\n        Velocity{ .dx = -0.5, .dy = 1.0 },\n    });\n\n    // Query and iterate over entities\n    var query = manager.query(\n        struct { pos: Position, vel: Velocity },\n        .{},\n    );\n\n    // var query = manager.query(.{Position, Velocity}, struct {}); // Alternative syntax\n\n    while (query.next()) |item| {\n        // item.pos is *Position, item.vel is *Velocity\n        item.pos.x += item.vel.dx;\n        item.pos.y += item.vel.dy;\n    }\n\n    // Create and run system\n    const move_system = manager.cacheSystem(zevy_ecs.ToSystem(movementSystem, zevy_ecs.DefaultParamRegistry));\n    try manager.runSystem(move_system);\n}\n\nfn movementSystem(\n    query: zevy_ecs.Query(\n        struct { pos: Position, vel: Velocity }, // Include components\n        .{}, // No exclusions\n    ),\n) void {\n    while (query.next()) |item| {\n        item.pos.x += item.vel.dx;\n        item.pos.y += item.vel.dy;\n    }\n}\n```\n\n## Core Concepts\n\n### Entities\n\nEntities are lightweight identifiers that tie components together. They have an ID and generation for safe reuse.\n\n```zig\n// Create an entity with components\nconst entity = manager.create(.{\n    Position{ .x = 0.0, .y = 0.0 },\n    Health{ .current = 100, .max = 100 },\n});\n\n// Create empty entity\nconst empty = manager.createEmpty();\n\nconst allocator = std.heap.page_allocator;\n\n// Batch create entities (more efficient)\nconst entities = try manager.createBatch(allocator,1000, .{\n    Position{ .x = 0.0, .y = 0.0 },\n});\ndefer allocator.free(entities);\n\n// Check if entity is alive\nif (manager.isAlive(entity)) {\n    // Entity exists\n}\n```\n\n### Components\n\nComponents are plain Zig structs that hold data. Any type can be a component.\n\n```zig\nconst Position = struct {\n    x: f32,\n    y: f32,\n};\n\nconst Health = struct {\n    current: u32,\n    max: u32,\n};\n\n// Add component to existing entity\ntry manager.addComponent(entity, Velocity, .{ .dx = 1.0, .dy = 0.0 });\n\n// Get component (returns ?*T)\nif (try manager.getComponent(entity, Position)) |pos| {\n    pos.x += 1.0;\n}\n\n// Check if entity has component\nconst has_health = try manager.hasComponent(entity, Health);\n\n// Remove component\ntry manager.removeComponent(entity, Velocity);\n\n// Get all components for an entity\nconst components = try manager.getAllComponents(allocator, entity);\ndefer allocator.free(components);\n```\n\n### Queries\n\nQueries allow you to iterate over entities with specific component combinations.\n\n```zig\n// Query entities with Position and Velocity\nvar query = manager.query(\n    struct { pos: Position, vel: Velocity },\n    struct {}, // No exclusions\n);\n\nwhile (query.next()) |item| {\n    // Mutable access to components\n    item.pos.x += item.vel.dx;\n    item.pos.y += item.vel.dy;\n}\n\n// Query with exclusions (entities that DON'T have Armor)\nvar no_armor_query = manager.query(\n    struct { health: Health },\n    struct { armor: Armor },\n);\n\n// Query with optional components\nvar optional_query = manager.query(\n    struct {\n        pos: Position,\n        vel: ?Velocity,  // Optional - may be null\n    },\n    struct {},\n);\n\nwhile (optional_query.next()) |item| {\n    item.pos.x += 1.0;\n    if (item.vel) |vel| {\n        // Only if entity has Velocity\n        item.pos.y += vel.dy;\n    }\n}\n\n// Query with Entity ID\nvar entity_query = manager.query(\n    struct {\n        entity: zevy_ecs.Entity,\n        pos: Position,\n    },\n    struct {},\n);while (entity_query.next()) |item| {\n    std.debug.print(\"Entity {d} at ({d}, {d})\\n\",\n        .{ item.entity.id, item.pos.x, item.pos.y });\n}\n```\n\n### Systems\n\nSystems are functions that operate on entities and resources. They use a parameter injection system for automatic dependency resolution. All parameters are automatically injected.\n\n```zig\nconst DeltaTime = struct { value: f32 };\n\n// System function - all parameters are automatically resolved\nfn movementSystem(\n    query: zevy_ecs.Query(\n        struct { pos: Position, vel: Velocity },\n        struct {},\n    ),\n) void {\n    while (query.next()) |item| {\n        item.pos.x += item.vel.dx;\n        item.pos.y += item.vel.dy;\n    }\n}\n\n// System with resources\nfn damageSystem(\n    dt: zevy_ecs.Res(DeltaTime),\n    query: zevy_ecs.Query(\n        struct { health: Health },\n        struct {},\n    ),\n) void {\n    _ = dt;\n    while (query.next()) |item| {\n        if (item.health.current > 0) {\n            item.health.current -= 1;\n        }\n    }\n}\n\n// System with Commands for deferred operations\nfn spawnSystem(\n    commands: *zevy_ecs.Commands,\n    query: zevy_ecs.Query(\n        struct { spawner: Spawner },\n        struct {},\n    ),\n) !void {\n    while (query.next()) |item| {\n        if (item.spawner.should_spawn) {\n            // Deferred entity creation - entity created when deinit() is called\n            var entity_cmds = try commands.create();\n            defer entity_cmds.deinit();\n            _ = try entity_cmds.add(Position, .{ .x = 0, .y = 0 });\n            _ = try entity_cmds.add(Velocity, .{ .dx = 1.0, .dy = 0.0 });\n        }\n    }\n}\n\n// Create and run system directly\npub fn main() !void {\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    // Add a resource\n    _ = try manager.addResource(DeltaTime, .{ .value = 0.016 });\n\n    // Cache and reuse systems\n    const system_handle = manager.cacheSystem(zevy_ecs.ToSystem(movementSystem, zevy_ecs.DefaultParamRegistry));\n    try manager.runSystem(system_handle);\n\n    // Or cache another system\n    const handle = manager.cacheSystem(zevy_ecs.ToSystem(damageSystem, zevy_ecs.DefaultParamRegistry));\n    try manager.runSystem(handle);\n}\n```\n\n#### Debug Information\n\nIn Debug builds, systems include additional metadata about their signature and parameters. This is useful for logging, debugging, and tooling.\n\n```zig\nconst system = zevy_ecs.ToSystem(movementSystem, zevy_ecs.DefaultParamRegistry);\n\n// In Debug builds, access system debug info\nif (@import(\"builtin\").mode == .Debug) {\n    // Access function signature\n    std.debug.print(\"System signature: {s}\\n\", .{system.debug_info.signature});\n    // Example output: \"fn(*Manager, Query(Position, Velocity))\"\n\n    // Access individual parameter types\n    std.debug.print(\"Number of params: {}\\n\", .{system.debug_info.params.len});\n    for (system.debug_info.params, 0..) |param, i| {\n        std.debug.print(\"  Param {}: {s}\\n\", .{ i, param.type_name });\n        // Example output: \"Param 0: Query(Position, Velocity)\"\n    }\n}\n\n// System handles also have debug info\nconst handle = manager.createSystemCached(movementSystem, zevy_ecs.DefaultParamRegistry);\nif (@import(\"builtin\").mode == .Debug) {\n    std.debug.print(\"Handle signature: {s}\\n\", .{handle.debug_info.signature});\n}\n```\n\nThe debug info provides clean, readable type names for all system parameters including:\n\n- `Res(T)` - Resource types\n- `Query(Include, Exclude)` - Query types with component names\n- `Local(T)` - Local storage types\n- `EventReader(T)` / `EventWriter(T)` - Event types\n- `OnAdded(T)` / `OnRemoved(T)` - Component lifecycle types\n- And all other system parameters\n\nIn Release builds, `debug_info` is `void` and has zero runtime overhead.\n\n### System Parameters\n\nSystems can request various parameters that are automatically injected. All parameters are optional and resolved at compile time:\n\n- **`*Commands`**: Deferred command buffer for entity/component/resource operations (executed after system completes)\n- **`Query(Include, Exclude)`**: Query entities with specific components or **`Single`** to get a single entity with specific components\n- **`Res(T)`**: Access to a global resource of type T\n- **`Local(T)`**: Per-system persistent local state\n- **`State(T)`**: Read-only access to check the current state (where T is an enum)\n- **`NextState(T)`**: Trigger state transitions (where T is an enum)\n- **`EventReader(T)`**: Read events of type T\n- **`EventWriter(T)`**: Write events of type T\n- **`OnAdded(T)`**: Iterate over entities that had component T added since the last system run\n- **`OnRemoved(T)`**: Iterate over entities from which component T was removed since the last system run\n- **`*Relations`**: Access to the RelationManager for entity relationships\n\n> [!NOTE]\n> Direct `*Manager` access is available via `commands.manager`, _compatibility for now_, when using `*Commands`. For immediate operations during system execution, use `commands.manager` methods directly. For deferred entity creation, use `commands.create()` which returns an `EntityCommands` with a `PendingEntity` - call `entity_cmds.flush()` to create the entity and apply queued components. For deferred operations on existing entities, use `Commands` methods like `addComponent`, `removeComponent`, `destroyEntity`, etc.\n\nMore can be added by implementing custom parameter types. (see [Custom System Registries](#custom-system-registries))\n\n### Resources\n\nResources are global singleton values accessible across systems.\n\n```zig\nconst GameConfig = struct {\n    width: u32,\n    height: u32,\n    fps: u32,\n};\n\n// Add resource, returns pointer to resource\nvar config = try manager.addResource(GameConfig, .{\n    .width = 1920,\n    .height = 1080,\n    .fps = 60,\n});\n\n// Modify resource\nconfig.fps = 120;\n\n// Get resource\nif (manager.getResource(GameConfig)) |cfg| {\n    std.debug.print(\"FPS: {d}\\n\", .{cfg.fps});\n}\n\n// Check if resource exists\nconst has_config = manager.hasResource(GameConfig);\n\n// Remove resource\nmanager.removeResource(GameConfig);\n\n// List all resources\nvar types = manager.listResourceTypes();\ndefer types.deinit();\n```\n\n### Events\n\nEvents allow decoupled communication between systems.\n\n```zig\nconst CollisionEvent = struct {\n    entity_a: zevy_ecs.Entity,\n    entity_b: zevy_ecs.Entity,\n};\n\n// System that writes events\nfn collisionDetectionSystem(\n    writer: zevy_ecs.EventWriter(CollisionEvent), // will add EventStore resource for CollisionEvent if not present\n) void {\n    // Emit event\n    writer.write(.{\n        .entity_a = .{ .id = 1, .generation = 0 },\n        .entity_b = .{ .id = 2, .generation = 0 },\n    });\n}\n\n// System that reads events\nfn collisionResponseSystem(\n    reader: zevy_ecs.EventReader(CollisionEvent), // will add EventStore resource for CollisionEvent if not present\n) void {\n    while (reader.read()) |event| {\n        std.debug.print(\"Collision between {d} and {d}\\n\",\n            .{ event.data.entity_a.id, event.data.entity_b.id });\n            event.handled = true; // Mark handled if this event type won't be processed again in another system\n    }\n}\n\n// Initialize event store for your event types\npub fn main() !void {\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    // Create event store\n    var collision_events = zevy_ecs.EventStore(CollisionEvent).init(allocator, 64);\n    defer collision_events.deinit();\n\n    _ = try manager.addResource(zevy_ecs.EventStore(CollisionEvent), collision_events);\n\n    // Run systems...\n\n    // recommended to discard unhandled events later on\n    collision_events.discardUnhandled();\n}\n```\n\n### Component Lifecycle Tracking\n\n`OnAdded` and `OnRemoved` system parameters allow you to react to component changes in real-time.\n\n```zig\nconst Position = struct { x: f32, y: f32 };\n\n// System that reacts to Position components being added\nfn onPositionAddedSystem(\n    added: zevy_ecs.OnAdded(Position),\n) void {\n    for (added.iter()) |item| {\n        std.debug.print(\"Entity {d} gained Position at ({d}, {d})\\n\",\n            .{ item.entity.id, item.comp.x, item.comp.y });\n    }\n}\n\n// System that reacts to Position components being removed\nfn onPositionRemovedSystem(\n    removed: zevy_ecs.OnRemoved(Position),\n) void {\n    for (removed.iter()) |entity| {\n        std.debug.print(\"Entity {d} lost Position component\\n\", .{entity.id});\n    }\n}\n\n// Both can be used together\nfn positionChangeSystem(\n    added: zevy_ecs.OnAdded(Position),\n    removed: zevy_ecs.OnRemoved(Position),\n) void {\n    // Track new entities with Position\n    for (added.iter()) |item| {\n        std.debug.print(\"Added: {d}\\n\", .{item.entity.id});\n    }\n\n    // Track entities losing Position\n    for (removed.iter()) |entity| {\n        std.debug.print(\"Removed: {d}\\n\", .{entity.id});\n    }\n}\n\npub fn main() !void {\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    // Create and cache systems\n    const added_system = manager.cacheSystem(zevy_ecs.ToSystem(onPositionAddedSystem, zevy_ecs.DefaultParamRegistry));\n    const removed_system = manager.cacheSystem(zevy_ecs.ToSystem(onPositionRemovedSystem, zevy_ecs.DefaultParamRegistry));\n\n    // Add/remove components to trigger the systems\n    const entity = manager.create(.{});\n    try manager.addComponent(entity, Position, .{ .x = 0, .y = 0 });\n\n    try manager.runSystem(added_system);    // Prints: \"Entity X gained Position...\"\n\n    try manager.removeComponent(entity, Position);\n\n    try manager.runSystem(removed_system);  // Prints: \"Entity X lost Position...\"\n}\n```\n\n### Relations\n\nRelations allow you to create connections between entities with minimal memory overhead. The `RelationManager` is automatically initialized as a built-in resource when the ECS Manager is created, since entities and relations go hand-in-hand. The system uses an adaptive hybrid approach where relations can be either component-based (minimal overhead for sparse relations) or indexed (for efficient traversal of many relations).\n\nRelation components added via `manager.addComponent()` are automatically synced to the RelationManager for indexed relation types.\n\n#### Relation Types\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\n\n// Non-indexed relation\nconst AttachedTo = struct {};\n\n// Indexed exclusive relation (parent-child hierarchy)\nconst Child = struct {\n    pub const relation_config = zevy_ecs.relations.RelationConfig{\n        .indexed = true,    // Creates bidirectional indices\n        .exclusive = true,  // Entity can only have one parent\n    };\n};\n\n// Indexed non-exclusive relation (entity can own multiple items)\nconst Owns = struct {\n    pub const relation_config = zevy_ecs.relations.RelationConfig{\n        .indexed = true,\n        .exclusive = false,\n    };\n};\n\n// Relation with custom data\nconst SocketData = struct {\n    socket_name: []const u8,\n};\n```\n\n#### Basic Usage\n\n```zig\n// Relations can be added in two ways:\n// 1. Directly via manager.addComponent() - automatically syncs to RelationManager\n// 2. Via RelationManager API - explicitly manages relations\n\nfn setupHierarchy(\n    commands: *zevy_ecs.Commands,\n    relations: *zevy_ecs.Relations,\n) !void {\n    const ecs = commands.manager;\n\n    // Create entities using deferred creation\n    var parent_cmds = try commands.create();\n    _ = try parent_cmds.add(Transform, .{});\n    parent_cmds.flush();\n    const parent = parent_cmds.getEntity();\n\n    var child_cmds = try commands.create();\n    _ = try child1_cmds.add(Transform, .{});\n    child1_cmds.flush();\n    const child = child1_cmds.getEntity();\n\n    // Use RelationManager API\n    try relations.add(ecs, child, parent, Child);\n\n    // Query children of parent\n    const children = relations.getChildren(parent, Child);\n    for (children) |child| {\n        std.debug.print(\"Child: {d}\\n\", .{child.id});\n    }\n\n    // Get parent of child\n    if (try relations.getParent(ecs, child, Child)) |p| {\n        std.debug.print(\"Parent: {d}\\n\", .{p.id});\n    }\n\n    // Check if relation exists\n    if (try relations.has(ecs, child, parent, Child)) {\n        std.debug.print(\"Child1 has parent relation\\n\", .{});\n    }\n\n    // Remove relation\n    try relations.remove(ecs, child, parent, Child);\n}\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    // RelationManager is automatically initialized\n    try setupHierarchy(&manager);\n}\n```\n\n#### Relations with Data\n\n```zig\nfn attachWeapon(\n    commands: *zevy_ecs.Commands,\n    relations: *zevy_ecs.Relations,\n) !void {\n    const ecs = commands.manager;\n\n    // Create entities using deferred creation\n    var char_cmds = try commands.create();\n    _ = try char_cmds.add(Transform, .{});\n    char_cmds.flush();\n    const character = char_cmds.getEntity();\n\n    var weapon_cmds = try commands.create();\n    _ = try weapon_cmds.add(Transform, .{});\n    weapon_cmds.flush();\n    const weapon = weapon_cmds.getEntity();\n\n    // Method 1: Add relation with custom data using RelationManager API\n    try relations.addWithData(\n        ecs,\n        weapon,\n        character,\n        SocketData,\n        .{ .socket_name = \"hand_socket\" },\n    );\n\n    // Method 2: Add relation component directly (auto-syncs)\n    // try ecs.addComponent(weapon, zevy_ecs.relations.Relation(SocketData),\n    //     .{ .target = character, .data = .{ .socket_name = \"hand_socket\" } });\n\n    // Access relation data via component\n    if (try ecs.getComponent(weapon, zevy_ecs.relations.Relation(SocketData))) |rel| {\n        std.debug.print(\"Socket: {s}\\n\", .{rel.data.socket_name});\n        std.debug.print(\"Attached to: {d}\\n\", .{rel.target.id});\n    }\n}\n```\n\n#### Non-Exclusive Relations\n\n```zig\n// Entity can own multiple items\nfn setupInventory(\n    commands: *zevy_ecs.Commands,\n    relations: *zevy_ecs.Relations,\n) !void {\n    const ecs = commands.manager;\n\n    // Create entities using deferred creation\n    var player_cmds = try commands.create();\n    _ = try player_cmds.add(Transform, .{});\n    player_cmds.flush();\n    const player = player_cmds.getEntity();\n\n    var sword_cmds = try commands.create();\n    _ = try sword_cmds.add(Transform, .{});\n    sword_cmds.flush();\n    const sword = sword_cmds.getEntity();\n\n    var shield_cmds = try commands.create();\n    _ = try shield_cmds.add(Transform, .{});\n    shield_cmds.flush();\n    const shield = shield_cmds.getEntity();\n\n    var potion_cmds = try commands.create();\n    _ = try potion_cmds.add(Transform, .{});\n    potion_cmds.flush();\n    const potion = potion_cmds.getEntity();\n\n    // Add non-exclusive relations (entity can have multiple)\n    try relations.add(ecs, player, sword, Owns);\n    try relations.add(ecs, player, shield, Owns);\n    try relations.add(ecs, player, potion, Owns);\n\n    // Get all owned items\n    const items = relations.getParents(player, Owns);\n    std.debug.print(\"Player owns {d} items\\n\", .{items.len});\n}\n```\n\n## Advanced Features\n\n### System Composition\n\n```zig\n// Systems with injected arguments\nfn damageSystemWithMultiplier(\n    multiplier: f32,\n    query: zevy_ecs.Query(struct { health: Health }, .{}),\n) void {\n    while (query.next()) |item| {\n        item.health.current = @intFromFloat(\n            @as(f32, @floatFromInt(item.health.current)) * multiplier\n        );\n    }\n}\n\n// Create system with arguments\nconst system = zevy_ecs.ToSystemWithArgs(\n    damageSystemWithMultiplier,\n    .{0.5}, // multiplier = 0.5\n    zevy_ecs.DefaultParamRegistry,\n);\n\ntry system.run(&manager, system.ctx);\n```\n\n### Custom System Registries\n\nYou can create custom system parameter types by implementing the `analyze` and `apply` functions, then merge them with the default registry. Below is an example of a custom system parameter that combines multiple built-in parameters.\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\npub const ComplexType = struct {\n    /// Unfortunately with the way zig handles anonymous structs we need to define this separately\n    pub const IncludeTypes = struct { a: ComponentA, b: ComponentB };\n    query: zevy_ecs.Query(IncludeTypes, .{}),\n    res: params.Res(i32),\n    local: *params.Local(u64),\n};\n\nconst CustomComplexParam = struct {\n    pub fn analyze(comptime T: type) ?type {\n        const ti = @typeInfo(T);\n        if (ti == .pointer) {\n            const Child = ti.pointer.child;\n            return analyze(Child);\n        }\n        if (ti == .@\"struct\" and @hasField(T, \"query\") and @hasField(T, \"res\") and @hasField(T, \"local\")) {\n            return T;\n        }\n        return null;\n    }\n    pub fn apply(e: *ecs.Manager, comptime _: type) anyerror!ComplexType {\n        const query_val = e.query(ComplexType.IncludeTypes, .{});\n        const res_value = try params.ResourceSystemParam.apply(e, i32);\n        const local_ptr = try params.LocalSystemParam.apply(e, u64);\n        return ComplexType{\n            .query = query_val,\n            .res = res_value,\n            .local = local_ptr,\n        };\n    }\n\n    //Optional but required if you have to clean up\n    pub fn deinit(e: *ecs.Manager, ptr: *anyopaque, comptime Component: type) void {\n        ...\n    }\n};\n\nconst CustomParamRegistry = zevy_ecs.MergedSystemParamRegistry(&[_]type{\n    zevy_ecs.DefaultParamRegistry,\n    CustomComplexParam,\n});\n```\n\n### Serialization\n\nzevy_ecs provides flexible component and entity serialization through `ComponentInstance`, `EntityInstance`, `ComponentWriter`, and `ComponentReader`.\n\n#### Basic Component Serialization\n\n```zig\nconst Position = struct { x: f32, y: f32 };\n\n// Create component instance\nconst pos = Position{ .x = 10.0, .y = 20.0 };\nconst comp = zevy_ecs.serialize.ComponentInstance.from(Position, &pos);\n\n// Serialize to writer\nvar buffer = try std.ArrayList(u8).initCapacity(allocator, 0);\ndefer buffer.deinit(allocator);\ntry comp.writeTo(buffer.writer(allocator).any());\n\n// Deserialize from reader\nvar fbs = std.io.fixedBufferStream(buffer.items);\nconst read_comp = try zevy_ecs.serialize.ComponentInstance.readFrom(fbs.reader().any(), allocator);\ndefer allocator.free(read_comp.data);\n\n// Access typed data\nif (read_comp.as(Position)) |read_pos| {\n    std.debug.print(\"Position: ({d}, {d})\\n\", .{ read_pos.x, read_pos.y });\n}\n```\n\n#### Using ComponentWriter\n\n`ComponentWriter` provides a convenient interface for writing multiple components to a stream.\n\n```zig\nconst Position = struct { x: f32, y: f32 };\nconst Velocity = struct { dx: f32, dy: f32 };\n\n// Create an entity with components\nconst entity = manager.create(.{\n    Position{ .x = 10.0, .y = 20.0 },\n    Velocity{ .dx = 0.5, .dy = -0.3 },\n});\n\n// Get all components from the entity\nconst components = try manager.getAllComponents(allocator, entity);\ndefer allocator.free(components);\n\n// Serialize all components to a buffer\nvar buffer = try std.ArrayList(u8).initCapacity(allocator, 0);\ndefer buffer.deinit(allocator);\n\nvar writer = zevy_ecs.serialize.ComponentWriter.init(buffer.writer(allocator).any());\ntry writer.writeComponents(components);\n```\n\n#### Using ComponentReader\n\n`ComponentReader` provides methods for reading components from a stream with automatic memory management helpers.\n\n```zig\n// Deserialize components from buffer\nvar fbs = std.io.fixedBufferStream(buffer.items);\nvar reader = zevy_ecs.serialize.ComponentReader.init(fbs.reader().any());\n\nconst components = try reader.readComponents(allocator);\ndefer reader.freeComponents(allocator, components);\n\n// Access the typed data\nfor (components) |comp| {\n    if (comp.as(Position)) |pos| {\n        std.debug.print(\"Position: ({d}, {d})\\n\", .{ pos.x, pos.y });\n    } else if (comp.as(Velocity)) |vel| {\n        std.debug.print(\"Velocity: ({d}, {d})\\n\", .{ vel.dx, vel.dy });\n    }\n}\n```\n\n#### Entity Serialization\n\n`EntityInstance` provides complete entity serialization including all components.\n\n```zig\n// Create an entity with multiple components\nconst entity = manager.create(.{\n    Position{ .x = 5.0, .y = 10.0 },\n    Velocity{ .dx = 1.0, .dy = 2.0 },\n    Health{ .value = 100 },\n});\n\n// Convert entity to EntityInstance (owns component data copies)\nconst entity_instance = try zevy_ecs.serialize.EntityInstance.fromEntity(allocator, &manager, entity);\ndefer entity_instance.deinit(allocator);\n\n// Serialize to buffer\nvar buffer = try std.ArrayList(u8).initCapacity(allocator, 0);\ndefer buffer.deinit(allocator);\ntry entity_instance.writeTo(buffer.writer(allocator).any());\n\n// Deserialize from buffer\nvar fbs = std.io.fixedBufferStream(buffer.items);\nconst restored_instance = try zevy_ecs.serialize.EntityInstance.readFrom(fbs.reader().any(), allocator);\ndefer restored_instance.deinit(allocator);\n\n// Create a new entity from the restored data\nconst new_entity = try restored_instance.toEntity(&manager);\n```\n\n#### Batch Entity Serialization\n\n```zig\n// Serialize multiple entities\nvar buffer = try std.ArrayList(u8).initCapacity(allocator, 0);\ndefer buffer.deinit(allocator);\nconst writer = buffer.writer(allocator).any();\n\nconst entities = [_]zevy_ecs.Entity{ entity1, entity2, entity3 };\ntry writer.writeInt(usize, entities.len, .little);\n\nfor (entities) |entity| {\n    const instance = try zevy_ecs.serialize.EntityInstance.fromEntity(allocator, &manager, entity);\n    defer instance.deinit(allocator);\n    try instance.writeTo(writer);\n}\n\n// Deserialize multiple entities\nvar fbs = std.io.fixedBufferStream(buffer.items);\nconst reader = fbs.reader().any();\n\nconst count = try reader.readInt(usize, .little);\nvar i: usize = 0;\nwhile (i < count) : (i += 1) {\n    const restored = try zevy_ecs.serialize.EntityInstance.readFrom(reader, allocator);\n    defer restored.deinit(allocator);\n    _ = try restored.toEntity(&manager);\n}\n```\n\n### Plugin System\n\nThe plugin system provides a modular way to organize and initialize features in your application. Plugins can register systems, resources, and perform setup tasks in a reusable manner.\n\n#### Basic Plugin Usage\n\n```zig\nconst std = @import(\"std\");\nconst zevy_ecs = @import(\"zevy_ecs\");\nconst zevy_plugin = @import(\"zevy_ecs_plugin\");\n\n// Define a plugin with state\nconst PhysicsPlugin = struct {\n    gravity: f32,\n\n    pub fn build(self: *@This(), manager: *zevy_ecs.Manager, plugins: *zevy_ecs.PluginManager) !void {\n        // Add resources\n        _ = try manager.addResource(f32, self.gravity);\n\n        // Register systems, setup state, etc.\n        // check if required plugins are loaded\n    }\n};\n\n// Or use FnPlugin for simple stateless plugins\nconst InputPlugin = zevy_plugin.FnPlugin(\"Input\", struct {\n    fn build(manager: *zevy_ecs.Manager, plugins: *zevy_ecs.PluginManager) !void {\n        // Setup input event handling using Scheduler\n        const InputEvent = struct { key: u32 };\n        const scheduler = manager.getResource(zevy_ecs.Scheduler) orelse return error.SchedulerNotFound;\n        try scheduler.registerEvent(manager, InputEvent);\n    }\n}.build);\n\n// maybe one day Zig will support lambda funcs ðŸ¤ž\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    // Create scheduler and add as resource so plugins can access it\n    const scheduler = try zevy_ecs.Scheduler.init(allocator);\n    defer scheduler.deinit();\n    const sch_res = try manager.addResource(zevy_ecs.Scheduler, scheduler);\n\n    // Create plugin manager\n    var plugin_manager = zevy_plugin.PluginManager.init(allocator);\n    defer plugin_manager.deinit();\n\n    // Add plugins\n    try plugin_manager.add(PhysicsPlugin, .{ .gravity = 9.8 });\n    try plugin_manager.add(InputPlugin, .{});\n\n    // Build all plugins (calls build on each)\n    try plugin_manager.build(&manager);\n\n    // Now use the ECS with initialized plugins\n    const gravity = manager.getResource(f32).?;\n    std.debug.print(\"Gravity: {d}\\n\", .{gravity.*});\n}\n```\n\n#### Creating Reusable Plugins\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\n\npub const RenderPlugin = struct {\n    width: u32,\n    height: u32,\n\n    pub fn build(self: *@This(), manager: *zevy_ecs.Manager, plugins: *zevy_ecs.PluginManager) !void {\n        // Add window config resource\n        const WindowConfig = struct { width: u32, height: u32 };\n        _ = try manager.addResource(WindowConfig, .{\n            .width = self.width,\n            .height = self.height,\n        });\n\n        // Register render systems in a scheduler if available\n        // Cache systems, setup render resources, etc.\n    }\n\n    pub fn deinit(self: *@This(), manager: *zevy_ecs.Manager) void {\n        // Optional: cleanup plugin-specific resources\n        _ = self;\n        _ = manager; // Use manager.allocator or store a custom allocator as a field in the plugin.\n    }\n};\n```\n\n### Scheduler\n\nThe Scheduler manages system execution order through stages. Systems are organized into predefined or custom stages that run in a specific order, allowing you to control the flow of your game loop or application.\n\n#### Predefined Stages\n\nzevy_ecs comes with the following predefined stages (in execution order):\n\n- `Stages.PreStartup` - Runs before startup initialization\n- `Stages.Startup` - Initial setup and initialization\n- `Stages.First` - First stage of the main loop\n- `Stages.PreUpdate` - Before main update logic\n- `Stages.Update` - Main game/app logic\n- `Stages.PostUpdate` - After main update logic\n- `Stages.PreDraw` - Before rendering\n- `Stages.Draw` - Rendering stage\n- `Stages.PostDraw` - After rendering\n- `Stages.StateTransition` - Process state transitions\n- `Stages.StateOnExit` - Systems that run when exiting states\n- `Stages.StateOnEnter` - Systems that run when entering states\n- `Stages.StateUpdate` - Systems that run while in states\n- `Stages.Last` - Final stage of the loop\n- `Stages.Exit` - Cleanup and shutdown\n\n#### Basic Usage\n\n```zig\nconst std = @import(\"std\");\nconst zevy_ecs = @import(\"zevy_ecs\");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    var scheduler = try zevy_ecs.Scheduler.init(allocator);\n    defer scheduler.deinit();\n\n    // Add systems to stages using Stage() function\n    scheduler.addSystem(&manager, zevy_ecs.Stage(zevy_ecs.Stages.Update), movementSystem, zevy_ecs.DefaultParamRegistry);\n    scheduler.addSystem(&manager, zevy_ecs.Stage(zevy_ecs.Stages.Draw), renderSystem, zevy_ecs.DefaultParamRegistry);\n\n    // Run all systems in a specific stage\n    try scheduler.runStage(&manager, zevy_ecs.Stage(zevy_ecs.Stages.Update));\n\n    // Run all systems in a range of stages\n    try scheduler.runStages(&manager, zevy_ecs.Stage(zevy_ecs.Stages.First), zevy_ecs.Stage(zevy_ecs.Stages.Last));\n}\n\nfn movementSystem(\n    query: zevy_ecs.Query(struct { pos: Position, vel: Velocity }, .{}),\n) void {\n    while (query.next()) |item| {\n        item.pos.x += item.vel.dx;\n        item.pos.y += item.vel.dy;\n    }\n}\n\nfn renderSystem(\n    query: zevy_ecs.Query(struct { pos: Position }, .{}),\n) void {\n    while (query.next()) |item| {\n        std.debug.print(\"Render at ({d}, {d})\\n\", .{ item.pos.x, item.pos.y });\n    }\n}\n```\n\n#### Creating Custom Stages\n\nStages are fully extensible! You can create custom stage types with explicit priorities for controlled ordering, or without priorities for hash-based IDs.\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    var scheduler = try zevy_ecs.Scheduler.init(allocator);\n    defer scheduler.deinit();\n\n    // Define custom stages with explicit priorities for controlled ordering\n    const CustomStages = struct {\n        pub const Physics = struct {\n            pub const priority: zevy_ecs.StageId = 350_000; // Between Update (300,000) and PostUpdate (400,000)\n        };\n        pub const AI = struct {\n            pub const priority: zevy_ecs.StageId = 360_000;\n        };\n        pub const Animation = struct {\n            pub const priority: zevy_ecs.StageId = 370_000;\n        };\n    };\n\n    // Or define custom stages without priorities (get hash-based IDs in 2M+ range)\n    const HashStages = struct {\n        pub const CustomLogic = struct {}; // Gets unique hash-based ID\n        pub const SpecialEffects = struct {}; // Different hash-based ID\n    };\n\n    // Add systems to custom stages using Stage() function\n    scheduler.addSystem(&manager, zevy_ecs.Stage(CustomStages.Physics), physicsSystem, zevy_ecs.DefaultParamRegistry);\n    scheduler.addSystem(&manager, zevy_ecs.Stage(CustomStages.AI), aiSystem, zevy_ecs.DefaultParamRegistry);\n    scheduler.addSystem(&manager, zevy_ecs.Stage(HashStages.CustomLogic), customSystem, zevy_ecs.DefaultParamRegistry);\n\n    // Run stages in a range (includes all custom stages in the range)\n    try scheduler.runStages(&manager, zevy_ecs.Stage(zevy_ecs.Stages.Update), zevy_ecs.Stage(zevy_ecs.Stages.PostUpdate));\n}\n\nfn physicsSystem(\n    query: zevy_ecs.Query(struct { pos: Position, vel: Velocity }, .{}),\n) void {\n    while (query.next()) |item| {\n        item.vel.dy += 9.8; // gravity\n    }\n}\n\nfn aiSystem(\n    query: zevy_ecs.Query(struct { pos: Position }, .{}),\n) void {\n    // AI logic here\n    _ = query;\n}\n\nfn customSystem() void {\n    // Custom logic here\n}\n```\n\n#### State Management\n\nzevy_ecs provides powerful enum-based state management with automatic state transitions and lifecycle hooks.\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\n\nconst GameState = enum {\n    MainMenu,\n    Playing,\n    Paused,\n};\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    var scheduler = try zevy_ecs.Scheduler.init(allocator);\n    defer scheduler.deinit();\n\n    // Register state type (automatically adds StateManager resource)\n    try scheduler.registerState(&manager, GameState);\n\n    // Set initial state (or use NextState in a startup system)\n    try scheduler.transitionTo(&manager, GameState, .MainMenu);\n\n    // Add state-specific systems - pass raw functions and param registry\n    // Systems run when entering/exiting states\n    scheduler.addSystem(&manager, zevy_ecs.OnEnter(GameState.Playing), gameplaySystem, zevy_ecs.DefaultParamRegistry);\n    scheduler.addSystem(&manager, zevy_ecs.OnExit(GameState.Playing), cleanupSystem, zevy_ecs.DefaultParamRegistry);\n\n    // Systems run while in a specific state (call manually in game loop)\n    scheduler.addSystem(&manager, zevy_ecs.InState(GameState.MainMenu), menuSystem, zevy_ecs.DefaultParamRegistry);\n    scheduler.addSystem(&manager, zevy_ecs.InState(GameState.Playing), gameplaySystem, zevy_ecs.DefaultParamRegistry);\n\n    // In your game loop, run systems for the active state\n    try scheduler.runActiveStateSystems(&manager, GameState);\n}\n\nfn menuSystem(\n    state: zevy_ecs.State(GameState),\n    next: *zevy_ecs.NextState(GameState),\n) void {\n    if (state.isActive(.MainMenu)) {\n        // Handle menu input\n        // Transition to playing when user presses start\n        next.set(.Playing); // Immediate transition - triggers OnExit/OnEnter\n    }\n}\n\nfn gameplaySystem(\n    query: zevy_ecs.Query(struct { pos: Position, vel: Velocity }, .{}),\n) void {\n    while (query.next()) |item| {\n        item.pos.x += item.vel.dx;\n        item.pos.y += item.vel.dy;\n    }\n}\n```\n\n#### Event Registration\n\nThe Scheduler can automatically set up event handling with cleanup:\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\n\nconst InputEvent = struct {\n    key: u32,\n    pressed: bool,\n};\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    var scheduler = try zevy_ecs.Scheduler.init(allocator);\n    defer scheduler.deinit();\n\n    // Register event type - creates EventStore resource and adds cleanup system\n    try scheduler.registerEvent(&manager, InputEvent);\n\n    // Add system that writes events\n    scheduler.addSystem(&manager, zevy_ecs.Stage(zevy_ecs.Stages.First), inputSystem, zevy_ecs.DefaultParamRegistry);\n\n    // Add system that reads events\n    scheduler.addSystem(&manager, zevy_ecs.Stage(zevy_ecs.Stages.Update), inputHandlerSystem, zevy_ecs.DefaultParamRegistry);\n\n    // Run the stages - cleanup happens automatically in Last stage\n    try scheduler.runStages(&manager, zevy_ecs.Stage(zevy_ecs.Stages.First), zevy_ecs.Stage(zevy_ecs.Stages.Last));\n}\n\nfn inputSystem(\n    writer: zevy_ecs.EventWriter(InputEvent),\n) void {\n    writer.write(.{ .key = 32, .pressed = true }); // Space key pressed\n}\n\nfn inputHandlerSystem(\n    reader: zevy_ecs.EventReader(InputEvent),\n) void {\n    while (reader.read()) |event| {\n        std.debug.print(\"Key {d} pressed: {}\\n\", .{ event.data.key, event.data.pressed });\n        event.handled = true;\n    }\n}\n```\n\n#### Getting Stage Information\n\nYou can inspect the scheduler's current configuration:\n\n```zig\nconst zevy_ecs = @import(\"zevy_ecs\");\n\npub fn main() !void {\n    const allocator = std.heap.page_allocator;\n\n    var manager = try zevy_ecs.Manager.init(allocator);\n    defer manager.deinit();\n\n    var scheduler = try zevy_ecs.Scheduler.init(allocator);\n    defer scheduler.deinit();\n\n    // Get information about all stages\n    var stage_info = scheduler.getStageInfo(allocator);\n    defer stage_info.deinit(allocator);\n\n    for (stage_info.items) |info| {\n        std.debug.print(\"Stage {d}: {d} systems\\n\", .{ info.stage, info.system_count });\n    }\n}\n```\n\n## Performance\n\nzevy_ecs includes a simple benchmarking utility to measure the performance of various operations. Below are some benchmark results for entity creation and system execution.\n\n### Benchmarks\n\n#### 4GHz CPU, ReleaseFast\n\n#### Creation\n\n| Benchmark | Operations | Time/op | Memory/op | Allocs/op\n|-----------|------------|---------|----------|----------|\n| Create 100 Entities | 3 | 23.400 us/op | 17.73 KiB/op | 6/op |\n| Create 1000 Entities | 3 | 120.033 us/op | 161.27 KiB/op | 13/op |\n| Create 10000 Entities | 3 | 983.600 us/op | 2.34 MiB/op | 27/op |\n| Create 100000 Entities | 3 | 7.279 ms/op | 21.96 MiB/op | 40/op |\n| Create 1000000 Entities | 3 | 71.723 ms/op | 235.59 MiB/op | 56/op |\n\n#### Batch Creation\n\n| Benchmark | Operations | Time/op | Memory/op | Allocs/op\n|-----------|------------|---------|----------|----------|\n| Create 100 Entities | 3 | 19.500 us/op | 19.87 KiB/op | 6/op |\n| Create 1000 Entities | 3 | 96.433 us/op | 147.28 KiB/op | 9/op |\n| Create 10000 Entities | 3 | 541.600 us/op | 1.66 MiB/op | 11/op |\n| Create 100000 Entities | 3 | 4.086 ms/op | 16.42 MiB/op | 11/op |\n| Create 1000000 Entities | 3 | 39.222 ms/op | 167.03 MiB/op | 12/op |\n\n#### Mixed Systems\n\n| Benchmark | Operations | Time/op | Memory/op | Allocs/op\n|-----------|------------|---------|----------|----------|\n| Run 7 Systems on 100 Entities | 3 | 2.833 us/op | 0 B/op | 0/op |\n| Run 7 Systems on 1000 Entities | 3 | 5.666 us/op | 0 B/op | 0/op |\n| Run 7 Systems on 10000 Entities | 3 | 48.933 us/op | 0 B/op | 0/op |\n| Run 7 Systems on 100000 Entities | 3 | 484.833 us/op | 0 B/op | 0/op |\n| Run 7 Systems on 1000000 Entities | 3 | 5.354 ms/op | 0 B/op | 0/op |\n\n#### Relations\n\n| Benchmark | Operations | Time/op | Memory/op | Allocs/op\n|-----------|------------|---------|----------|----------|\n| Scene Graph 100 Entities | 3 | 1.100 us/op | 16 B/op | 0/op |\n| Scene Graph 1000 Entities | 3 | 6.633 us/op | 16 B/op | 0/op |\n| Scene Graph 10000 Entities | 3 | 59.233 us/op | 16 B/op | 0/op |\n| Scene Graph 100000 Entities | 3 | 578.166 us/op | 16 B/op | 0/op |\n| Scene Graph 1000000 Entities | 3 | 5.975 ms/op | 16 B/op | 0/op |\n\n## Projects\n\n- [zevy-raylib](https://github.com/captkirk88/zevy-raylib)\n  - A game engine built on top of zevy_ecs and raylib for graphics and input handling.\n  - Uses plugins. Either call plug() or add the plugins manually.\n\n## Dependencies\n- [zevy-reflect](https://github.com/captkirk88/zevy-reflect) - Reflection utilities for Zig.\n- [zevy-mem](https://github.com/captkirk88/zevy-mem) - Memory allocators and utilities for Zig.\n\n## Contributing\n\nContributions are welcome!\nPlease describe issues in detail. Bug reports, feature requests, etc. Pull requests are also welcome.",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/6296457?u=57a7319f473f4c068419efb04c3c3b0f54a42efe&v=4",
  "releases": [],
  "owner_bio": "Am I A.I?",
  "owner_company": "Evil Lair",
  "owner_location": "Moon",
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 6,
  "owner_following": 18,
  "owner_created_at": "2014-01-01T08:56:32Z",
  "license": "MIT",
  "category": "library"
}