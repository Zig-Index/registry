{
  "name": "dishwasher",
  "owner": "edqx",
  "repo": "dishwasher",
  "description": "A non-spec-compliant, but probably pretty fast, XML parser for Zig.",
  "type": "project",
  "topics": [
    "xml",
    "zig",
    "zig-package",
    "household-appliance"
  ],
  "stars": 18,
  "forks": 3,
  "watchers": 1,
  "updated_at": "2025-11-22T19:57:16Z",
  "readme": "# Dishwasher\n\nA fairly fast XML parser for [Zig](https://ziglang.org).\n\nNote that this parser isn't strictly spec-compliant, however it will probably\nwork with most well-formed xml documents.\n\n## Features\n- [x] Pretty speedy\n- [x] Reader API-friendly\n- [x] Can populate structs\n- [x] Can populate dynamic values\n- [x] Compile-time parsing\n- [x] Diagnostics for malformed documents\n- [ ] Stringification (coming soon)\n\n### Benchmarks\n\nHere are the results from the given benchmarks on my pc (i9-14900kf) in different\noptimisation modes, when parsing the [OpenGL XML Spec document](https://github.com/KhronosGroup/OpenGL-Registry/blob/main/xml/gl.xml)\nfully.\n\n| Mode | Min | Max | Avg |\n|------|-----|-----|-----|\n| `Debug` | `100ms` | `280ms` | `131ms` |\n| `ReleaseSafe` | `13ms` | `25ms` | `15ms` | \n| `ReleaseSmall` | `18ms` | `50ms` | `30ms` |\n| `ReleaseFast` | `7ms` | `27ms` | `13ms` |\n\n_All times are averaged over 100 runs, rounded to the nearest 2sf._\n\n## Documentation\n\nGenerate documentation for dishwasher with `zig build docs`, will output browser files at `zig-out/docs`. You can serve\nthis however you like, for example with Python: `python -m http.server` or with NodeJS: `npx serve`.\n\n## Usage\n\nDishwasher has 4 APIs, 3 of which will be most useful.\n\n- [Parsing API](#parsing-api) - for parsing an entire XML document at runtime.\n- [Populate API](#populate-api) - for mapping an XML document to a given struct.\n- [Comptime Parsing and Populate API](#comptime-parsing-and-populate-api) - for parsing an entire XML document at compile time.\n- [Scanner API](#scanner-api) - for iterating through XML symbols from a slice or reader.\n\n### Parsing API\nDishwasher lets you parse an XML document from either an entire slice or a\nreader into a tree-like structure that represents all nodes.\n\nAll of the parse methods create an arena which is returned back to you so that\nyou can deinitialise it when you no longer need the data.\n\n#### Parse from a slice\n```zig\nconst owned_tree = dishwasher.parse.fromSlice(allocator, xml_text);\ndefer owned_tree.deinit(); // all strings and lists will be free'd\n\nstd.debug.assert(owned_tree.tree.children[0] == .elem);\n```\n\n#### Parse from a reader\n```zig\nconst owned_tree = dishwasher.parse.fromReader(allocator, file.reader());\ndefer owned_tree.deinit();\n\nstd.debug.assert(owned_tree.tree.children[0] == .elem);\n```\n\n#### Diagnostics\nYou can also get basic information about invalid documents using the parse\ndiagnostics struct, and passing it into either `parse.fromSliceDiagnostics`\nor `parse.fromReaderDiagnostics`.\n```zig\nvar diagnostics = dishwasher.parse.Diagnostics.init(allocator);\ndefer diagnostics.deinit();\n\nconst parsed = try dishwasher.parse.fromReaderDiagnostics(allocator, file.reader(), &diagnostics);\ndefer parsed.deinit();\n\nfor (diagnostics.defects.items) |defect| {\n  std.debug.print(\"{} from {}..{}\", .{ defect.kind, defect.range.start, defect.range.end });\n}\n```\n\n#### Tree API\nThe returned tree has the following signature:\n```zig\nconst Tree = struct {\n    pub const Node = union(enum) {\n        pub const Elem = struct {\n            pub const Attr = struct {\n                name: []const u8,\n                value: ?[]const u8,\n            };\n\n            tag_name: []const u8,\n            attributes: []const Attr,\n            tree: ?Tree,\n\n            // Get an attribute given its name.\n            pub fn attributeByName(self: Elem, needle: []const u8) ?Attr;\n            pub fn attr(self: Elem, needle: []const u8) ?Attr;\n\n            // Get the value of an attribute given its name. Note that if the\n            // attribute has no value, e.g., <button disabled> this will\n            // still return null. Use attr or attributeByName in those\n            // cases.\n            pub fn attributeValueByName(self: Elem, needle: []const u8) ?[]const u8;\n            pub fn attrValue(self: Elem, needle: []const u8) ?[]const u8;\n        };\n\n        pub const Text = struct {\n            contents: []const u8,\n\n            // Return the text without any whitespace at the beginning or end.\n            pub fn trimmed(self: Text) []const u8;\n        }\n\n        pub const Comment = struct {\n            contents: []const u8,\n        };\n\n        elem: Elem,\n        text: text,\n        comment: Comment,\n    };\n\n    children: []const Node,\n\n    // Find an element child by its tag name\n    pub fn elementByTagName(self: Tree, needle: []const u8) ?Node.Elem;\n    pub fn elem(self: Tree, needle: []const u8) ?Node.Elem;\n    \n    // Allocate a slice for all of the element children of a given tag name\n    // To free the returned slice, you can just call allocator.free(elements)\n    // where 'elements' is the returned slice.\n    pub fn elementsByTagNameAlloc(self: Tree, allocator: std.mem.Allocator, needle: []const u8) ![]Node.Elem;\n    pub fn elemsAlloc(self: Tree, allocator: std.mem.Allocator, needle: []const u8) ![]Node.Elem;\n\n    // Get an element by the value of one of its attributes\n    pub fn elementByAttributeValue(self: Tree, needle_name: []const u8, needle_value: []const u8) ?Node.Elem;\n    pub fn elemByAttr(self: Tree, needle_name: []const u8, needle_value: []const u8) ?Node.Elem;\n\n    // Return the inner text (not including the elements) of the tree. Note that the\n    // result will be entirely unformatted.\n    pub fn concatTextAlloc(self: Tree, allocator: std.mem.Allocator) ![]const u8;\n    // Return the inner text (not including the elements) of the tree but without\n    // any whitespace at the start or end.\n    pub fn concatTextTrimmedAlloc(self: Tree, allocator: std.mem.Allocator) ![]const u8;\n}\n```\n\n### Populate API\nOften, it's useful to be able to populate a given struct with values from an XML\ndocument. That is, 'reading' the document into the struct.\n\nDishwasher comes with a shaping API so you can dictate how the document should\nbe read into the struct. Simply declare an `xml_shape` on the struct:\n\n```zig\nconst Job = struct {\n  title: []const u8,\n  start_date: []const u8,\n  end_date: []const u8,\n}\n\nconst Person = struct {\n    pub const xml_shape = .{\n        .name = .content_trimmed,\n        .age = .{ .attribute, \"age\" },\n        .jobs = .{ .elements, \"job\", .{\n            .start_date = .{ .attribute, \"start_date\" },\n            .end_date = .{ .attribute, \"end_date\" },\n            .title = .content_trimmed,\n            .fired = .attribute_exists,\n        } },\n        .location = .{\n            .one_of,\n            .{ .element, \"house\", .content },\n            .{ .element, \"work\", .content },\n            .none,\n        },\n        .apprentice = .{ .maybe, .{ .element, \"apprentice\", Person } },\n        .children = .{ .elements, \"child\", Person },\n    };\n\n    name: []const u8,\n    age: []const u8,\n    jobs: []struct {\n        start_date: []const u8,\n        end_date: []const u8,\n        title: []const u8,\n        fired: bool,\n    },\n    location: union(enum) {\n        house: []const u8,\n        work: []const u8,\n        none: void,\n    },\n    apprentice: ?*Person,\n    children: []Person,\n};\n\npub const Register = struct {\n    pub const xml_shape = .{\n        .people = .{ .elements, \"person\", Person },\n    };\n\n    people: []Person,\n};\n\nconst register = try diswasher.Populate(Register).initFromSlice(allocator, xml_text);\ndefer register.deinit();\n\n// register.value: Register\n```\n\nAlternatively, you can populate an existing struct:\n```zig\nvar register: Register = undefined;\nconst arena = try dishwasher.Populate(Register).fromSlice(allocator, xml_text, &register);\ndefer arena.deinit();\n```\n\nIf you want to own all of your values yourself, use:\n```zig\nconst owned_tree = dishwasher.parse.fromReader(allocator, file.reader());\ndefer owned_tree.deinit();\n\nconst register = try dishwasher.Populate(Register).initFromTreeOwned(allocator, owned_tree.tree);\n// free 'register' values yourself..\n```\n\n#### Dynamic values\nIf some field accepts any sort of XML document shape, you can instruct it\nto accept a `parse.Tree`:\n\n```zig\nconst Register = struct {\n  pub const xml_shape = .{\n    .people = .{ .elements, \"person\", dishwasher.parse.Tree },\n  };\n\n  people: []dishwasher.parse.Tree,\n};\n```\n\n> [!NOTE]\n> Note that the tree is not duplicated for you, so if you use the `initFromTreeOwned` method, the values in the tree\n> will still belong to the arena that was initialised for the tree.\n\n#### Free struct\nIf you use the `initFromTreeOwned` population method, you can free all of the values in an arena-friendly way with:\n```zig\ndishwasher.Populate(Register).deinit(allocator, register);\n```\n\n### Comptime Parsing and Populate API\nIt could be useful to parse an XML document at compile time, for example\nfor some inline code generation. While comptime doesn't have allocators,\nthere's a custom API for this:\n\n```zig\nconst tree = dishwasher.parse.fromSliceComptime(xml_text);\n```\n\nCheck out the [Tree API](#tree-api) to know what to do with the returned value.\n\n#### Comptime Populate API\nIf you want to populate a struct at compile time, you can use the `*Comptime` methods\non the `Populate` struct:\n```zig\nconst register = dishwasher.Populate(Register).initFromSliceComptime(xml_text);\n```\n\n> [!NOTE]\n> Remember that for the target struct, all pointers need to be `*const T` or\n> `[]const T`.\n\n### Scanner API\nIf you want low-level access to the iterator for lexing an XML document,\nyou can use the Scanner API, which accepts a slice buffer:\n```zig\nvar xmlScanner = Scanner.fromSlice(xml_text);\nwhile (try xmlScanner.next()) |token| {\n  std.debug.print(\"token kind: \", .{ token.kind });\n}\n```\n\nIf you have a reader and no access to the entire slice, the Reader API\ncan connect any reader to the Scanner API so you can lex from a reader:\n```zig\nvar xmlReader = Scanner.staticBufferReader(file.reader());\nwhile (try xmlScanner.next()) |token| {\n  std.debug.print(\"token kind: \", .{ token.kind });\n}\n```\n\n> [!NOTE]\n> If you're given an error about running out of buffer space, try increase\n> the reader buffer size with\n> ```zig\n> const buffer_size = 4096;\n> const XmlFileReader = zigScanner.StaticBufferReader(@TypeOf(file.reader()), buffer_size);\n> const xmlReader = XmlFileReader.init(file.reader());\n> ```\n\n#### Comptime Scanner\nThe scanner works during compile time without any modification.\n\n## License\nAll dishwasher code is under the MIT license.\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/60631511?u=639fba5272efcca7f8326dcd8ac430073b556726&v=4",
  "releases": [
    {
      "tag_name": "1.0.7",
      "name": "1.0.7",
      "body": "Updated everything for Zig version 0.14.0 (Thanks to @r4gus in https://github.com/edqx/dishwasher/pull/4)",
      "prerelease": false,
      "published_at": "2025-03-15T21:59:03Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.7",
      "assets": []
    },
    {
      "tag_name": "1.0.6",
      "name": "",
      "body": "Update to zig master",
      "prerelease": false,
      "published_at": "2024-08-31T00:46:43Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.6",
      "assets": []
    },
    {
      "tag_name": "1.0.5",
      "name": "1.0.5",
      "body": "Remove string interning attempt, performance improvements",
      "prerelease": false,
      "published_at": "2024-06-12T12:17:02Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.5",
      "assets": []
    },
    {
      "tag_name": "1.0.4",
      "name": "1.0.4",
      "body": "Add patterns for scanning XML children",
      "prerelease": false,
      "published_at": "2024-06-11T23:45:27Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.4",
      "assets": []
    },
    {
      "tag_name": "1.0.3",
      "name": "1.0.3",
      "body": "Fix issues related to optional values",
      "prerelease": false,
      "published_at": "2024-06-11T00:28:41Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.3",
      "assets": []
    },
    {
      "tag_name": "1.0.2",
      "name": "1.0.2",
      "body": "Copy attribute value to resulting value",
      "prerelease": false,
      "published_at": "2024-06-10T11:01:40Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.2",
      "assets": []
    },
    {
      "tag_name": "1.0.1",
      "name": "1.0.1",
      "body": "Add functionality to populate values from a schema",
      "prerelease": false,
      "published_at": "2024-06-10T10:50:24Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.1",
      "assets": []
    },
    {
      "tag_name": "1.0.0",
      "name": "",
      "body": "Initial 'release'",
      "prerelease": false,
      "published_at": "2024-06-10T00:00:44Z",
      "html_url": "https://github.com/edqx/dishwasher/releases/tag/1.0.0",
      "assets": []
    }
  ],
  "owner_company": null,
  "owner_location": "United Kingdom",
  "owner_blog": "https://esma.rocks",
  "owner_twitter_username": null,
  "owner_followers": 37,
  "owner_following": 3,
  "owner_created_at": "2020-02-03T23:35:35Z",
  "license": "MIT",
  "category": "library"
}