{
  "name": "cozi",
  "owner": "zxubian",
  "repo": "cozi",
  "description": "Concurrency primitives for Zig",
  "type": "package",
  "topics": [
    "concurrency",
    "concurrent-programming",
    "fiber",
    "fiber-framework",
    "fibers",
    "futures",
    "multithreading",
    "promise",
    "promises",
    "thread-pool"
  ],
  "stars": 14,
  "forks": 2,
  "watchers": 1,
  "updated_at": "2026-01-17T16:46:34Z",
  "minimum_zig_version": "0.15.0-dev.1262+e12dc4947",
  "readme": "# **cozi** - concurrency primitives for Zig\n_Fibers, thread pools, futures - all in userland Zig. Oh My!_\n\n## Goals\n- empower Zig users to solve concurrent & parallel engineering problems\n  - at a higher level of expressiveness than basic synchronization primitives (mutex/condvar)\n  - while maintaining the low-level control that is crucial for systems programming\n- to that end, provide a toolbox of software components with the following properties:\n  - orthogonal - components are meaningful and useful by themselves. Components have minimal coupling between themselves.\n  - composable - components can be combined to produce more powerful behaviours.\n  - extensible - we cannot anticipate every use-case. So, our APIs must be designed in a way that allows users of the library to integrate their custom solutions.\n\n## Installation\n\n### Minimum Supported Zig Version\n\n```\n0.15.0-dev.1262+e12dc4947\n```\n\n### Steps\n\n1. Install package:\n```bash\nzig fetch --save git+https://github.com/zxubian/cozi.git#main\n```\n\n2. Add `cozi` module to your executable:\n```zig\n// build.zig\nconst cozi = b.dependency(\"cozi\", .{});\nexe.root_module.addImport(\"cozi\", cozi.module(\"root\"));\n```\n\n3. Import  and use:\n- [examples](examples/)\n\n### Build Configuration Options\nYou can modify the behavior of `cozi` by overriding [build options](src/buildOptions.zig) at import timing.\n1. For convenience, copy the [build scipt](buildScripts/cozi_build.zig) into your repository\n2. Register the build options, and forward the results to `cozi` when registering it as a dependency:\n```zig\n//build.zig\nconst exe_mod = b.createModule(.{...});\n// import cozi's build script\nconst cozi_build = @import(\"./cozi_build.zig\");\n// register cozi's build options & gather results\nconst cozi_build_options = cozi_build.parseBuildOptions(b);\n// pass the parsed results to the cozi dependency\nconst cozi = b.dependency(\"cozi\", cozi_build_options);\nexe_mod.addImport(\"cozi\", cozi.module(\"root\"));\n```\n3. You can then check the list of available build options:\n```bash\nzig build -h\n# > -Dcozi_log=[bool]            Enable verbose logging from inside the cozi library\n# ...\n```\nFor each option that is not overridden, `cozi` will use the default defined in [BuildOptions](src/buildOptions.zig).\n\n### Stability Guarantees\n`cozi` is experimental and unstable. Expect `main` branch to occasionally break.\n\n## [Examples](examples/)\n\n```bash\n# get list of available examples\nzig build example-run\n# build & run specific example\nzig build example-run -Dexample-name=\"some_example\"\n```\n## Docs\n```bash\n# build documentation\nzig build docs\n# host docs on local http server\npython3 -m http.server 8000 -d ./zig-out/docs\n# open in browser\nhttp://localhost:8000/index.html\n```\n\n## Features & Roadmap\n\n### [Executors & Schedulers](src/executors)\n- `Executor` is a type-erased interface representing an abstract task queue:\n    - users can submit [Runnable](src/core/runnable.zig)s (an abstract representation of a task) for eventual execution\n- `cozi`'s concurrency primitives (`Future`s, `Fiber`s) can run on any `Executor`\n- `Executor` is to asynchronous task execution what [Allocator](https://github.com/ziglang/zig/blob/master/lib/std/mem/Allocator.zig) is to memory management.\n\n```zig\nconst executor = thread_pool.executor();\nexecutor.submit(some_function, .{args}, allocator);\n// eventually, some_function(args) will be called.\n// exact timing depends on the specific Executor implementation\n```\n\n### [Fibers](src/fiber) - stackfull cooperatively-scheduled user-space threads\n- **threads**: like OS threads, fibers represents a \"thread\" of execution, i.e. an independent sequence of instructions together with its execution context (stack space)\n- **stackful**: user must allocate memory for each fiber's execution stack (in contrast to e.g. stackless coroutines)\n- **cooperatively-scheduled**: fibers are not pre-empted by the system or the `cozi` runtime\n     - Instead, each fiber itself is responsible for releasing control of the underlying thread and allow other fibers to run\n     - When in this state, the fiber is refered to as being _suspended_ or _parked_.\n\n#### Comparison to other languages\n- Fibers are an example of [Green Threads](https://en.wikipedia.org/wiki/Green_thread)\n- Fibers are similar to [goroutines](https://go.dev/tour/concurrency/1) in GoLang, and [coroutines](https://kotlinlang.org/docs/coroutines-guide.html) in Kotlin\n\n#### Supported Platforms\nSee [Coroutine - Supported Platforms](#coroutine---supported-platforms)\n\n```zig\nconst Ctx = struct {\n    sum: usize,\n    wait_group: std.Thread.WaitGroup = .{},\n    // non-blocking mutex for fibers\n    mutex: Fiber.Mutex = .{},\n    pub fn run(\n        self: *@This(),\n    ) void {\n        for (0..10) |_| {\n            {\n                // Fibers running on thread pool may access\n                // shared variable `sum` in parallel.\n                // Fiber.Mutex provides mutual exclusion without\n                // blocking underlying thread.\n                self.mutex.lock();\n                defer self.mutex.unlock();\n                self.sum += 1;\n            }\n            // Suspend execution here (allowing for other fibers to be run),\n            // and immediately reschedule self with the Executor.\n            Fiber.yield();\n        }\n        self.wait_group.finish();\n    }\n};\nvar ctx: Ctx = .{ .sum = 0 };\nconst fiber_count = 4;\nctx.wait_group.startMany(fiber_count);\n\n// Run 4 fibers on 2 threads\nfor (0..4) |fiber_id| {\n    try Fiber.goWithNameFmt(\n        Ctx.run,\n        .{&ctx},\n        allocator,\n        executor,\n        \"Fiber #{}\",\n        .{fiber_id},\n    );\n}\n// Synchronize Fibers running in a thread pool\n// with the launching (main) thread.\nctx.wait_group.wait();\n```\n### Futures & Promises\n- [source](src/future/lazy/root.zig)\n> [!NOTE]  \n> documentation WIP\n\n### Stackfull Coroutine - a function you can suspend & resume\n- [example](examples/coroutine.zig)\n- [source](src/coroutine/root.zig)\n- [roadmap](https://github.com/zxubian/cozi/issues?q=is%3Aissue%20state%3Aopen%20label%3ACoroutine%20label%3Afeature)\n\n#### Coroutine - Supported Platforms\n\nSee [issue](https://github.com/zxubian/cozi/issues/8).\n\n| Arch\\OS | MacOS | Windows | Linux |\n|:-------:|:-----:|:-------:|:-----:|\n| aarch64 | ✅     | ❌     | ✅    |\n| x86_64  | ❌     | ✅     | ❌    |\n\n```zig\nconst cozi = @import(\"cozi\");\nconst Coroutine = cozi.Coroutine;\n// ... \nconst Ctx = struct {\n    pub fn run(ctx: *Coroutine) void {\n        log.debug(\"step 1\", .{});\n        ctx.@\"suspend\"();\n        log.debug(\"step 2\", .{});\n        ctx.@\"suspend\"();\n        log.debug(\"step 3\", .{});\n    }\n};\n\nvar coro: Coroutine.Managed = undefined;\ntry coro.initInPlace(Ctx.run, .{&coro.coroutine}, gpa.allocator());\ndefer coro.deinit();\nfor (0..3) |_| {\n    coro.@\"resume\"();\n}\nassert(coro.isCompleted());\n```\n\n### Long-term initiatives\n#### integration with Zig async/await\n  - It is currently unclear what direction Zig will go with for language support of async/await. \n  - Once the Zig Language direction is decided, we will consider the best way to integrate it with the library.\n\n## Memory Management Policy:\n  - API must allow fine-grained control over allocations for users who care\n  - it's nice to provide \"managed\" API for users who don't (e.g. for testing)\n  - regardless of memory management approach chosen by the user, library must minimize number of runtime allocations\n\n# Acknowledgements\nThe design of **cozi** is heavily based on prior work, especially the [concurrency course](https://www.youtube.com/watch?v=zw6V3SDsXDk&list=PL4_hYwCyhAva37lNnoMuBcKRELso5nvBm) taught by [Roman Lipovsky](https://gitlab.com/Lipovsky) at MIPT.\nThe author would like to express his deepest gratitude to Roman for all of the knowledge that he shares publicly, and for his dedication to education in technology.\nThis library began as a fun exercise to go along with the course, and would not exist without it.\n\n**Honourable mentions:**\n- [YACLib](https://github.com/YACLib/YACLib)\n- GoLang\n    - [select](https://github.com/golang/go/blob/master/src/runtime/select.go)\n- Rust\n    - [zero-cost futures](https://aturon.github.io/tech/2016/09/07/futures-design/)\n",
  "owner_avatar_url": "https://avatars.githubusercontent.com/u/8446683?v=4",
  "releases": [],
  "owner_company": null,
  "owner_location": null,
  "owner_blog": null,
  "owner_twitter_username": null,
  "owner_followers": 5,
  "owner_following": 15,
  "owner_created_at": "2014-08-14T08:18:22Z",
  "license": "MIT",
  "category": "library"
}